v8-version,10,2,154,13,-node.9,0
v8-platform,macos,macos
shared-library,/Users/tiagolandim/.nvm/versions/node/v18.7.0/bin/node,0x102551000,0x103b69077,39124992
shared-library,/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation,0x7ff805f40ad0,0x7ff806116515,95518720
shared-library,/usr/lib/libobjc.A.dylib,0x7ff805b71d00,0x7ff805b99a37,95518720
shared-library,/System/Library/PrivateFrameworks/CoreServicesInternal.framework/Versions/A/CoreServicesInternal,0x7ff808e432f0,0x7ff808e7a428,95518720
shared-library,/usr/lib/liboah.dylib,0x7ff811fb9380,0x7ff811fbee6a,95518720
shared-library,/usr/lib/libfakelink.dylib,0x7ff811fef452,0x7ff811ff0b62,95518720
shared-library,/usr/lib/libicucore.A.dylib,0x7ff8088a86b0,0x7ff808acbc94,95518720
shared-library,/usr/lib/libSystem.B.dylib,0x7ff811fec722,0x7ff811feccee,95518720
shared-library,/System/Library/PrivateFrameworks/SoftLinking.framework/Versions/A/SoftLinking,0x7ff811ff1c3e,0x7ff811ff1ebe,95518720
shared-library,/usr/lib/libc++abi.dylib,0x7ff805e8e0a0,0x7ff805e9fe20,95518720
shared-library,/usr/lib/libc++.1.dylib,0x7ff805e38e50,0x7ff805e82ffd,95518720
shared-library,/usr/lib/system/libcache.dylib,0x7ff811fe67f0,0x7ff811fe948b,95518720
shared-library,/usr/lib/system/libcommonCrypto.dylib,0x7ff811fa1ee0,0x7ff811fabeec,95518720
shared-library,/usr/lib/system/libcompiler_rt.dylib,0x7ff811fcacf8,0x7ff811fcfc55,95518720
shared-library,/usr/lib/system/libcopyfile.dylib,0x7ff811fc08d0,0x7ff811fc841f,95518720
shared-library,/usr/lib/system/libcorecrypto.dylib,0x7ff805c9fac0,0x7ff805d10801,95518720
shared-library,/usr/lib/system/libdispatch.dylib,0x7ff805d62030,0x7ff805d98226,95518720
shared-library,/usr/lib/system/libdyld.dylib,0x7ff805eea130,0x7ff805f08140,95518720
shared-library,/usr/lib/system/libkeymgr.dylib,0x7ff811fdcad9,0x7ff811fdcf18,95518720
shared-library,/usr/lib/system/libmacho.dylib,0x7ff811f8067c,0x7ff811f849f5,95518720
shared-library,/usr/lib/system/libquarantine.dylib,0x7ff81156eefb,0x7ff811570d02,95518720
shared-library,/usr/lib/system/libremovefile.dylib,0x7ff811fda800,0x7ff811fdbd98,95518720
shared-library,/usr/lib/system/libsystem_asl.dylib,0x7ff80aab0358,0x7ff80aac4717,95518720
shared-library,/usr/lib/system/libsystem_blocks.dylib,0x7ff805c42130,0x7ff805c444f0,95518720
shared-library,/usr/lib/system/libsystem_c.dylib,0x7ff805dac5e0,0x7ff805e2d414,95518720
shared-library,/usr/lib/system/libsystem_collections.dylib,0x7ff811fd2f9c,0x7ff811fd69dc,95518720
shared-library,/usr/lib/system/libsystem_configuration.dylib,0x7ff810871028,0x7ff8108738bd,95518720
shared-library,/usr/lib/system/libsystem_containermanager.dylib,0x7ff80f8fc284,0x7ff80f92265b,95518720
shared-library,/usr/lib/system/libsystem_coreservices.dylib,0x7ff811c4c720,0x7ff811c502c0,95518720
shared-library,/usr/lib/system/libsystem_darwin.dylib,0x7ff808b3c240,0x7ff808b43356,95518720
shared-library,/usr/lib/system/libsystem_dnssd.dylib,0x7ff811fde794,0x7ff811fe41e7,95518720
shared-library,/usr/lib/system/libsystem_featureflags.dylib,0x7ff805da8c17,0x7ff805daac06,95518720
shared-library,/usr/lib/system/libsystem_info.dylib,0x7ff805f15030,0x7ff805f3a9d6,95518720
shared-library,/usr/lib/system/libsystem_m.dylib,0x7ff811f14c80,0x7ff811f506f0,95518720
shared-library,/usr/lib/system/libsystem_malloc.dylib,0x7ff805d35350,0x7ff805d58430,95518720
shared-library,/usr/lib/system/libsystem_networkextension.dylib,0x7ff80aa3f1c2,0x7ff80aa50ade,95518720
shared-library,/usr/lib/system/libsystem_notify.dylib,0x7ff808f7cb24,0x7ff808f89ed5,95518720
shared-library,/usr/lib/system/libsystem_sandbox.dylib,0x7ff8108753f8,0x7ff81087931a,95518720
shared-library,/usr/lib/system/libsystem_secinit.dylib,0x7ff811fd8191,0x7ff811fd9546,95518720
shared-library,/usr/lib/system/libsystem_kernel.dylib,0x7ff805ea42e0,0x7ff805ecc938,95518720
shared-library,/usr/lib/system/libsystem_platform.dylib,0x7ff805f0aec0,0x7ff805f12032,95518720
shared-library,/usr/lib/system/libsystem_pthread.dylib,0x7ff805eddcc0,0x7ff805ee6715,95518720
shared-library,/usr/lib/system/libsystem_symptoms.dylib,0x7ff80c4f8dce,0x7ff80c4fe4ca,95518720
shared-library,/usr/lib/system/libsystem_trace.dylib,0x7ff805c870a0,0x7ff805c9c21a,95518720
shared-library,/usr/lib/system/libunwind.dylib,0x7ff811fb23f0,0x7ff811fb746a,95518720
shared-library,/usr/lib/system/libxpc.dylib,0x7ff805c46e60,0x7ff805c75092,95518720
shared-library,/System/Library/Frameworks/IOKit.framework/Versions/A/IOKit,0x7ff808ebeba0,0x7ff808f62ff6,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/CoreServices,0x7ff81882ffc0,0x7ff81882ffc0,95518720
shared-library,/usr/lib/libDiagnosticMessagesClient.dylib,0x7ff80d258f87,0x7ff80d259c04,95518720
shared-library,/usr/lib/libenergytrace.dylib,0x7ff80aa5577f,0x7ff80aa55d3e,95518720
shared-library,/usr/lib/libbsm.0.dylib,0x7ff811595be8,0x7ff8115a2fe9,95518720
shared-library,/usr/lib/libz.1.dylib,0x7ff811f01880,0x7ff811f0dbf5,95518720
shared-library,/usr/lib/system/libkxld.dylib,0x7ff811f89220,0x7ff811f9fde4,95518720
shared-library,/System/Library/Frameworks/CFNetwork.framework/Versions/A/CFNetwork,0x7ff80a69b1e0,0x7ff80a9000cd,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/FSEvents.framework/Versions/A/FSEvents,0x7ff80e583f00,0x7ff80e58dfb0,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/CarbonCore.framework/Versions/A/CarbonCore,0x7ff808b4abd0,0x7ff808c2d4b3,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/Metadata.framework/Versions/A/Metadata,0x7ff80d29cc00,0x7ff80d31bfec,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/OSServices.framework/Versions/A/OSServices,0x7ff811c52890,0x7ff811c772f3,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/SearchKit.framework/Versions/A/SearchKit,0x7ff8121b3920,0x7ff812204e10,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/AE.framework/Versions/A/AE,0x7ff80c480a70,0x7ff80c4df620,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/LaunchServices.framework/Versions/A/LaunchServices,0x7ff8063d8690,0x7ff8065ba2dc,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/DictionaryServices.framework/Versions/A/DictionaryServices,0x7ff8126fd420,0x7ff81273d770,95518720
shared-library,/System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/SharedFileList.framework/Versions/A/SharedFileList,0x7ff80e59194f,0x7ff80e5ae6c4,95518720
shared-library,/System/Library/Frameworks/Security.framework/Versions/A/Security,0x7ff8085291f0,0x7ff808805eb0,95518720
shared-library,/System/Library/Frameworks/SystemConfiguration.framework/Versions/A/SystemConfiguration,0x7ff8069dce30,0x7ff806a4cd90,95518720
shared-library,/usr/lib/libapple_nghttp2.dylib,0x7ff81223e830,0x7ff81224e73a,95518720
shared-library,/usr/lib/libcompression.dylib,0x7ff812271580,0x7ff8122d1b07,95518720
shared-library,/usr/lib/libnetwork.dylib,0x7ff80a698fc0,0x7ff80a698fc0,95518720
shared-library,/usr/lib/libsqlite3.dylib,0x7ff80c100650,0x7ff80c2bf83a,95518720
shared-library,/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation,0x7ff806cf2c90,0x7ff807419954,95518720
shared-library,/System/Library/Frameworks/Network.framework/Versions/A/Network,0x7ff80c501dd0,0x7ff80cfe2dba,95518720
shared-library,/usr/lib/libCoreEntitlements.dylib,0x7ffb205ce4f0,0x7ffb205d46c7,95518720
shared-library,/System/Library/PrivateFrameworks/MessageSecurity.framework/Versions/A/MessageSecurity,0x7ffb0e320b50,0x7ffb0e340feb,95518720
shared-library,/System/Library/PrivateFrameworks/ProtocolBuffer.framework/Versions/A/ProtocolBuffer,0x7ff80c0e6df0,0x7ff80c0fa580,95518720
shared-library,/usr/lib/libMobileGestalt.dylib,0x7ff80aa57980,0x7ff80aa974f7,95518720
shared-library,/System/Library/PrivateFrameworks/AppleFSCompression.framework/Versions/A/AppleFSCompression,0x7ff811c2b800,0x7ff811c3706a,95518720
shared-library,/usr/lib/libcoretls.dylib,0x7ff81157dea0,0x7ff811590849,95518720
shared-library,/usr/lib/libcoretls_cfhelpers.dylib,0x7ff8127660a8,0x7ff812766df2,95518720
shared-library,/usr/lib/libpam.2.dylib,0x7ff81226c208,0x7ff81226f21a,95518720
shared-library,/usr/lib/libxar.1.dylib,0x7ff8127d2b90,0x7ff8127deab5,95518720
shared-library,/System/Library/PrivateFrameworks/CoreAutoLayout.framework/Versions/A/CoreAutoLayout,0x7ff80e5bae90,0x7ff80e5f0250,95518720
shared-library,/System/Library/Frameworks/DiskArbitration.framework/Versions/A/DiskArbitration,0x7ff80d333830,0x7ff80d339196,95518720
shared-library,/usr/lib/libarchive.2.dylib,0x7ff81212b650,0x7ff81219de49,95518720
shared-library,/usr/lib/libxml2.2.dylib,0x7ff80e6029c0,0x7ff80e6c1dc4,95518720
shared-library,/usr/lib/liblangid.dylib,0x7ff8108803ee,0x7ff810880db6,95518720
shared-library,/System/Library/Frameworks/Combine.framework/Versions/A/Combine,0x7ff8166e83d0,0x7ff8167bddf0,95518720
shared-library,/usr/lib/swift/libswiftCore.dylib,0x7ff814835c60,0x7ff814bf3614,95518720
shared-library,/usr/lib/swift/libswiftCoreFoundation.dylib,0x7ff90a791550,0x7ff90a796110,95518720
shared-library,/usr/lib/swift/libswiftDarwin.dylib,0x7ff908797110,0x7ff90879b39a,95518720
shared-library,/usr/lib/swift/libswiftDispatch.dylib,0x7ff81a052f50,0x7ff81a06231e,95518720
shared-library,/usr/lib/swift/libswiftIOKit.dylib,0x7ff90a7acc70,0x7ff90a7acfab,95518720
shared-library,/usr/lib/swift/libswiftObjectiveC.dylib,0x7ff81c441810,0x7ff81c44310a,95518720
shared-library,/usr/lib/swift/libswiftXPC.dylib,0x7ff90a7a2b20,0x7ff90a7aa2c0,95518720
shared-library,/usr/lib/swift/libswift_Concurrency.dylib,0x7ffb215a2d30,0x7ffb215d9525,95518720
shared-library,/usr/lib/swift/libswift_StringProcessing.dylib,0x7ffb216e2760,0x7ffb2175f288,95518720
shared-library,/usr/lib/swift/libswiftos.dylib,0x7ff81c445320,0x7ff81c457c00,95518720
shared-library,/System/Library/PrivateFrameworks/AppleSystemInfo.framework/Versions/A/AppleSystemInfo,0x7ff81087b807,0x7ff81087e2dc,95518720
shared-library,/System/Library/PrivateFrameworks/IOMobileFramebuffer.framework/Versions/A/IOMobileFramebuffer,0x7ff81128d5c0,0x7ff81129741a,95518720
shared-library,/System/Library/Frameworks/IOSurface.framework/Versions/A/IOSurface,0x7ff80f92b950,0x7ff80f939621,95518720
shared-library,/usr/lib/libpcap.A.dylib,0x7ff811ff2e60,0x7ff812013a98,95518720
shared-library,/usr/lib/libdns_services.dylib,0x7ff80c4f02ad,0x7ff80c4f6324,95518720
shared-library,/usr/lib/liblzma.5.dylib,0x7ff81274c48c,0x7ff81275e7d8,95518720
shared-library,/usr/lib/libbz2.1.0.dylib,0x7ff811c3be00,0x7ff811c49f15,95518720
shared-library,/usr/lib/libiconv.2.dylib,0x7ff812028520,0x7ff81203c089,95518720
shared-library,/usr/lib/libcharset.1.dylib,0x7ff811f7f9f9,0x7ff811f7fee0,95518720
shared-library,/usr/lib/swift/libswift_RegexParser.dylib,0x7ffb21627740,0x7ffb216c5baa,95518720
shared-library,/usr/lib/libheimdal-asn1.dylib,0x7ff812d677d0,0x7ff812d6fcf9,95518720
shared-library,/usr/lib/libCheckFix.dylib,0x7ff811572ce3,0x7ff811579372,95518720
shared-library,/System/Library/PrivateFrameworks/TCC.framework/Versions/A/TCC,0x7ff80aac6fd0,0x7ff80aadbd81,95518720
shared-library,/System/Library/PrivateFrameworks/CoreNLP.framework/Versions/A/CoreNLP,0x7ff810882f90,0x7ff81094992e,95518720
shared-library,/System/Library/PrivateFrameworks/MetadataUtilities.framework/Versions/A/MetadataUtilities,0x7ff80d25be20,0x7ff80d28fc30,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Accelerate,0x7ff818ad9000,0x7ff818ad9000,95518720
shared-library,/usr/lib/libmecab.dylib,0x7ff8115a59a0,0x7ff8115f2310,95518720
shared-library,/usr/lib/libCRFSuite.dylib,0x7ff806a5bb10,0x7ff806a8ac90,95518720
shared-library,/usr/lib/libgermantok.dylib,0x7ff811600050,0x7ff811601dca,95518720
shared-library,/usr/lib/libThaiTokenizer.dylib,0x7ff812219e52,0x7ff81221ae16,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vImage.framework/Versions/A/vImage,0x7ff80d33ade0,0x7ff80de939ea,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/vecLib,0x7ff818803000,0x7ff818803000,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libvMisc.dylib,0x7ff812815420,0x7ff81297b361,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libvDSP.dylib,0x7ff811088020,0x7ff81126f1bd,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib,0x7ff8067918b0,0x7ff80691882e,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLAPACK.dylib,0x7ff81234ff90,0x7ff8126f805c,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libLinearAlgebra.dylib,0x7ff8116032ec,0x7ff811615f3e,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libSparseBLAS.dylib,0x7ff812256970,0x7ff812268bf8,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libQuadrature.dylib,0x7ff81234a04b,0x7ff81234e0dc,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBNNS.dylib,0x7ff81096f030,0x7ff811065c9b,95518720
shared-library,/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libSparse.dylib,0x7ff806965d90,0x7ff8069d7046,95518720
shared-library,/System/Library/PrivateFrameworks/MIL.framework/Versions/A/MIL,0x7ffb0d65d730,0x7ffb0d8e3c00,95518720
shared-library,/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/CFOpenDirectory,0x7ff80e5682a0,0x7ff80e57b89f,95518720
shared-library,/System/Library/Frameworks/OpenDirectory.framework/Versions/A/OpenDirectory,0x7ff80e55bff5,0x7ff80e562a72,95518720
shared-library,/System/Library/PrivateFrameworks/APFS.framework/Versions/A/APFS,0x7ff812768000,0x7ff8127bab90,95518720
shared-library,/System/Library/Frameworks/SecurityFoundation.framework/Versions/A/SecurityFoundation,0x7ff8114b6ac0,0x7ff8114fdc41,95518720
shared-library,/usr/lib/libutil.dylib,0x7ff8127e15b0,0x7ff8127e3966,95518720
shared-library,/System/Library/PrivateFrameworks/InstalledContentLibrary.framework/Versions/A/InstalledContentLibrary,0x7ffb0c864460,0x7ffb0c9165dc,95518720
shared-library,/System/Library/PrivateFrameworks/CoreServicesStore.framework/Versions/A/CoreServicesStore,0x7ff808e821c0,0x7ff808eb21da,95518720
shared-library,/usr/lib/libapp_launch_measurement.dylib,0x7ff80e5b7b1b,0x7ff80e5b978e,95518720
shared-library,/System/Library/PrivateFrameworks/AppleMobileFileIntegrity.framework/Versions/A/AppleMobileFileIntegrity,0x7ffa23a9d81a,0x7ffa23aa6516,95518720
shared-library,/usr/lib/libmis.dylib,0x7ff90a771660,0x7ff90a77e19e,95518720
shared-library,/System/Library/PrivateFrameworks/MobileSystemServices.framework/Versions/A/MobileSystemServices,0x7ff918c3e270,0x7ff918c40682,95518720
shared-library,/System/Library/PrivateFrameworks/ConfigProfileHelper.framework/Versions/A/ConfigProfileHelper,0x7ffa129d7842,0x7ffa129d8a86,95518720
shared-library,/System/Library/PrivateFrameworks/CoreAnalytics.framework/Versions/A/CoreAnalytics,0x7ff80d22ff00,0x7ff80d24ff30,95518720
shared-library,/System/Library/PrivateFrameworks/AppleSauce.framework/Versions/A/AppleSauce,0x7ff81221c390,0x7ff81223afc9,95518720
shared-library,/System/Library/PrivateFrameworks/LanguageModeling.framework/Versions/A/LanguageModeling,0x7ff807703370,0x7ff80782f618,95518720
shared-library,/usr/lib/libxslt.1.dylib,0x7ff8127e4fb0,0x7ff812805337,95518720
shared-library,/usr/lib/libcmph.dylib,0x7ff81211989c,0x7ff812127cde,95518720
shared-library,/System/Library/PrivateFrameworks/CoreEmoji.framework/Versions/A/CoreEmoji,0x7ff81127aa40,0x7ff8112891d0,95518720
shared-library,/System/Library/PrivateFrameworks/LinguisticData.framework/Versions/A/LinguisticData,0x7ff810969840,0x7ff81096d0a4,95518720
shared-library,/System/Library/PrivateFrameworks/Lexicon.framework/Versions/A/Lexicon,0x7ff80691c840,0x7ff80695b5da,95518720
shared-library,/System/Library/PrivateFrameworks/BackgroundTaskManagement.framework/Versions/A/BackgroundTaskManagement,0x7ff8115440c4,0x7ff81155c0c1,95518720
shared-library,/usr/lib/libTLE.dylib,0x7ffb207047a0,0x7ffb20709b18,95518720
shared-library-end
tick,0x7ff805b78643,1930,0,0x0,6
profiler,begin,1000
tick,0x1028e7ca8,3239,0,0x0,6
tick,0x10339a25d,4993,0,0x0,6
tick,0x10347affd,5691,0,0x0,6
new,CodeRange,0x1131c8000,0
new,MemoryChunk,0xb463c1c0000,262144
tick,0x102d9100d,7214,0,0x0,6
new,MemoryChunk,0xb46fb440000,262144
new,MemoryChunk,0xb465ee00000,262144
new,MemoryChunk,0xb46a4100000,262144
new,MemoryChunk,0xb4631f80000,262144
heap-capacity,1030976
heap-available,2198828672
tick,0x1028e801e,8260,0,0x0,6
new,MemoryChunk,0xb4630580000,262144
new,MemoryChunk,0xb4631d40000,262144
tick,0x102a9cc10,10794,0,0x0,6
new,MemoryChunk,0xb4665140000,262144
new,MemoryChunk,0xb469fcc0000,262144
new,MemoryChunk,0xb46d2c80000,262144
new,MemoryChunk,0xb4680680000,262144
new,MemoryChunk,0xb46d1080000,262144
new,MemoryChunk,0xb462a840000,262144
tick,0x102d8f98b,12081,0,0x0,6
new,MemoryChunk,0xb46634c0000,262144
new,MemoryChunk,0xb461e340000,262144
new,MemoryChunk,0x113200000,262144
tick,0x102d8f9e6,13299,0,0x0,6
code-creation,Builtin,2,14215,0x1030d8fc0,792,DeoptimizationEntry_Eager
code-creation,Builtin,2,14445,0x1030d9300,796,DeoptimizationEntry_Lazy
code-creation,Builtin,2,14454,0x1030d9640,796,DeoptimizationEntry_Unused
code-creation,Builtin,2,14462,0x1030d9980,1364,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,14471,0x1030d9f00,460,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,14480,0x1030da100,644,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,14490,0x1030da3c0,216,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,14499,0x1030da4c0,364,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,14507,0x1030da640,128,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,14515,0x1030da700,64,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,14524,0x1030da780,316,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,14533,0x1030da8c0,368,CallFunction_ReceiverIsNotNullOrUndefined
tick,0x7ff805f105d0,14790,0,0x0,6
code-creation,Builtin,2,14897,0x1030daa40,404,CallFunction_ReceiverIsAny
code-creation,Builtin,2,14909,0x1030dac00,104,CallBoundFunction
code-creation,Builtin,2,14917,0x1030dac80,828,CallWrappedFunction
code-creation,Builtin,2,14925,0x1030dafc0,168,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,14934,0x1030db080,168,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,14944,0x1030db140,168,Call_ReceiverIsAny
code-creation,Builtin,2,14951,0x1030db200,972,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,14962,0x1030db600,964,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,14972,0x1030dba00,1052,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,14982,0x1030dbe40,1044,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,14992,0x1030dc280,1052,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,15002,0x1030dc6c0,1044,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,15011,0x1030dcb00,916,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,15021,0x1030dcec0,916,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,15031,0x1030dd280,916,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,15040,0x1030dd640,744,CallProxy
code-creation,Builtin,2,15047,0x1030dd940,152,CallVarargs
code-creation,Builtin,2,15054,0x1030dda00,940,CallWithSpread
code-creation,Builtin,2,15062,0x1030dddc0,1944,CallWithSpread_Baseline
code-creation,Builtin,2,15070,0x1030de580,1888,CallWithSpread_WithFeedback
code-creation,Builtin,2,15079,0x1030ded00,936,CallWithArrayLike
code-creation,Builtin,2,15087,0x1030df0c0,1864,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,15095,0x1030df840,156,CallForwardVarargs
code-creation,Builtin,2,15103,0x1030df900,156,CallFunctionForwardVarargs
code-creation,Builtin,2,15112,0x1030df9c0,136,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,15131,0x1030dfa80,236,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,15141,0x1030dfb80,324,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,15151,0x1030dfd00,32,ConstructFunction
code-creation,Builtin,2,15158,0x1030dfd40,104,ConstructBoundFunction
code-creation,Builtin,2,15166,0x1030dfdc0,28,ConstructedNonConstructable
code-creation,Builtin,2,15174,0x1030dfe00,100,Construct
code-creation,Builtin,2,15181,0x1030dfe80,152,ConstructVarargs
code-creation,Builtin,2,15188,0x1030dff40,964,ConstructWithSpread
code-creation,Builtin,2,15195,0x1030e0340,1748,ConstructWithSpread_Baseline
code-creation,Builtin,2,15203,0x1030e0a40,1736,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,15212,0x1030e1140,964,ConstructWithArrayLike
code-creation,Builtin,2,15220,0x1030e1540,1700,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,15229,0x1030e1c00,196,ConstructForwardVarargs
code-creation,Builtin,2,15237,0x1030e1d00,196,ConstructFunctionForwardVarargs
code-creation,Builtin,2,15245,0x1030e1e00,772,Construct_Baseline
code-creation,Builtin,2,15252,0x1030e2140,796,Construct_WithFeedback
code-creation,Builtin,2,15259,0x1030e2480,476,JSConstructStubGeneric
code-creation,Builtin,2,15267,0x1030e2680,368,JSBuiltinsConstructStub
code-creation,Builtin,2,15274,0x1030e2800,652,FastNewObject
code-creation,Builtin,2,15281,0x1030e2ac0,296,FastNewClosure
code-creation,Builtin,2,15288,0x1030e2c00,724,ConstructProxy
code-creation,Builtin,2,15295,0x1030e2f00,192,JSEntry
code-creation,Builtin,2,15301,0x1030e3000,192,JSConstructEntry
code-creation,Builtin,2,15308,0x1030e3100,192,JSRunMicrotasksEntry
code-creation,Builtin,2,15315,0x1030e3200,100,JSEntryTrampoline
code-creation,Builtin,2,15322,0x1030e3280,100,JSConstructEntryTrampoline
code-creation,Builtin,2,15330,0x1030e3300,288,ResumeGeneratorTrampoline
code-creation,Builtin,2,15338,0x1030e3440,1500,StringFromCodePointAt
code-creation,Builtin,2,15346,0x1030e3a40,528,StringEqual
code-creation,Builtin,2,15352,0x1030e3c80,280,StringGreaterThan
code-creation,Builtin,2,15360,0x1030e3dc0,280,StringGreaterThanOrEqual
code-creation,Builtin,2,15368,0x1030e3f00,280,StringLessThan
code-creation,Builtin,2,15375,0x1030e4040,280,StringLessThanOrEqual
code-creation,Builtin,2,15382,0x1030e4180,2420,StringSubstring
code-creation,Builtin,2,15390,0x1030e4b00,80,OrderedHashTableHealIndex
code-creation,Builtin,2,15399,0x1030e4b80,1264,InterpreterEntryTrampoline
code-creation,Builtin,2,15407,0x1030e5080,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,15415,0x1030e5100,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,15424,0x1030e5180,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,15434,0x1030e5200,84,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,15443,0x1030e5280,84,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,15453,0x1030e5300,88,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,15463,0x1030e5380,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,15471,0x1030e5400,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,15480,0x1030e5500,52,InterpreterOnStackReplacement
code-creation,Builtin,2,15488,0x1030e5540,688,BaselineOutOfLinePrologue
code-creation,Builtin,2,15496,0x1030e5800,56,BaselineOnStackReplacement
code-creation,Builtin,2,15504,0x1030e5840,84,BaselineLeaveFrame
code-creation,Builtin,2,15511,0x1030e58c0,220,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,15520,0x1030e59c0,228,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,15530,0x1030e5ac0,196,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,15539,0x1030e5bc0,1184,CompileLazy
code-creation,Builtin,2,15546,0x1030e6080,72,CompileLazyDeoptimizedCode
code-creation,Builtin,2,15554,0x1030e6100,256,InstantiateAsmJs
code-creation,Builtin,2,15561,0x1030e6240,32,NotifyDeoptimized
code-creation,Builtin,2,15569,0x1030e6280,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,15577,0x1030e62c0,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,15589,0x1030e6300,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,15597,0x1030e6340,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,15606,0x1030e63c0,292,CallApiCallback
code-creation,Builtin,2,15614,0x1030e6500,276,CallApiGetter
code-creation,Builtin,2,15621,0x1030e6640,12,HandleApiCall
code-creation,Builtin,2,15627,0x1030e6680,12,HandleApiCallAsFunction
code-creation,Builtin,2,15635,0x1030e66c0,12,HandleApiCallAsConstructor
code-creation,Builtin,2,15643,0x1030e6700,64,AllocateInYoungGeneration
code-creation,Builtin,2,15651,0x1030e6780,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,15660,0x1030e67c0,64,AllocateInOldGeneration
code-creation,Builtin,2,15668,0x1030e6840,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,15676,0x1030e6880,432,CopyFastSmiOrObjectElements
code-creation,Builtin,2,15685,0x1030e6a40,508,GrowFastDoubleElements
code-creation,Builtin,2,15692,0x1030e6c40,400,GrowFastSmiOrObjectElements
code-creation,Builtin,2,15701,0x1030e6e00,480,DebugBreakTrampoline
code-creation,Builtin,2,15708,0x1030e7000,184,ToNumber
code-creation,Builtin,2,15715,0x1030e70c0,300,ToNumber_Baseline
code-creation,Builtin,2,15722,0x1030e7200,368,ToNumeric_Baseline
code-creation,Builtin,2,15729,0x1030e7380,104,PlainPrimitiveToNumber
code-creation,Builtin,2,15737,0x1030e7400,224,ToNumberConvertBigInt
code-creation,Builtin,2,15745,0x1030e7500,140,Typeof
code-creation,Builtin,2,15751,0x1030e75c0,108,BigIntToI64
code-creation,Builtin,2,15758,0x1030e7640,4,BigIntToI32Pair
code-creation,Builtin,2,15765,0x1030e7680,228,I64ToBigInt
code-creation,Builtin,2,15772,0x1030e7780,4,I32PairToBigInt
code-creation,Builtin,2,15779,0x1030e77c0,112,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,15789,0x1030e7840,4044,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,15798,0x1030e8840,15484,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,15806,0x1030ec4c0,11992,DefineKeyedOwnIC_Megamorphic
code-creation,Builtin,2,15814,0x1030ef3c0,464,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,15925,0x1030ef5c0,68,LoadIC_FunctionPrototype
code-creation,Builtin,2,15935,0x1030ef640,12,LoadIC_StringLength
code-creation,Builtin,2,15946,0x1030ef680,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,15956,0x1030ef6c0,3064,LoadIC_NoFeedback
code-creation,Builtin,2,15965,0x1030f02c0,32,StoreGlobalIC_Slow
code-creation,Builtin,2,15975,0x1030f0300,7312,StoreIC_NoFeedback
code-creation,Builtin,2,15984,0x1030f1fc0,3224,DefineNamedOwnIC_NoFeedback
code-creation,Builtin,2,15994,0x1030f2c80,184,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,16005,0x1030f2d40,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,16015,0x1030f2dc0,244,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,16026,0x1030f2ec0,244,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,16039,0x1030f2fc0,244,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,16051,0x1030f30c0,244,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,16063,0x1030f31c0,14448,StoreFastElementIC_Standard
code-creation,Builtin,2,16074,0x1030f6a40,9864,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,16086,0x1030f9100,13660,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,16097,0x1030fc680,5676,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,16108,0x1030fdcc0,8584,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,16119,0x1030ffe80,19624,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,16132,0x103104b40,8584,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,16144,0x103106d00,11168,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,16157,0x1031098c0,820,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,16167,0x103109c00,172,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,16177,0x103109cc0,72,HasIndexedInterceptorIC
code-creation,Builtin,2,16187,0x103109d40,172,EnqueueMicrotask
code-creation,Builtin,2,16196,0x103109e00,8,RunMicrotasksTrampoline
code-creation,Builtin,2,16209,0x103109e40,3744,RunMicrotasks
code-creation,Builtin,2,16218,0x10310ad00,2716,HasProperty
code-creation,Builtin,2,16227,0x10310b7c0,1168,DeleteProperty
code-creation,Builtin,2,16236,0x10310bc80,2004,CopyDataProperties
code-creation,Builtin,2,16245,0x10310c480,9352,SetDataProperties
code-creation,Builtin,2,16254,0x10310e940,2736,CopyDataPropertiesWithExcludedPropertiesOnStack
code-creation,Builtin,2,16266,0x10310f400,56,CopyDataPropertiesWithExcludedProperties
code-creation,Builtin,2,16278,0x10310f440,28,Abort
code-creation,Builtin,2,16286,0x10310f480,28,AbortCSADcheck
code-creation,Builtin,2,16295,0x10310f4c0,12,EmptyFunction
code-creation,Builtin,2,16303,0x10310f500,12,Illegal
code-creation,Builtin,2,16311,0x10310f540,12,StrictPoisonPillThrower
code-creation,Builtin,2,16321,0x10310f580,12,UnsupportedThrower
code-creation,Builtin,2,16330,0x10310f5c0,60,ReturnReceiver
code-creation,Builtin,2,16338,0x10310f600,36,ArrayConstructor
code-creation,Builtin,2,16347,0x10310f640,412,ArrayConstructorImpl
code-creation,Builtin,2,16356,0x10310f800,220,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,16368,0x10310f900,220,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,16380,0x10310fa00,180,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,16393,0x10310fac0,180,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,16406,0x10310fb80,180,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,16419,0x10310fc40,180,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,16432,0x10310fd00,192,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,16445,0x10310fe00,192,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,16458,0x10310ff00,508,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,16471,0x103110100,472,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,16483,0x103110300,436,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,16496,0x1031104c0,400,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,16510,0x103110680,436,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,16523,0x103110840,400,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,16537,0x103110a00,444,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,16551,0x103110bc0,408,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,16564,0x103110d80,56,ArrayNArgumentsConstructor
code-creation,Builtin,2,16574,0x103110dc0,12,ArrayConcat
code-creation,Builtin,2,16582,0x103110e00,12,ArrayPrototypeFill
code-creation,Builtin,2,16594,0x103110e40,928,ArrayIncludesSmiOrObject
code-creation,Builtin,2,16604,0x103111200,152,ArrayIncludesPackedDoubles
code-creation,Builtin,2,16614,0x1031112c0,220,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,16623,0x1031113c0,544,ArrayIncludes
code-creation,Builtin,2,16632,0x103111600,844,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,16642,0x103111980,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,16652,0x103111a00,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,16662,0x103111a80,548,ArrayIndexOf
code-creation,Builtin,2,16670,0x103111cc0,12,ArrayPop
code-creation,Builtin,2,16679,0x103111d00,608,ArrayPrototypePop
code-creation,Builtin,2,16688,0x103111f80,12,ArrayPrototypeGroupBy
code-creation,Builtin,2,16697,0x103111fc0,12,ArrayPrototypeGroupByToMap
code-creation,Builtin,2,16707,0x103112000,12,ArrayPush
code-creation,Builtin,2,16716,0x103112040,2420,ArrayPrototypePush
code-creation,Builtin,2,16725,0x1031129c0,12,ArrayShift
code-creation,Builtin,2,16733,0x103112a00,12,ArrayUnshift
code-creation,Builtin,2,16741,0x103112a40,952,CloneFastJSArray
code-creation,Builtin,2,16750,0x103112e00,2164,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,16766,0x103113680,984,ExtractFastJSArray
code-creation,Builtin,2,16775,0x103113a80,260,ArrayPrototypeEntries
code-creation,Builtin,2,16785,0x103113bc0,244,ArrayPrototypeKeys
code-creation,Builtin,2,16794,0x103113cc0,260,ArrayPrototypeValues
code-creation,Builtin,2,16803,0x103113e00,4464,ArrayIteratorPrototypeNext
code-creation,Builtin,2,16813,0x103114f80,4148,FlattenIntoArray
code-creation,Builtin,2,16821,0x103115fc0,4160,FlatMapIntoArray
code-creation,Builtin,2,16830,0x103117040,384,ArrayPrototypeFlat
code-creation,Builtin,2,16839,0x103117200,444,ArrayPrototypeFlatMap
code-creation,Builtin,2,16849,0x1031173c0,12,ArrayBufferConstructor
code-creation,Builtin,2,16858,0x103117400,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,16870,0x103117440,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,16880,0x103117480,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,16890,0x1031174c0,924,AsyncFunctionEnter
code-creation,Builtin,2,16899,0x103117880,80,AsyncFunctionReject
code-creation,Builtin,2,16908,0x103117900,76,AsyncFunctionResolve
code-creation,Builtin,2,16918,0x103117980,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,16928,0x1031179c0,1820,AsyncFunctionAwaitCaught
code-creation,Builtin,2,16938,0x103118100,1820,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,16948,0x103118840,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,16959,0x103118900,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,16969,0x1031189c0,12,BigIntConstructor
code-creation,Builtin,2,16978,0x103118a00,12,BigIntAsUintN
code-creation,Builtin,2,16987,0x103118a40,12,BigIntAsIntN
code-creation,Builtin,2,16995,0x103118a80,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,17006,0x103118ac0,12,BigIntPrototypeToString
code-creation,Builtin,2,17016,0x103118b00,12,BigIntPrototypeValueOf
code-creation,Builtin,2,17026,0x103118b40,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,17036,0x103118b80,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,17047,0x103118bc0,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,17058,0x103118c00,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,17069,0x103118c40,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,17127,0x103118c80,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,17137,0x103118cc0,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,17149,0x103118d00,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,17161,0x103118d40,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,17171,0x103118d80,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,17182,0x103118dc0,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,17192,0x103118e00,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,17203,0x103118e40,12,CallSitePrototypeGetThis
code-creation,Builtin,2,17213,0x103118e80,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,17224,0x103118ec0,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,17233,0x103118f00,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,17243,0x103118f40,12,CallSitePrototypeIsEval
code-creation,Builtin,2,17253,0x103118f80,12,CallSitePrototypeIsNative
code-creation,Builtin,2,17263,0x103118fc0,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,17273,0x103119000,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,17283,0x103119040,12,CallSitePrototypeToString
code-creation,Builtin,2,17293,0x103119080,12,ConsoleDebug
code-creation,Builtin,2,17301,0x1031190c0,12,ConsoleError
code-creation,Builtin,2,17310,0x103119100,12,ConsoleInfo
code-creation,Builtin,2,17318,0x103119140,12,ConsoleLog
code-creation,Builtin,2,17326,0x103119180,12,ConsoleWarn
code-creation,Builtin,2,17335,0x1031191c0,12,ConsoleDir
code-creation,Builtin,2,17345,0x103119200,12,ConsoleDirXml
code-creation,Builtin,2,17354,0x103119240,12,ConsoleTable
code-creation,Builtin,2,17362,0x103119280,12,ConsoleTrace
code-creation,Builtin,2,17370,0x1031192c0,12,ConsoleGroup
code-creation,Builtin,2,17379,0x103119300,12,ConsoleGroupCollapsed
code-creation,Builtin,2,17394,0x103119340,12,ConsoleGroupEnd
code-creation,Builtin,2,17403,0x103119380,12,ConsoleClear
code-creation,Builtin,2,17412,0x1031193c0,12,ConsoleCount
code-creation,Builtin,2,17420,0x103119400,12,ConsoleCountReset
code-creation,Builtin,2,17429,0x103119440,12,ConsoleAssert
code-creation,Builtin,2,17438,0x103119480,12,ConsoleProfile
code-creation,Builtin,2,17446,0x1031194c0,12,ConsoleProfileEnd
code-creation,Builtin,2,17455,0x103119500,12,ConsoleTime
code-creation,Builtin,2,17463,0x103119540,12,ConsoleTimeLog
code-creation,Builtin,2,17472,0x103119580,12,ConsoleTimeEnd
code-creation,Builtin,2,17480,0x1031195c0,12,ConsoleTimeStamp
code-creation,Builtin,2,17490,0x103119600,12,ConsoleContext
code-creation,Builtin,2,17499,0x103119640,12,DataViewConstructor
code-creation,Builtin,2,17509,0x103119680,12,DateConstructor
code-creation,Builtin,2,17518,0x1031196c0,224,DatePrototypeGetDate
code-creation,Builtin,2,17527,0x1031197c0,224,DatePrototypeGetDay
code-creation,Builtin,2,17536,0x1031198c0,224,DatePrototypeGetFullYear
code-creation,Builtin,2,17545,0x1031199c0,224,DatePrototypeGetHours
code-creation,Builtin,2,17555,0x103119ac0,212,DatePrototypeGetMilliseconds
code-creation,Builtin,2,17564,0x103119bc0,224,DatePrototypeGetMinutes
code-creation,Builtin,2,17574,0x103119cc0,224,DatePrototypeGetMonth
code-creation,Builtin,2,17583,0x103119dc0,224,DatePrototypeGetSeconds
code-creation,Builtin,2,17592,0x103119ec0,124,DatePrototypeGetTime
code-creation,Builtin,2,17601,0x103119f40,212,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,17611,0x10311a040,212,DatePrototypeGetUTCDate
code-creation,Builtin,2,17620,0x10311a140,212,DatePrototypeGetUTCDay
code-creation,Builtin,2,17630,0x10311a240,212,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,17639,0x10311a340,212,DatePrototypeGetUTCHours
code-creation,Builtin,2,17649,0x10311a440,212,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,17659,0x10311a540,212,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,17668,0x10311a640,212,DatePrototypeGetUTCMonth
code-creation,Builtin,2,17678,0x10311a740,212,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,17688,0x10311a840,124,DatePrototypeValueOf
code-creation,Builtin,2,17697,0x10311a8c0,372,DatePrototypeToPrimitive
code-creation,Builtin,2,17707,0x10311aa40,12,DatePrototypeGetYear
code-creation,Builtin,2,17716,0x10311aa80,12,DatePrototypeSetYear
code-creation,Builtin,2,17725,0x10311aac0,12,DateNow
code-creation,Builtin,2,17733,0x10311ab00,12,DateParse
code-creation,Builtin,2,17741,0x10311ab40,12,DatePrototypeSetDate
code-creation,Builtin,2,17750,0x10311ab80,12,DatePrototypeSetFullYear
code-creation,Builtin,2,17759,0x10311abc0,12,DatePrototypeSetHours
code-creation,Builtin,2,17769,0x10311ac00,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,17780,0x10311ac40,12,DatePrototypeSetMinutes
code-creation,Builtin,2,17790,0x10311ac80,12,DatePrototypeSetMonth
code-creation,Builtin,2,17799,0x10311acc0,12,DatePrototypeSetSeconds
code-creation,Builtin,2,17808,0x10311ad00,12,DatePrototypeSetTime
code-creation,Builtin,2,17817,0x10311ad40,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,17826,0x10311ad80,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,17836,0x10311adc0,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,17845,0x10311ae00,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,17856,0x10311ae40,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,17865,0x10311ae80,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,17875,0x10311aec0,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,17884,0x10311af00,12,DatePrototypeToDateString
code-creation,Builtin,2,17894,0x10311af40,12,DatePrototypeToISOString
code-creation,Builtin,2,17904,0x10311af80,12,DatePrototypeToUTCString
code-creation,Builtin,2,17913,0x10311afc0,12,DatePrototypeToString
code-creation,Builtin,2,17922,0x10311b000,12,DatePrototypeToTimeString
code-creation,Builtin,2,17932,0x10311b040,12,DatePrototypeToJson
code-creation,Builtin,2,17941,0x10311b080,12,DateUTC
code-creation,Builtin,2,17949,0x10311b0c0,12,ErrorConstructor
code-creation,Builtin,2,17962,0x10311b100,12,ErrorCaptureStackTrace
code-creation,Builtin,2,17971,0x10311b140,12,ErrorPrototypeToString
code-creation,Builtin,2,17980,0x10311b180,12,FunctionConstructor
code-creation,Builtin,2,17989,0x10311b1c0,80,FunctionPrototypeApply
code-creation,Builtin,2,17999,0x10311b240,12,FunctionPrototypeBind
code-creation,Builtin,2,18008,0x10311b280,36,FunctionPrototypeCall
code-creation,Builtin,2,18018,0x10311b2c0,12,FunctionPrototypeToString
code-creation,Builtin,2,18027,0x10311b300,192,CreateIterResultObject
code-creation,Builtin,2,18037,0x10311b400,812,CreateGeneratorObject
code-creation,Builtin,2,18046,0x10311b740,12,GeneratorFunctionConstructor
code-creation,Builtin,2,18056,0x10311b780,416,GeneratorPrototypeNext
code-creation,Builtin,2,18065,0x10311b940,420,GeneratorPrototypeReturn
code-creation,Builtin,2,18075,0x10311bb00,424,GeneratorPrototypeThrow
code-creation,Builtin,2,18084,0x10311bcc0,12,AsyncFunctionConstructor
code-creation,Builtin,2,18094,0x10311bd00,384,SuspendGeneratorBaseline
code-creation,Builtin,2,18103,0x10311bec0,100,ResumeGeneratorBaseline
code-creation,Builtin,2,18112,0x10311bf40,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,18124,0x10311bf80,12,GlobalDecodeURI
code-creation,Builtin,2,18133,0x10311bfc0,12,GlobalDecodeURIComponent
code-creation,Builtin,2,18142,0x10311c000,12,GlobalEncodeURI
code-creation,Builtin,2,18151,0x10311c040,12,GlobalEncodeURIComponent
code-creation,Builtin,2,18160,0x10311c080,12,GlobalEscape
code-creation,Builtin,2,18169,0x10311c0c0,12,GlobalUnescape
code-creation,Builtin,2,18177,0x10311c100,12,GlobalEval
code-creation,Builtin,2,18185,0x10311c140,136,GlobalIsFinite
code-creation,Builtin,2,18194,0x10311c200,132,GlobalIsNaN
code-creation,Builtin,2,18202,0x10311c2c0,12,JsonParse
code-creation,Builtin,2,18210,0x10311c300,12,JsonStringify
code-creation,Builtin,2,18218,0x10311c340,4340,LoadIC
code-creation,Builtin,2,18226,0x10311d440,4156,LoadIC_Megamorphic
code-creation,Builtin,2,18235,0x10311e480,4352,LoadIC_Noninlined
code-creation,Builtin,2,18243,0x10311f5c0,44,LoadICTrampoline
code-creation,Builtin,2,18252,0x10311f600,24,LoadICBaseline
code-creation,Builtin,2,18261,0x10311f640,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,18270,0x10311f680,7196,LoadSuperIC
code-creation,Builtin,2,18278,0x1031212c0,24,LoadSuperICBaseline
code-creation,Builtin,2,18287,0x103121300,8204,KeyedLoadIC
code-creation,Builtin,2,18295,0x103123340,13196,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,18305,0x103126700,44,KeyedLoadICTrampoline
code-creation,Builtin,2,18314,0x103126740,24,KeyedLoadICBaseline
tick,0x7ff805e4dd52,18327,0,0x0,6
tick,0x7ff805db1759,18333,0,0x0,6
tick,0x7ff805ea6abe,18345,0,0x0,6
code-creation,Builtin,2,18379,0x103126780,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,18393,0x1031267c0,5072,StoreGlobalIC
code-creation,Builtin,2,18401,0x103127bc0,44,StoreGlobalICTrampoline
code-creation,Builtin,2,18409,0x103127c00,24,StoreGlobalICBaseline
code-creation,Builtin,2,18417,0x103127c40,5276,StoreIC
code-creation,Builtin,2,18424,0x103129100,44,StoreICTrampoline
code-creation,Builtin,2,18431,0x103129140,24,StoreICBaseline
code-creation,Builtin,2,18438,0x103129180,5088,DefineNamedOwnIC
code-creation,Builtin,2,18446,0x10312a580,44,DefineNamedOwnICTrampoline
code-creation,Builtin,2,18454,0x10312a5c0,24,DefineNamedOwnICBaseline
code-creation,Builtin,2,18462,0x10312a600,5744,KeyedStoreIC
code-creation,Builtin,2,18469,0x10312bc80,44,KeyedStoreICTrampoline
code-creation,Builtin,2,18478,0x10312bcc0,24,KeyedStoreICBaseline
code-creation,Builtin,2,18485,0x10312bd00,5564,DefineKeyedOwnIC
code-creation,Builtin,2,18492,0x10312d2c0,44,DefineKeyedOwnICTrampoline
code-creation,Builtin,2,18501,0x10312d300,24,DefineKeyedOwnICBaseline
code-creation,Builtin,2,18509,0x10312d340,384,StoreInArrayLiteralIC
code-creation,Builtin,2,18516,0x10312d500,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,18525,0x10312d540,140,LookupContextBaseline
code-creation,Builtin,2,18533,0x10312d600,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,18548,0x10312d6c0,3036,LoadGlobalIC
code-creation,Builtin,2,18555,0x10312e2c0,3020,LoadGlobalICInsideTypeof
code-creation,Builtin,2,18564,0x10312eec0,44,LoadGlobalICTrampoline
code-creation,Builtin,2,18571,0x10312ef00,24,LoadGlobalICBaseline
code-creation,Builtin,2,18579,0x10312ef40,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,18588,0x10312ef80,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,18597,0x10312efc0,144,LookupGlobalICBaseline
code-creation,Builtin,2,18604,0x10312f080,144,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,18614,0x10312f140,2048,CloneObjectIC
code-creation,Builtin,2,18621,0x10312f980,24,CloneObjectICBaseline
code-creation,Builtin,2,18629,0x10312f9c0,2060,CloneObjectIC_Slow
code-creation,Builtin,2,18636,0x103130200,2908,KeyedHasIC
code-creation,Builtin,2,18643,0x103130d80,24,KeyedHasICBaseline
code-creation,Builtin,2,18650,0x103130dc0,2716,KeyedHasIC_Megamorphic
code-creation,Builtin,2,18658,0x103131880,1456,IterableToList
code-creation,Builtin,2,18665,0x103131e40,1260,IterableToFixedArray
code-creation,Builtin,2,18672,0x103132340,736,IterableToListWithSymbolLookup
code-creation,Builtin,2,18681,0x103132640,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,18691,0x103132680,128,IterableToListMayPreserveHoles
code-creation,Builtin,2,18699,0x103132740,1012,IterableToFixedArrayForWasm
code-creation,Builtin,2,18707,0x103132b40,1516,StringListFromIterable
code-creation,Builtin,2,18714,0x103133140,1216,FindOrderedHashMapEntry
code-creation,Builtin,2,18722,0x103133640,4212,MapConstructor
code-creation,Builtin,2,18728,0x1031346c0,1968,MapPrototypeSet
code-creation,Builtin,2,18735,0x103134e80,1532,MapPrototypeDelete
code-creation,Builtin,2,18742,0x103135480,208,MapPrototypeGet
code-creation,Builtin,2,18749,0x103135580,168,MapPrototypeHas
code-creation,Builtin,2,18756,0x103135640,12,MapPrototypeClear
code-creation,Builtin,2,18763,0x103135680,284,MapPrototypeEntries
code-creation,Builtin,2,18770,0x1031357c0,144,MapPrototypeGetSize
code-creation,Builtin,2,18777,0x103135880,500,MapPrototypeForEach
code-creation,Builtin,2,18784,0x103135a80,288,MapPrototypeKeys
code-creation,Builtin,2,18791,0x103135bc0,288,MapPrototypeValues
code-creation,Builtin,2,18798,0x103135d00,1048,MapIteratorPrototypeNext
code-creation,Builtin,2,18806,0x103136140,1180,MapIteratorToList
code-creation,Builtin,2,18813,0x103136600,12,NumberPrototypeToExponential
code-creation,Builtin,2,18821,0x103136640,12,NumberPrototypeToFixed
code-creation,Builtin,2,18828,0x103136680,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,18836,0x1031366c0,12,NumberPrototypeToPrecision
code-creation,Builtin,2,18844,0x103136700,324,SameValue
code-creation,Builtin,2,18850,0x103136880,200,SameValueNumbersOnly
code-creation,Builtin,2,18857,0x103136980,792,Add_Baseline
code-creation,Builtin,2,18864,0x103136cc0,652,AddSmi_Baseline
code-creation,Builtin,2,18871,0x103136f80,832,Subtract_Baseline
code-creation,Builtin,2,18878,0x103137300,692,SubtractSmi_Baseline
code-creation,Builtin,2,18885,0x1031375c0,820,Multiply_Baseline
code-creation,Builtin,2,18892,0x103137900,712,MultiplySmi_Baseline
code-creation,Builtin,2,18899,0x103137c00,836,Divide_Baseline
code-creation,Builtin,2,18906,0x103137f80,772,DivideSmi_Baseline
code-creation,Builtin,2,18913,0x1031382c0,776,Modulus_Baseline
code-creation,Builtin,2,18920,0x103138600,668,ModulusSmi_Baseline
code-creation,Builtin,2,18927,0x1031388c0,824,Exponentiate_Baseline
code-creation,Builtin,2,18934,0x103138c00,720,ExponentiateSmi_Baseline
code-creation,Builtin,2,18942,0x103138f00,792,BitwiseAnd_Baseline
code-creation,Builtin,2,18949,0x103139240,376,BitwiseAndSmi_Baseline
code-creation,Builtin,2,18956,0x1031393c0,788,BitwiseOr_Baseline
code-creation,Builtin,2,18963,0x103139700,376,BitwiseOrSmi_Baseline
code-creation,Builtin,2,18970,0x103139880,792,BitwiseXor_Baseline
code-creation,Builtin,2,18978,0x103139bc0,376,BitwiseXorSmi_Baseline
code-creation,Builtin,2,18985,0x103139d40,812,ShiftLeft_Baseline
code-creation,Builtin,2,18992,0x10313a080,400,ShiftLeftSmi_Baseline
code-creation,Builtin,2,19005,0x10313a240,812,ShiftRight_Baseline
code-creation,Builtin,2,19012,0x10313a580,388,ShiftRightSmi_Baseline
code-creation,Builtin,2,19020,0x10313a740,924,ShiftRightLogical_Baseline
code-creation,Builtin,2,19027,0x10313ab00,652,ShiftRightLogicalSmi_Baseline
code-creation,Builtin,2,19035,0x10313adc0,724,Add_WithFeedback
code-creation,Builtin,2,19042,0x10313b0c0,784,Subtract_WithFeedback
code-creation,Builtin,2,19050,0x10313b400,784,Multiply_WithFeedback
code-creation,Builtin,2,19057,0x10313b740,812,Divide_WithFeedback
code-creation,Builtin,2,19064,0x10313ba80,736,Modulus_WithFeedback
code-creation,Builtin,2,19071,0x10313bd80,788,Exponentiate_WithFeedback
code-creation,Builtin,2,19079,0x10313c0c0,772,BitwiseAnd_WithFeedback
code-creation,Builtin,2,19086,0x10313c400,768,BitwiseOr_WithFeedback
code-creation,Builtin,2,19094,0x10313c740,772,BitwiseXor_WithFeedback
code-creation,Builtin,2,19101,0x10313ca80,784,ShiftLeft_WithFeedback
code-creation,Builtin,2,19109,0x10313cdc0,784,ShiftRight_WithFeedback
code-creation,Builtin,2,19116,0x10313d100,900,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,19124,0x10313d4c0,1692,Equal_Baseline
code-creation,Builtin,2,19131,0x10313db80,896,StrictEqual_Baseline
code-creation,Builtin,2,19138,0x10313df40,1260,LessThan_Baseline
code-creation,Builtin,2,19145,0x10313e440,1256,GreaterThan_Baseline
code-creation,Builtin,2,19152,0x10313e940,1260,LessThanOrEqual_Baseline
code-creation,Builtin,2,19160,0x10313ee40,1256,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,19167,0x10313f340,1632,Equal_WithFeedback
code-creation,Builtin,2,19175,0x10313f9c0,920,StrictEqual_WithFeedback
code-creation,Builtin,2,19182,0x10313fd80,1240,LessThan_WithFeedback
code-creation,Builtin,2,19189,0x103140280,1240,GreaterThan_WithFeedback
code-creation,Builtin,2,19197,0x103140780,1240,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,19205,0x103140c80,1240,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,19213,0x103141180,356,BitwiseNot_Baseline
code-creation,Builtin,2,19220,0x103141300,460,Decrement_Baseline
code-creation,Builtin,2,19227,0x103141500,464,Increment_Baseline
code-creation,Builtin,2,19234,0x103141700,492,Negate_Baseline
code-creation,Builtin,2,19241,0x103141900,344,BitwiseNot_WithFeedback
code-creation,Builtin,2,19249,0x103141a80,440,Decrement_WithFeedback
code-creation,Builtin,2,19256,0x103141c40,444,Increment_WithFeedback
code-creation,Builtin,2,19264,0x103141e00,472,Negate_WithFeedback
code-creation,Builtin,2,19271,0x103142000,264,ObjectAssign
code-creation,Builtin,2,19277,0x103142140,864,ObjectCreate
code-creation,Builtin,2,19284,0x1031424c0,12,ObjectDefineGetter
code-creation,Builtin,2,19291,0x103142500,12,ObjectDefineProperties
code-creation,Builtin,2,19298,0x103142540,12,ObjectDefineProperty
code-creation,Builtin,2,19305,0x103142580,12,ObjectDefineSetter
code-creation,Builtin,2,19312,0x1031425c0,1476,ObjectEntries
code-creation,Builtin,2,19319,0x103142bc0,12,ObjectFreeze
code-creation,Builtin,2,19325,0x103142c00,5632,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,19333,0x103144240,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,19342,0x103144280,596,ObjectGetOwnPropertyNames
code-creation,Builtin,2,19349,0x103144500,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,19357,0x103144540,168,ObjectHasOwn
code-creation,Builtin,2,19368,0x103144600,388,ObjectIs
code-creation,Builtin,2,19374,0x1031447c0,12,ObjectIsFrozen
code-creation,Builtin,2,19381,0x103144800,12,ObjectIsSealed
code-creation,Builtin,2,19387,0x103144840,532,ObjectKeys
code-creation,Builtin,2,19394,0x103144a80,12,ObjectLookupGetter
code-creation,Builtin,2,19401,0x103144ac0,12,ObjectLookupSetter
code-creation,Builtin,2,19408,0x103144b00,2364,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,19416,0x103145440,236,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,19424,0x103145540,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,19432,0x103145580,12,ObjectPrototypeGetProto
code-creation,Builtin,2,19440,0x1031455c0,12,ObjectPrototypeSetProto
code-creation,Builtin,2,19450,0x103145600,12,ObjectSeal
code-creation,Builtin,2,19457,0x103145640,1132,ObjectToString
code-creation,Builtin,2,19463,0x103145ac0,1248,ObjectValues
code-creation,Builtin,2,19470,0x103145fc0,296,OrdinaryHasInstance
code-creation,Builtin,2,19477,0x103146100,368,InstanceOf
code-creation,Builtin,2,19483,0x103146280,636,InstanceOf_WithFeedback
code-creation,Builtin,2,19491,0x103146500,656,InstanceOf_Baseline
code-creation,Builtin,2,19498,0x1031467c0,268,ForInEnumerate
code-creation,Builtin,2,19505,0x103146900,148,ForInPrepare
code-creation,Builtin,2,19512,0x1031469c0,2668,ForInFilter
code-creation,Builtin,2,19518,0x103147440,56,ReflectApply
code-creation,Builtin,2,19525,0x103147480,64,ReflectConstruct
code-creation,Builtin,2,19532,0x103147500,12,ReflectDefineProperty
code-creation,Builtin,2,19540,0x103147540,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,19549,0x103147580,12,ReflectOwnKeys
code-creation,Builtin,2,19556,0x1031475c0,12,ReflectSet
code-creation,Builtin,2,19562,0x103147600,12,RegExpCapture1Getter
code-creation,Builtin,2,19570,0x103147640,12,RegExpCapture2Getter
code-creation,Builtin,2,19577,0x103147680,12,RegExpCapture3Getter
code-creation,Builtin,2,19687,0x1031476c0,12,RegExpCapture4Getter
code-creation,Builtin,2,19696,0x103147700,12,RegExpCapture5Getter
code-creation,Builtin,2,19705,0x103147740,12,RegExpCapture6Getter
code-creation,Builtin,2,19714,0x103147780,12,RegExpCapture7Getter
code-creation,Builtin,2,19723,0x1031477c0,12,RegExpCapture8Getter
code-creation,Builtin,2,19732,0x103147800,12,RegExpCapture9Getter
code-creation,Builtin,2,19741,0x103147840,2140,RegExpConstructor
code-creation,Builtin,2,19750,0x1031480c0,12,RegExpInputGetter
code-creation,Builtin,2,19758,0x103148100,12,RegExpInputSetter
code-creation,Builtin,2,19767,0x103148140,12,RegExpLastMatchGetter
code-creation,Builtin,2,19776,0x103148180,12,RegExpLastParenGetter
code-creation,Builtin,2,19785,0x1031481c0,12,RegExpLeftContextGetter
code-creation,Builtin,2,19794,0x103148200,848,RegExpPrototypeCompile
code-creation,Builtin,2,19804,0x103148580,12,RegExpPrototypeToString
code-creation,Builtin,2,19813,0x1031485c0,12,RegExpRightContextGetter
code-creation,Builtin,2,19822,0x103148600,252,RegExpExecAtom
code-creation,Builtin,2,19831,0x103148700,1004,RegExpExecInternal
code-creation,Builtin,2,19840,0x103148b00,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,19849,0x103148b40,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,19859,0x103148b80,2764,SetConstructor
code-creation,Builtin,2,19868,0x103149680,1312,SetPrototypeHas
code-creation,Builtin,2,19876,0x103149bc0,1744,SetPrototypeAdd
code-creation,Builtin,2,19884,0x10314a2c0,1492,SetPrototypeDelete
code-creation,Builtin,2,19893,0x10314a8c0,12,SetPrototypeClear
code-creation,Builtin,2,19902,0x10314a900,288,SetPrototypeEntries
code-creation,Builtin,2,19911,0x10314aa40,144,SetPrototypeGetSize
code-creation,Builtin,2,19920,0x10314ab00,464,SetPrototypeForEach
code-creation,Builtin,2,19929,0x10314ad00,288,SetPrototypeValues
code-creation,Builtin,2,19937,0x10314ae40,984,SetIteratorPrototypeNext
code-creation,Builtin,2,19947,0x10314b240,1112,SetOrSetIteratorToList
code-creation,Builtin,2,19956,0x10314b6c0,12,ShadowRealmConstructor
code-creation,Builtin,2,19965,0x10314b700,572,ShadowRealmGetWrappedValue
code-creation,Builtin,2,19974,0x10314b940,12,ShadowRealmPrototypeEvaluate
code-creation,Builtin,2,19984,0x10314b980,12,ShadowRealmPrototypeImportValue
code-creation,Builtin,2,19994,0x10314b9c0,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,20004,0x10314ba00,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,20014,0x10314ba40,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,20024,0x10314ba80,1336,AtomicsLoad
code-creation,Builtin,2,20032,0x10314bfc0,1068,AtomicsStore
code-creation,Builtin,2,20040,0x10314c400,1716,AtomicsExchange
code-creation,Builtin,2,20049,0x10314cac0,2064,AtomicsCompareExchange
code-creation,Builtin,2,20058,0x10314d300,1804,AtomicsAdd
code-creation,Builtin,2,20066,0x10314da40,1804,AtomicsSub
code-creation,Builtin,2,20078,0x10314e180,1804,AtomicsAnd
code-creation,Builtin,2,20086,0x10314e8c0,1804,AtomicsOr
code-creation,Builtin,2,20094,0x10314f000,1804,AtomicsXor
code-creation,Builtin,2,20102,0x10314f740,12,AtomicsNotify
code-creation,Builtin,2,20110,0x10314f780,12,AtomicsIsLockFree
code-creation,Builtin,2,20119,0x10314f7c0,12,AtomicsWait
code-creation,Builtin,2,20127,0x10314f800,12,AtomicsWaitAsync
code-creation,Builtin,2,20136,0x10314f840,12,StringFromCodePoint
code-creation,Builtin,2,20145,0x10314f880,1456,StringFromCharCode
code-creation,Builtin,2,20153,0x10314fe40,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,20163,0x10314fe80,4316,StringPrototypeMatchAll
code-creation,Builtin,2,20172,0x103150f80,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,20181,0x103150fc0,1216,StringPrototypeReplace
code-creation,Builtin,2,20191,0x1031514c0,2900,StringPrototypeSplit
code-creation,Builtin,2,20200,0x103152040,12,StringRaw
code-creation,Builtin,2,20207,0x103152080,12,SymbolConstructor
code-creation,Builtin,2,20216,0x1031520c0,12,SymbolFor
code-creation,Builtin,2,20224,0x103152100,12,SymbolKeyFor
code-creation,Builtin,2,20232,0x103152140,88,TypedArrayBaseConstructor
code-creation,Builtin,2,20241,0x1031521c0,264,TypedArrayConstructor
code-creation,Builtin,2,20251,0x103152300,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,20260,0x103152340,908,TypedArrayPrototypeByteLength
code-creation,Builtin,2,20270,0x103152700,360,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,20279,0x103152880,612,TypedArrayPrototypeLength
code-creation,Builtin,2,20289,0x103152b00,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,20298,0x103152b40,12,TypedArrayPrototypeFill
code-creation,Builtin,2,20308,0x103152b80,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,20317,0x103152bc0,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,20327,0x103152c00,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,20336,0x103152c40,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,20346,0x103152c80,304,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,20356,0x103152dc0,24312,TypedArrayPrototypeMap
code-creation,Builtin,2,20365,0x103158cc0,1000,GenericJSToWasmWrapper
code-creation,Builtin,2,20374,0x1031590c0,1176,WasmReturnPromiseOnSuspend
code-creation,Builtin,2,20384,0x103159580,156,WasmSuspend
code-creation,Builtin,2,20392,0x103159640,248,WasmResume
code-creation,Builtin,2,20400,0x103159740,160,WasmCompileLazy
code-creation,Builtin,2,20408,0x103159800,168,WasmDebugBreak
code-creation,Builtin,2,20416,0x1031598c0,16,WasmOnStackReplace
code-creation,Builtin,2,20425,0x103159900,136,WasmFloat32ToNumber
code-creation,Builtin,2,20434,0x1031599c0,148,WasmFloat64ToNumber
code-creation,Builtin,2,20443,0x103159a80,4,WasmI32AtomicWait32
code-creation,Builtin,2,20452,0x103159ac0,4,WasmI64AtomicWait32
code-creation,Builtin,2,20460,0x103159b00,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,20470,0x103159b40,4372,WeakMapConstructor
code-creation,Builtin,2,20479,0x10315ac80,212,WeakMapLookupHashIndex
code-creation,Builtin,2,20488,0x10315ad80,220,WeakMapGet
code-creation,Builtin,2,20496,0x10315ae80,180,WeakMapPrototypeHas
code-creation,Builtin,2,20505,0x10315af40,220,WeakMapPrototypeSet
code-creation,Builtin,2,20514,0x10315b040,144,WeakMapPrototypeDelete
code-creation,Builtin,2,20523,0x10315b100,2956,WeakSetConstructor
code-creation,Builtin,2,20531,0x10315bcc0,180,WeakSetPrototypeHas
code-creation,Builtin,2,20540,0x10315bd80,224,WeakSetPrototypeAdd
code-creation,Builtin,2,20549,0x10315be80,144,WeakSetPrototypeDelete
code-creation,Builtin,2,20558,0x10315bf40,396,WeakCollectionDelete
code-creation,Builtin,2,20567,0x10315c100,784,WeakCollectionSet
code-creation,Builtin,2,20575,0x10315c440,12,SharedStructTypeConstructor
code-creation,Builtin,2,20585,0x10315c480,12,SharedStructConstructor
code-creation,Builtin,2,20594,0x10315c4c0,292,AsyncGeneratorResolve
code-creation,Builtin,2,20603,0x10315c600,104,AsyncGeneratorReject
code-creation,Builtin,2,20612,0x10315c680,1912,AsyncGeneratorYield
code-creation,Builtin,2,20621,0x10315ce00,2028,AsyncGeneratorReturn
code-creation,Builtin,2,20633,0x10315d600,312,AsyncGeneratorResumeNext
code-creation,Builtin,2,20642,0x10315d740,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,20652,0x10315d780,1012,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,20662,0x10315db80,1016,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,20672,0x10315df80,1016,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,20681,0x10315e380,1860,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,20691,0x10315eb00,1860,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,20700,0x10315f280,168,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,20711,0x10315f340,176,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,20721,0x10315f400,120,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,20731,0x10315f480,120,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,20741,0x10315f500,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,20752,0x10315f580,176,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,20762,0x10315f640,1668,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,20773,0x10315fd00,1780,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,20783,0x103160400,1800,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,20793,0x103160b40,96,AsyncIteratorValueUnwrap
code-creation,Builtin,2,20803,0x103160bc0,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,20815,0x103160cc0,220,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,20827,0x103160dc0,204,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,20859,0x103160ec0,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,20872,0x103161080,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,20884,0x103161240,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,20896,0x103161340,220,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,20908,0x103161440,204,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,20921,0x103161540,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,20933,0x103161700,400,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,20944,0x1031618c0,4,DirectCEntry
code-creation,Builtin,2,20953,0x103161900,1072,StringAdd_CheckNone
code-creation,Builtin,2,20962,0x103161d40,2416,SubString
code-creation,Builtin,2,20970,0x1031626c0,16,StackCheck
code-creation,Builtin,2,20978,0x103162700,84,DoubleToI
code-creation,Builtin,2,20986,0x103162780,2276,GetProperty
code-creation,Builtin,2,20994,0x103163080,2368,GetPropertyWithReceiver
code-creation,Builtin,2,21003,0x103163a00,15652,SetProperty
code-creation,Builtin,2,21011,0x103167740,13592,CreateDataProperty
code-creation,Builtin,2,21020,0x10316ac80,8,MemCopyUint8Uint8
code-creation,Builtin,2,21029,0x10316acc0,8,MemMove
code-creation,Builtin,2,21036,0x10316ad00,12,IsTraceCategoryEnabled
code-creation,Builtin,2,21045,0x10316ad40,12,Trace
code-creation,Builtin,2,21053,0x10316ad80,12,FinalizationRegistryUnregister
code-creation,Builtin,2,21063,0x10316adc0,420,AsyncModuleEvaluate
code-creation,Builtin,2,21248,0x10316af80,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,21258,0x10316afc0,12,CallAsyncModuleRejected
code-creation,Builtin,2,21268,0x10316b000,12,TemporalNowTimeZone
code-creation,Builtin,2,21277,0x10316b040,12,TemporalNowInstant
code-creation,Builtin,2,21286,0x10316b080,12,TemporalNowPlainDateTime
code-creation,Builtin,2,21296,0x10316b0c0,12,TemporalNowPlainDateTimeISO
code-creation,Builtin,2,21306,0x10316b100,12,TemporalNowZonedDateTime
code-creation,Builtin,2,21317,0x10316b140,12,TemporalNowZonedDateTimeISO
code-creation,Builtin,2,21327,0x10316b180,12,TemporalNowPlainDate
code-creation,Builtin,2,21336,0x10316b1c0,12,TemporalNowPlainDateISO
code-creation,Builtin,2,21346,0x10316b200,12,TemporalNowPlainTimeISO
code-creation,Builtin,2,21355,0x10316b240,12,TemporalPlainDateConstructor
code-creation,Builtin,2,21370,0x10316b280,12,TemporalPlainDateFrom
code-creation,Builtin,2,21379,0x10316b2c0,12,TemporalPlainDateCompare
code-creation,Builtin,2,21388,0x10316b300,12,TemporalPlainDatePrototypeCalendar
code-creation,Builtin,2,21399,0x10316b340,12,TemporalPlainDatePrototypeYear
code-creation,Builtin,2,21408,0x10316b380,12,TemporalPlainDatePrototypeMonth
code-creation,Builtin,2,21418,0x10316b3c0,12,TemporalPlainDatePrototypeMonthCode
code-creation,Builtin,2,21429,0x10316b400,12,TemporalPlainDatePrototypeDay
code-creation,Builtin,2,21439,0x10316b440,12,TemporalPlainDatePrototypeDayOfWeek
code-creation,Builtin,2,21450,0x10316b480,12,TemporalPlainDatePrototypeDayOfYear
code-creation,Builtin,2,21461,0x10316b4c0,12,TemporalPlainDatePrototypeWeekOfYear
code-creation,Builtin,2,21472,0x10316b500,12,TemporalPlainDatePrototypeDaysInWeek
code-creation,Builtin,2,21483,0x10316b540,12,TemporalPlainDatePrototypeDaysInMonth
code-creation,Builtin,2,21494,0x10316b580,12,TemporalPlainDatePrototypeDaysInYear
code-creation,Builtin,2,21504,0x10316b5c0,12,TemporalPlainDatePrototypeMonthsInYear
code-creation,Builtin,2,21515,0x10316b600,12,TemporalPlainDatePrototypeInLeapYear
code-creation,Builtin,2,21525,0x10316b640,12,TemporalPlainDatePrototypeToPlainYearMonth
code-creation,Builtin,2,21537,0x10316b680,12,TemporalPlainDatePrototypeToPlainMonthDay
code-creation,Builtin,2,21548,0x10316b6c0,12,TemporalPlainDatePrototypeGetISOFields
code-creation,Builtin,2,21560,0x10316b700,12,TemporalPlainDatePrototypeAdd
code-creation,Builtin,2,21571,0x10316b740,12,TemporalPlainDatePrototypeSubtract
code-creation,Builtin,2,21582,0x10316b780,12,TemporalPlainDatePrototypeWith
code-creation,Builtin,2,21592,0x10316b7c0,12,TemporalPlainDatePrototypeWithCalendar
code-creation,Builtin,2,21602,0x10316b800,12,TemporalPlainDatePrototypeUntil
code-creation,Builtin,2,21612,0x10316b840,12,TemporalPlainDatePrototypeSince
code-creation,Builtin,2,21623,0x10316b880,12,TemporalPlainDatePrototypeEquals
code-creation,Builtin,2,21635,0x10316b8c0,12,TemporalPlainDatePrototypeToPlainDateTime
code-creation,Builtin,2,21646,0x10316b900,12,TemporalPlainDatePrototypeToZonedDateTime
code-creation,Builtin,2,21656,0x10316b940,12,TemporalPlainDatePrototypeToString
code-creation,Builtin,2,21667,0x10316b980,12,TemporalPlainDatePrototypeToJSON
code-creation,Builtin,2,21677,0x10316b9c0,12,TemporalPlainDatePrototypeValueOf
code-creation,Builtin,2,21687,0x10316ba00,12,TemporalPlainTimeConstructor
code-creation,Builtin,2,21697,0x10316ba40,12,TemporalPlainTimeFrom
code-creation,Builtin,2,21706,0x10316ba80,12,TemporalPlainTimeCompare
code-creation,Builtin,2,21715,0x10316bac0,12,TemporalPlainTimePrototypeCalendar
code-creation,Builtin,2,21726,0x10316bb00,12,TemporalPlainTimePrototypeHour
code-creation,Builtin,2,21735,0x10316bb40,12,TemporalPlainTimePrototypeMinute
code-creation,Builtin,2,21746,0x10316bb80,12,TemporalPlainTimePrototypeSecond
code-creation,Builtin,2,21756,0x10316bbc0,12,TemporalPlainTimePrototypeMillisecond
code-creation,Builtin,2,21767,0x10316bc00,12,TemporalPlainTimePrototypeMicrosecond
code-creation,Builtin,2,21778,0x10316bc40,12,TemporalPlainTimePrototypeNanosecond
code-creation,Builtin,2,21789,0x10316bc80,12,TemporalPlainTimePrototypeAdd
code-creation,Builtin,2,21799,0x10316bcc0,12,TemporalPlainTimePrototypeSubtract
code-creation,Builtin,2,21810,0x10316bd00,12,TemporalPlainTimePrototypeWith
code-creation,Builtin,2,21820,0x10316bd40,12,TemporalPlainTimePrototypeUntil
code-creation,Builtin,2,21831,0x10316bd80,12,TemporalPlainTimePrototypeSince
code-creation,Builtin,2,21842,0x10316bdc0,12,TemporalPlainTimePrototypeRound
code-creation,Builtin,2,21853,0x10316be00,12,TemporalPlainTimePrototypeEquals
code-creation,Builtin,2,21863,0x10316be40,12,TemporalPlainTimePrototypeToPlainDateTime
code-creation,Builtin,2,21874,0x10316be80,12,TemporalPlainTimePrototypeToZonedDateTime
code-creation,Builtin,2,21885,0x10316bec0,12,TemporalPlainTimePrototypeGetISOFields
code-creation,Builtin,2,21896,0x10316bf00,12,TemporalPlainTimePrototypeToString
code-creation,Builtin,2,21911,0x10316bf40,12,TemporalPlainTimePrototypeToJSON
code-creation,Builtin,2,21922,0x10316bf80,12,TemporalPlainTimePrototypeValueOf
code-creation,Builtin,2,21932,0x10316bfc0,12,TemporalPlainDateTimeConstructor
code-creation,Builtin,2,21942,0x10316c000,12,TemporalPlainDateTimeFrom
code-creation,Builtin,2,21952,0x10316c040,12,TemporalPlainDateTimeCompare
code-creation,Builtin,2,21961,0x10316c080,12,TemporalPlainDateTimePrototypeCalendar
code-creation,Builtin,2,21972,0x10316c0c0,12,TemporalPlainDateTimePrototypeYear
code-creation,Builtin,2,21982,0x10316c100,12,TemporalPlainDateTimePrototypeMonth
code-creation,Builtin,2,21993,0x10316c140,12,TemporalPlainDateTimePrototypeMonthCode
code-creation,Builtin,2,22005,0x10316c180,12,TemporalPlainDateTimePrototypeDay
code-creation,Builtin,2,22015,0x10316c1c0,12,TemporalPlainDateTimePrototypeHour
code-creation,Builtin,2,22025,0x10316c200,12,TemporalPlainDateTimePrototypeMinute
code-creation,Builtin,2,22036,0x10316c240,12,TemporalPlainDateTimePrototypeSecond
code-creation,Builtin,2,22046,0x10316c280,12,TemporalPlainDateTimePrototypeMillisecond
code-creation,Builtin,2,22057,0x10316c2c0,12,TemporalPlainDateTimePrototypeMicrosecond
code-creation,Builtin,2,22068,0x10316c300,12,TemporalPlainDateTimePrototypeNanosecond
code-creation,Builtin,2,22079,0x10316c340,12,TemporalPlainDateTimePrototypeDayOfWeek
code-creation,Builtin,2,22121,0x10316c380,12,TemporalPlainDateTimePrototypeDayOfYear
code-creation,Builtin,2,22132,0x10316c3c0,12,TemporalPlainDateTimePrototypeWeekOfYear
code-creation,Builtin,2,22143,0x10316c400,12,TemporalPlainDateTimePrototypeDaysInWeek
code-creation,Builtin,2,22153,0x10316c440,12,TemporalPlainDateTimePrototypeDaysInMonth
code-creation,Builtin,2,22164,0x10316c480,12,TemporalPlainDateTimePrototypeDaysInYear
code-creation,Builtin,2,22175,0x10316c4c0,12,TemporalPlainDateTimePrototypeMonthsInYear
code-creation,Builtin,2,22186,0x10316c500,12,TemporalPlainDateTimePrototypeInLeapYear
code-creation,Builtin,2,22197,0x10316c540,12,TemporalPlainDateTimePrototypeWith
code-creation,Builtin,2,22207,0x10316c580,12,TemporalPlainDateTimePrototypeWithPlainTime
code-creation,Builtin,2,22218,0x10316c5c0,12,TemporalPlainDateTimePrototypeWithPlainDate
code-creation,Builtin,2,22229,0x10316c600,12,TemporalPlainDateTimePrototypeWithCalendar
code-creation,Builtin,2,22240,0x10316c640,12,TemporalPlainDateTimePrototypeAdd
code-creation,Builtin,2,22251,0x10316c680,12,TemporalPlainDateTimePrototypeSubtract
code-creation,Builtin,2,22261,0x10316c6c0,12,TemporalPlainDateTimePrototypeUntil
code-creation,Builtin,2,22272,0x10316c700,12,TemporalPlainDateTimePrototypeSince
code-creation,Builtin,2,22282,0x10316c740,12,TemporalPlainDateTimePrototypeRound
code-creation,Builtin,2,22292,0x10316c780,12,TemporalPlainDateTimePrototypeEquals
code-creation,Builtin,2,22303,0x10316c7c0,12,TemporalPlainDateTimePrototypeToString
code-creation,Builtin,2,22313,0x10316c800,12,TemporalPlainDateTimePrototypeToJSON
code-creation,Builtin,2,22323,0x10316c840,12,TemporalPlainDateTimePrototypeValueOf
code-creation,Builtin,2,22334,0x10316c880,12,TemporalPlainDateTimePrototypeToZonedDateTime
code-creation,Builtin,2,22345,0x10316c8c0,12,TemporalPlainDateTimePrototypeToPlainDate
code-creation,Builtin,2,22356,0x10316c900,12,TemporalPlainDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,22368,0x10316c940,12,TemporalPlainDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,22379,0x10316c980,12,TemporalPlainDateTimePrototypeToPlainTime
code-creation,Builtin,2,22390,0x10316c9c0,12,TemporalPlainDateTimePrototypeGetISOFields
code-creation,Builtin,2,22401,0x10316ca00,12,TemporalZonedDateTimeConstructor
code-creation,Builtin,2,22411,0x10316ca40,12,TemporalZonedDateTimeFrom
code-creation,Builtin,2,22422,0x10316ca80,12,TemporalZonedDateTimeCompare
code-creation,Builtin,2,22432,0x10316cac0,12,TemporalZonedDateTimePrototypeCalendar
code-creation,Builtin,2,22442,0x10316cb00,12,TemporalZonedDateTimePrototypeTimeZone
code-creation,Builtin,2,22453,0x10316cb40,12,TemporalZonedDateTimePrototypeYear
code-creation,Builtin,2,22463,0x10316cb80,12,TemporalZonedDateTimePrototypeMonth
code-creation,Builtin,2,22477,0x10316cbc0,12,TemporalZonedDateTimePrototypeMonthCode
code-creation,Builtin,2,22488,0x10316cc00,12,TemporalZonedDateTimePrototypeDay
code-creation,Builtin,2,22498,0x10316cc40,12,TemporalZonedDateTimePrototypeHour
code-creation,Builtin,2,22509,0x10316cc80,12,TemporalZonedDateTimePrototypeMinute
code-creation,Builtin,2,22521,0x10316ccc0,12,TemporalZonedDateTimePrototypeSecond
code-creation,Builtin,2,22532,0x10316cd00,12,TemporalZonedDateTimePrototypeMillisecond
code-creation,Builtin,2,22542,0x10316cd40,12,TemporalZonedDateTimePrototypeMicrosecond
code-creation,Builtin,2,22553,0x10316cd80,12,TemporalZonedDateTimePrototypeNanosecond
code-creation,Builtin,2,22564,0x10316cdc0,12,TemporalZonedDateTimePrototypeEpochSeconds
code-creation,Builtin,2,22575,0x10316ce00,12,TemporalZonedDateTimePrototypeEpochMilliseconds
code-creation,Builtin,2,22587,0x10316ce40,12,TemporalZonedDateTimePrototypeEpochMicroseconds
code-creation,Builtin,2,22598,0x10316ce80,12,TemporalZonedDateTimePrototypeEpochNanoseconds
code-creation,Builtin,2,22609,0x10316cec0,12,TemporalZonedDateTimePrototypeDayOfWeek
code-creation,Builtin,2,22620,0x10316cf00,12,TemporalZonedDateTimePrototypeDayOfYear
code-creation,Builtin,2,22631,0x10316cf40,12,TemporalZonedDateTimePrototypeWeekOfYear
code-creation,Builtin,2,22642,0x10316cf80,12,TemporalZonedDateTimePrototypeHoursInDay
code-creation,Builtin,2,22653,0x10316cfc0,12,TemporalZonedDateTimePrototypeDaysInWeek
code-creation,Builtin,2,22663,0x10316d000,12,TemporalZonedDateTimePrototypeDaysInMonth
code-creation,Builtin,2,22674,0x10316d040,12,TemporalZonedDateTimePrototypeDaysInYear
code-creation,Builtin,2,22685,0x10316d080,12,TemporalZonedDateTimePrototypeMonthsInYear
code-creation,Builtin,2,22697,0x10316d0c0,12,TemporalZonedDateTimePrototypeInLeapYear
code-creation,Builtin,2,22708,0x10316d100,12,TemporalZonedDateTimePrototypeOffsetNanoseconds
code-creation,Builtin,2,22719,0x10316d140,12,TemporalZonedDateTimePrototypeOffset
code-creation,Builtin,2,22729,0x10316d180,12,TemporalZonedDateTimePrototypeWith
code-creation,Builtin,2,22740,0x10316d1c0,12,TemporalZonedDateTimePrototypeWithPlainTime
code-creation,Builtin,2,22751,0x10316d200,12,TemporalZonedDateTimePrototypeWithPlainDate
code-creation,Builtin,2,22762,0x10316d240,12,TemporalZonedDateTimePrototypeWithTimeZone
code-creation,Builtin,2,22772,0x10316d280,12,TemporalZonedDateTimePrototypeWithCalendar
code-creation,Builtin,2,22783,0x10316d2c0,12,TemporalZonedDateTimePrototypeAdd
code-creation,Builtin,2,22794,0x10316d300,12,TemporalZonedDateTimePrototypeSubtract
code-creation,Builtin,2,22804,0x10316d340,12,TemporalZonedDateTimePrototypeUntil
code-creation,Builtin,2,22814,0x10316d380,12,TemporalZonedDateTimePrototypeSince
code-creation,Builtin,2,22825,0x10316d3c0,12,TemporalZonedDateTimePrototypeRound
code-creation,Builtin,2,22835,0x10316d400,12,TemporalZonedDateTimePrototypeEquals
code-creation,Builtin,2,22845,0x10316d440,12,TemporalZonedDateTimePrototypeToString
code-creation,Builtin,2,22856,0x10316d480,12,TemporalZonedDateTimePrototypeToJSON
code-creation,Builtin,2,22867,0x10316d4c0,12,TemporalZonedDateTimePrototypeValueOf
code-creation,Builtin,2,22877,0x10316d500,12,TemporalZonedDateTimePrototypeStartOfDay
code-creation,Builtin,2,22888,0x10316d540,12,TemporalZonedDateTimePrototypeToInstant
code-creation,Builtin,2,22899,0x10316d580,12,TemporalZonedDateTimePrototypeToPlainDate
code-creation,Builtin,2,22910,0x10316d5c0,12,TemporalZonedDateTimePrototypeToPlainTime
code-creation,Builtin,2,22921,0x10316d600,12,TemporalZonedDateTimePrototypeToPlainDateTime
code-creation,Builtin,2,22932,0x10316d640,12,TemporalZonedDateTimePrototypeToPlainYearMonth
code-creation,Builtin,2,22944,0x10316d680,12,TemporalZonedDateTimePrototypeToPlainMonthDay
code-creation,Builtin,2,22955,0x10316d6c0,12,TemporalZonedDateTimePrototypeGetISOFields
code-creation,Builtin,2,22966,0x10316d700,12,TemporalDurationConstructor
code-creation,Builtin,2,22976,0x10316d740,12,TemporalDurationFrom
code-creation,Builtin,2,22985,0x10316d780,12,TemporalDurationCompare
code-creation,Builtin,2,22998,0x10316d7c0,12,TemporalDurationPrototypeYears
code-creation,Builtin,2,23007,0x10316d800,12,TemporalDurationPrototypeMonths
code-creation,Builtin,2,23017,0x10316d840,12,TemporalDurationPrototypeWeeks
code-creation,Builtin,2,23027,0x10316d880,12,TemporalDurationPrototypeDays
code-creation,Builtin,2,23037,0x10316d8c0,12,TemporalDurationPrototypeHours
code-creation,Builtin,2,23047,0x10316d900,12,TemporalDurationPrototypeMinutes
code-creation,Builtin,2,23057,0x10316d940,12,TemporalDurationPrototypeSeconds
code-creation,Builtin,2,23067,0x10316d980,12,TemporalDurationPrototypeMilliseconds
code-creation,Builtin,2,23077,0x10316d9c0,12,TemporalDurationPrototypeMicroseconds
code-creation,Builtin,2,23089,0x10316da00,12,TemporalDurationPrototypeNanoseconds
code-creation,Builtin,2,23099,0x10316da40,12,TemporalDurationPrototypeSign
code-creation,Builtin,2,23109,0x10316da80,12,TemporalDurationPrototypeBlank
code-creation,Builtin,2,23119,0x10316dac0,12,TemporalDurationPrototypeWith
code-creation,Builtin,2,23129,0x10316db00,12,TemporalDurationPrototypeNegated
code-creation,Builtin,2,23139,0x10316db40,12,TemporalDurationPrototypeAbs
code-creation,Builtin,2,23149,0x10316db80,12,TemporalDurationPrototypeAdd
code-creation,Builtin,2,23159,0x10316dbc0,12,TemporalDurationPrototypeSubtract
code-creation,Builtin,2,23169,0x10316dc00,12,TemporalDurationPrototypeRound
code-creation,Builtin,2,23179,0x10316dc40,12,TemporalDurationPrototypeTotal
code-creation,Builtin,2,23189,0x10316dc80,12,TemporalDurationPrototypeToString
code-creation,Builtin,2,23199,0x10316dcc0,12,TemporalDurationPrototypeToJSON
code-creation,Builtin,2,23209,0x10316dd00,12,TemporalDurationPrototypeValueOf
code-creation,Builtin,2,23219,0x10316dd40,12,TemporalInstantConstructor
code-creation,Builtin,2,23229,0x10316dd80,12,TemporalInstantFrom
code-creation,Builtin,2,23238,0x10316ddc0,12,TemporalInstantFromEpochSeconds
code-creation,Builtin,2,23248,0x10316de00,12,TemporalInstantFromEpochMilliseconds
code-creation,Builtin,2,23258,0x10316de40,12,TemporalInstantFromEpochMicroseconds
code-creation,Builtin,2,23269,0x10316de80,12,TemporalInstantFromEpochNanoseconds
code-creation,Builtin,2,23279,0x10316dec0,12,TemporalInstantCompare
code-creation,Builtin,2,23288,0x10316df00,12,TemporalInstantPrototypeEpochSeconds
code-creation,Builtin,2,23299,0x10316df40,12,TemporalInstantPrototypeEpochMilliseconds
code-creation,Builtin,2,23310,0x10316df80,12,TemporalInstantPrototypeEpochMicroseconds
code-creation,Builtin,2,23321,0x10316dfc0,12,TemporalInstantPrototypeEpochNanoseconds
code-creation,Builtin,2,23332,0x10316e000,12,TemporalInstantPrototypeAdd
code-creation,Builtin,2,24050,0x10316e040,12,TemporalInstantPrototypeSubtract
code-creation,Builtin,2,24063,0x10316e080,12,TemporalInstantPrototypeUntil
code-creation,Builtin,2,24073,0x10316e0c0,12,TemporalInstantPrototypeSince
code-creation,Builtin,2,24083,0x10316e100,12,TemporalInstantPrototypeRound
code-creation,Builtin,2,24093,0x10316e140,12,TemporalInstantPrototypeEquals
code-creation,Builtin,2,24103,0x10316e180,12,TemporalInstantPrototypeToString
code-creation,Builtin,2,24113,0x10316e1c0,12,TemporalInstantPrototypeToJSON
code-creation,Builtin,2,24123,0x10316e200,12,TemporalInstantPrototypeValueOf
code-creation,Builtin,2,24133,0x10316e240,12,TemporalInstantPrototypeToZonedDateTime
code-creation,Builtin,2,24144,0x10316e280,12,TemporalInstantPrototypeToZonedDateTimeISO
code-creation,Builtin,2,24155,0x10316e2c0,12,TemporalPlainYearMonthConstructor
code-creation,Builtin,2,24165,0x10316e300,12,TemporalPlainYearMonthFrom
code-creation,Builtin,2,24175,0x10316e340,12,TemporalPlainYearMonthCompare
code-creation,Builtin,2,24185,0x10316e380,12,TemporalPlainYearMonthPrototypeCalendar
code-creation,Builtin,2,24195,0x10316e3c0,12,TemporalPlainYearMonthPrototypeYear
code-creation,Builtin,2,24206,0x10316e400,12,TemporalPlainYearMonthPrototypeMonth
code-creation,Builtin,2,24216,0x10316e440,12,TemporalPlainYearMonthPrototypeMonthCode
code-creation,Builtin,2,24228,0x10316e480,12,TemporalPlainYearMonthPrototypeDaysInYear
code-creation,Builtin,2,24244,0x10316e4c0,12,TemporalPlainYearMonthPrototypeDaysInMonth
code-creation,Builtin,2,24254,0x10316e500,12,TemporalPlainYearMonthPrototypeMonthsInYear
code-creation,Builtin,2,24264,0x10316e540,12,TemporalPlainYearMonthPrototypeInLeapYear
code-creation,Builtin,2,24275,0x10316e580,12,TemporalPlainYearMonthPrototypeWith
code-creation,Builtin,2,24286,0x10316e5c0,12,TemporalPlainYearMonthPrototypeAdd
code-creation,Builtin,2,24296,0x10316e600,12,TemporalPlainYearMonthPrototypeSubtract
code-creation,Builtin,2,24307,0x10316e640,12,TemporalPlainYearMonthPrototypeUntil
code-creation,Builtin,2,24317,0x10316e680,12,TemporalPlainYearMonthPrototypeSince
code-creation,Builtin,2,24328,0x10316e6c0,12,TemporalPlainYearMonthPrototypeEquals
code-creation,Builtin,2,24339,0x10316e700,12,TemporalPlainYearMonthPrototypeToString
code-creation,Builtin,2,24350,0x10316e740,12,TemporalPlainYearMonthPrototypeToJSON
code-creation,Builtin,2,24360,0x10316e780,12,TemporalPlainYearMonthPrototypeValueOf
code-creation,Builtin,2,24371,0x10316e7c0,12,TemporalPlainYearMonthPrototypeToPlainDate
code-creation,Builtin,2,24382,0x10316e800,12,TemporalPlainYearMonthPrototypeGetISOFields
code-creation,Builtin,2,24393,0x10316e840,12,TemporalPlainMonthDayConstructor
code-creation,Builtin,2,24403,0x10316e880,12,TemporalPlainMonthDayFrom
code-creation,Builtin,2,24414,0x10316e8c0,12,TemporalPlainMonthDayPrototypeCalendar
code-creation,Builtin,2,24425,0x10316e900,12,TemporalPlainMonthDayPrototypeMonthCode
code-creation,Builtin,2,24435,0x10316e940,12,TemporalPlainMonthDayPrototypeDay
code-creation,Builtin,2,24446,0x10316e980,12,TemporalPlainMonthDayPrototypeWith
code-creation,Builtin,2,24456,0x10316e9c0,12,TemporalPlainMonthDayPrototypeEquals
code-creation,Builtin,2,24467,0x10316ea00,12,TemporalPlainMonthDayPrototypeToString
code-creation,Builtin,2,24477,0x10316ea40,12,TemporalPlainMonthDayPrototypeToJSON
code-creation,Builtin,2,24488,0x10316ea80,12,TemporalPlainMonthDayPrototypeValueOf
code-creation,Builtin,2,24498,0x10316eac0,12,TemporalPlainMonthDayPrototypeToPlainDate
code-creation,Builtin,2,24509,0x10316eb00,12,TemporalPlainMonthDayPrototypeGetISOFields
code-creation,Builtin,2,24520,0x10316eb40,12,TemporalTimeZoneConstructor
code-creation,Builtin,2,24530,0x10316eb80,12,TemporalTimeZoneFrom
code-creation,Builtin,2,24539,0x10316ebc0,12,TemporalTimeZonePrototypeId
code-creation,Builtin,2,24549,0x10316ec00,12,TemporalTimeZonePrototypeGetOffsetNanosecondsFor
code-creation,Builtin,2,24561,0x10316ec40,12,TemporalTimeZonePrototypeGetOffsetStringFor
code-creation,Builtin,2,24573,0x10316ec80,12,TemporalTimeZonePrototypeGetPlainDateTimeFor
code-creation,Builtin,2,24584,0x10316ecc0,12,TemporalTimeZonePrototypeGetInstantFor
tick,0x7ff805edea05,24600,0,0x0,6
tick,0x7ff805f105d0,24608,0,0x0,6
tick,0x7ff805db17ae,24614,0,0x0,6
tick,0x7ff805ea76fa,24620,0,0x0,6
tick,0x7ff805ea6abe,24626,0,0x0,6
code-creation,Builtin,2,24632,0x10316ed00,12,TemporalTimeZonePrototypeGetPossibleInstantsFor
code-creation,Builtin,2,24645,0x10316ed40,12,TemporalTimeZonePrototypeGetNextTransition
code-creation,Builtin,2,24654,0x10316ed80,12,TemporalTimeZonePrototypeGetPreviousTransition
code-creation,Builtin,2,24664,0x10316edc0,12,TemporalTimeZonePrototypeToString
code-creation,Builtin,2,24673,0x10316ee00,12,TemporalTimeZonePrototypeToJSON
code-creation,Builtin,2,24681,0x10316ee40,12,TemporalCalendarConstructor
code-creation,Builtin,2,24690,0x10316ee80,12,TemporalCalendarFrom
code-creation,Builtin,2,24697,0x10316eec0,12,TemporalCalendarPrototypeId
code-creation,Builtin,2,24705,0x10316ef00,12,TemporalCalendarPrototypeDateFromFields
code-creation,Builtin,2,24715,0x10316ef40,12,TemporalCalendarPrototypeYearMonthFromFields
code-creation,Builtin,2,24724,0x10316ef80,12,TemporalCalendarPrototypeMonthDayFromFields
code-creation,Builtin,2,24734,0x10316efc0,12,TemporalCalendarPrototypeDateAdd
code-creation,Builtin,2,24743,0x10316f000,12,TemporalCalendarPrototypeDateUntil
code-creation,Builtin,2,24751,0x10316f040,12,TemporalCalendarPrototypeYear
code-creation,Builtin,2,24760,0x10316f080,12,TemporalCalendarPrototypeMonth
code-creation,Builtin,2,24771,0x10316f0c0,12,TemporalCalendarPrototypeMonthCode
code-creation,Builtin,2,24780,0x10316f100,12,TemporalCalendarPrototypeDay
code-creation,Builtin,2,24788,0x10316f140,12,TemporalCalendarPrototypeDayOfWeek
code-creation,Builtin,2,24797,0x10316f180,12,TemporalCalendarPrototypeDayOfYear
code-creation,Builtin,2,24806,0x10316f1c0,12,TemporalCalendarPrototypeWeekOfYear
code-creation,Builtin,2,24815,0x10316f200,12,TemporalCalendarPrototypeDaysInWeek
code-creation,Builtin,2,24824,0x10316f240,12,TemporalCalendarPrototypeDaysInMonth
code-creation,Builtin,2,24832,0x10316f280,12,TemporalCalendarPrototypeDaysInYear
code-creation,Builtin,2,24841,0x10316f2c0,12,TemporalCalendarPrototypeMonthsInYear
code-creation,Builtin,2,24850,0x10316f300,12,TemporalCalendarPrototypeInLeapYear
code-creation,Builtin,2,24859,0x10316f340,12,TemporalCalendarPrototypeFields
code-creation,Builtin,2,24868,0x10316f380,12,TemporalCalendarPrototypeMergeFields
code-creation,Builtin,2,24877,0x10316f3c0,12,TemporalCalendarPrototypeToString
code-creation,Builtin,2,24885,0x10316f400,12,TemporalCalendarPrototypeToJSON
code-creation,Builtin,2,24894,0x10316f440,1592,StringFixedArrayFromIterable
code-creation,Builtin,2,24902,0x10316fa80,1564,TemporalInstantFixedArrayFromIterable
code-creation,Builtin,2,24911,0x1031700c0,272,AggregateErrorConstructor
code-creation,Builtin,2,24919,0x103170200,860,ArrayPrototypeAt
code-creation,Builtin,2,24926,0x103170580,628,ArrayPrototypeConcat
code-creation,Builtin,2,24934,0x103170800,5604,ArrayPrototypeCopyWithin
code-creation,Builtin,2,24941,0x103171e00,212,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,24950,0x103171f00,584,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,24959,0x103172180,3352,ArrayEveryLoopContinuation
code-creation,Builtin,2,24968,0x103172ec0,1496,ArrayEvery
code-creation,Builtin,2,24974,0x1031734c0,276,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,24983,0x103173600,912,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,24992,0x1031739c0,3628,ArrayFilterLoopContinuation
code-creation,Builtin,2,24999,0x103174800,4176,ArrayFilter
code-creation,Builtin,2,25006,0x103175880,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,25015,0x103175980,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,25023,0x1031759c0,304,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,25033,0x103175b00,508,ArrayFindLoopContinuation
code-creation,Builtin,2,25040,0x103175d00,1476,ArrayPrototypeFind
code-creation,Builtin,2,25047,0x103176300,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,25056,0x103176400,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,25065,0x103176440,304,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,25075,0x103176580,504,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,25084,0x103176780,1472,ArrayPrototypeFindIndex
code-creation,Builtin,2,25091,0x103176d80,448,ArrayFindLastLoopContinuation
code-creation,Builtin,2,25099,0x103176f80,1668,ArrayPrototypeFindLast
code-creation,Builtin,2,25107,0x103177640,444,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,25115,0x103177800,1664,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,25123,0x103177ec0,212,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,25132,0x103177fc0,212,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,25140,0x1031780c0,3208,ArrayForEachLoopContinuation
code-creation,Builtin,2,25148,0x103178d80,1344,ArrayForEach
code-creation,Builtin,2,25155,0x103179300,3412,ArrayFrom
code-creation,Builtin,2,25161,0x10317a080,160,ArrayIsArray
code-creation,Builtin,2,25168,0x10317a140,412,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,25176,0x10317a300,44,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,25185,0x10317a340,140,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,25194,0x10317a400,324,ConvertToLocaleString
code-creation,Builtin,2,25201,0x10317a580,764,JoinStackPush
code-creation,Builtin,2,25211,0x10317a880,280,JoinStackPop
code-creation,Builtin,2,25217,0x10317a9c0,6612,ArrayPrototypeJoin
code-creation,Builtin,2,25224,0x10317c3c0,5364,ArrayPrototypeToLocaleString
code-creation,Builtin,2,25232,0x10317d8c0,240,ArrayPrototypeToString
code-creation,Builtin,2,25240,0x10317d9c0,6520,TypedArrayPrototypeJoin
code-creation,Builtin,2,25247,0x10317f340,5192,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,25256,0x1031807c0,3724,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,25263,0x103181680,256,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,25272,0x1031817c0,244,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,25281,0x1031818c0,496,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,25289,0x103181ac0,3252,ArrayMapLoopContinuation
code-creation,Builtin,2,25297,0x103182780,3832,ArrayMap
code-creation,Builtin,2,25303,0x103183680,868,ArrayOf
code-creation,Builtin,2,25309,0x103183a00,424,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,25318,0x103183bc0,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,25328,0x103183cc0,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,25337,0x103183dc0,3272,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,25345,0x103184ac0,1948,ArrayReduceRight
code-creation,Builtin,2,25352,0x103185280,180,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,25361,0x103185340,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,25370,0x103185440,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,25379,0x103185540,3308,ArrayReduceLoopContinuation
code-creation,Builtin,2,25387,0x103186240,1564,ArrayReduce
code-creation,Builtin,2,25393,0x103186880,3172,ArrayPrototypeReverse
code-creation,Builtin,2,25400,0x103187500,3572,ArrayPrototypeShift
code-creation,Builtin,2,25408,0x103188300,5180,ArrayPrototypeSlice
code-creation,Builtin,2,25415,0x103189740,212,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,25423,0x103189840,556,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,25432,0x103189a80,3348,ArraySomeLoopContinuation
code-creation,Builtin,2,25440,0x10318a7c0,1476,ArraySome
code-creation,Builtin,2,25446,0x10318adc0,14000,ArrayPrototypeSplice
code-creation,Builtin,2,25453,0x10318e480,3080,ArrayPrototypeUnshift
code-creation,Builtin,2,25460,0x10318f0c0,324,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,25469,0x10318f240,488,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,25477,0x10318f440,212,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,25486,0x10318f540,324,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,25495,0x10318f6c0,212,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,25504,0x10318f7c0,100,ArrayBufferIsView
code-creation,Builtin,2,25516,0x10318f840,396,ToInteger
code-creation,Builtin,2,25522,0x10318fa00,3096,FastCreateDataProperty
code-creation,Builtin,2,25530,0x103190640,612,CheckSameObject
code-creation,Builtin,2,25537,0x1031908c0,928,BooleanConstructor
code-creation,Builtin,2,25544,0x103190c80,160,BooleanPrototypeToString
code-creation,Builtin,2,25551,0x103190d40,156,BooleanPrototypeValueOf
code-creation,Builtin,2,25559,0x103190e00,1188,BigIntAddNoThrow
code-creation,Builtin,2,25566,0x1031912c0,1272,BigIntAdd
code-creation,Builtin,2,25572,0x1031917c0,1188,BigIntSubtractNoThrow
code-creation,Builtin,2,25580,0x103191c80,1276,BigIntSubtract
code-creation,Builtin,2,25586,0x103192180,288,BigIntUnaryMinus
code-creation,Builtin,2,25595,0x1031922c0,1344,ToString
code-creation,Builtin,2,25601,0x103192840,156,StringPrototypeToString
code-creation,Builtin,2,25608,0x103192900,156,StringPrototypeValueOf
code-creation,Builtin,2,25616,0x1031929c0,2472,StringToList
code-creation,Builtin,2,25622,0x103193380,996,StringPrototypeCharAt
code-creation,Builtin,2,25630,0x103193780,696,StringPrototypeCharCodeAt
code-creation,Builtin,2,25637,0x103193a40,1236,StringPrototypeCodePointAt
code-creation,Builtin,2,25645,0x103193f40,420,StringPrototypeConcat
code-creation,Builtin,2,25655,0x103194100,984,StringConstructor
code-creation,Builtin,2,25662,0x103194500,1404,StringAddConvertLeft
code-creation,Builtin,2,25669,0x103194a80,1452,StringAddConvertRight
code-creation,Builtin,2,25677,0x103195040,788,StringCharAt
code-creation,Builtin,2,25683,0x103195380,16,FastNewClosureBaseline
code-creation,Builtin,2,25691,0x1031953c0,200,FastNewFunctionContextEval
code-creation,Builtin,2,25699,0x1031954c0,200,FastNewFunctionContextFunction
code-creation,Builtin,2,25707,0x1031955c0,248,CreateRegExpLiteral
code-creation,Builtin,2,25714,0x1031956c0,1088,CreateShallowArrayLiteral
code-creation,Builtin,2,25722,0x103195b40,492,CreateEmptyArrayLiteral
code-creation,Builtin,2,25729,0x103195d40,1820,CreateShallowObjectLiteral
code-creation,Builtin,2,25737,0x103196480,388,ObjectConstructor
code-creation,Builtin,2,25744,0x103196640,176,CreateEmptyLiteralObject
code-creation,Builtin,2,25751,0x103196700,544,NumberConstructor
code-creation,Builtin,2,25758,0x103196940,60,GenericLazyDeoptContinuation
code-creation,Builtin,2,25766,0x103196980,64,StringToNumber
code-creation,Builtin,2,25773,0x103196a00,184,NonNumberToNumber
code-creation,Builtin,2,25780,0x103196ac0,240,NonNumberToNumeric
code-creation,Builtin,2,25787,0x103196bc0,36,ToNumeric
code-creation,Builtin,2,25793,0x103196c00,1292,NumberToString
code-creation,Builtin,2,25800,0x103197140,104,ToBoolean
code-creation,Builtin,2,25806,0x1031971c0,100,ToBooleanForBaselineJump
code-creation,Builtin,2,25814,0x103197240,604,ToLength
code-creation,Builtin,2,25820,0x1031974c0,1328,ToName
code-creation,Builtin,2,25826,0x103197a00,756,ToObject
code-creation,Builtin,2,25833,0x103197d00,236,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,25841,0x103197e00,236,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,25850,0x103197f00,236,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,26516,0x103198000,380,OrdinaryToPrimitive_Number
code-creation,Builtin,2,26526,0x103198180,380,OrdinaryToPrimitive_String
code-creation,Builtin,2,26536,0x103198300,232,FastConsoleAssert
code-creation,Builtin,2,26545,0x103198400,156,DataViewPrototypeGetBuffer
code-creation,Builtin,2,26554,0x1031984c0,752,DataViewPrototypeGetByteLength
code-creation,Builtin,2,26564,0x1031987c0,416,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,26574,0x103198980,816,DataViewPrototypeGetUint8
code-creation,Builtin,2,26584,0x103198cc0,816,DataViewPrototypeGetInt8
code-creation,Builtin,2,26593,0x103199000,892,DataViewPrototypeGetUint16
code-creation,Builtin,2,26603,0x103199380,888,DataViewPrototypeGetInt16
code-creation,Builtin,2,26612,0x103199700,1048,DataViewPrototypeGetUint32
code-creation,Builtin,2,26622,0x103199b40,924,DataViewPrototypeGetInt32
code-creation,Builtin,2,26632,0x103199f00,1080,DataViewPrototypeGetFloat32
code-creation,Builtin,2,26641,0x10319a340,1144,DataViewPrototypeGetFloat64
code-creation,Builtin,2,26651,0x10319a7c0,1216,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,26661,0x10319acc0,1240,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,26671,0x10319b1c0,1196,DataViewPrototypeSetUint8
code-creation,Builtin,2,26680,0x10319b680,1196,DataViewPrototypeSetInt8
code-creation,Builtin,2,26690,0x10319bb40,1280,DataViewPrototypeSetUint16
code-creation,Builtin,2,26699,0x10319c080,1280,DataViewPrototypeSetInt16
code-creation,Builtin,2,26709,0x10319c5c0,1320,DataViewPrototypeSetUint32
code-creation,Builtin,2,26719,0x10319cb00,1320,DataViewPrototypeSetInt32
code-creation,Builtin,2,26729,0x10319d040,1288,DataViewPrototypeSetFloat32
code-creation,Builtin,2,26738,0x10319d580,1348,DataViewPrototypeSetFloat64
code-creation,Builtin,2,26748,0x10319db00,1224,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,26758,0x10319e000,1224,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,26768,0x10319e500,828,FinalizationRegistryConstructor
code-creation,Builtin,2,26778,0x10319e840,1132,FinalizationRegistryRegister
code-creation,Builtin,2,26788,0x10319ecc0,684,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,26799,0x10319ef80,340,FunctionPrototypeHasInstance
code-creation,Builtin,2,26813,0x10319f100,940,FastFunctionPrototypeBind
code-creation,Builtin,2,26823,0x10319f4c0,92,IncBlockCounter
code-creation,Builtin,2,26831,0x10319f540,236,GetTemplateObject
code-creation,Builtin,2,26840,0x10319f640,92,ForInNext
code-creation,Builtin,2,26848,0x10319f6c0,132,GetImportMetaObjectBaseline
code-creation,Builtin,2,26858,0x10319f780,116,GetIteratorWithFeedback
code-creation,Builtin,2,26867,0x10319f800,100,GetIteratorBaseline
code-creation,Builtin,2,26876,0x10319f880,268,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,26886,0x10319f9c0,1064,CallIteratorWithFeedback
code-creation,Builtin,2,26896,0x10319fe00,284,MathAbs
code-creation,Builtin,2,26903,0x10319ff40,424,MathCeil
code-creation,Builtin,2,26911,0x1031a0100,428,MathFloor
code-creation,Builtin,2,26919,0x1031a02c0,484,MathRound
code-creation,Builtin,2,26928,0x1031a04c0,428,MathTrunc
code-creation,Builtin,2,26936,0x1031a0680,376,MathPow
code-creation,Builtin,2,26943,0x1031a0800,412,MathMax
code-creation,Builtin,2,26951,0x1031a09c0,416,MathMin
code-creation,Builtin,2,26959,0x1031a0b80,324,MathAcos
code-creation,Builtin,2,26967,0x1031a0d00,324,MathAcosh
code-creation,Builtin,2,26975,0x1031a0e80,324,MathAsin
code-creation,Builtin,2,26982,0x1031a1000,324,MathAsinh
code-creation,Builtin,2,26990,0x1031a1180,324,MathAtan
code-creation,Builtin,2,26998,0x1031a1300,420,MathAtan2
code-creation,Builtin,2,27006,0x1031a14c0,324,MathAtanh
code-creation,Builtin,2,27014,0x1031a1640,324,MathCbrt
code-creation,Builtin,2,27022,0x1031a17c0,168,MathClz32
code-creation,Builtin,2,27030,0x1031a1880,324,MathCos
code-creation,Builtin,2,27039,0x1031a1a00,324,MathCosh
code-creation,Builtin,2,27047,0x1031a1b80,324,MathExp
code-creation,Builtin,2,27055,0x1031a1d00,324,MathExpm1
code-creation,Builtin,2,27063,0x1031a1e80,268,MathFround
code-creation,Builtin,2,27071,0x1031a1fc0,304,MathImul
code-creation,Builtin,2,27079,0x1031a2100,324,MathLog
code-creation,Builtin,2,27087,0x1031a2280,324,MathLog1p
code-creation,Builtin,2,27095,0x1031a2400,324,MathLog10
code-creation,Builtin,2,27103,0x1031a2580,324,MathLog2
code-creation,Builtin,2,27957,0x1031a2700,324,MathSin
code-creation,Builtin,2,27966,0x1031a2880,176,MathSign
code-creation,Builtin,2,27974,0x1031a2940,324,MathSinh
code-creation,Builtin,2,27982,0x1031a2ac0,264,MathSqrt
code-creation,Builtin,2,27990,0x1031a2c00,324,MathTan
code-creation,Builtin,2,27997,0x1031a2d80,324,MathTanh
code-creation,Builtin,2,28005,0x1031a2f00,1052,MathHypot
code-creation,Builtin,2,28013,0x1031a3340,332,MathRandom
code-creation,Builtin,2,28021,0x1031a34c0,2828,NumberPrototypeToString
code-creation,Builtin,2,28030,0x1031a4000,156,NumberIsFinite
code-creation,Builtin,2,28039,0x1031a40c0,344,NumberIsInteger
code-creation,Builtin,2,28047,0x1031a4240,128,NumberIsNaN
code-creation,Builtin,2,28056,0x1031a4300,376,NumberIsSafeInteger
code-creation,Builtin,2,28065,0x1031a4480,156,NumberPrototypeValueOf
code-creation,Builtin,2,28074,0x1031a4540,200,NumberParseFloat
tick,0x7ff805f105d0,28086,0,0x0,6
tick,0x7ff805dd2b58,28094,0,0x0,6
code-creation,Builtin,2,28100,0x1031a4640,252,ParseInt
code-creation,Builtin,2,28108,0x1031a4740,84,NumberParseInt
code-creation,Builtin,2,28116,0x1031a47c0,820,Add
code-creation,Builtin,2,28122,0x1031a4b00,420,Subtract
code-creation,Builtin,2,28128,0x1031a4cc0,608,Multiply
code-creation,Builtin,2,28134,0x1031a4f40,532,Divide
code-creation,Builtin,2,28141,0x1031a5180,592,Modulus
code-creation,Builtin,2,28147,0x1031a5400,520,Exponentiate
code-creation,Builtin,2,28154,0x1031a5640,344,Negate
code-creation,Builtin,2,28160,0x1031a57c0,108,BitwiseNot
code-creation,Builtin,2,28167,0x1031a5840,108,Decrement
code-creation,Builtin,2,28173,0x1031a58c0,108,Increment
code-creation,Builtin,2,28180,0x1031a5940,428,ShiftLeft
code-creation,Builtin,2,28186,0x1031a5b00,428,ShiftRight
code-creation,Builtin,2,28193,0x1031a5cc0,540,ShiftRightLogical
code-creation,Builtin,2,28200,0x1031a5f00,424,BitwiseAnd
code-creation,Builtin,2,28207,0x1031a60c0,424,BitwiseOr
code-creation,Builtin,2,28213,0x1031a6280,424,BitwiseXor
code-creation,Builtin,2,28220,0x1031a6440,796,LessThan
code-creation,Builtin,2,28230,0x1031a6780,796,LessThanOrEqual
code-creation,Builtin,2,28237,0x1031a6ac0,792,GreaterThan
code-creation,Builtin,2,28244,0x1031a6e00,792,GreaterThanOrEqual
code-creation,Builtin,2,28251,0x1031a7140,852,Equal
code-creation,Builtin,2,28257,0x1031a74c0,332,StrictEqual
code-creation,Builtin,2,28264,0x1031a7640,3332,ObjectFromEntries
code-creation,Builtin,2,28271,0x1031a8380,752,CreateObjectWithoutProperties
code-creation,Builtin,2,28279,0x1031a8680,144,ObjectIsExtensible
code-creation,Builtin,2,28287,0x1031a8740,148,ObjectPreventExtensions
code-creation,Builtin,2,28294,0x1031a8800,140,ObjectGetPrototypeOf
code-creation,Builtin,2,28302,0x1031a88c0,304,ObjectSetPrototypeOf
code-creation,Builtin,2,28309,0x1031a8a00,80,ObjectPrototypeToString
code-creation,Builtin,2,28317,0x1031a8a80,96,ObjectPrototypeValueOf
code-creation,Builtin,2,28325,0x1031a8b00,176,ObjectPrototypeToLocaleString
code-creation,Builtin,2,28333,0x1031a8bc0,864,FulfillPromise
code-creation,Builtin,2,28340,0x1031a8f40,1000,RejectPromise
code-creation,Builtin,2,28347,0x1031a9340,2696,NewPromiseCapability
code-creation,Builtin,2,28355,0x1031a9e00,168,PromiseCapabilityDefaultReject
code-creation,Builtin,2,28414,0x1031a9ec0,156,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,28424,0x1031a9f80,1296,PerformPromiseThen
code-creation,Builtin,2,28433,0x1031aa4c0,668,PromiseReject
code-creation,Builtin,2,28441,0x1031aa780,300,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,28451,0x1031aa8c0,108,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,28462,0x1031aa940,4716,PromiseAll
code-creation,Builtin,2,28470,0x1031abbc0,5140,PromiseAllSettled
code-creation,Builtin,2,28479,0x1031ad000,1100,PromiseAllResolveElementClosure
code-creation,Builtin,2,28489,0x1031ad480,1396,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,28500,0x1031ada00,1404,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,28511,0x1031adf80,1176,PromiseAnyRejectElementClosure
code-creation,Builtin,2,28521,0x1031ae440,2692,PromiseAny
code-creation,Builtin,2,28529,0x1031aef00,3136,PromiseConstructor
code-creation,Builtin,2,28538,0x1031afb80,300,PromisePrototypeCatch
code-creation,Builtin,2,28547,0x1031afcc0,88,PromiseValueThunkFinally
code-creation,Builtin,2,28556,0x1031afd40,80,PromiseThrowerFinally
code-creation,Builtin,2,28565,0x1031afdc0,1020,PromiseCatchFinally
code-creation,Builtin,2,28574,0x1031b01c0,1020,PromiseThenFinally
code-creation,Builtin,2,28583,0x1031b05c0,1796,PromisePrototypeFinally
code-creation,Builtin,2,28592,0x1031b0d00,1544,PromiseRace
code-creation,Builtin,2,28601,0x1031b1340,340,PromiseFulfillReactionJob
code-creation,Builtin,2,28610,0x1031b14c0,444,PromiseRejectReactionJob
code-creation,Builtin,2,28619,0x1031b1680,156,PromiseResolveTrampoline
code-creation,Builtin,2,28629,0x1031b1740,680,PromiseResolve
code-creation,Builtin,2,28637,0x1031b1a00,696,ResolvePromise
code-creation,Builtin,2,28646,0x1031b1cc0,2248,PromisePrototypeThen
code-creation,Builtin,2,28655,0x1031b25c0,1364,PromiseResolveThenableJob
code-creation,Builtin,2,28664,0x1031b2b40,448,ProxyConstructor
code-creation,Builtin,2,28673,0x1031b2d40,1768,ProxyDeleteProperty
code-creation,Builtin,2,28682,0x1031b3440,2144,ProxyGetProperty
code-creation,Builtin,2,28691,0x1031b3cc0,1056,ProxyGetPrototypeOf
code-creation,Builtin,2,28700,0x1031b4100,1692,ProxyHasProperty
code-creation,Builtin,2,28708,0x1031b47c0,772,ProxyIsExtensible
code-creation,Builtin,2,28717,0x1031b4b00,824,ProxyPreventExtensions
code-creation,Builtin,2,28726,0x1031b4e40,1236,ProxyRevocable
code-creation,Builtin,2,28735,0x1031b5340,132,ProxyRevoke
code-creation,Builtin,2,28743,0x1031b5400,2240,ProxySetProperty
code-creation,Builtin,2,28752,0x1031b5d00,1312,ProxySetPrototypeOf
code-creation,Builtin,2,28761,0x1031b6240,208,ReflectIsExtensible
code-creation,Builtin,2,28770,0x1031b6340,216,ReflectPreventExtensions
code-creation,Builtin,2,28779,0x1031b6440,184,ReflectGetPrototypeOf
code-creation,Builtin,2,28788,0x1031b6500,296,ReflectSetPrototypeOf
code-creation,Builtin,2,28801,0x1031b6640,300,ReflectGet
code-creation,Builtin,2,28809,0x1031b6780,156,ReflectDeleteProperty
code-creation,Builtin,2,28818,0x1031b6840,144,ReflectHas
code-creation,Builtin,2,28826,0x1031b6900,5048,RegExpPrototypeExecSlow
code-creation,Builtin,2,28836,0x1031b7cc0,5044,RegExpPrototypeExec
code-creation,Builtin,2,28845,0x1031b9080,2312,RegExpPrototypeMatchAll
code-creation,Builtin,2,28854,0x1031b99c0,9316,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,28864,0x1031bbe40,8736,RegExpMatchFast
code-creation,Builtin,2,28873,0x1031be080,3564,RegExpPrototypeMatch
code-creation,Builtin,2,28882,0x1031bee80,6156,RegExpReplace
code-creation,Builtin,2,28890,0x1031c06c0,524,RegExpPrototypeReplace
code-creation,Builtin,2,28899,0x1031c0900,1336,RegExpSearchFast
code-creation,Builtin,2,28908,0x1031c0e40,1636,RegExpPrototypeSearch
code-creation,Builtin,2,28917,0x1031c14c0,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,28927,0x1031c15c0,5672,RegExpSplit
code-creation,Builtin,2,28935,0x1031c2c00,484,RegExpPrototypeSplit
code-creation,Builtin,2,28944,0x1031c2e00,2208,RegExpPrototypeTest
code-creation,Builtin,2,28953,0x1031c36c0,1288,RegExpPrototypeTestFast
code-creation,Builtin,2,28962,0x1031c3c00,240,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,28972,0x1031c3d00,256,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,28994,0x1031c3e40,256,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,29004,0x1031c3f80,256,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,29014,0x1031c40c0,256,RegExpPrototypeLinearGetter
code-creation,Builtin,2,29024,0x1031c4200,256,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,29033,0x1031c4340,284,RegExpPrototypeStickyGetter
code-creation,Builtin,2,29043,0x1031c4480,284,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,29053,0x1031c45c0,2288,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,29063,0x1031c4ec0,1468,StringPrototypeAt
code-creation,Builtin,2,29071,0x1031c5480,3092,StringPrototypeEndsWith
code-creation,Builtin,2,29081,0x1031c60c0,488,CreateHTML
code-creation,Builtin,2,29089,0x1031c62c0,164,StringPrototypeAnchor
code-creation,Builtin,2,29098,0x1031c6380,128,StringPrototypeBig
code-creation,Builtin,2,29107,0x1031c6440,128,StringPrototypeBlink
code-creation,Builtin,2,29116,0x1031c6500,128,StringPrototypeBold
code-creation,Builtin,2,29125,0x1031c65c0,172,StringPrototypeFontcolor
code-creation,Builtin,2,29135,0x1031c6680,172,StringPrototypeFontsize
code-creation,Builtin,2,29144,0x1031c6740,128,StringPrototypeFixed
code-creation,Builtin,2,29153,0x1031c6800,128,StringPrototypeItalics
code-creation,Builtin,2,29163,0x1031c68c0,172,StringPrototypeLink
code-creation,Builtin,2,29172,0x1031c6980,128,StringPrototypeSmall
code-creation,Builtin,2,29181,0x1031c6a40,128,StringPrototypeStrike
code-creation,Builtin,2,29190,0x1031c6b00,128,StringPrototypeSub
code-creation,Builtin,2,29199,0x1031c6bc0,128,StringPrototypeSup
code-creation,Builtin,2,29208,0x1031c6c80,1060,StringPrototypeIncludes
code-creation,Builtin,2,29217,0x1031c70c0,648,StringPrototypeIndexOf
code-creation,Builtin,2,29226,0x1031c7380,344,StringPrototypeIterator
code-creation,Builtin,2,29236,0x1031c7500,1980,StringIteratorPrototypeNext
code-creation,Builtin,2,29245,0x1031c7cc0,1264,StringPrototypeMatch
code-creation,Builtin,2,29254,0x1031c81c0,1264,StringPrototypeSearch
code-creation,Builtin,2,29264,0x1031c86c0,816,StringPrototypePadStart
code-creation,Builtin,2,29273,0x1031c8a00,816,StringPrototypePadEnd
code-creation,Builtin,2,29282,0x1031c8d40,120,StringRepeat
code-creation,Builtin,2,29291,0x1031c8dc0,404,StringPrototypeRepeat
code-creation,Builtin,2,29300,0x1031c8f80,10980,StringPrototypeReplaceAll
code-creation,Builtin,2,29310,0x1031cba80,3312,StringPrototypeSlice
code-creation,Builtin,2,29319,0x1031cc780,3116,StringPrototypeStartsWith
code-creation,Builtin,2,29328,0x1031cd3c0,3244,StringPrototypeSubstr
code-creation,Builtin,2,29337,0x1031ce080,3168,StringPrototypeSubstring
code-creation,Builtin,2,29347,0x1031ced00,6852,StringPrototypeTrim
code-creation,Builtin,2,29356,0x1031d0800,6204,StringPrototypeTrimStart
code-creation,Builtin,2,29368,0x1031d2040,5816,StringPrototypeTrimEnd
code-creation,Builtin,2,29377,0x1031d3700,160,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,29387,0x1031d37c0,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,29397,0x1031d3880,176,SymbolPrototypeToString
code-creation,Builtin,2,29406,0x1031d3940,156,SymbolPrototypeValueOf
code-creation,Builtin,2,29416,0x1031d3a00,1172,TypedArrayPrototypeAt
code-creation,Builtin,2,29425,0x1031d3ec0,10128,CreateTypedArray
code-creation,Builtin,2,29433,0x1031d6680,1792,TypedArrayPrototypeEvery
code-creation,Builtin,2,29443,0x1031d6dc0,420,TypedArrayPrototypeEntries
code-creation,Builtin,2,29453,0x1031d6f80,4224,TypedArrayPrototypeFilter
code-creation,Builtin,2,29462,0x1031d8040,1760,TypedArrayPrototypeFind
code-creation,Builtin,2,29471,0x1031d8740,1764,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,29481,0x1031d8e40,1792,TypedArrayPrototypeFindLast
code-creation,Builtin,2,29491,0x1031d9580,1796,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,29501,0x1031d9cc0,1628,TypedArrayPrototypeForEach
code-creation,Builtin,2,29511,0x1031da340,2348,TypedArrayFrom
code-creation,Builtin,2,29519,0x1031dac80,404,TypedArrayPrototypeKeys
code-creation,Builtin,2,29529,0x1031dae40,1036,TypedArrayOf
code-creation,Builtin,2,29537,0x1031db280,1728,TypedArrayPrototypeReduce
code-creation,Builtin,2,29546,0x1031db980,1764,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,29556,0x1031dc080,3456,TypedArrayPrototypeSet
code-creation,Builtin,2,29566,0x1031dce40,3972,TypedArrayPrototypeSlice
code-creation,Builtin,2,29575,0x1031dde00,1760,TypedArrayPrototypeSome
code-creation,Builtin,2,29584,0x1031de500,940,TypedArrayMergeSort
code-creation,Builtin,2,29593,0x1031de8c0,2348,TypedArrayPrototypeSort
code-creation,Builtin,2,29603,0x1031df200,3184,TypedArrayPrototypeSubArray
code-creation,Builtin,2,29613,0x1031dfe80,420,TypedArrayPrototypeValues
code-creation,Builtin,2,29636,0x1031e0040,960,WeakRefConstructor
code-creation,Builtin,2,29645,0x1031e0440,184,WeakRefDeref
code-creation,Builtin,2,29653,0x1031e0500,664,NewSloppyArgumentsElements
code-creation,Builtin,2,29662,0x1031e07c0,304,NewStrictArgumentsElements
code-creation,Builtin,2,29672,0x1031e0900,332,NewRestArgumentsElements
code-creation,Builtin,2,29681,0x1031e0a80,1536,FastNewSloppyArguments
code-creation,Builtin,2,29690,0x1031e10c0,516,FastNewStrictArguments
code-creation,Builtin,2,29699,0x1031e1300,564,FastNewRestArguments
code-creation,Builtin,2,29708,0x1031e1540,664,StringSlowFlatten
code-creation,Builtin,2,29717,0x1031e1800,2100,StringIndexOf
code-creation,Builtin,2,29725,0x1031e2040,2064,TestTurbofanType
code-creation,Builtin,2,29734,0x1031e2880,152,CheckTurbofanType
code-creation,Builtin,2,29742,0x1031e2940,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,29752,0x1031e2980,20,TestHelperPlus1
code-creation,Builtin,2,29760,0x1031e29c0,20,TestHelperPlus2
code-creation,Builtin,2,29769,0x1031e2a00,96,NewSmiBox
code-creation,Builtin,2,29776,0x1031e2a80,24,ReturnTwoValues
code-creation,Builtin,2,29785,0x1031e2ac0,32,Load_FastSmiElements_0
code-creation,Builtin,2,29794,0x1031e2b00,32,Load_FastObjectElements_0
code-creation,Builtin,2,29803,0x1031e2b40,144,Load_FastDoubleElements_0
code-creation,Builtin,2,29813,0x1031e2c00,32,Store_FastSmiElements_0
code-creation,Builtin,2,29822,0x1031e2c40,92,Store_FastObjectElements_0
code-creation,Builtin,2,29831,0x1031e2cc0,48,Store_FastDoubleElements_0
code-creation,Builtin,2,29841,0x1031e2d00,40,Delete_FastSmiElements_0
code-creation,Builtin,2,29850,0x1031e2d40,40,Delete_FastObjectElements_0
code-creation,Builtin,2,29860,0x1031e2d80,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,29869,0x1031e2dc0,296,SortCompareDefault
code-creation,Builtin,2,29878,0x1031e2f00,96,SortCompareUserFn
code-creation,Builtin,2,29887,0x1031e2f80,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,29898,0x1031e2fc0,308,Copy
code-creation,Builtin,2,29905,0x1031e3100,5740,MergeAt
code-creation,Builtin,2,29913,0x1031e4780,792,GallopLeft
code-creation,Builtin,2,29929,0x1031e4ac0,832,GallopRight
code-creation,Builtin,2,29937,0x1031e4e40,3788,ArrayTimSort
code-creation,Builtin,2,29945,0x1031e5d40,2100,ArrayPrototypeSort
code-creation,Builtin,2,29954,0x1031e6580,3608,StringFastLocaleCompare
code-creation,Builtin,2,29963,0x1031e73c0,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,29972,0x1031e7440,24,WasmFuncRefToJS
code-creation,Builtin,2,29981,0x1031e7480,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,29990,0x1031e7500,76,WasmTaggedToFloat64
code-creation,Builtin,2,29999,0x1031e7580,72,WasmMemoryGrow
code-creation,Builtin,2,30007,0x1031e7600,100,WasmTableInit
code-creation,Builtin,2,30015,0x1031e7680,100,WasmTableCopy
code-creation,Builtin,2,30024,0x1031e7700,84,WasmTableFill
code-creation,Builtin,2,30032,0x1031e7780,72,WasmTableGrow
code-creation,Builtin,2,30040,0x1031e7800,148,WasmTableGet
code-creation,Builtin,2,30048,0x1031e78c0,240,WasmTableSet
code-creation,Builtin,2,30057,0x1031e79c0,96,WasmRefFunc
code-creation,Builtin,2,30065,0x1031e7a40,144,WasmAllocateFixedArray
code-creation,Builtin,2,30074,0x1031e7b00,44,WasmThrow
code-creation,Builtin,2,30082,0x1031e7b40,56,WasmRethrow
code-creation,Builtin,2,30090,0x1031e7b80,44,WasmRethrowExplicitContext
code-creation,Builtin,2,30099,0x1031e7bc0,44,WasmTriggerTierUp
code-creation,Builtin,2,30108,0x1031e7c00,32,WasmStackGuard
code-creation,Builtin,2,30116,0x1031e7c40,32,WasmStackOverflow
code-creation,Builtin,2,30125,0x1031e7c80,40,WasmTraceMemory
code-creation,Builtin,2,30133,0x1031e7cc0,32,WasmTraceEnter
code-creation,Builtin,2,30142,0x1031e7d00,40,WasmTraceExit
code-creation,Builtin,2,30150,0x1031e7d40,340,WasmAllocateJSArray
code-creation,Builtin,2,30159,0x1031e7ec0,120,WasmAllocateStructWithRtt
code-creation,Builtin,2,30168,0x1031e7f40,136,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,30178,0x1031e8000,172,WasmAllocateArray_InitZero
code-creation,Builtin,2,30188,0x1031e80c0,176,WasmAllocateArray_InitNull
code-creation,Builtin,2,30197,0x1031e8180,60,WasmArrayInitFromData
code-creation,Builtin,2,30206,0x1031e81c0,140,WasmArrayCopyWithChecks
code-creation,Builtin,2,30215,0x1031e8280,72,WasmArrayCopy
code-creation,Builtin,2,30224,0x1031e8300,240,WasmAllocateObjectWrapper
code-creation,Builtin,2,30233,0x1031e8400,52,WasmSubtypeCheck
code-creation,Builtin,2,30241,0x1031e8440,8,WasmInt32ToNumber
code-creation,Builtin,2,30250,0x1031e8480,116,WasmUint32ToNumber
code-creation,Builtin,2,30259,0x1031e8500,144,UintPtr53ToNumber
code-creation,Builtin,2,30267,0x1031e85c0,96,WasmAtomicNotify
code-creation,Builtin,2,30276,0x1031e8640,116,WasmI32AtomicWait64
code-creation,Builtin,2,30285,0x1031e86c0,116,WasmI64AtomicWait64
code-creation,Builtin,2,30294,0x1031e8740,1260,CallRefIC
code-creation,Builtin,2,30301,0x1031e8c40,596,WasmGetOwnProperty
code-creation,Builtin,2,30310,0x1031e8ec0,40,WasmTrap
code-creation,Builtin,2,30318,0x1031e8f00,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,30327,0x1031e8f40,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,30337,0x1031e8f80,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,30347,0x1031e8fc0,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,30356,0x1031e9000,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,30366,0x1031e9040,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,30375,0x1031e9080,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,30385,0x1031e90c0,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,30394,0x1031e9100,16,ThrowWasmTrapDataSegmentOutOfBounds
code-creation,Builtin,2,30405,0x1031e9140,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,30415,0x1031e9180,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,30425,0x1031e91c0,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,30434,0x1031e9200,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,30444,0x1031e9240,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,30453,0x1031e9280,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,30463,0x1031e92c0,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,30472,0x1031e9300,168,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,30486,0x1031e93c0,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,30497,0x1031e9400,112,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,30507,0x1031e9480,108,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,30518,0x1031e9500,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,30529,0x1031e9540,216,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,30540,0x1031e9640,244,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,30550,0x1031e9740,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,30561,0x1031e9780,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,30571,0x1031e97c0,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,30582,0x1031e9800,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,30592,0x1031e9840,128,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,30603,0x1031e9900,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,30612,0x1031e9940,40,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,30623,0x1031e9980,40,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,30635,0x1031e99c0,40,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,30646,0x1031e9a00,2760,Load_GenericElementsAccessor_0
code-creation,Builtin,2,30655,0x1031ea500,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,30665,0x1031ea540,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,30675,0x1031ea580,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,30685,0x1031ea5c0,172,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,30696,0x1031ea680,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,30707,0x1031ea740,112,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,30717,0x1031ea7c0,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,30729,0x1031ea800,160,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,30740,0x1031ea8c0,108,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,30751,0x1031ea940,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,30762,0x1031ea980,156,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,30773,0x1031eaa40,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,30784,0x1031eaa80,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,30796,0x1031eaac0,616,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,30810,0x1031ead40,216,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,30821,0x1031eae40,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,30832,0x1031eae80,196,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,30844,0x1031eaf80,244,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,30854,0x1031eb080,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,30866,0x1031eb0c0,196,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,30905,0x1031eb1c0,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,30915,0x1031eb200,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,30926,0x1031eb240,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,30936,0x1031eb300,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,30946,0x1031eb340,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,30957,0x1031eb380,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,30968,0x1031eb440,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,30978,0x1031eb480,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,30989,0x1031eb4c0,184,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,31000,0x1031eb580,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,31010,0x1031eb5c0,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,31021,0x1031eb600,184,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,31031,0x1031eb6c0,128,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,31045,0x1031eb780,172,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,31056,0x1031eb840,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,31066,0x1031eb900,12,CollatorConstructor
code-creation,Builtin,2,31075,0x1031eb940,12,CollatorInternalCompare
code-creation,Builtin,2,31085,0x1031eb980,12,CollatorPrototypeCompare
code-creation,Builtin,2,31094,0x1031eb9c0,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,31103,0x1031eba00,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,31113,0x1031eba40,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,31123,0x1031eba80,12,DatePrototypeToLocaleString
code-creation,Builtin,2,31133,0x1031ebac0,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,31143,0x1031ebb00,12,DateTimeFormatConstructor
code-creation,Builtin,2,31153,0x1031ebb40,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,31162,0x1031ebb80,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,31172,0x1031ebbc0,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,31183,0x1031ebc00,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,31194,0x1031ebc40,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,31204,0x1031ebc80,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,31215,0x1031ebcc0,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,31225,0x1031ebd00,12,DisplayNamesConstructor
code-creation,Builtin,2,31235,0x1031ebd40,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,31244,0x1031ebd80,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,31255,0x1031ebdc0,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,31265,0x1031ebe00,12,IntlGetCanonicalLocales
code-creation,Builtin,2,31274,0x1031ebe40,12,IntlSupportedValuesOf
code-creation,Builtin,2,31283,0x1031ebe80,12,ListFormatConstructor
code-creation,Builtin,2,31292,0x1031ebec0,228,ListFormatPrototypeFormat
code-creation,Builtin,2,31302,0x1031ebfc0,228,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,31312,0x1031ec0c0,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,31322,0x1031ec100,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,31332,0x1031ec140,12,LocaleConstructor
code-creation,Builtin,2,31341,0x1031ec180,12,LocalePrototypeBaseName
code-creation,Builtin,2,31350,0x1031ec1c0,12,LocalePrototypeCalendar
code-creation,Builtin,2,31359,0x1031ec200,12,LocalePrototypeCalendars
code-creation,Builtin,2,31369,0x1031ec240,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,31378,0x1031ec280,12,LocalePrototypeCollation
code-creation,Builtin,2,31387,0x1031ec2c0,12,LocalePrototypeCollations
code-creation,Builtin,2,31397,0x1031ec300,12,LocalePrototypeHourCycle
code-creation,Builtin,2,31406,0x1031ec340,12,LocalePrototypeHourCycles
code-creation,Builtin,2,31416,0x1031ec380,12,LocalePrototypeLanguage
code-creation,Builtin,2,31425,0x1031ec3c0,12,LocalePrototypeMaximize
code-creation,Builtin,2,31434,0x1031ec400,12,LocalePrototypeMinimize
code-creation,Builtin,2,31444,0x1031ec440,12,LocalePrototypeNumeric
code-creation,Builtin,2,31453,0x1031ec480,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,31463,0x1031ec4c0,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,31473,0x1031ec500,12,LocalePrototypeRegion
code-creation,Builtin,2,31482,0x1031ec540,12,LocalePrototypeScript
code-creation,Builtin,2,31491,0x1031ec580,12,LocalePrototypeTextInfo
code-creation,Builtin,2,31501,0x1031ec5c0,12,LocalePrototypeTimeZones
code-creation,Builtin,2,31510,0x1031ec600,12,LocalePrototypeToString
code-creation,Builtin,2,31519,0x1031ec640,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,31529,0x1031ec680,12,NumberFormatConstructor
code-creation,Builtin,2,31538,0x1031ec6c0,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,31548,0x1031ec700,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,31558,0x1031ec740,12,NumberFormatPrototypeFormatRange
code-creation,Builtin,2,31568,0x1031ec780,12,NumberFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,31579,0x1031ec7c0,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,31592,0x1031ec800,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,31603,0x1031ec840,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,31613,0x1031ec880,12,PluralRulesConstructor
code-creation,Builtin,2,31622,0x1031ec8c0,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,31632,0x1031ec900,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,31642,0x1031ec940,12,PluralRulesPrototypeSelectRange
code-creation,Builtin,2,31652,0x1031ec980,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,31662,0x1031ec9c0,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,31672,0x1031eca00,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,31682,0x1031eca40,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,31693,0x1031eca80,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,31704,0x1031ecac0,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,31715,0x1031ecb00,12,SegmenterConstructor
code-creation,Builtin,2,31724,0x1031ecb40,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,31734,0x1031ecb80,12,SegmenterPrototypeSegment
code-creation,Builtin,2,31743,0x1031ecbc0,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,31753,0x1031ecc00,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,31763,0x1031ecc40,12,SegmentsPrototypeContaining
code-creation,Builtin,2,31772,0x1031ecc80,12,SegmentsPrototypeIterator
code-creation,Builtin,2,31782,0x1031eccc0,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,31792,0x1031ecd00,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,31802,0x1031ecd40,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,31812,0x1031ecd80,196,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,31822,0x1031ece80,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,31832,0x1031ecec0,656,StringToLowerCaseIntl
code-creation,Builtin,2,31841,0x1031ed180,12,TemporalCalendarPrototypeEra
code-creation,Builtin,2,31851,0x1031ed1c0,12,TemporalCalendarPrototypeEraYear
code-creation,Builtin,2,31861,0x1031ed200,12,TemporalDurationPrototypeToLocaleString
code-creation,Builtin,2,31871,0x1031ed240,12,TemporalInstantPrototypeToLocaleString
code-creation,Builtin,2,31882,0x1031ed280,12,TemporalPlainDatePrototypeEra
code-creation,Builtin,2,31892,0x1031ed2c0,12,TemporalPlainDatePrototypeEraYear
code-creation,Builtin,2,31902,0x1031ed300,12,TemporalPlainDatePrototypeToLocaleString
code-creation,Builtin,2,31913,0x1031ed340,12,TemporalPlainDateTimePrototypeEra
code-creation,Builtin,2,31923,0x1031ed380,12,TemporalPlainDateTimePrototypeEraYear
code-creation,Builtin,2,31934,0x1031ed3c0,12,TemporalPlainDateTimePrototypeToLocaleString
code-creation,Builtin,2,31949,0x1031ed400,12,TemporalPlainMonthDayPrototypeToLocaleString
code-creation,Builtin,2,31961,0x1031ed440,12,TemporalPlainTimePrototypeToLocaleString
code-creation,Builtin,2,31971,0x1031ed480,12,TemporalPlainYearMonthPrototypeEra
code-creation,Builtin,2,31982,0x1031ed4c0,12,TemporalPlainYearMonthPrototypeEraYear
code-creation,Builtin,2,31992,0x1031ed500,12,TemporalPlainYearMonthPrototypeToLocaleString
code-creation,Builtin,2,32004,0x1031ed540,12,TemporalZonedDateTimePrototypeEra
code-creation,Builtin,2,32014,0x1031ed580,12,TemporalZonedDateTimePrototypeEraYear
code-creation,Builtin,2,32024,0x1031ed5c0,12,TemporalZonedDateTimePrototypeToLocaleString
code-creation,Builtin,2,32036,0x1031ed600,12,V8BreakIteratorConstructor
code-creation,Builtin,2,32045,0x1031ed640,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,32055,0x1031ed680,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,32065,0x1031ed6c0,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,32075,0x1031ed700,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,32085,0x1031ed740,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,32094,0x1031ed780,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,32105,0x1031ed7c0,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,32115,0x1031ed800,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,32163,0x1031ed840,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,32173,0x1031ed880,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,32183,0x1031ed8c0,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,32194,0x1031ed900,12,V8BreakIteratorSupportedLocalesOf
tick,0x7ff805ede983,32206,0,0x0,6
tick,0x7ff805f12098,32213,0,0x0,6
tick,0x7ff805e4dd18,32217,0,0x0,6
tick,0x7ff805e2d43e,32222,0,0x0,6
code-creation,BytecodeHandler,0,32392,0x1031ed940,24,Wide
code-creation,BytecodeHandler,0,32400,0x1031ed980,24,ExtraWide
code-creation,BytecodeHandler,0,32408,0x1031ed9c0,104,DebugBreakWide
code-creation,BytecodeHandler,0,32416,0x1031eda40,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,32425,0x1031edac0,164,DebugBreak0
code-creation,BytecodeHandler,0,32432,0x1031edb80,104,DebugBreak1
code-creation,BytecodeHandler,0,32440,0x1031edc00,104,DebugBreak2
code-creation,BytecodeHandler,0,32448,0x1031edc80,104,DebugBreak3
code-creation,BytecodeHandler,0,32456,0x1031edd00,104,DebugBreak4
code-creation,BytecodeHandler,0,32463,0x1031edd80,104,DebugBreak5
code-creation,BytecodeHandler,0,32471,0x1031ede00,104,DebugBreak6
code-creation,BytecodeHandler,0,32479,0x1031ede80,32,Ldar
code-creation,BytecodeHandler,0,32486,0x1031edec0,60,LdaZero
code-creation,BytecodeHandler,0,32493,0x1031edf00,68,LdaSmi
code-creation,BytecodeHandler,0,32500,0x1031edf80,64,LdaUndefined
code-creation,BytecodeHandler,0,32508,0x1031ee000,64,LdaNull
code-creation,BytecodeHandler,0,32515,0x1031ee080,64,LdaTheHole
code-creation,BytecodeHandler,0,32523,0x1031ee100,24,LdaTrue
code-creation,BytecodeHandler,0,32530,0x1031ee140,24,LdaFalse
code-creation,BytecodeHandler,0,32537,0x1031ee180,68,LdaConstant
code-creation,BytecodeHandler,0,32545,0x1031ee200,124,LdaContextSlot
code-creation,BytecodeHandler,0,32553,0x1031ee280,124,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,32564,0x1031ee300,80,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,32573,0x1031ee380,80,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,32583,0x1031ee400,32,Star
code-creation,BytecodeHandler,0,32590,0x1031ee440,48,Mov
code-creation,BytecodeHandler,0,32597,0x1031ee480,40,PushContext
code-creation,BytecodeHandler,0,32605,0x1031ee4c0,36,PopContext
code-creation,BytecodeHandler,0,32612,0x1031ee500,56,TestReferenceEqual
code-creation,BytecodeHandler,0,32620,0x1031ee540,60,TestUndetectable
code-creation,BytecodeHandler,0,32629,0x1031ee580,44,TestNull
code-creation,BytecodeHandler,0,32636,0x1031ee5c0,44,TestUndefined
code-creation,BytecodeHandler,0,32644,0x1031ee600,364,TestTypeOf
code-creation,BytecodeHandler,0,32652,0x1031ee780,5648,LdaGlobal
code-creation,BytecodeHandler,0,32659,0x1031efdc0,4400,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,32668,0x1031f0f00,160,StaGlobal
code-creation,BytecodeHandler,0,32675,0x1031f0fc0,156,StaContextSlot
code-creation,BytecodeHandler,0,32683,0x1031f1080,112,StaCurrentContextSlot
code-creation,BytecodeHandler,0,32692,0x1031f1100,124,LdaLookupSlot
code-creation,BytecodeHandler,0,32700,0x1031f1180,244,LdaLookupContextSlot
code-creation,BytecodeHandler,0,32708,0x1031f1280,4660,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,32717,0x1031f24c0,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,32727,0x1031f2540,244,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,32736,0x1031f2640,4572,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,32746,0x1031f3840,220,StaLookupSlot
code-creation,BytecodeHandler,0,32753,0x1031f3940,5288,GetNamedProperty
code-creation,BytecodeHandler,0,32761,0x1031f4e00,184,GetNamedPropertyFromSuper
code-creation,BytecodeHandler,0,32770,0x1031f4ec0,200,GetKeyedProperty
code-creation,BytecodeHandler,0,32778,0x1031f4fc0,160,LdaModuleVariable
code-creation,BytecodeHandler,0,32786,0x1031f5080,292,StaModuleVariable
code-creation,BytecodeHandler,0,32794,0x1031f51c0,176,SetNamedProperty
code-creation,BytecodeHandler,0,32802,0x1031f5280,176,DefineNamedOwnProperty
code-creation,BytecodeHandler,0,32810,0x1031f5340,168,SetKeyedProperty
code-creation,BytecodeHandler,0,32821,0x1031f5400,168,DefineKeyedOwnProperty
code-creation,BytecodeHandler,0,32830,0x1031f54c0,168,StaInArrayLiteral
code-creation,BytecodeHandler,0,32838,0x1031f5580,200,DefineKeyedOwnPropertyInLiteral
code-creation,BytecodeHandler,0,32847,0x1031f5680,164,CollectTypeProfile
code-creation,BytecodeHandler,0,32855,0x1031f5740,1028,Add
code-creation,BytecodeHandler,0,32863,0x1031f5b80,1056,Sub
code-creation,BytecodeHandler,0,32869,0x1031f5fc0,1036,Mul
code-creation,BytecodeHandler,0,32876,0x1031f6400,988,Div
code-creation,BytecodeHandler,0,32883,0x1031f6800,936,Mod
code-creation,BytecodeHandler,0,32890,0x1031f6bc0,984,Exp
code-creation,BytecodeHandler,0,32896,0x1031f6fc0,992,BitwiseOr
code-creation,BytecodeHandler,0,32904,0x1031f73c0,992,BitwiseXor
code-creation,BytecodeHandler,0,32911,0x1031f77c0,992,BitwiseAnd
code-creation,BytecodeHandler,0,32918,0x1031f7bc0,1008,ShiftLeft
code-creation,BytecodeHandler,0,32925,0x1031f7fc0,1008,ShiftRight
code-creation,BytecodeHandler,0,32933,0x1031f83c0,1128,ShiftRightLogical
code-creation,BytecodeHandler,0,32941,0x1031f8840,956,AddSmi
code-creation,BytecodeHandler,0,32948,0x1031f8c00,964,SubSmi
code-creation,BytecodeHandler,0,32954,0x1031f9000,892,MulSmi
code-creation,BytecodeHandler,0,32961,0x1031f9380,940,DivSmi
code-creation,BytecodeHandler,0,32968,0x1031f9740,812,ModSmi
code-creation,BytecodeHandler,0,32975,0x1031f9a80,868,ExpSmi
code-creation,BytecodeHandler,0,32982,0x1031f9e00,500,BitwiseOrSmi
code-creation,BytecodeHandler,0,32989,0x1031fa000,500,BitwiseXorSmi
code-creation,BytecodeHandler,0,32997,0x1031fa200,500,BitwiseAndSmi
code-creation,BytecodeHandler,0,33004,0x1031fa400,524,ShiftLeftSmi
code-creation,BytecodeHandler,0,33012,0x1031fa640,512,ShiftRightSmi
code-creation,BytecodeHandler,0,33020,0x1031fa880,820,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,33028,0x1031fabc0,656,Inc
code-creation,BytecodeHandler,0,33038,0x1031fae80,656,Dec
code-creation,BytecodeHandler,0,33045,0x1031fb140,652,Negate
code-creation,BytecodeHandler,0,33052,0x1031fb400,500,BitwiseNot
code-creation,BytecodeHandler,0,33059,0x1031fb600,120,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,33067,0x1031fb680,44,LogicalNot
code-creation,BytecodeHandler,0,33074,0x1031fb6c0,208,TypeOf
code-creation,BytecodeHandler,0,33081,0x1031fb7c0,124,DeletePropertyStrict
code-creation,BytecodeHandler,0,33090,0x1031fb840,116,DeletePropertySloppy
code-creation,BytecodeHandler,0,33098,0x1031fb8c0,40,GetSuperConstructor
code-creation,BytecodeHandler,0,33108,0x1031fb900,1100,CallAnyReceiver
code-creation,BytecodeHandler,0,33116,0x1031fbd80,1100,CallProperty
code-creation,BytecodeHandler,0,33123,0x1031fc200,996,CallProperty0
code-creation,BytecodeHandler,0,33131,0x1031fc600,1008,CallProperty1
code-creation,BytecodeHandler,0,33138,0x1031fca00,1020,CallProperty2
code-creation,BytecodeHandler,0,33146,0x1031fce00,976,CallUndefinedReceiver
code-creation,BytecodeHandler,0,33154,0x1031fd200,1036,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,33163,0x1031fd640,1008,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,33171,0x1031fda40,1028,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,33180,0x1031fde80,1100,CallWithSpread
code-creation,BytecodeHandler,0,33187,0x1031fe300,128,CallRuntime
code-creation,BytecodeHandler,0,33194,0x1031fe3c0,164,CallRuntimeForPair
code-creation,BytecodeHandler,0,33202,0x1031fe480,84,CallJSRuntime
code-creation,BytecodeHandler,0,33210,0x1031fe500,1280,InvokeIntrinsic
code-creation,BytecodeHandler,0,33218,0x1031fea40,1008,Construct
code-creation,BytecodeHandler,0,33225,0x1031fee40,516,ConstructWithSpread
code-creation,BytecodeHandler,0,33233,0x1031ff080,1920,TestEqual
code-creation,BytecodeHandler,0,33240,0x1031ff840,1048,TestEqualStrict
code-creation,BytecodeHandler,0,33248,0x1031ffc80,1624,TestLessThan
code-creation,BytecodeHandler,0,33256,0x103200300,1624,TestGreaterThan
code-creation,BytecodeHandler,0,33263,0x103200980,1624,TestLessThanOrEqual
code-creation,BytecodeHandler,0,33271,0x103201000,1624,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,33283,0x103201680,868,TestInstanceOf
code-creation,BytecodeHandler,0,33290,0x103201a00,156,TestIn
code-creation,BytecodeHandler,0,33297,0x103201ac0,116,ToName
code-creation,BytecodeHandler,0,33304,0x103201b40,220,ToNumber
code-creation,BytecodeHandler,0,33311,0x103201c40,240,ToNumeric
code-creation,BytecodeHandler,0,33318,0x103201d40,116,ToObject
code-creation,BytecodeHandler,0,33326,0x103201dc0,120,ToString
code-creation,BytecodeHandler,0,33333,0x103201e40,404,CreateRegExpLiteral
code-creation,BytecodeHandler,0,33341,0x103202000,1468,CreateArrayLiteral
code-creation,BytecodeHandler,0,33350,0x1032025c0,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,33359,0x103202640,792,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,33367,0x103202980,2236,CreateObjectLiteral
code-creation,BytecodeHandler,0,33376,0x103203240,224,CreateEmptyObjectLiteral
tick,0x7ff805e2d43e,33417,0,0x0,6
code-creation,BytecodeHandler,0,33424,0x103203340,172,CloneObject
code-creation,BytecodeHandler,0,33434,0x103203400,208,GetTemplateObject
code-creation,BytecodeHandler,0,33442,0x103203500,328,CreateClosure
code-creation,BytecodeHandler,0,33450,0x103203680,116,CreateBlockContext
code-creation,BytecodeHandler,0,33459,0x103203700,132,CreateCatchContext
code-creation,BytecodeHandler,0,33467,0x1032037c0,260,CreateFunctionContext
code-creation,BytecodeHandler,0,33476,0x103203900,260,CreateEvalContext
code-creation,BytecodeHandler,0,33484,0x103203a40,132,CreateWithContext
code-creation,BytecodeHandler,0,33492,0x103203b00,1600,CreateMappedArguments
code-creation,BytecodeHandler,0,33500,0x103204180,588,CreateUnmappedArguments
code-creation,BytecodeHandler,0,33509,0x103204400,644,CreateRestParameter
code-creation,BytecodeHandler,0,33518,0x1032046c0,480,JumpLoop
code-creation,BytecodeHandler,0,33525,0x1032048c0,44,Jump
code-creation,BytecodeHandler,0,33532,0x103204900,56,JumpConstant
code-creation,BytecodeHandler,0,33540,0x103204940,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,33548,0x1032049c0,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,33557,0x103204a40,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,33565,0x103204ac0,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,33574,0x103204b40,92,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,33584,0x103204bc0,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,33593,0x103204c40,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,33601,0x103204cc0,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,33610,0x103204d40,160,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,33619,0x103204e00,156,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,33628,0x103204ec0,144,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,33637,0x103204f80,144,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,33645,0x103205040,68,JumpIfTrue
code-creation,BytecodeHandler,0,33653,0x1032050c0,68,JumpIfFalse
code-creation,BytecodeHandler,0,33660,0x103205140,68,JumpIfNull
code-creation,BytecodeHandler,0,33668,0x1032051c0,68,JumpIfNotNull
code-creation,BytecodeHandler,0,33676,0x103205240,68,JumpIfUndefined
code-creation,BytecodeHandler,0,33684,0x1032052c0,68,JumpIfNotUndefined
code-creation,BytecodeHandler,0,33692,0x103205340,76,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,33700,0x1032053c0,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,33708,0x103205440,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,33717,0x1032054c0,468,ForInEnumerate
code-creation,BytecodeHandler,0,33725,0x1032056c0,260,ForInPrepare
code-creation,BytecodeHandler,0,33732,0x103205800,64,ForInContinue
code-creation,BytecodeHandler,0,33740,0x103205880,264,ForInNext
code-creation,BytecodeHandler,0,33748,0x1032059c0,48,ForInStep
code-creation,BytecodeHandler,0,33755,0x103205a00,36,SetPendingMessage
code-creation,BytecodeHandler,0,33764,0x103205a40,116,Throw
code-creation,BytecodeHandler,0,33770,0x103205ac0,116,ReThrow
code-creation,BytecodeHandler,0,33777,0x103205b40,112,Return
code-creation,BytecodeHandler,0,33784,0x103205bc0,192,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,33796,0x103205cc0,136,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,33805,0x103205d80,136,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,33814,0x103205e40,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,33823,0x103205f00,124,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,33832,0x103205f80,512,SuspendGenerator
code-creation,BytecodeHandler,0,33839,0x1032061c0,140,ResumeGenerator
code-creation,BytecodeHandler,0,33847,0x103206280,164,GetIterator
code-creation,BytecodeHandler,0,33854,0x103206340,116,Debugger
code-creation,BytecodeHandler,0,33861,0x1032063c0,124,IncBlockCounter
code-creation,BytecodeHandler,0,33869,0x103206440,56,Abort
code-creation,BytecodeHandler,0,33876,0x103206480,32,Star0
code-creation,BytecodeHandler,0,33883,0x1032064c0,60,Illegal
code-creation,BytecodeHandler,0,33890,0x103206500,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,33898,0x103206580,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,33906,0x103206600,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,33913,0x103206680,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,33921,0x103206700,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,33929,0x103206780,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,33937,0x103206800,32,Ldar.Wide
code-creation,BytecodeHandler,0,33944,0x103206840,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,33951,0x103206880,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,33959,0x1032068c0,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,33967,0x103206940,92,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,33976,0x1032069c0,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,33985,0x103206a00,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,33994,0x103206a40,32,Star.Wide
code-creation,BytecodeHandler,0,34001,0x103206a80,48,Mov.Wide
code-creation,BytecodeHandler,0,34009,0x103206ac0,40,PushContext.Wide
code-creation,BytecodeHandler,0,34016,0x103206b00,36,PopContext.Wide
code-creation,BytecodeHandler,0,34024,0x103206b40,56,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,34033,0x103206b80,4536,LdaGlobal.Wide
code-creation,BytecodeHandler,0,34040,0x103207d40,4464,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,34049,0x103208ec0,164,StaGlobal.Wide
code-creation,BytecodeHandler,0,34056,0x103208f80,156,StaContextSlot.Wide
code-creation,BytecodeHandler,0,34064,0x103209040,112,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,34073,0x1032090c0,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,34081,0x103209180,248,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,34090,0x103209280,4732,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,34098,0x10320a500,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,34107,0x10320a5c0,248,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,34117,0x10320a6c0,4636,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,34127,0x10320b900,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,34135,0x10320ba00,5300,GetNamedProperty.Wide
code-creation,BytecodeHandler,0,34143,0x10320cec0,192,GetNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,34152,0x10320cfc0,156,GetKeyedProperty.Wide
code-creation,BytecodeHandler,0,34161,0x10320d080,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,34169,0x10320d140,296,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,34177,0x10320d280,180,SetNamedProperty.Wide
code-creation,BytecodeHandler,0,34185,0x10320d340,180,DefineNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,34194,0x10320d400,172,SetKeyedProperty.Wide
code-creation,BytecodeHandler,0,34202,0x10320d4c0,172,DefineKeyedOwnProperty.Wide
code-creation,BytecodeHandler,0,34211,0x10320d580,172,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,34219,0x10320d640,204,DefineKeyedOwnPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,34229,0x10320d740,168,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,34242,0x10320d800,988,Add.Wide
code-creation,BytecodeHandler,0,34249,0x10320dc00,1024,Sub.Wide
code-creation,BytecodeHandler,0,34256,0x10320e040,992,Mul.Wide
code-creation,BytecodeHandler,0,34263,0x10320e440,992,Div.Wide
code-creation,BytecodeHandler,0,34270,0x10320e840,944,Mod.Wide
code-creation,BytecodeHandler,0,34277,0x10320ec00,1000,Exp.Wide
code-creation,BytecodeHandler,0,34284,0x10320f000,1016,BitwiseOr.Wide
code-creation,BytecodeHandler,0,34292,0x10320f400,1016,BitwiseXor.Wide
code-creation,BytecodeHandler,0,34299,0x10320f800,1016,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,34307,0x10320fc00,1032,ShiftLeft.Wide
code-creation,BytecodeHandler,0,34315,0x103210040,1032,ShiftRight.Wide
code-creation,BytecodeHandler,0,34322,0x103210480,1152,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,34330,0x103210940,920,AddSmi.Wide
code-creation,BytecodeHandler,0,34338,0x103210d00,932,SubSmi.Wide
code-creation,BytecodeHandler,0,34345,0x1032110c0,892,MulSmi.Wide
code-creation,BytecodeHandler,0,34352,0x103211440,940,DivSmi.Wide
code-creation,BytecodeHandler,0,34359,0x103211800,812,ModSmi.Wide
code-creation,BytecodeHandler,0,34367,0x103211b40,868,ExpSmi.Wide
code-creation,BytecodeHandler,0,34374,0x103211ec0,508,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,34382,0x1032120c0,508,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,34390,0x1032122c0,508,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,34397,0x1032124c0,532,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,34405,0x103212700,520,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,34413,0x103212940,828,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,34422,0x103212c80,624,Inc.Wide
code-creation,BytecodeHandler,0,34429,0x103212f00,624,Dec.Wide
code-creation,BytecodeHandler,0,34436,0x103213180,660,Negate.Wide
code-creation,BytecodeHandler,0,34443,0x103213440,512,BitwiseNot.Wide
code-creation,BytecodeHandler,0,34451,0x103213680,128,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,34459,0x103213740,120,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,34468,0x1032137c0,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,34476,0x103213800,1104,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,34484,0x103213c80,1104,CallProperty.Wide
code-creation,BytecodeHandler,0,34492,0x103214100,1000,CallProperty0.Wide
code-creation,BytecodeHandler,0,34500,0x103214500,1012,CallProperty1.Wide
code-creation,BytecodeHandler,0,34508,0x103214900,1024,CallProperty2.Wide
code-creation,BytecodeHandler,0,34516,0x103214d40,976,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,34525,0x103215140,1036,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,34533,0x103215580,1012,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,34542,0x103215980,1032,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,34551,0x103215dc0,1104,CallWithSpread.Wide
code-creation,BytecodeHandler,0,34559,0x103216240,132,CallRuntime.Wide
code-creation,BytecodeHandler,0,34567,0x103216300,176,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,34575,0x1032163c0,88,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,34583,0x103216440,1284,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,34591,0x103216980,964,Construct.Wide
code-creation,BytecodeHandler,0,34598,0x103216d80,460,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,34607,0x103216f80,1944,TestEqual.Wide
code-creation,BytecodeHandler,0,34615,0x103217740,1056,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,34623,0x103217b80,1612,TestLessThan.Wide
code-creation,BytecodeHandler,0,34632,0x103218200,1612,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,34640,0x103218880,1612,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,34649,0x103218f00,1612,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,34658,0x103219580,876,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,34685,0x103219900,156,TestIn.Wide
code-creation,BytecodeHandler,0,34694,0x1032199c0,120,ToName.Wide
code-creation,BytecodeHandler,0,34703,0x103219a40,224,ToNumber.Wide
code-creation,BytecodeHandler,0,34716,0x103219b40,244,ToNumeric.Wide
code-creation,BytecodeHandler,0,34726,0x103219c40,120,ToObject.Wide
code-creation,BytecodeHandler,0,34735,0x103219cc0,408,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,34745,0x103219e80,1396,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,34756,0x10321a400,792,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,34767,0x10321a740,2168,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,34777,0x10321afc0,176,CloneObject.Wide
code-creation,BytecodeHandler,0,34786,0x10321b080,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,34796,0x10321b140,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,34806,0x10321b2c0,120,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,34817,0x10321b340,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,34827,0x10321b400,260,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,34837,0x10321b540,260,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,34847,0x10321b680,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,34857,0x10321b740,492,JumpLoop.Wide
code-creation,BytecodeHandler,0,34867,0x10321b940,44,Jump.Wide
code-creation,BytecodeHandler,0,34876,0x10321b980,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,34885,0x10321b9c0,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,34896,0x10321ba40,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,34906,0x10321bac0,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,34917,0x10321bb40,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,34928,0x10321bbc0,92,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,34940,0x10321bc40,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,34950,0x10321bcc0,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,34961,0x10321bd40,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,34972,0x10321bdc0,160,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,34983,0x10321be80,156,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,34994,0x10321bf40,144,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,35005,0x10321c000,144,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,35015,0x10321c0c0,68,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,35025,0x10321c140,68,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,35034,0x10321c1c0,68,JumpIfNull.Wide
code-creation,BytecodeHandler,0,35044,0x10321c240,68,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,35053,0x10321c2c0,68,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,35063,0x10321c340,68,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,35074,0x10321c3c0,76,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,35084,0x10321c440,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,35094,0x10321c4c0,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,35105,0x10321c540,472,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,35114,0x10321c740,260,ForInPrepare.Wide
code-creation,BytecodeHandler,0,35124,0x10321c880,64,ForInContinue.Wide
code-creation,BytecodeHandler,0,35134,0x10321c900,268,ForInNext.Wide
code-creation,BytecodeHandler,0,35143,0x10321ca40,48,ForInStep.Wide
code-creation,BytecodeHandler,0,35152,0x10321ca80,160,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,35163,0x10321cb40,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,35174,0x10321cc00,124,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,35185,0x10321cc80,532,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,35195,0x10321cec0,140,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,35205,0x10321cf80,168,GetIterator.Wide
code-creation,BytecodeHandler,0,35214,0x10321d040,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,35224,0x10321d100,56,Abort.Wide
code-creation,BytecodeHandler,0,35233,0x10321d140,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,35243,0x10321d1c0,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,35253,0x10321d240,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,35266,0x10321d2c0,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,35276,0x10321d340,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,35286,0x10321d3c0,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,35296,0x10321d440,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,35305,0x10321d480,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,35314,0x10321d4c0,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,35325,0x10321d500,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35335,0x10321d580,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35346,0x10321d600,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35357,0x10321d640,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35369,0x10321d680,32,Star.ExtraWide
code-creation,BytecodeHandler,0,35378,0x10321d6c0,44,Mov.ExtraWide
code-creation,BytecodeHandler,0,35387,0x10321d700,40,PushContext.ExtraWide
code-creation,BytecodeHandler,0,35397,0x10321d740,36,PopContext.ExtraWide
code-creation,BytecodeHandler,0,35407,0x10321d780,52,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,35418,0x10321d7c0,4524,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,35428,0x10321e980,4452,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35439,0x10321fb00,164,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,35449,0x10321fbc0,152,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35459,0x10321fc80,108,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35470,0x10321fd00,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,35480,0x10321fdc0,244,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,35491,0x10321fec0,4716,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,35502,0x103221140,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35513,0x103221200,244,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35525,0x103221300,4624,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,35537,0x103222540,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,35548,0x103222640,5284,GetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,35558,0x103223b00,188,GetNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,35569,0x103223bc0,156,GetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,35580,0x103223c80,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,35591,0x103223d40,292,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,35601,0x103223e80,176,SetNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,35612,0x103223f40,176,DefineNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,35623,0x103224000,168,SetKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,35633,0x1032240c0,168,DefineKeyedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,35644,0x103224180,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,35655,0x103224240,200,DefineKeyedOwnPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,35667,0x103224340,168,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,35678,0x103224400,984,Add.ExtraWide
code-creation,BytecodeHandler,0,35687,0x103224800,1024,Sub.ExtraWide
code-creation,BytecodeHandler,0,35696,0x103224c40,988,Mul.ExtraWide
code-creation,BytecodeHandler,0,35705,0x103225040,992,Div.ExtraWide
code-creation,BytecodeHandler,0,35714,0x103225440,944,Mod.ExtraWide
code-creation,BytecodeHandler,0,35723,0x103225800,996,Exp.ExtraWide
code-creation,BytecodeHandler,0,35733,0x103225c00,1012,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,35742,0x103226000,1016,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,35752,0x103226400,1016,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,35762,0x103226800,1028,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,35772,0x103226c40,1028,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,35782,0x103227080,1152,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,35792,0x103227540,916,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,35805,0x103227900,928,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,35814,0x103227cc0,892,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,35824,0x103228040,936,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,35833,0x103228400,812,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,35843,0x103228740,864,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,35853,0x103228ac0,508,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,35863,0x103228cc0,508,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,35873,0x103228ec0,508,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,35883,0x1032290c0,528,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,35894,0x103229300,516,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,35904,0x103229540,828,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,35929,0x103229880,624,Inc.ExtraWide
code-creation,BytecodeHandler,0,35940,0x103229b00,620,Dec.ExtraWide
code-creation,BytecodeHandler,0,35949,0x103229d80,656,Negate.ExtraWide
code-creation,BytecodeHandler,0,35959,0x10322a040,508,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,35969,0x10322a240,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,35980,0x10322a2c0,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,35991,0x10322a340,40,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,36002,0x10322a380,1100,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,36012,0x10322a800,1100,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,36022,0x10322ac80,996,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,36033,0x10322b080,1004,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,36043,0x10322b480,1016,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,36054,0x10322b880,972,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,36065,0x10322bc80,1036,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,36076,0x10322c0c0,1008,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,36087,0x10322c4c0,1028,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,36098,0x10322c900,1100,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,36108,0x10322cd80,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,36118,0x10322ce40,176,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,36129,0x10322cf00,84,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,36139,0x10322cf80,1280,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,36150,0x10322d4c0,960,Construct.ExtraWide
code-creation,BytecodeHandler,0,36160,0x10322d8c0,456,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,36170,0x10322dac0,1944,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,36180,0x10322e280,1052,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,36191,0x10322e6c0,1608,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,36201,0x10322ed40,1608,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,36211,0x10322f3c0,1608,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,36222,0x10322fa40,1608,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,36233,0x1032300c0,872,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,36243,0x103230440,156,TestIn.ExtraWide
code-creation,BytecodeHandler,0,36253,0x103230500,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,36262,0x103230580,220,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,36272,0x103230680,240,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,36282,0x103230780,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,36292,0x103230800,404,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,36303,0x1032309c0,1392,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,36314,0x103230f40,792,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,36325,0x103231280,2164,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,36336,0x103231b00,172,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,36346,0x103231bc0,164,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,36361,0x103231c80,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,36371,0x103231e00,120,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,36382,0x103231e80,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,36393,0x103231f40,260,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,36404,0x103232080,260,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,36414,0x1032321c0,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,36425,0x103232280,488,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,36435,0x103232480,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,36444,0x1032324c0,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,36455,0x103232500,80,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,36465,0x103232580,80,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,36476,0x103232600,80,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,36488,0x103232680,80,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,36499,0x103232700,88,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,36511,0x103232780,80,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,36522,0x103232800,80,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,36533,0x103232880,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,36544,0x103232900,160,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,36556,0x1032329c0,156,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,36567,0x103232a80,144,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,36578,0x103232b40,144,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,36589,0x103232c00,68,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,36599,0x103232c80,68,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,36608,0x103232d00,68,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,36618,0x103232d80,68,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,36628,0x103232e00,68,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,36639,0x103232e80,68,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,36649,0x103232f00,76,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,36660,0x103232f80,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,36671,0x103233000,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,36682,0x103233080,472,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,36692,0x103233280,256,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,36702,0x1032333c0,64,ForInContinue.ExtraWide
tick,0x7ff805f12098,36715,0,0x0,6
tick,0x7ff805ea76fa,36723,0,0x0,6
code-creation,BytecodeHandler,0,36729,0x103233440,264,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,36739,0x103233580,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,36748,0x1032335c0,160,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,36758,0x103233680,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,36768,0x103233740,124,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,36778,0x1032337c0,528,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,36787,0x103233a00,136,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,36796,0x103233ac0,164,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,36804,0x103233b80,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,36813,0x103233c00,56,Abort.ExtraWide
new,MemoryChunk,0xb46f3dc0000,262144
new,MemoryChunk,0xb467d580000,262144
tick,0x103845aaf,39994,0,0x0,5
tick,0x103845da5,40954,0,0x0,5
tick,0x102973120,42224,0,0x0,5
new,MemoryChunk,0xb46f0e80000,262144
tick,0x102d9100d,43238,0,0x0,5
new,MemoryChunk,0xb46464c0000,262144
new,MemoryChunk,0xb46f7dc0000,262144
tick,0x102c32e61,44875,0,0x0,5
tick,0x102796730,46020,0,0x0,6
code-creation,Eval,10,46708,0xb46f7dee540,5, node:internal/main/run_main_module:1:1,0xb46f7dee3f8,~
script-source,388,node:internal/main/run_main_module,'use strict';\n\nconst {\n  prepareMainThreadExecution\n} = require('internal/bootstrap/pre_execution');\n\nprepareMainThreadExecution(true);\n\nmarkBootstrapComplete();\n\n// Note: this loads the module through the ESM loader if the module is\n// determined to be an ES module. This hangs from the CJS module loader\n// because we currently allow monkey-patching of the module loaders\n// in the preloaded scripts through require('module').\n// runMain here might be monkey-patched by users in --require.\n// XXX: the monkey-patchability here should probably be deprecated.\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\n
code-source-info,0xb46f7dee540,388,0,632,C0O0C4O632,,
code-creation,Function,10,46816,0xb46f7dee5e8,58, node:internal/main/run_main_module:1:1,0xb46f7dee4b8,~
code-source-info,0xb46f7dee5e8,388,0,632,C0O56C3O56C8O25C13O102C15O102C19O137C22O560C25O560C30O598C35O605C40O622C47O626C51O606C57O631,,
tick,0x102db0baf,47055,0,0x0,6
code-creation,LazyCompile,10,47728,0xb46f7dee830,76,nativeModuleRequire node:internal/bootstrap/loaders:349:29,0xb466514b8b0,~
script-source,15,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\n// modules. In contrast\x2C user land modules are loaded using\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\n// lib/internal/modules/esm/* (ES Modules).\n//\n// This file is compiled and run by node.cc before bootstrap/node.js\n// was called\x2C therefore the loaders are bootstrapped before we start to\n// actually bootstrap Node.js. It creates the following objects:\n//\n// C++ binding loaders:\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\n//   because it is an object attached to the global process object.\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\n//   about the stability of these bindings\x2C but still have to take care of\n//   compatibility issues caused by them from time to time.\n// - process._linkedBinding(): intended to be used by embedders to add\n//   additional C++ bindings in their applications. These C++ bindings\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\n//   NM_F_LINKED.\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\n//   from user land unless through `require('internal/test/binding')`.\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\n//   and have their nm_flags set to NM_F_INTERNAL.\n//\n// Internal JavaScript module loader:\n// - NativeModule: a minimal module system used to load the JavaScript core\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\n//   so they can be loaded faster without the cost of I/O. This class makes the\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\n//   default to core modules\x2C and lets the core modules require itself via\n//   require('internal/bootstrap/loaders') even when this file is not written in\n//   CommonJS style.\n//\n// Other objects:\n// - process.moduleLoadList: an array recording the bindings and the modules\n//   loaded in the process and the order in which they are loaded.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\n\nconst {\n  ArrayFrom\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ReflectGet\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeStartsWith\x2C\n  TypeError\x2C\n} = primordials;\n\n// Set up process.moduleLoadList.\nconst moduleLoadList = [];\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\n  __proto__: null\x2C\n  value: moduleLoadList\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  writable: false\n});\n\n\n// internalBindingAllowlist contains the name of internalBinding modules\n// that are allowed for access via process.binding()... This is used\n// to provide a transition path for modules that are being moved over to\n// internalBinding.\nconst internalBindingAllowlist = new SafeSet([\n  'async_wrap'\x2C\n  'buffer'\x2C\n  'cares_wrap'\x2C\n  'config'\x2C\n  'constants'\x2C\n  'contextify'\x2C\n  'crypto'\x2C\n  'fs'\x2C\n  'fs_event_wrap'\x2C\n  'http_parser'\x2C\n  'icu'\x2C\n  'inspector'\x2C\n  'js_stream'\x2C\n  'natives'\x2C\n  'os'\x2C\n  'pipe_wrap'\x2C\n  'process_wrap'\x2C\n  'signal_wrap'\x2C\n  'spawn_sync'\x2C\n  'stream_wrap'\x2C\n  'tcp_wrap'\x2C\n  'tls_wrap'\x2C\n  'tty_wrap'\x2C\n  'udp_wrap'\x2C\n  'url'\x2C\n  'util'\x2C\n  'uv'\x2C\n  'v8'\x2C\n  'zlib'\x2C\n]);\n\nconst runtimeDeprecatedList = new SafeSet([\n  'async_wrap'\x2C\n  'crypto'\x2C\n  'http_parser'\x2C\n  'signal_wrap'\x2C\n  'url'\x2C\n  'v8'\x2C\n]);\n\nconst legacyWrapperList = new SafeSet([\n  'util'\x2C\n]);\n\n// Modules that can only be imported via the node: scheme.\nconst schemelessBlockList = new SafeSet([\n  'test'\x2C\n]);\n\n// Set up process.binding() and process._linkedBinding().\n{\n  const bindingObj = ObjectCreate(null);\n\n  process.binding = function binding(module) {\n    module = String(module);\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\n    // selective fallback to internalBinding for the deprecated ones.\n    if (internalBindingAllowlist.has(module)) {\n      if (runtimeDeprecatedList.has(module)) {\n        runtimeDeprecatedList.delete(module);\n        process.emitWarning(\n          `Access to process.binding('${module}') is deprecated.`\x2C\n          'DeprecationWarning'\x2C\n          'DEP0111');\n      }\n      if (legacyWrapperList.has(module)) {\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\n      }\n      return internalBinding(module);\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    throw new Error(`No such module: ${module}`);\n  };\n\n  process._linkedBinding = function _linkedBinding(module) {\n    module = String(module);\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object')\n      mod = bindingObj[module] = getLinkedBinding(module);\n    return mod;\n  };\n}\n\n// Set up internalBinding() in the closure.\n/**\n * @type {InternalBinding}\n */\nlet internalBinding;\n{\n  const bindingObj = ObjectCreate(null);\n  // eslint-disable-next-line no-global-assign\n  internalBinding = function internalBinding(module) {\n    let mod = bindingObj[module];\n    if (typeof mod !== 'object') {\n      mod = bindingObj[module] = getInternalBinding(module);\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\n    }\n    return mod;\n  };\n}\n\nconst loaderId = 'internal/bootstrap/loaders';\nconst {\n  moduleIds\x2C\n  compileFunction\n} = internalBinding('native_module');\n\nconst getOwn = (target\x2C property\x2C receiver) => {\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\n    ReflectGet(target\x2C property\x2C receiver) :\n    undefined;\n};\n\n/**\n * An internal abstraction for the built-in JavaScript modules of Node.js.\n * Be careful not to expose this to user land unless --expose-internals is\n * used\x2C in which case there is no compatibility guarantee about this class.\n */\nclass NativeModule {\n  /**\n   * A map from the module IDs to the module instances.\n   * @type {Map<string\x2C NativeModule>}\n   */\n  static map = new SafeMap(\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\n  );\n\n  constructor(id) {\n    this.filename = `${id}.js`;\n    this.id = id;\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\n\n    // The CJS exports object of the module.\n    this.exports = {};\n    // States used to work around circular dependencies.\n    this.loaded = false;\n    this.loading = false;\n\n    // The following properties are used by the ESM implementation and only\n    // initialized when the native module is loaded by users.\n    /**\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\n     * @type {ModuleWrap|undefined}\n     */\n    this.module = undefined;\n    /**\n     * Exported names for the ESM imports.\n     * @type {string[]|undefined}\n     */\n    this.exportKeys = undefined;\n  }\n\n  // To be called during pre-execution when --expose-internals is on.\n  // Enables the user-land module loader to access internal modules.\n  static exposeInternals() {\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\n      // Do not expose this to user land even with --expose-internals.\n      if (id !== loaderId) {\n        mod.canBeRequiredByUsers = true;\n      }\n    }\n  }\n\n  static exists(id) {\n    return NativeModule.map.has(id);\n  }\n\n  static canBeRequiredByUsers(id) {\n    const mod = NativeModule.map.get(id);\n    return mod && mod.canBeRequiredByUsers;\n  }\n\n  // Determine if a core module can be loaded without the node: prefix. This\n  // function does not validate if the module actually exists.\n  static canBeRequiredWithoutScheme(id) {\n    return !schemelessBlockList.has(id);\n  }\n\n  static getSchemeOnlyModuleNames() {\n    return ArrayFrom(schemelessBlockList);\n  }\n\n  // Used by user-land module loaders to compile and load builtins.\n  compileForPublicLoader() {\n    if (!this.canBeRequiredByUsers) {\n      // No code because this is an assertion against bugs\n      // eslint-disable-next-line no-restricted-syntax\n      throw new Error(`Should not compile ${this.id} for public use`);\n    }\n    this.compileForInternalLoader();\n    if (!this.exportKeys) {\n      // When using --expose-internals\x2C we do not want to reflect the named\n      // exports from core modules as this can trigger unnecessary getters.\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\n    }\n    this.getESMFacade();\n    this.syncExports();\n    return this.exports;\n  }\n\n  getESMFacade() {\n    if (this.module) return this.module;\n    const { ModuleWrap } = internalBinding('module_wrap');\n    const url = `node:${this.id}`;\n    const nativeModule = this;\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\n    ArrayPrototypePush(exportsKeys\x2C 'default');\n    this.module = new ModuleWrap(\n      url\x2C undefined\x2C exportsKeys\x2C\n      function() {\n        nativeModule.syncExports();\n        this.setExport('default'\x2C nativeModule.exports);\n      });\n    // Ensure immediate sync execution to capture exports now\n    this.module.instantiate();\n    this.module.evaluate(-1\x2C false);\n    return this.module;\n  }\n\n  // Provide named exports for all builtin libraries so that the libraries\n  // may be imported in a nicer way for ESM users. The default export is left\n  // as the entire namespace (module.exports) and updates when this function is\n  // called so that APMs and other behavior are supported.\n  syncExports() {\n    const names = this.exportKeys;\n    if (this.module) {\n      for (let i = 0; i < names.length; i++) {\n        const exportName = names[i];\n        if (exportName === 'default') continue;\n        this.module.setExport(exportName\x2C\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\n      }\n    }\n  }\n\n  compileForInternalLoader() {\n    if (this.loaded || this.loading) {\n      return this.exports;\n    }\n\n    const id = this.id;\n    this.loading = true;\n\n    try {\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\n        requireWithFallbackInDeps : nativeModuleRequire;\n\n      const fn = compileFunction(id);\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\n\n      this.loaded = true;\n    } finally {\n      this.loading = false;\n    }\n\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\n    return this.exports;\n  }\n}\n\n// Think of this as module.exports in this file even though it is not\n// written in CommonJS style.\nconst loaderExports = {\n  internalBinding\x2C\n  NativeModule\x2C\n  require: nativeModuleRequire\n};\n\nfunction nativeModuleRequire(id) {\n  if (id === loaderId) {\n    return loaderExports;\n  }\n\n  const mod = NativeModule.map.get(id);\n  // Can't load the internal errors module from here\x2C have to use a raw error.\n  // eslint-disable-next-line no-restricted-syntax\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\n  return mod.compileForInternalLoader();\n}\n\n// Allow internal modules from dependencies to require\n// other modules from dependencies by providing fallbacks.\nfunction requireWithFallbackInDeps(request) {\n  if (!NativeModule.map.has(request)) {\n    request = `internal/deps/${request}`;\n  }\n  return nativeModuleRequire(request);\n}\n\n// Pass the exports back to C++ land for C++ internals to use.\nreturn loaderExports;\n
tick,0x7ff805ede915,49232,0,0x0,3,0x102d5e910,0xb46f7dee5eb
code-source-info,0xb46f7dee830,15,10778,11121,C0O10787C2O10798C4O10794C9O10814C13O10835C14O10855C19O10868C24O10872C29O10872C35O11013C37O11023C47O11071C60O11029C65O11023C66O11092C71O11092C75O11119,,
tick,0x1028443a0,49576,0,0x0,3,0x102d5e910,0xb46f7dee5eb
code-creation,LazyCompile,10,49996,0xb46f7def5c0,175,compileForInternalLoader node:internal/bootstrap/loaders:316:27,0xb466514b810,~
code-source-info,0xb46f7def5c0,15,9991,10552,C0O10009C6O10024C12O10053C16O10061C17O10089C22O10097C23O10110C30O10153C37O10184C45O10153C63O10283C70O10283C75O10318C89O10353C103O10310C108O10391C109O10403C124O10433C126O10446C141O10466C152O10485C160O10517C165O10466C170O10540C174O10548,,
code-creation,Eval,10,50441,0xb46f7df0610,5, node:internal/bootstrap/pre_execution:1:1,0xb46f7df01e8,~
script-source,389,node:internal/bootstrap/pre_execution,'use strict';\n\nconst {\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeStartsWith\x2C\n  globalThis\x2C\n} = primordials;\n\nconst {\n  getOptionValue\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\x2C\n} = require('internal/options');\nconst { reconnectZeroFillToggle } = require('internal/buffer');\nconst {\n  defineOperation\x2C\n  emitExperimentalWarning\x2C\n  exposeInterface\x2C\n} = require('internal/util');\n\nconst {\n  ERR_MANIFEST_ASSERT_INTEGRITY\x2C\n} = require('internal/errors').codes;\nconst assert = require('internal/assert');\n\nfunction prepareMainThreadExecution(expandArgv1 = false\x2C\n                                    initialzeModules = true) {\n  refreshRuntimeOptions();\n\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\n  // this toggle from the snapshot.\n  reconnectZeroFillToggle();\n\n  // Patch the process object with legacy properties and normalizations\n  patchProcessObject(expandArgv1);\n  setupTraceCategoryState();\n  setupPerfHooks();\n  setupInspectorHooks();\n  setupWarningHandler();\n  setupFetch();\n  setupWebCrypto();\n  setupCustomEvent();\n\n  // Resolve the coverage directory to an absolute path\x2C and\n  // overwrite process.env so that the original path gets passed\n  // to child processes even when they switch cwd.\n  if (process.env.NODE_V8_COVERAGE) {\n    process.env.NODE_V8_COVERAGE =\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\n  }\n\n  setupDebugEnv();\n\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\n  setupStacktracePrinterOnSigint();\n\n  // Process initial diagnostic reporting configuration\x2C if present.\n  initializeReport();\n  initializeReportSignalHandlers();  // Main-thread-only.\n\n  initializeHeapSnapshotSignalHandlers();\n\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\n  // spawned by our child_process module\x2C then initialize IPC.\n  // This attaches some internal event listeners and creates:\n  // process.send()\x2C process.channel\x2C process.connected\x2C\n  // process.disconnect().\n  setupChildProcessIpcChannel();\n\n  // Load policy from disk and parse it.\n  initializePolicy();\n\n  // If this is a worker in cluster mode\x2C start up the communication\n  // channel. This needs to be done before any user code gets executed\n  // (including preload modules).\n  initializeClusterIPC();\n\n  initializeSourceMapsHandlers();\n  initializeDeprecations();\n  initializeWASI();\n\n  require('internal/v8/startup_snapshot').runDeserializeCallbacks();\n\n  if (!initialzeModules) {\n    return;\n  }\n\n  initializeCJSLoader();\n  initializeESMLoader();\n  const CJSLoader = require('internal/modules/cjs/loader');\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\n  loadPreloadModules();\n  initializeFrozenIntrinsics();\n}\n\nfunction refreshRuntimeOptions() {\n  refreshOptions();\n}\n\nfunction patchProcessObject(expandArgv1) {\n  const binding = internalBinding('process_methods');\n  binding.patchProcessObject(process);\n\n  require('internal/process/per_thread').refreshHrtimeBuffer();\n\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    // Only set it to true during snapshot building.\n    configurable: getOptionValue('--build-snapshot')\x2C\n    value: process.argv[0]\n  });\n\n  process.exitCode = undefined;\n  process._exiting = false;\n  process.argv[0] = process.execPath;\n\n  if (expandArgv1 && process.argv[1] &&\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\n    // Expand process.argv[1] into a full path.\n    const path = require('path');\n    try {\n      process.argv[1] = path.resolve(process.argv[1]);\n    } catch {\n      // Continue regardless of error.\n    }\n  }\n\n  // We need to initialize the global console here again with process.stdout\n  // and friends for snapshot deserialization.\n  const globalConsole = require('internal/console/global');\n  const { initializeGlobalConsole } = require('internal/console/constructor');\n  initializeGlobalConsole(globalConsole);\n\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\n  // except some that we need to be able to mutate during run time.\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\n}\n\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\n  const value = getOptionValue(option);\n  if (value) {\n    ObjectDefineProperty(process\x2C name\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      configurable: true\x2C\n      enumerable\x2C\n      value\n    });\n  }\n}\n\nfunction setupWarningHandler() {\n  const {\n    onWarning\n  } = require('internal/process/warning');\n  if (getOptionValue('--warnings') &&\n    process.env.NODE_NO_WARNINGS !== '1') {\n    process.on('warning'\x2C onWarning);\n  }\n}\n\n// https://fetch.spec.whatwg.org/\nfunction setupFetch() {\n  if (process.config.variables.node_no_browser_globals ||\n      getOptionValue('--no-experimental-fetch')) {\n    return;\n  }\n\n  let undici;\n  function lazyUndici() {\n    if (undici) {\n      return undici;\n    }\n\n    undici = require('internal/deps/undici/undici');\n    return undici;\n  }\n\n  async function fetch(input\x2C init = undefined) {\n    emitExperimentalWarning('The Fetch API');\n    return lazyUndici().fetch(input\x2C init);\n  }\n\n  defineOperation(globalThis\x2C 'fetch'\x2C fetch);\n\n  function lazyInterface(name) {\n    return {\n      configurable: true\x2C\n      enumerable: false\x2C\n      get() {\n        return lazyUndici()[name];\n      }\x2C\n      set(value) {\n        exposeInterface(globalThis\x2C name\x2C value);\n      }\n    };\n  }\n\n  ObjectDefineProperties(globalThis\x2C {\n    FormData: lazyInterface('FormData')\x2C\n    Headers: lazyInterface('Headers')\x2C\n    Request: lazyInterface('Request')\x2C\n    Response: lazyInterface('Response')\x2C\n  });\n\n  // The WebAssembly Web API: https://webassembly.github.io/spec/web-api\n  const { wasmStreamingCallback } = require('internal/wasm_web_api');\n  internalBinding('wasm_web_api').setImplementation(wasmStreamingCallback);\n}\n\n// TODO(aduh95): move this to internal/bootstrap/browser when the CLI flag is\n//               removed.\nfunction setupWebCrypto() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-webcrypto')) {\n    return;\n  }\n\n  let webcrypto;\n  ObjectDefineProperty(globalThis\x2C 'crypto'\x2C\n                       { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor({\n                         get crypto() {\n                           webcrypto ??= require('internal/crypto/webcrypto');\n                           return webcrypto.crypto;\n                         }\n                       }\x2C 'crypto') });\n  if (internalBinding('config').hasOpenSSL) {\n    webcrypto ??= require('internal/crypto/webcrypto');\n    exposeInterface(globalThis\x2C 'Crypto'\x2C webcrypto.Crypto);\n    exposeInterface(globalThis\x2C 'CryptoKey'\x2C webcrypto.CryptoKey);\n    exposeInterface(globalThis\x2C 'SubtleCrypto'\x2C webcrypto.SubtleCrypto);\n  }\n}\n\n// TODO(daeyeon): move this to internal/bootstrap/browser when the CLI flag is\n//                removed.\nfunction setupCustomEvent() {\n  if (process.config.variables.node_no_browser_globals ||\n      !getOptionValue('--experimental-global-customevent')) {\n    return;\n  }\n  const { CustomEvent } = require('internal/event_target');\n  exposeInterface(globalThis\x2C 'CustomEvent'\x2C CustomEvent);\n}\n\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\n// ScriptCoverage to a specified file.\nfunction setupCoverageHooks(dir) {\n  const cwd = require('internal/process/execution').tryGetCwd();\n  const { resolve } = require('path');\n  const coverageDirectory = resolve(cwd\x2C dir);\n  const { sourceMapCacheToObject } =\n    require('internal/source_map/source_map_cache');\n\n  if (process.features.inspector) {\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\n  } else {\n    process.emitWarning('The inspector is disabled\x2C ' +\n                        'coverage could not be collected'\x2C\n                        'Warning');\n    return '';\n  }\n  return coverageDirectory;\n}\n\nfunction setupStacktracePrinterOnSigint() {\n  if (!getOptionValue('--trace-sigint')) {\n    return;\n  }\n  const { SigintWatchdog } = require('internal/watchdog');\n\n  const watchdog = new SigintWatchdog();\n  watchdog.start();\n}\n\nfunction initializeReport() {\n  const { report } = require('internal/process/report');\n  ObjectDefineProperty(process\x2C 'report'\x2C {\n    __proto__: null\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    get() {\n      return report;\n    }\n  });\n}\n\nfunction setupDebugEnv() {\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\n  if (getOptionValue('--expose-internals')) {\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\n  }\n}\n\n// This has to be called after initializeReport() is called\nfunction initializeReportSignalHandlers() {\n  const { addSignalHandler } = require('internal/process/report');\n\n  addSignalHandler();\n}\n\nfunction initializeHeapSnapshotSignalHandlers() {\n  const signal = getOptionValue('--heapsnapshot-signal');\n\n  if (!signal)\n    return;\n\n  require('internal/validators').validateSignalName(signal);\n  const { writeHeapSnapshot } = require('v8');\n\n  process.on(signal\x2C () => {\n    writeHeapSnapshot();\n  });\n}\n\nfunction setupTraceCategoryState() {\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\n}\n\nfunction setupPerfHooks() {\n  require('internal/perf/performance').refreshTimeOrigin();\n  require('internal/perf/utils').refreshTimeOrigin();\n}\n\nfunction setupInspectorHooks() {\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\n  // we cannot immediately call into JS to enable the hooks\x2C which could\n  // interrupt the JS execution of bootstrap. So instead we save the\n  // notification in the inspector agent if it's sent in the middle of\n  // bootstrap\x2C and process the notification later here.\n  if (internalBinding('config').hasInspector) {\n    const {\n      enable\x2C\n      disable\n    } = require('internal/inspector_async_hook');\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\n  }\n}\n\n// In general deprecations are initialized wherever the APIs are implemented\x2C\n// this is used to deprecate APIs implemented in C++ where the deprecation\n// utilities are not easily accessible.\nfunction initializeDeprecations() {\n  const { deprecate } = require('internal/util');\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\n\n  // DEP0103: access to `process.binding('util').isX` type checkers\n  // TODO(addaleax): Turn into a full runtime deprecation.\n  const utilBinding = internalBinding('util');\n  const types = require('internal/util/types');\n  for (const name of [\n    'isArrayBuffer'\x2C\n    'isArrayBufferView'\x2C\n    'isAsyncFunction'\x2C\n    'isDataView'\x2C\n    'isDate'\x2C\n    'isExternal'\x2C\n    'isMap'\x2C\n    'isMapIterator'\x2C\n    'isNativeError'\x2C\n    'isPromise'\x2C\n    'isRegExp'\x2C\n    'isSet'\x2C\n    'isSetIterator'\x2C\n    'isTypedArray'\x2C\n    'isUint8Array'\x2C\n    'isAnyArrayBuffer'\x2C\n  ]) {\n    utilBinding[name] = pendingDeprecation ?\n      deprecate(types[name]\x2C\n                'Accessing native typechecking bindings of Node ' +\n                'directly is deprecated. ' +\n                `Please use \\`util.types.${name}\\` instead.`\x2C\n                'DEP0103') :\n      types[name];\n  }\n\n  // TODO(joyeecheung): this is a legacy property exposed to process.\n  // Now that we use the config binding to carry this information\x2C remove\n  // it from the process. We may consider exposing it properly in\n  // process.features.\n  const { noBrowserGlobals } = internalBinding('config');\n  if (noBrowserGlobals) {\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: noBrowserGlobals\n    });\n  }\n\n  if (pendingDeprecation) {\n    process.binding = deprecate(process.binding\x2C\n                                'process.binding() is deprecated. ' +\n                                'Please use public APIs instead.'\x2C 'DEP0111');\n\n    process._tickCallback = deprecate(process._tickCallback\x2C\n                                      'process._tickCallback() is deprecated'\x2C\n                                      'DEP0134');\n  }\n}\n\nfunction setupChildProcessIpcChannel() {\n  if (process.env.NODE_CHANNEL_FD) {\n    const assert = require('internal/assert');\n\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\n    assert(fd >= 0);\n\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_CHANNEL_FD;\n\n    const serializationMode =\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\n\n    require('child_process')._forkChild(fd\x2C serializationMode);\n    assert(process.send);\n  }\n}\n\nfunction initializeClusterIPC() {\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\n    const cluster = require('cluster');\n    cluster._setupWorker();\n    // Make sure it's not accidentally inherited by child processes.\n    delete process.env.NODE_UNIQUE_ID;\n  }\n}\n\nfunction initializePolicy() {\n  const experimentalPolicy = getOptionValue('--experimental-policy');\n  if (experimentalPolicy) {\n    process.emitWarning('Policies are experimental.'\x2C\n                        'ExperimentalWarning');\n    const { pathToFileURL\x2C URL } = require('internal/url');\n    // URL here as it is slightly different parsing\n    // no bare specifiers for now\n    let manifestURL;\n    if (require('path').isAbsolute(experimentalPolicy)) {\n      manifestURL = new URL(`file://${experimentalPolicy}`);\n    } else {\n      const cwdURL = pathToFileURL(process.cwd());\n      cwdURL.pathname += '/';\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\n    }\n    const fs = require('fs');\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\n    if (experimentalPolicyIntegrity) {\n      const SRI = require('internal/policy/sri');\n      const { createHash\x2C timingSafeEqual } = require('crypto');\n      const realIntegrities = new SafeMap();\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\n      let foundMatch = false;\n      for (let i = 0; i < integrityEntries.length; i++) {\n        const {\n          algorithm\x2C\n          value: expected\n        } = integrityEntries[i];\n        const hash = createHash(algorithm);\n        hash.update(src);\n        const digest = hash.digest();\n        if (digest.length === expected.length &&\n          timingSafeEqual(digest\x2C expected)) {\n          foundMatch = true;\n          break;\n        }\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\n      }\n      if (!foundMatch) {\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\n      }\n    }\n    require('internal/process/policy')\n      .setup(src\x2C manifestURL.href);\n  }\n}\n\nfunction initializeWASI() {\n  const { NativeModule } = require('internal/bootstrap/loaders');\n  const mod = NativeModule.map.get('wasi');\n  mod.canBeRequiredByUsers =\n    getOptionValue('--experimental-wasi-unstable-preview1');\n}\n\nfunction initializeCJSLoader() {\n  const CJSLoader = require('internal/modules/cjs/loader');\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\n    CJSLoader.Module._initPaths();\n  }\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\n  CJSLoader.Module.runMain =\n    require('internal/modules/run_main').executeUserEntryPoint;\n}\n\nfunction initializeESMLoader() {\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\n\n  if (getEmbedderOptions().shouldNotRegisterESMLoader) return;\n\n  const {\n    setImportModuleDynamicallyCallback\x2C\n    setInitializeImportMetaObjectCallback\n  } = internalBinding('module_wrap');\n  const esm = require('internal/process/esm_loader');\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\n  // track of for different ESM modules.\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\n\n  // Patch the vm module when --experimental-vm-modules is on.\n  // Please update the comments in vm.js when this block changes.\n  if (getOptionValue('--experimental-vm-modules')) {\n    const {\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\n    } = require('internal/vm/module');\n    const vm = require('vm');\n    vm.Module = Module;\n    vm.SourceTextModule = SourceTextModule;\n    vm.SyntheticModule = SyntheticModule;\n  }\n}\n\nfunction initializeSourceMapsHandlers() {\n  const { setSourceMapsEnabled } =\n    require('internal/source_map/source_map_cache');\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\n}\n\nfunction initializeFrozenIntrinsics() {\n  if (getOptionValue('--frozen-intrinsics')) {\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\n                        'ExperimentalWarning');\n    require('internal/freeze_intrinsics')();\n  }\n}\n\nfunction loadPreloadModules() {\n  // For user code\x2C we preload modules if `-r` is passed\n  const preloadModules = getOptionValue('--require');\n  if (preloadModules && preloadModules.length > 0) {\n    const {\n      Module: {\n        _preloadModules\n      }\x2C\n    } = require('internal/modules/cjs/loader');\n    _preloadModules(preloadModules);\n  }\n}\n\nmodule.exports = {\n  refreshRuntimeOptions\x2C\n  patchProcessObject\x2C\n  setupCoverageHooks\x2C\n  setupWarningHandler\x2C\n  setupFetch\x2C\n  setupWebCrypto\x2C\n  setupCustomEvent\x2C\n  setupDebugEnv\x2C\n  setupPerfHooks\x2C\n  prepareMainThreadExecution\x2C\n  initializeDeprecations\x2C\n  initializeESMLoader\x2C\n  initializeFrozenIntrinsics\x2C\n  initializeSourceMapsHandlers\x2C\n  loadPreloadModules\x2C\n  setupTraceCategoryState\x2C\n  setupInspectorHooks\x2C\n  initializeReport\x2C\n  initializeCJSLoader\x2C\n  initializeWASI\n};\n
code-source-info,0xb46f7df0610,389,0,18793,C0O0C4O18793,,
tick,0x7ff805e2d43e,52674,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0xb46f7dee877,0xb46f7dee5eb
tick,0x7ff805ea4dea,52685,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0xb46f7dee877,0xb46f7dee5eb
code-creation,Function,10,52693,0xb46f7df1340,519, node:internal/bootstrap/pre_execution:1:1,0xb46f7df0588,~
code-source-info,0xb46f7df1340,389,0,18793,C0O0C229O25C235O43C241O69C247O93C253O127C259O138C265O153C271O182C277O282C283O282C288O222C294O240C300O262C306O347C312O347C317O319C323O452C329O452C334O385C340O404C346O431C352O524C358O524C363O550C368O489C374O573C380O573C384O573C386O18319C393O18340C399O18365C405O18387C411O18409C417O18432C423O18446C429O18464C435O18484C441O18501C447O18519C453O18549C459O18575C465O18598C471O18628C477O18660C483O18682C489O18709C495O18732C501O18752C507O18775C513O18334C518O18792,,
tick,0x10266c112,53361,1,0x10266e4e0,6,0x1027fed10,0xb46f7def606,0xb46f7dee877,0xb46f7dee5eb
code-creation,LazyCompile,10,53733,0xb46f7df2e00,273,prepareMainThreadExecution node:internal/bootstrap/pre_execution:31:36,0xb46f7df0640,~
code-source-info,0xb46f7df2e00,389,637,2786,C20O724C23O724C26O869C31O869C34O971C37O971C41O1006C44O1006C47O1035C50O1035C53O1055C56O1055C59O1080C62O1080C65O1105C68O1105C71O1121C74O1121C77O1141C80O1141C83O1341C86O1353C91O1357C97O1381C100O1389C111O1445C116O1449C121O1418C125O1410C129O1475C132O1475C135O1567C138O1567C141O1673C144O1673C147O1695C150O1695C153O1754C156O1754C159O2077C162O2077C165O2152C168O2152C171O2349C174O2349C177O2376C180O2376C183O2410C186O2410C189O2438C192O2438C195O2459C201O2459C206O2498C211O2499C215O2529C219O2558C220O2565C221O2573C224O2573C227O2598C230O2598C233O2641C239O2641C244O2683C249O2701C255O2683C259O2731C262O2731C265O2755C268O2755C272O2785,,
code-creation,LazyCompile,10,53819,0xb46f7df4368,10,refreshRuntimeOptions node:internal/bootstrap/pre_execution:101:31,0xb46f7df0690,~
code-source-info,0xb46f7df4368,389,2818,2844,C0O2825C5O2825C9O2843,,
code-creation,LazyCompile,10,53859,0xb46f7df4458,22,refreshOptions node:internal/options:39:24,0xb46806bdc28,~
script-source,88,node:internal/options,'use strict';\n\nconst {\n  getCLIOptions\x2C\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\n} = internalBinding('options');\n\nlet warnOnAllowUnauthorized = true;\n\nlet optionsMap;\nlet aliasesMap;\nlet embedderOptions;\n\n// getCLIOptions() would serialize the option values from C++ land.\n// It would error if the values are queried before bootstrap is\n// complete so that we don't accidentally include runtime-dependent\n// states into a runtime-independent snapshot.\nfunction getCLIOptionsFromBinding() {\n  if (!optionsMap) {\n    ({ options: optionsMap } = getCLIOptions());\n  }\n  return optionsMap;\n}\n\nfunction getAliasesFromBinding() {\n  if (!aliasesMap) {\n    ({ aliases: aliasesMap } = getCLIOptions());\n  }\n  return aliasesMap;\n}\n\nfunction getEmbedderOptions() {\n  if (!embedderOptions) {\n    embedderOptions = getEmbedderOptionsFromBinding();\n  }\n  return embedderOptions;\n}\n\nfunction refreshOptions() {\n  optionsMap = undefined;\n  aliasesMap = undefined;\n}\n\nfunction getOptionValue(optionName) {\n  const options = getCLIOptionsFromBinding();\n  if (optionName.startsWith('--no-')) {\n    const option = options.get('--' + optionName.slice(5));\n    return option && !option.value;\n  }\n  return options.get(optionName)?.value;\n}\n\nfunction getAllowUnauthorized() {\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\n\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\n    warnOnAllowUnauthorized = false;\n    process.emitWarning(\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\n      'environment variable to \\'0\\' makes TLS connections ' +\n      'and HTTPS requests insecure by disabling ' +\n      'certificate verification.');\n  }\n  return allowUnauthorized;\n}\n\nmodule.exports = {\n  get options() {\n    return getCLIOptionsFromBinding();\n  }\x2C\n  get aliases() {\n    return getAliasesFromBinding();\n  }\x2C\n  getOptionValue\x2C\n  getAllowUnauthorized\x2C\n  getEmbedderOptions\x2C\n  refreshOptions\n};\n
code-source-info,0xb46f7df4458,88,902,960,C0O909C4O920C10O935C14O946C21O959,,
code-creation,LazyCompile,10,54153,0xb46f7df47c0,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0xb469fcfb7d0,~
script-source,31,node:internal/buffer,'use strict';\n\nconst {\n  BigInt\x2C\n  Float32Array\x2C\n  Float64Array\x2C\n  MathFloor\x2C\n  Number\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst { validateNumber } = require('internal/validators');\nconst {\n  asciiSlice\x2C\n  base64Slice\x2C\n  base64urlSlice\x2C\n  latin1Slice\x2C\n  hexSlice\x2C\n  ucs2Slice\x2C\n  utf8Slice\x2C\n  asciiWrite\x2C\n  base64Write\x2C\n  base64urlWrite\x2C\n  latin1Write\x2C\n  hexWrite\x2C\n  ucs2Write\x2C\n  utf8Write\x2C\n  getZeroFillToggle\n} = internalBinding('buffer');\nconst {\n  untransferable_object_private_symbol\x2C\n  setHiddenValue\x2C\n} = internalBinding('util');\n\n// Temporary buffers to convert numbers.\nconst float32Array = new Float32Array(1);\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\nconst float64Array = new Float64Array(1);\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\n\n// Check endianness.\nfloat32Array[0] = -1; // 0xBF800000\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\n// check this with `os.endianness()` because that is determined at compile time.\nconst bigEndian = uInt8Float32Array[3] === 0;\n\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\n  validateNumber(offset\x2C 'offset');\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\n    boundsError(offset\x2C buf.length - (byteLength + 1));\n}\n\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : '';\n    let range;\n    if (byteLength > 3) {\n      if (min === 0 || min === 0n) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`;\n    }\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\n  }\n  checkBounds(buf\x2C offset\x2C byteLength);\n}\n\nfunction boundsError(value\x2C length\x2C type) {\n  if (MathFloor(value) !== value) {\n    validateNumber(value\x2C type);\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\n  }\n\n  if (length < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\n                             value);\n}\n\n// Read integers.\nfunction readBigUInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24;\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n\n  return BigInt(lo) + (BigInt(hi) << 32n);\n}\n\nfunction readBigUInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n\n  return (BigInt(hi) << 32n) + BigInt(lo);\n}\n\nfunction readBigInt64LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24); // Overflow\n  return (BigInt(val) << 32n) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24);\n}\n\nfunction readBigInt64BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset];\n  return (BigInt(val) << 32n) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last);\n}\n\nfunction readUIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32LE(offset);\n  if (byteLength === 2)\n    return this.readUInt16LE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\n}\n\nfunction readUInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24 +\n    last * 2 ** 32;\n}\n\nfunction readUInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24;\n}\n\nfunction readUInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n}\n\nfunction readUInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first + last * 2 ** 8;\n}\n\nfunction readUInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val;\n}\n\nfunction readUIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readUInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readUInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readUInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readUInt32BE(offset);\n  if (byteLength === 2)\n    return this.readUInt16BE(offset);\n  if (byteLength === 1)\n    return this.readUInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readUInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return first * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readUInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n}\n\nfunction readUInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  return first * 2 ** 8 + last;\n}\n\nfunction readIntLE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48LE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40LE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24LE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32LE(offset);\n  if (byteLength === 2)\n    return this.readInt16LE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[offset + 4] + last * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt40LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    first +\n    buf[++offset] * 2 ** 8 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 24;\n}\n\nfunction readInt32LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    (last << 24); // Overflow\n}\n\nfunction readInt24LE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16LE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first + last * 2 ** 8;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\nfunction readInt8(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const val = this[offset];\n  if (val === undefined)\n    boundsError(offset\x2C this.length - 1);\n\n  return val | (val & 2 ** 7) * 0x1fffffe;\n}\n\nfunction readIntBE(offset\x2C byteLength) {\n  if (offset === undefined)\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\n  if (byteLength === 6)\n    return readInt48BE(this\x2C offset);\n  if (byteLength === 5)\n    return readInt40BE(this\x2C offset);\n  if (byteLength === 3)\n    return readInt24BE(this\x2C offset);\n  if (byteLength === 4)\n    return this.readInt32BE(offset);\n  if (byteLength === 2)\n    return this.readInt16BE(offset);\n  if (byteLength === 1)\n    return this.readInt8(offset);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction readInt48BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 5];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 6);\n\n  const val = buf[++offset] + first * 2 ** 8;\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt40BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 4];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 5);\n\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\n    buf[++offset] * 2 ** 24 +\n    buf[++offset] * 2 ** 16 +\n    buf[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt32BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  return (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last;\n}\n\nfunction readInt24BE(buf\x2C offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = buf[offset];\n  const last = buf[offset + 2];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C buf.length - 3);\n\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\n  return val | (val & 2 ** 23) * 0x1fe;\n}\n\nfunction readInt16BE(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 1];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 2);\n\n  const val = first * 2 ** 8 + last;\n  return val | (val & 2 ** 15) * 0x1fffe;\n}\n\n// Read floats\nfunction readFloatBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[3] = first;\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[0] = last;\n  return float32Array[0];\n}\n\nfunction readFloatForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 3];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 4);\n\n  uInt8Float32Array[0] = first;\n  uInt8Float32Array[1] = this[++offset];\n  uInt8Float32Array[2] = this[++offset];\n  uInt8Float32Array[3] = last;\n  return float32Array[0];\n}\n\nfunction readDoubleBackwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[7] = first;\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[0] = last;\n  return float64Array[0];\n}\n\nfunction readDoubleForwards(offset = 0) {\n  validateNumber(offset\x2C 'offset');\n  const first = this[offset];\n  const last = this[offset + 7];\n  if (first === undefined || last === undefined)\n    boundsError(offset\x2C this.length - 8);\n\n  uInt8Float64Array[0] = first;\n  uInt8Float64Array[1] = this[++offset];\n  uInt8Float64Array[2] = this[++offset];\n  uInt8Float64Array[3] = this[++offset];\n  uInt8Float64Array[4] = this[++offset];\n  uInt8Float64Array[5] = this[++offset];\n  uInt8Float64Array[6] = this[++offset];\n  uInt8Float64Array[7] = last;\n  return float64Array[0];\n}\n\n// Write integers.\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  lo = lo >> 8;\n  buf[offset++] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  hi = hi >> 8;\n  buf[offset++] = hi;\n  return offset;\n}\n\nfunction writeBigUInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\n\n  let lo = Number(value & 0xffffffffn);\n  buf[offset + 7] = lo;\n  lo = lo >> 8;\n  buf[offset + 6] = lo;\n  lo = lo >> 8;\n  buf[offset + 5] = lo;\n  lo = lo >> 8;\n  buf[offset + 4] = lo;\n  let hi = Number(value >> 32n & 0xffffffffn);\n  buf[offset + 3] = hi;\n  hi = hi >> 8;\n  buf[offset + 2] = hi;\n  hi = hi >> 8;\n  buf[offset + 1] = hi;\n  hi = hi >> 8;\n  buf[offset] = hi;\n  return offset + 8;\n}\n\nfunction writeBigUInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\n}\n\nfunction writeBigInt64LE(value\x2C offset = 0) {\n  return writeBigU_Int64LE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeBigInt64BE(value\x2C offset = 0) {\n  return writeBigU_Int64BE(\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\n}\n\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = newVal;\n  buf[offset++] = (newVal >>> 8);\n  return offset;\n}\n\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  const newVal = value;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\n  return offset;\n}\n\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  value = value >>> 8;\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = value;\n  buf[offset++] = (value >>> 8);\n  return offset;\n}\n\nfunction writeUInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  // `checkInt()` can not be used here because it checks two entries.\n  validateNumber(offset\x2C 'offset');\n  if (value > max || value < min) {\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\n  }\n  if (buf[offset] === undefined)\n    boundsError(offset\x2C buf.length - 1);\n\n  buf[offset] = value;\n  return offset + 1;\n}\n\nfunction writeUInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n}\n\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\n\n  const newVal = MathFloor(value * 2 ** -32);\n  buf[offset++] = (newVal >>> 8);\n  buf[offset++] = newVal;\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\n\n  buf[offset++] = MathFloor(value * 2 ** -32);\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\n\n  buf[offset + 3] = value;\n  value = value >>> 8;\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 4;\n}\n\nfunction writeUInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\n}\n\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\n\n  buf[offset + 2] = value;\n  value = value >>> 8;\n  buf[offset + 1] = value;\n  value = value >>> 8;\n  buf[offset] = value;\n  return offset + 3;\n}\n\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\n  value = +value;\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\n\n  buf[offset++] = (value >>> 8);\n  buf[offset++] = value;\n  return offset;\n}\n\nfunction writeUInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\n}\n\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32LE(value\x2C offset = 0) {\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16LE(value\x2C offset = 0) {\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\nfunction writeInt8(value\x2C offset = 0) {\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n}\n\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\n  if (byteLength === 6)\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\n  if (byteLength === 5)\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\n  if (byteLength === 3)\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\n  if (byteLength === 4)\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n  if (byteLength === 2)\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n  if (byteLength === 1)\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\n\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\n}\n\nfunction writeInt32BE(value\x2C offset = 0) {\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\n}\n\nfunction writeInt16BE(value\x2C offset = 0) {\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\n}\n\n// Write floats.\nfunction writeDoubleForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[0];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[7];\n  return offset;\n}\n\nfunction writeDoubleBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 7);\n\n  float64Array[0] = val;\n  this[offset++] = uInt8Float64Array[7];\n  this[offset++] = uInt8Float64Array[6];\n  this[offset++] = uInt8Float64Array[5];\n  this[offset++] = uInt8Float64Array[4];\n  this[offset++] = uInt8Float64Array[3];\n  this[offset++] = uInt8Float64Array[2];\n  this[offset++] = uInt8Float64Array[1];\n  this[offset++] = uInt8Float64Array[0];\n  return offset;\n}\n\nfunction writeFloatForwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[0];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[3];\n  return offset;\n}\n\nfunction writeFloatBackwards(val\x2C offset = 0) {\n  val = +val;\n  checkBounds(this\x2C offset\x2C 3);\n\n  float32Array[0] = val;\n  this[offset++] = uInt8Float32Array[3];\n  this[offset++] = uInt8Float32Array[2];\n  this[offset++] = uInt8Float32Array[1];\n  this[offset++] = uInt8Float32Array[0];\n  return offset;\n}\n\nclass FastBuffer extends Uint8Array {\n  // Using an explicit constructor here is necessary to avoid relying on\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\n  // eslint-disable-next-line no-useless-constructor\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\n    super(bufferOrLength\x2C byteOffset\x2C length);\n  }\n}\n\nfunction addBufferPrototypeMethods(proto) {\n  proto.readBigUInt64LE = readBigUInt64LE;\n  proto.readBigUInt64BE = readBigUInt64BE;\n  proto.readBigUint64LE = readBigUInt64LE;\n  proto.readBigUint64BE = readBigUInt64BE;\n  proto.readBigInt64LE = readBigInt64LE;\n  proto.readBigInt64BE = readBigInt64BE;\n  proto.writeBigUInt64LE = writeBigUInt64LE;\n  proto.writeBigUInt64BE = writeBigUInt64BE;\n  proto.writeBigUint64LE = writeBigUInt64LE;\n  proto.writeBigUint64BE = writeBigUInt64BE;\n  proto.writeBigInt64LE = writeBigInt64LE;\n  proto.writeBigInt64BE = writeBigInt64BE;\n\n  proto.readUIntLE = readUIntLE;\n  proto.readUInt32LE = readUInt32LE;\n  proto.readUInt16LE = readUInt16LE;\n  proto.readUInt8 = readUInt8;\n  proto.readUIntBE = readUIntBE;\n  proto.readUInt32BE = readUInt32BE;\n  proto.readUInt16BE = readUInt16BE;\n  proto.readUintLE = readUIntLE;\n  proto.readUint32LE = readUInt32LE;\n  proto.readUint16LE = readUInt16LE;\n  proto.readUint8 = readUInt8;\n  proto.readUintBE = readUIntBE;\n  proto.readUint32BE = readUInt32BE;\n  proto.readUint16BE = readUInt16BE;\n  proto.readIntLE = readIntLE;\n  proto.readInt32LE = readInt32LE;\n  proto.readInt16LE = readInt16LE;\n  proto.readInt8 = readInt8;\n  proto.readIntBE = readIntBE;\n  proto.readInt32BE = readInt32BE;\n  proto.readInt16BE = readInt16BE;\n\n  proto.writeUIntLE = writeUIntLE;\n  proto.writeUInt32LE = writeUInt32LE;\n  proto.writeUInt16LE = writeUInt16LE;\n  proto.writeUInt8 = writeUInt8;\n  proto.writeUIntBE = writeUIntBE;\n  proto.writeUInt32BE = writeUInt32BE;\n  proto.writeUInt16BE = writeUInt16BE;\n  proto.writeUintLE = writeUIntLE;\n  proto.writeUint32LE = writeUInt32LE;\n  proto.writeUint16LE = writeUInt16LE;\n  proto.writeUint8 = writeUInt8;\n  proto.writeUintBE = writeUIntBE;\n  proto.writeUint32BE = writeUInt32BE;\n  proto.writeUint16BE = writeUInt16BE;\n  proto.writeIntLE = writeIntLE;\n  proto.writeInt32LE = writeInt32LE;\n  proto.writeInt16LE = writeInt16LE;\n  proto.writeInt8 = writeInt8;\n  proto.writeIntBE = writeIntBE;\n  proto.writeInt32BE = writeInt32BE;\n  proto.writeInt16BE = writeInt16BE;\n\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\n\n  proto.asciiSlice = asciiSlice;\n  proto.base64Slice = base64Slice;\n  proto.base64urlSlice = base64urlSlice;\n  proto.latin1Slice = latin1Slice;\n  proto.hexSlice = hexSlice;\n  proto.ucs2Slice = ucs2Slice;\n  proto.utf8Slice = utf8Slice;\n  proto.asciiWrite = asciiWrite;\n  proto.base64Write = base64Write;\n  proto.base64urlWrite = base64urlWrite;\n  proto.latin1Write = latin1Write;\n  proto.hexWrite = hexWrite;\n  proto.ucs2Write = ucs2Write;\n  proto.utf8Write = utf8Write;\n}\n\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\n// because Buffer needs this and that would introduce a cyclic dependency.\nfunction markAsUntransferable(obj) {\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\n    return;  // This object is a primitive and therefore already untransferable.\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\n}\n\n// A toggle used to access the zero fill setting of the array buffer allocator\n// in C++.\n// |zeroFill| can be undefined when running inside an isolate where we\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\nlet zeroFill = getZeroFillToggle();\nfunction createUnsafeBuffer(size) {\n  zeroFill[0] = 0;\n  try {\n    return new FastBuffer(size);\n  } finally {\n    zeroFill[0] = 1;\n  }\n}\n\n// The connection between the JS land zero fill toggle and the\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\n// is deserialized from the snapshot\x2C because V8 owns the underlying\n// memory of this toggle. This resets the connection.\nfunction reconnectZeroFillToggle() {\n  zeroFill = getZeroFillToggle();\n}\n\nmodule.exports = {\n  FastBuffer\x2C\n  addBufferPrototypeMethods\x2C\n  markAsUntransferable\x2C\n  createUnsafeBuffer\x2C\n  readUInt16BE\x2C\n  readUInt32BE\x2C\n  reconnectZeroFillToggle\n};\n
code-source-info,0xb46f7df47c0,31,30717,30757,C0O30724C5O30735C11O30733C18O30756,,
tick,0x10280e197,58093,0,0x0,3,0x102d5e910,0xb46f7df2e1f,0xb46f7dee5f7
tick,0x7ff805e4dd52,58106,0,0x0,3,0x102d5e910,0xb46f7df2e1f,0xb46f7dee5f7
tick,0x7ff805dd2b58,58112,0,0x0,3,0x102d5e910,0xb46f7df2e1f,0xb46f7dee5f7
code-creation,LazyCompile,10,58194,0xb46f7df70b0,460,patchProcessObject node:internal/bootstrap/pre_execution:105:28,0xb46f7df06e0,~
code-source-info,0xb46f7df70b0,389,2873,4956,C0O2907C6O2907C11O2953C19O2953C24O2985C30O2985C35O3023C40O3024C44O3050C55O3071C62O3205C68O3205C79O3260C85O3264C92O3050C97O3277C101O3294C105O3309C109O3326C113O3337C116O3345C126O3363C130O3353C134O3376C141O3403C148O3407C155O3421C161O3455C168O3459C175O3421C182O3537C188O3537C196O3570C199O3578C207O3593C215O3609C222O3613C226O3593C231O3586C241O3831C247O3831C252O3905C258O3905C263O3877C268O3948C272O4131C281O4131C286O4177C295O4177C300O4230C309O4230C314O4290C323O4290C328O4348C337O4348C342O4408C351O4408C356O4472C365O4472C370O4537C379O4537C384O4608C393O4608C398O4678C407O4678C412O4738C421O4738C426O4808C437O4808C442O4878C453O4878C459O4955,,
code-creation,LazyCompile,10,58287,0xb46f7df7440,69,internalBinding node:internal/bootstrap/loaders:171:45,0xb466514b380,~
code-source-info,0xb46f7df7440,15,5263,5501,C0O5288C7O5298C11O5312C15O5349C25O5376C30O5374C37O5410C48O5429C56O5465C61O5410C66O5486C68O5497,,
tick,0x102dbc8ec,58541,1,0x102692f60,5,0x1027fed10,0xb46f7df70c3,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,58937,0xb46f7df7710,69,refreshHrtimeBuffer node:internal/process/per_thread:67:29,0xb46d2c89cf8,~
script-source,36,node:internal/process/per_thread,'use strict';\n\n// This files contains process bootstrappers that can be\n// run when setting up each thread\x2C including the main\n// thread and the worker threads.\n\nconst {\n  ArrayPrototypeEvery\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  BigUint64Array\x2C\n  Float64Array\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  ObjectFreeze\x2C\n  ObjectDefineProperty\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  Set\x2C\n  SetPrototypeEntries\x2C\n  SetPrototypeValues\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  Uint32Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_ASSERTION\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\n} = require('internal/errors');\nconst format = require('internal/util/inspect').format;\nconst {\n  validateArray\x2C\n  validateNumber\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst constants = internalBinding('constants').os.signals;\n\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nconst kInternal = Symbol('internal properties');\n\nfunction assert(x\x2C msg) {\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\n}\n\nconst binding = internalBinding('process_methods');\n\nlet hrValues;\nlet hrBigintValues;\n\nfunction refreshHrtimeBuffer() {\n  // The 3 entries filled in by the original process.hrtime contains\n  // the upper/lower 32 bits of the second part of the value\x2C\n  // and the remaining nanoseconds of the value.\n  hrValues = new Uint32Array(binding.hrtimeBuffer);\n  // Use a BigUint64Array in the closure because this is actually a bit\n  // faster than simply returning a BigInt from C++ in V8 7.1.\n  hrBigintValues = new BigUint64Array(binding.hrtimeBuffer\x2C 0\x2C 1);\n}\n\n// Create the buffers.\nrefreshHrtimeBuffer();\n\nfunction hrtime(time) {\n  binding.hrtime();\n\n  if (time !== undefined) {\n    validateArray(time\x2C 'time');\n    if (time.length !== 2) {\n      throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\n    }\n\n    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\n    const nsec = hrValues[2] - time[1];\n    const needsBorrow = nsec < 0;\n    return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\n  }\n\n  return [\n    hrValues[0] * 0x100000000 + hrValues[1]\x2C\n    hrValues[2]\x2C\n  ];\n}\n\nfunction hrtimeBigInt() {\n  binding.hrtimeBigInt();\n  return hrBigintValues[0];\n}\n\n// The execution of this function itself should not cause any side effects.\nfunction wrapProcessMethods(binding) {\n  const {\n    cpuUsage: _cpuUsage\x2C\n    memoryUsage: _memoryUsage\x2C\n    rss\x2C\n    resourceUsage: _resourceUsage\n  } = binding;\n\n  function _rawDebug(...args) {\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\n  }\n\n  // Create the argument array that will be passed to the native function.\n  const cpuValues = new Float64Array(2);\n\n  // Replace the native function with the JS version that calls the native\n  // function.\n  function cpuUsage(prevValue) {\n    // If a previous value was passed in\x2C ensure it has the correct shape.\n    if (prevValue) {\n      if (!previousValueIsValid(prevValue.user)) {\n        validateObject(prevValue\x2C 'prevValue');\n\n        validateNumber(prevValue.user\x2C 'prevValue.user');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\n                                                   prevValue.user);\n      }\n\n      if (!previousValueIsValid(prevValue.system)) {\n        validateNumber(prevValue.system\x2C 'prevValue.system');\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\n                                                   prevValue.system);\n      }\n    }\n\n    // Call the native function to get the current values.\n    _cpuUsage(cpuValues);\n\n    // If a previous value was passed in\x2C return diff of current from previous.\n    if (prevValue) {\n      return {\n        user: cpuValues[0] - prevValue.user\x2C\n        system: cpuValues[1] - prevValue.system\n      };\n    }\n\n    // If no previous value passed in\x2C return current value.\n    return {\n      user: cpuValues[0]\x2C\n      system: cpuValues[1]\n    };\n  }\n\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\n  function previousValueIsValid(num) {\n    return typeof num === 'number' &&\n        num <= NumberMAX_SAFE_INTEGER &&\n        num >= 0;\n  }\n\n  const memValues = new Float64Array(5);\n  function memoryUsage() {\n    _memoryUsage(memValues);\n    return {\n      rss: memValues[0]\x2C\n      heapTotal: memValues[1]\x2C\n      heapUsed: memValues[2]\x2C\n      external: memValues[3]\x2C\n      arrayBuffers: memValues[4]\n    };\n  }\n\n  memoryUsage.rss = rss;\n\n  function exit(code) {\n    process.off('exit'\x2C handleProcessExit);\n\n    if (code || code === 0)\n      process.exitCode = code;\n\n    if (!process._exiting) {\n      process._exiting = true;\n      process.emit('exit'\x2C process.exitCode || 0);\n    }\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\n    // in the user land. Either document it\x2C or deprecate it in favor of a\n    // better public alternative.\n    process.reallyExit(process.exitCode || 0);\n  }\n\n  function kill(pid\x2C sig) {\n    let err;\n\n    // eslint-disable-next-line eqeqeq\n    if (pid != (pid | 0)) {\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\n    }\n\n    // Preserve null signal\n    if (sig === (sig | 0)) {\n      // XXX(joyeecheung): we have to use process._kill here because\n      // it's monkey-patched by tests.\n      err = process._kill(pid\x2C sig);\n    } else {\n      sig = sig || 'SIGTERM';\n      if (constants[sig]) {\n        err = process._kill(pid\x2C constants[sig]);\n      } else {\n        throw new ERR_UNKNOWN_SIGNAL(sig);\n      }\n    }\n\n    if (err)\n      throw errnoException(err\x2C 'kill');\n\n    return true;\n  }\n\n  const resourceValues = new Float64Array(16);\n  function resourceUsage() {\n    _resourceUsage(resourceValues);\n    return {\n      userCPUTime: resourceValues[0]\x2C\n      systemCPUTime: resourceValues[1]\x2C\n      maxRSS: resourceValues[2]\x2C\n      sharedMemorySize: resourceValues[3]\x2C\n      unsharedDataSize: resourceValues[4]\x2C\n      unsharedStackSize: resourceValues[5]\x2C\n      minorPageFault: resourceValues[6]\x2C\n      majorPageFault: resourceValues[7]\x2C\n      swappedOut: resourceValues[8]\x2C\n      fsRead: resourceValues[9]\x2C\n      fsWrite: resourceValues[10]\x2C\n      ipcSent: resourceValues[11]\x2C\n      ipcReceived: resourceValues[12]\x2C\n      signalsCount: resourceValues[13]\x2C\n      voluntaryContextSwitches: resourceValues[14]\x2C\n      involuntaryContextSwitches: resourceValues[15]\n    };\n  }\n\n\n  return {\n    _rawDebug\x2C\n    cpuUsage\x2C\n    resourceUsage\x2C\n    memoryUsage\x2C\n    kill\x2C\n    exit\n  };\n}\n\nconst replaceUnderscoresRegex = /_/g;\nconst leadingDashesRegex = /^--?/;\nconst trailingValuesRegex = /=.*$/;\n\n// This builds the initial process.allowedNodeEnvironmentFlags\n// from data in the config binding.\nfunction buildAllowedFlags() {\n  const {\n    envSettings: { kAllowedInEnvironment }\x2C\n    types: { kBoolean }\x2C\n  } = internalBinding('options');\n  const { options\x2C aliases } = require('internal/options');\n\n  const allowedNodeEnvironmentFlags = [];\n  for (const { 0: name\x2C 1: info } of options) {\n    if (info.envVarSettings === kAllowedInEnvironment) {\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\n      if (info.type === kBoolean) {\n        const negatedName = `--no-${name.slice(2)}`;\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\n      }\n    }\n  }\n\n  function isAccepted(to) {\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\n    const recursiveExpansion = aliases.get(to);\n    if (recursiveExpansion) {\n      if (recursiveExpansion[0] === to)\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\n    }\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\n  }\n  for (const { 0: from\x2C 1: expansion } of aliases) {\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\n      let canonical = from;\n      if (StringPrototypeEndsWith(canonical\x2C '='))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\n    }\n  }\n\n  const trimLeadingDashes =\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\n\n  // Save these for comparison against flags provided to\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\n                                      trimLeadingDashes);\n\n  class NodeEnvironmentFlagsSet extends Set {\n    constructor(array) {\n      super();\n      this[kInternal] = { array };\n    }\n\n    add() {\n      // No-op\x2C `Set` API compatible\n      return this;\n    }\n\n    delete() {\n      // No-op\x2C `Set` API compatible\n      return false;\n    }\n\n    clear() {\n      // No-op\x2C `Set` API compatible\n    }\n\n    has(key) {\n      // This will return `true` based on various possible\n      // permutations of a flag\x2C including present/missing leading\n      // dash(es) and/or underscores-for-dashes.\n      // Strips any values after `=`\x2C inclusive.\n      // TODO(addaleax): It might be more flexible to run the option parser\n      // on a dummy option set and see whether it rejects the argument or\n      // not.\n      if (typeof key === 'string') {\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\n        if (RegExpPrototypeExec(leadingDashesRegex\x2C key) !== null) {\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\n        }\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\n      }\n      return false;\n    }\n\n    entries() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeEntries(this[kInternal].set);\n    }\n\n    forEach(callback\x2C thisArg = undefined) {\n      ArrayPrototypeForEach(\n        this[kInternal].array\x2C\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\n      );\n    }\n\n    get size() {\n      return this[kInternal].array.length;\n    }\n\n    values() {\n      this[kInternal].set ??=\n        new Set(new SafeArrayIterator(this[kInternal].array));\n      return SetPrototypeValues(this[kInternal].set);\n    }\n  }\n  const flagSetValues = NodeEnvironmentFlagsSet.prototype.values;\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C SymbolIterator\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n  ObjectDefineProperty(NodeEnvironmentFlagsSet.prototype\x2C 'keys'\x2C {\n    __proto__: null\x2C\n    value: flagSetValues\x2C\n  });\n\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\n\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\n    allowedNodeEnvironmentFlags\n  ));\n}\n\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\n// trace event category is enabled.\nlet traceEventsAsyncHook;\n// Dynamically enable/disable the traceEventsAsyncHook\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\n  if (asyncHooksEnabled) {\n    if (!traceEventsAsyncHook) {\n      traceEventsAsyncHook =\n        require('internal/trace_events_async_hooks').createHook();\n    }\n    traceEventsAsyncHook.enable();\n  } else if (traceEventsAsyncHook) {\n    traceEventsAsyncHook.disable();\n  }\n}\n\nmodule.exports = {\n  toggleTraceCategoryState\x2C\n  assert\x2C\n  buildAllowedFlags\x2C\n  wrapProcessMethods\x2C\n  hrtime\x2C\n  hrtimeBigInt\x2C\n  refreshHrtimeBuffer\x2C\n};\n
code-source-info,0xb46f7df7710,36,1436,1876,C0O1623C7O1650C10O1658C17O1634C25O1632C31O1810C38O1846C41O1854C53O1827C61O1825C68O1875,,
tick,0x7ff805e4dde4,60409,0,0x0,3,0x102d5e910,0xb46f7df70d8,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,60440,0xb46f7df85d8,82,getOptionValue node:internal/options:44:24,0xb46806bdc78,~
code-source-info,0xb46f7df85d8,88,985,1228,C0O1018C3O1018C7O1063C15O1063C22O1113C30O1135C38O1135C43O1122C47O1113C53O1150C55O1175C60O1181C61O1203C66O1203C74O1218C81O1226,,
code-creation,LazyCompile,10,60486,0xb46f7df8738,33,getCLIOptionsFromBinding node:internal/options:18:34,0xb46806bda60,~
code-source-info,0xb46f7df8738,88,497,598,C0O504C6O527C11O554C15O539C28O578C32O596,,
tick,0x1027de180,60925,0,0x0,2,0x102d5e910,0xb46f7df7192,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,61360,0xb46f7df8900,175,resolve node:path:1091:10,0xb46806acd98,~
script-source,71,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst {\n  CHAR_UPPERCASE_A\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_UPPERCASE_Z\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_DOT\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\x2C\n  CHAR_QUESTION_MARK\x2C\n} = require('internal/constants');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst platformIsWin32 = (process.platform === 'win32');\n\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\n\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\n\nfunction isWindowsDeviceRoot(code) {\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = StringPrototypeCharCodeAt(path\x2C i);\n    else if (isPathSeparator(code))\n      break;\n    else\n      code = CHAR_FORWARD_SLASH;\n\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\n              lastSegmentLength =\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\n        else\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\n/**\n * @param {string} sep\n * @param {{\n *  dir?: string;\n *  root?: string;\n *  base?: string;\n *  name?: string;\n *  ext?: string;\n *  }} pathObject\n * @returns {string}\n */\nfunction _format(sep\x2C pathObject) {\n  validateObject(pathObject\x2C 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base ||\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\n\nconst win32 = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = args[i];\n        validateString(path\x2C 'path');\n\n        // Skip empty entries\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = process.cwd();\n      } else {\n        // Windows has the concept of drive-specific current working\n        // directories. If we've resolved a drive letter but not yet an\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\n        // the drive cwd is not available. We're sure the device is not\n        // a UNC path at this points\x2C because UNC paths are always absolute.\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\n\n        // Verify that a cwd was found and that it actually points\n        // to our drive. If not\x2C default to the drive's root.\n        if (path === undefined ||\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\n            StringPrototypeToLowerCase(resolvedDevice) &&\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n      // Try to match a root\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          // `path` contains just a path separator\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        // Possible UNC root\n\n        // If we started with a separator\x2C we know we at least have an\n        // absolute path of some kind (UNC or otherwise)\n        isAbsolute = true;\n\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n          // Matched double path separator at beginning\n          let j = 2;\n          let last = j;\n          // Match 1 or more non-path separators\n          while (j < len &&\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n            // Matched!\n            last = j;\n            // Match 1 or more path separators\n            while (j < len &&\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              // Matched!\n              last = j;\n              // Match 1 or more non-path separators\n              while (j < len &&\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                // We matched a UNC root\n                device =\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) &&\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n        // Possible device root\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n          // Treat separator following drive name as an absolute path\n          // indicator\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (StringPrototypeToLowerCase(device) !==\n              StringPrototypeToLowerCase(resolvedDevice))\n            // This path points to another device so it is not applicable\n            continue;\n        } else {\n          resolvedDevice = device;\n        }\n      }\n\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0)\n          break;\n      } else {\n        resolvedTail =\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C\n    // but handle relative paths to be safe (might happen when process.cwd()\n    // fails)\n\n    // Normalize the tail path\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\n                                   isPathSeparator);\n\n    return resolvedAbsolute ?\n      `${resolvedDevice}\\\\${resolvedTail}` :\n      `${resolvedDevice}${resolvedTail}` || '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    // Try to match a root\n    if (len === 1) {\n      // `path` contains just a single char\x2C exit early to avoid\n      // unnecessary work\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      // If we started with a separator\x2C we know we at least have an absolute\n      // path of some kind (UNC or otherwise)\n      isAbsolute = true;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              // Return the normalized version of the UNC root since there\n              // is nothing left to process\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n              device =\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        // Treat separator following drive name as an absolute path\n        // indicator\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n\n    let tail = rootEnd < len ?\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\n      '';\n    if (tail.length === 0 && !isAbsolute)\n      tail = '.';\n    if (tail.length > 0 &&\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\n      tail += '\\\\';\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return false;\n\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n    return isPathSeparator(code) ||\n      // Possible device root\n      (len > 2 &&\n      isWindowsDeviceRoot(code) &&\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n\n    let joined;\n    let firstPart;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = firstPart = arg;\n        else\n          joined += `\\\\${arg}`;\n      }\n    }\n\n    if (joined === undefined)\n      return '.';\n\n    // Make sure that the joined path doesn't start with two slashes\x2C because\n    // normalize() will mistake it for a UNC path then.\n    //\n    // This step is skipped when it is very clear that the user actually\n    // intended to point at a UNC path. This is assumed when the first\n    // non-empty string arguments starts with exactly two slashes followed by\n    // at least one more non-slash character.\n    //\n    // Note that for normalize() to treat a path as a UNC path it needs to\n    // have at least 2 components\x2C so we don't filter for that here.\n    // This means that the user can use join to construct UNC paths from\n    // a server name and a share name; for example:\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\n    let needsReplace = true;\n    let slashCount = 0;\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 &&\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\n            ++slashCount;\n          else {\n            // We matched a UNC path in the first part\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      // Find any more consecutive slashes we need to replace\n      while (slashCount < joined.length &&\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\n        slashCount++;\n      }\n\n      // Replace the slashes if needed\n      if (slashCount >= 2)\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\n    }\n\n    return win32.normalize(joined);\n  }\x2C\n\n  /**\n   * It will solve the relative path from `from` to `to`\x2C for instance\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n\n    if (fromOrig === toOrig)\n      return '';\n\n    from = StringPrototypeToLowerCase(fromOrig);\n    to = StringPrototypeToLowerCase(toOrig);\n\n    if (from === to)\n      return '';\n\n    // Trim any leading backslashes\n    let fromStart = 0;\n    while (fromStart < from.length &&\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let fromEnd = from.length;\n    while (\n      fromEnd - 1 > fromStart &&\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\n    ) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    let toStart = 0;\n    while (toStart < to.length &&\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    // Trim trailing backslashes (applicable to UNC paths only)\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart &&\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_BACKWARD_SLASH)\n        lastCommonSep = i;\n    }\n\n    // We found a mismatch before the first common path separator was seen\x2C so\n    // return the original `to`.\n    if (i !== length) {\n      if (lastCommonSep === -1)\n        return toOrig;\n    } else {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\n        }\n        if (i === 2) {\n          // We get here if `from` is the device root.\n          // For example: from='C:\\\\'; to='C:\\\\foo'\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_BACKWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n          lastCommonSep = i;\n        } else if (i === 2) {\n          // We get here if `to` is the device root.\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1)\n        lastCommonSep = 0;\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to` and\n    // `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n\n    toStart += lastCommonSep;\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\n\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\n      ++toStart;\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Note: this will *probably* throw somewhere.\n    if (typeof path !== 'string' || path.length === 0)\n      return path;\n\n    const resolvedPath = win32.resolve(path);\n\n    if (resolvedPath.length <= 2)\n      return path;\n\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\n      // Possible UNC root\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\n        }\n      }\n    } else if (\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\n    ) {\n      // Matched device root\x2C convert the path to a long UNC path\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    const len = path.length;\n    if (len === 0)\n      return '.';\n    let rootEnd = -1;\n    let offset = 0;\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      // `path` contains just a path separator\x2C exit early to avoid\n      // unnecessary work or a dot.\n      return isPathSeparator(code) ? path : '.';\n    }\n\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = offset = 1;\n\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              return path;\n            }\n            if (j !== last) {\n              // We matched a UNC root with leftovers\n\n              // Offset by 1 to include the separator after the UNC root to\n              // treat it as a "normal root" on top of a (UNC) root\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    // Possible device root\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      rootEnd =\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) {\n      if (rootEnd === -1)\n        return '.';\n\n      end = rootEnd;\n    }\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n    if (path.length >= 2 &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      start = 2;\n    }\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= start; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (isPathSeparator(code)) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Check for a drive letter prefix so as not to mistake the following\n    // path separator as an extra separator at the end of the path that can be\n    // disregarded\n\n    if (path.length >= 2 &&\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\n      start = startPart = 2;\n    }\n\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *  dir: string;\n   *  root: string;\n   *  base: string;\n   *  name: string;\n   *  ext: string;\n   *  }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n\n    const len = path.length;\n    let rootEnd = 0;\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\n\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        // `path` contains just a path separator\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    // Try to match a root\n    if (isPathSeparator(code)) {\n      // Possible UNC root\n\n      rootEnd = 1;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\n        // Matched double path separator at beginning\n        let j = 2;\n        let last = j;\n        // Match 1 or more non-path separators\n        while (j < len &&\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          // Matched!\n          last = j;\n          // Match 1 or more path separators\n          while (j < len &&\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            // Matched!\n            last = j;\n            // Match 1 or more non-path separators\n            while (j < len &&\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\n              j++;\n            }\n            if (j === len) {\n              // We matched a UNC root only\n              rootEnd = j;\n            } else if (j !== last) {\n              // We matched a UNC root with leftovers\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) &&\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\n      // Possible device root\n      if (len <= 2) {\n        // `path` contains just a drive root\x2C exit early to avoid\n        // unnecessary work\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\n        if (len === 3) {\n          // `path` contains just a drive root\x2C exit early to avoid\n          // unnecessary work\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0)\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\n\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= rootEnd; --i) {\n      code = StringPrototypeCharCodeAt(path\x2C i);\n      if (isPathSeparator(code)) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n           startDot === end - 1 &&\n           startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    // If the directory is the root\x2C use the entire root as the `dir` including\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n    if (startPart > 0 && startPart !== rootEnd)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else\n      ret.dir = ret.root;\n\n    return ret;\n  }\x2C\n\n  sep: '\\\\'\x2C\n  delimiter: ';'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    // Converts Windows' backslash path separators to POSIX forward slashes\n    // and truncates any drive indicator\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\n    };\n  }\n\n  // We're already on POSIX\x2C no need for any transformations\n  return () => process.cwd();\n})();\n\nconst posix = {\n  /**\n   * path.resolve([from ...]\x2C to)\n   * @param {...string} args\n   * @returns {string}\n   */\n  resolve(...args) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? args[i] : posixCwd();\n\n      validateString(path\x2C 'path');\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute =\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    }\n\n    // At this point the path should be resolved to a full absolute path\x2C but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\n                                   isPosixPathSeparator);\n\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  normalize(path) {\n    validateString(path\x2C 'path');\n\n    if (path.length === 0)\n      return '.';\n\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator =\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\n\n    // Normalize the path\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\n\n    if (path.length === 0) {\n      if (isAbsolute)\n        return '/';\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator)\n      path += '/';\n\n    return isAbsolute ? `/${path}` : path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {boolean}\n   */\n  isAbsolute(path) {\n    validateString(path\x2C 'path');\n    return path.length > 0 &&\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n  }\x2C\n\n  /**\n   * @param {...string} args\n   * @returns {string}\n   */\n  join(...args) {\n    if (args.length === 0)\n      return '.';\n    let joined;\n    for (let i = 0; i < args.length; ++i) {\n      const arg = args[i];\n      validateString(arg\x2C 'path');\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += `/${arg}`;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  }\x2C\n\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @returns {string}\n   */\n  relative(from\x2C to) {\n    validateString(from\x2C 'from');\n    validateString(to\x2C 'to');\n\n    if (from === to)\n      return '';\n\n    // Trim leading forward slashes.\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to)\n      return '';\n\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n\n    // Compare paths to find the longest common path from root\n    const length = (fromLen < toLen ? fromLen : toLen);\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\n        break;\n      else if (fromCode === CHAR_FORWARD_SLASH)\n        lastCommonSep = i;\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\n          // We get here if `from` is the exact base path for `to`.\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\n        }\n        if (i === 0) {\n          // We get here if `from` is the root\n          // For example: from='/'; to='/foo'\n          return StringPrototypeSlice(to\x2C toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\n            CHAR_FORWARD_SLASH) {\n          // We get here if `to` is the exact base path for `from`.\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\n          lastCommonSep = i;\n        } else if (i === 0) {\n          // We get here if `to` is the root.\n          // For example: from='/foo/bar'; to='/'\n          lastCommonSep = 0;\n        }\n      }\n    }\n\n    let out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`.\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd ||\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\n    // the common path parts.\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  toNamespacedPath(path) {\n    // Non-op on posix systems\n    return path;\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  dirname(path) {\n    validateString(path\x2C 'path');\n    if (path.length === 0)\n      return '.';\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1)\n      return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1)\n      return '//';\n    return StringPrototypeSlice(path\x2C 0\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @param {string} [ext]\n   * @returns {string}\n   */\n  basename(path\x2C ext) {\n    if (ext !== undefined)\n      validateString(ext\x2C 'ext');\n    validateString(path\x2C 'path');\n\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path)\n        return '';\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (let i = path.length - 1; i >= 0; --i) {\n        const code = StringPrototypeCharCodeAt(path\x2C i);\n        if (code === CHAR_FORWARD_SLASH) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string\x2C stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator\x2C remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension\x2C so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match\x2C so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end)\n        end = firstNonSlashEnd;\n      else if (end === -1)\n        end = path.length;\n      return StringPrototypeSlice(path\x2C start\x2C end);\n    }\n    for (let i = path.length - 1; i >= 0; --i) {\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // path component\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n\n    if (end === -1)\n      return '';\n    return StringPrototypeSlice(path\x2C start\x2C end);\n  }\x2C\n\n  /**\n   * @param {string} path\n   * @returns {string}\n   */\n  extname(path) {\n    validateString(path\x2C 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 ||\n        end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        (preDotState === 1 &&\n         startDot === end - 1 &&\n         startDot === startPart + 1)) {\n      return '';\n    }\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\n  }\x2C\n\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\n\n  /**\n   * @param {string} path\n   * @returns {{\n   *   dir: string;\n   *   root: string;\n   *   base: string;\n   *   name: string;\n   *   ext: string;\n   *   }}\n   */\n  parse(path) {\n    validateString(path\x2C 'path');\n\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\n    if (path.length === 0)\n      return ret;\n    const isAbsolute =\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      const code = StringPrototypeCharCodeAt(path\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string\x2C stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator\x2C mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        // If this is our first dot\x2C mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 ||\n          // We saw a non-dot character immediately before the dot\n          preDotState === 0 ||\n          // The (right-most) trimmed path component is exactly '..'\n          (preDotState === 1 &&\n          startDot === end - 1 &&\n          startDot === startPart + 1)) {\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\n      } else {\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\n      }\n    }\n\n    if (startPart > 0)\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\n    else if (isAbsolute)\n      ret.dir = '/';\n\n    return ret;\n  }\x2C\n\n  sep: '/'\x2C\n  delimiter: ':'\x2C\n  win32: null\x2C\n  posix: null\n};\n\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\n\n// Legacy internal API\x2C docs-only deprecated: DEP0080\nwin32._makeLong = win32.toNamespacedPath;\nposix._makeLong = posix.toNamespacedPath;\n\nmodule.exports = platformIsWin32 ? win32 : posix;\n
code-source-info,0xb46f7df8900,71,33781,34691,C0O33781C3O33816C6O33847C8O33877C12O33884C16O33897C18O33891C25O33901C27O33945C28O33947C35O33958C42O33964C45O33964C49O33983C57O33983C62O34057C68O34064C73O34081C75O34106C87O34132C92O34154C99O34181C107O34220C109O34216C113O33920C118O33859C121O34436C126O34482C137O34451C143O34568C147O34598C152O34609C156O34624C157O34655C163O34662C174O34687,,
tick,0x7ff805e4dd52,66904,0,0x0,3,0x102d5e910,0xb46f7df7192,0xb46f7df2e25,0xb46f7dee5f7
tick,0x7ff805e4dd52,66913,0,0x0,3,0x102d5e910,0xb46f7df7192,0xb46f7df2e25,0xb46f7dee5f7
tick,0x7ff805e2d43e,66920,0,0x0,3,0x102d5e910,0xb46f7df7192,0xb46f7df2e25,0xb46f7dee5f7
tick,0x7ff805edebd6,66926,0,0x0,3,0x102d5e910,0xb46f7df7192,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,66940,0xb46f7dfbb38,30,validateString node:internal/validators:114:24,0xb466517a5c0,~
script-source,22,node:internal/validators,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  NumberParseInt\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  String\x2C\n  StringPrototypeToUpperCase\x2C\n  StringPrototypeTrim\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_SOCKET_BAD_PORT\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNKNOWN_SIGNAL\x2C\n  }\n} = require('internal/errors');\nconst { normalizeEncoding } = require('internal/util');\nconst {\n  isAsyncFunction\x2C\n  isArrayBufferView\n} = require('internal/util/types');\nconst { signals } = internalBinding('constants').os;\n\nfunction isInt32(value) {\n  return value === (value | 0);\n}\n\nfunction isUint32(value) {\n  return value === (value >>> 0);\n}\n\nconst octalReg = /^[0-7]+$/;\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\n\n/**\n * Parse and validate values that will be converted into mode_t (the S_*\n * constants). Only valid numbers and octal strings are allowed. They could be\n * converted to 32-bit unsigned integers or non-negative signed integers in the\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\n * behaviors.\n *\n * @param {*} value Values to be validated\n * @param {string} name Name of the argument\n * @param {number} [def] If specified\x2C will be returned for invalid values\n * @returns {number}\n */\nfunction parseFileMode(value\x2C name\x2C def) {\n  value ??= def;\n  if (typeof value === 'string') {\n    if (RegExpPrototypeExec(octalReg\x2C value) === null) {\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\n    }\n    value = NumberParseInt(value\x2C 8);\n  }\n\n  validateUint32(value\x2C name);\n  return value;\n}\n\nconst validateInteger = hideStackFrames(\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\n    if (typeof value !== 'number')\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    if (!NumberIsInteger(value))\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    if (value < min || value > max)\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n);\n\nconst validateInt32 = hideStackFrames(\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\n    // The defaults for min and max correspond to the limits of 32-bit integers.\n    if (typeof value !== 'number') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n    }\n    if (!NumberIsInteger(value)) {\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n    }\n    if (value < min || value > max) {\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n    }\n  }\n);\n\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\n  if (typeof value !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n  }\n  if (!NumberIsInteger(value)) {\n    throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\n  }\n  const min = positive ? 1 : 0;\n  // 2 ** 32 === 4294967296\n  const max = 4_294_967_295;\n  if (value < min || value > max) {\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\n  }\n});\n\nfunction validateString(value\x2C name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\n}\n\nfunction validateNumber(value\x2C name\x2C min = undefined\x2C max) {\n  if (typeof value !== 'number')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\n\n  if ((min != null && value < min) || (max != null && value > max) ||\n      ((min != null || max != null) && NumberIsNaN(value))) {\n    throw new ERR_OUT_OF_RANGE(\n      name\x2C\n      `${min != null ? `>= ${min}` : ''}${min != null && max != null ? ' && ' : ''}${max != null ? `<= ${max}` : ''}`\x2C\n      value);\n  }\n}\n\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\n    const allowed = ArrayPrototypeJoin(\n      ArrayPrototypeMap(oneOf\x2C (v) =>\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\n      '\x2C ');\n    const reason = 'must be one of: ' + allowed;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateBoolean(value\x2C name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\n}\n\nfunction getOwnPropertyValueOrDefault(options\x2C key\x2C defaultValue) {\n  return options == null || !ObjectPrototypeHasOwnProperty(options\x2C key) ?\n    defaultValue :\n    options[key];\n}\n\n/**\n * @param {unknown} value\n * @param {string} name\n * @param {{\n *   allowArray?: boolean\x2C\n *   allowFunction?: boolean\x2C\n *   nullable?: boolean\n * }} [options]\n */\nconst validateObject = hideStackFrames(\n  (value\x2C name\x2C options) => {\n    const allowArray = getOwnPropertyValueOrDefault(options\x2C 'allowArray'\x2C false);\n    const allowFunction = getOwnPropertyValueOrDefault(options\x2C 'allowFunction'\x2C false);\n    const nullable = getOwnPropertyValueOrDefault(options\x2C 'nullable'\x2C false);\n    if ((!nullable && value === null) ||\n        (!allowArray && ArrayIsArray(value)) ||\n        (typeof value !== 'object' && (\n          !allowFunction || typeof value !== 'function'\n        ))) {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\n    }\n  });\n\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\n  if (!ArrayIsArray(value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\n  }\n  if (value.length < minLength) {\n    const reason = `must be longer than ${minLength}`;\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\n  }\n});\n\nfunction validateSignalName(signal\x2C name = 'signal') {\n  validateString(signal\x2C name);\n\n  if (signals[signal] === undefined) {\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\n      throw new ERR_UNKNOWN_SIGNAL(signal +\n                                   ' (signals must use all capital letters)');\n    }\n\n    throw new ERR_UNKNOWN_SIGNAL(signal);\n  }\n}\n\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\n  if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n                                   buffer);\n  }\n});\n\nfunction validateEncoding(data\x2C encoding) {\n  const normalizedEncoding = normalizeEncoding(encoding);\n  const length = data.length;\n\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\n                                    `is invalid for data of length ${length}`);\n  }\n}\n\n// Check that the port number is not NaN when coerced to a number\x2C\n// is an integer and that it falls within the legal range of port numbers.\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\n      +port !== (+port >>> 0) ||\n      port > 0xFFFF ||\n      (port === 0 && !allowZero)) {\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\n  }\n  return port | 0;\n}\n\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\n  if (signal !== undefined &&\n      (signal === null ||\n       typeof signal !== 'object' ||\n       !('aborted' in signal))) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\n  }\n});\n\nconst validateFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validatePlainFunction = hideStackFrames((value\x2C name) => {\n  if (typeof value !== 'function' || isAsyncFunction(value))\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\n});\n\nconst validateUndefined = hideStackFrames((value\x2C name) => {\n  if (value !== undefined)\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\n});\n\nfunction validateUnion(value\x2C name\x2C union) {\n  if (!ArrayPrototypeIncludes(union\x2C value)) {\n    throw new ERR_INVALID_ARG_TYPE(name\x2C `('${ArrayPrototypeJoin(union\x2C '|')}')`\x2C value);\n  }\n}\n\nmodule.exports = {\n  isInt32\x2C\n  isUint32\x2C\n  parseFileMode\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateNumber\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validatePlainFunction\x2C\n  validatePort\x2C\n  validateSignalName\x2C\n  validateString\x2C\n  validateUint32\x2C\n  validateUndefined\x2C\n  validateUnion\x2C\n  validateAbortSignal\x2C\n};\n
code-source-info,0xb46f7dfbb38,22,3228,3337,C0O3246C6O3281C22O3287C27O3281C29O3336,,
tick,0x7ff805e4dd2c,68035,0,0x0,3,0x102d5e910,0xb46f7df8939,0xb46f7df7192,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,68046,0xb46f7dfc520,13, node:path:1082:10,0xb46806acd48,~
code-source-info,0xb46f7dfc520,71,33630,33649,C0O33644C3O33644C8O33644C12O33649,,
code-creation,LazyCompile,10,68084,0xb46f7dfc620,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0xb46634fac58,~
script-source,130,node:internal/bootstrap/switches/does_own_process_state,'use strict';\n\nconst credentials = internalBinding('credentials');\nconst rawMethods = internalBinding('process_methods');\n\nprocess.abort = rawMethods.abort;\nprocess.umask = wrappedUmask;\nprocess.chdir = wrappedChdir;\nprocess.cwd = wrappedCwd;\n\nif (credentials.implementsPosixCredentials) {\n  const wrapped = wrapPosixCredentialSetters(credentials);\n\n  process.initgroups = wrapped.initgroups;\n  process.setgroups = wrapped.setgroups;\n  process.setegid = wrapped.setegid;\n  process.seteuid = wrapped.seteuid;\n  process.setgid = wrapped.setgid;\n  process.setuid = wrapped.setuid;\n}\n\n// ---- keep the attachment of the wrappers above so that it's easier to ----\n// ----              compare the setups side-by-side                    -----\n\nconst {\n  parseFileMode\x2C\n  validateArray\x2C\n  validateString\n} = require('internal/validators');\n\nfunction wrapPosixCredentialSetters(credentials) {\n  const {\n    codes: {\n      ERR_INVALID_ARG_TYPE\x2C\n      ERR_UNKNOWN_CREDENTIAL\n    }\n  } = require('internal/errors');\n  const {\n    validateUint32\n  } = require('internal/validators');\n\n  const {\n    initgroups: _initgroups\x2C\n    setgroups: _setgroups\x2C\n    setegid: _setegid\x2C\n    seteuid: _seteuid\x2C\n    setgid: _setgid\x2C\n    setuid: _setuid\n  } = credentials;\n\n  function initgroups(user\x2C extraGroup) {\n    validateId(user\x2C 'user');\n    validateId(extraGroup\x2C 'extraGroup');\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\n    const result = _initgroups(user\x2C extraGroup);\n    if (result === 1) {\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\n    } else if (result === 2) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\n    }\n  }\n\n  function setgroups(groups) {\n    validateArray(groups\x2C 'groups');\n    for (let i = 0; i < groups.length; i++) {\n      validateId(groups[i]\x2C `groups[${i}]`);\n    }\n    // Result is 0 on success. A positive integer indicates that the\n    // corresponding group was not found.\n    const result = _setgroups(groups);\n    if (result > 0) {\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\n    }\n  }\n\n  function wrapIdSetter(type\x2C method) {\n    return function(id) {\n      validateId(id\x2C 'id');\n      if (typeof id === 'number') id |= 0;\n      // Result is 0 on success\x2C 1 if credential is unknown.\n      const result = method(id);\n      if (result === 1) {\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\n      }\n    };\n  }\n\n  function validateId(id\x2C name) {\n    if (typeof id === 'number') {\n      validateUint32(id\x2C name);\n    } else if (typeof id !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\n    }\n  }\n\n  return {\n    initgroups\x2C\n    setgroups\x2C\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\n    setuid: wrapIdSetter('User'\x2C _setuid)\n  };\n}\n\n// Cache the working directory to prevent lots of lookups. If the working\n// directory is changed by `chdir`\x2C it'll be updated.\nlet cachedCwd = '';\n\nfunction wrappedChdir(directory) {\n  validateString(directory\x2C 'directory');\n  rawMethods.chdir(directory);\n  // Mark cache that it requires an update.\n  cachedCwd = '';\n}\n\nfunction wrappedUmask(mask) {\n  if (mask !== undefined) {\n    mask = parseFileMode(mask\x2C 'mask');\n  }\n  return rawMethods.umask(mask);\n}\n\nfunction wrappedCwd() {\n  if (cachedCwd === '')\n    cachedCwd = rawMethods.cwd();\n  return cachedCwd;\n}\n
code-source-info,0xb46f7dfc620,130,3341,3425,C0O3348C7O3362C12O3374C17O3397C22O3397C29O3384C35O3406C39O3423,,
tick,0x10280e197,68550,0,0x0,3,0x102d5e910,0xb46f7dfc528,0xb46f7df892d,0xb46f7df7192,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,68674,0xb46f7dfcc88,442,normalizeString node:path:66:25,0xb46806ac988,~
code-source-info,0xb46f7dfcc88,71,2161,4085,C0O2226C3O2256C5O2277C8O2294C10O2310C12O2328C14O2341C18O2333C23O2373C27O2366C32O2387C37O2394C45O2443C51O2472C53O2494C58O2530C64O2561C66O2581C69O2575C76O2593C83O2631C85O2640C90O2665C97O2672C104O2697C111O2718C114O2753C118O2760C122O2718C130O2769C132O2765C139O2793C142O2828C146O2835C150O2793C158O2844C160O2840C165O2874C172O2881C177O2923C182O2923C188O2979C190O2998C195O3022C198O3046C202O3104C215O3110C221O3210C225O3217C231O3223C234O3223C239O3221C243O3293C246O3320C248O3342C250O3377C256O3384C261O3405C264O3427C266O3462C269O3489C271O3511C273O3551C277O3594C283O3601C293O3610C308O3642C313O3706C319O3713C324O3728C326O3738C330O3750C335O3787C345O3750C363O3821C370O3864C380O3827C386O3881C388O3903C391O3915C395O3934C398O3955C402O3976C404O3989C406O3985C413O4006C418O4022C425O4049C428O2351C433O2315C439O4072C441O4083,,
code-creation,LazyCompile,10,68772,0xb46f7dfd010,8,isPosixPathSeparator node:path:56:30,0xb46806ac8e8,~
code-source-info,0xb46f7dfd010,71,1854,1902,C0O1865C2O1881C4O1877C7O1900,,
code-creation,LazyCompile,10,68899,0xb46f7dfd420,37,initializeGlobalConsole node:internal/console/constructor:687:33,0xb462a871db8,~
script-source,107,node:internal/console/constructor,'use strict';\n\n// The Console constructor is not actually used to construct the global\n// console. It's exported for backwards compatibility.\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  MathFloor\x2C\n  Number\x2C\n  NumberPrototypeToFixed\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectValues\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst { trace } = internalBinding('trace_events');\nconst {\n  isStackOverflowError\x2C\n  codes: {\n    ERR_CONSOLE_WRITABLE_STREAM\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateInteger\x2C\n  validateObject\x2C\n} = require('internal/validators');\nconst { previewEntries } = internalBinding('util');\nconst { Buffer: { isBuffer } } = require('buffer');\nconst {\n  inspect\x2C\n  formatWithOptions\n} = require('internal/util/inspect');\nconst {\n  isTypedArray\x2C isSet\x2C isMap\x2C isSetIterator\x2C isMapIterator\x2C\n} = require('internal/util/types');\nconst {\n  CHAR_LOWERCASE_B: kTraceBegin\x2C\n  CHAR_LOWERCASE_E: kTraceEnd\x2C\n  CHAR_LOWERCASE_N: kTraceInstant\x2C\n  CHAR_UPPERCASE_C: kTraceCount\x2C\n} = require('internal/constants');\nconst kCounts = Symbol('counts');\n\nconst kTraceConsoleCategory = 'node\x2Cnode.console';\n\nconst kSecond = 1000;\nconst kMinute = 60 * kSecond;\nconst kHour = 60 * kMinute;\nconst kMaxGroupIndentation = 1000;\n\n// Lazy loaded for startup performance.\nlet cliTable;\n\n// Track amount of indentation required via `console.group()`.\nconst kGroupIndent = Symbol('kGroupIndent');\nconst kGroupIndentationWidth = Symbol('kGroupIndentWidth');\nconst kFormatForStderr = Symbol('kFormatForStderr');\nconst kFormatForStdout = Symbol('kFormatForStdout');\nconst kGetInspectOptions = Symbol('kGetInspectOptions');\nconst kColorMode = Symbol('kColorMode');\nconst kIsConsole = Symbol('kIsConsole');\nconst kWriteToConsole = Symbol('kWriteToConsole');\nconst kBindProperties = Symbol('kBindProperties');\nconst kBindStreamsEager = Symbol('kBindStreamsEager');\nconst kBindStreamsLazy = Symbol('kBindStreamsLazy');\nconst kUseStdout = Symbol('kUseStdout');\nconst kUseStderr = Symbol('kUseStderr');\n\nconst optionsMap = new SafeWeakMap();\n\nfunction Console(options /* or: stdout\x2C stderr\x2C ignoreErrors = true */) {\n  // We have to test new.target here to see if this function is called\n  // with new\x2C because we need to define a custom instanceof to accommodate\n  // the global console.\n  if (new.target === undefined) {\n    return ReflectConstruct(Console\x2C arguments);\n  }\n\n  if (!options || typeof options.write === 'function') {\n    options = {\n      stdout: options\x2C\n      stderr: arguments[1]\x2C\n      ignoreErrors: arguments[2]\n    };\n  }\n\n  const {\n    stdout\x2C\n    stderr = stdout\x2C\n    ignoreErrors = true\x2C\n    colorMode = 'auto'\x2C\n    inspectOptions\x2C\n    groupIndentation\x2C\n  } = options;\n\n  if (!stdout || typeof stdout.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stdout');\n  }\n  if (!stderr || typeof stderr.write !== 'function') {\n    throw new ERR_CONSOLE_WRITABLE_STREAM('stderr');\n  }\n\n  if (typeof colorMode !== 'boolean' && colorMode !== 'auto')\n    throw new ERR_INVALID_ARG_VALUE('colorMode'\x2C colorMode);\n\n  if (groupIndentation !== undefined) {\n    validateInteger(groupIndentation\x2C 'groupIndentation'\x2C\n                    0\x2C kMaxGroupIndentation);\n  }\n\n  if (inspectOptions !== undefined) {\n    validateObject(inspectOptions\x2C 'options.inspectOptions');\n\n    if (inspectOptions.colors !== undefined &&\n        options.colorMode !== undefined) {\n      throw new ERR_INCOMPATIBLE_OPTION_PAIR(\n        'options.inspectOptions.color'\x2C 'colorMode');\n    }\n    optionsMap.set(this\x2C inspectOptions);\n  }\n\n  // Bind the prototype functions to this Console instance\n  ArrayPrototypeForEach(ObjectKeys(Console.prototype)\x2C (key) => {\n    // We have to bind the methods grabbed from the instance instead of from\n    // the prototype so that users extending the Console can override them\n    // from the prototype chain of the subclass.\n    this[key] = FunctionPrototypeBind(this[key]\x2C this);\n    ObjectDefineProperty(this[key]\x2C 'name'\x2C {\n      __proto__: null\x2C\n      value: key\n    });\n  });\n\n  this[kBindStreamsEager](stdout\x2C stderr);\n  this[kBindProperties](ignoreErrors\x2C colorMode\x2C groupIndentation);\n}\n\nconst consolePropAttributes = {\n  writable: true\x2C\n  enumerable: false\x2C\n  configurable: true\n};\n\n// Fixup global.console instanceof global.console.Console\nObjectDefineProperty(Console\x2C SymbolHasInstance\x2C {\n  __proto__: null\x2C\n  value(instance) {\n    return instance[kIsConsole];\n  }\n});\n\nconst kColorInspectOptions = { colors: true };\nconst kNoColorInspectOptions = {};\n\nObjectDefineProperties(Console.prototype\x2C {\n  [kBindStreamsEager]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Eager version for the Console constructor\n    value: function(stdout\x2C stderr) {\n      ObjectDefineProperties(this\x2C {\n        '_stdout': { __proto__: null\x2C ...consolePropAttributes\x2C value: stdout }\x2C\n        '_stderr': { __proto__: null\x2C ...consolePropAttributes\x2C value: stderr }\x2C\n      });\n    }\n  }\x2C\n  [kBindStreamsLazy]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    // Lazily load the stdout and stderr from an object so we don't\n    // create the stdio streams when they are not even accessed\n    value: function(object) {\n      let stdout;\n      let stderr;\n      ObjectDefineProperties(this\x2C {\n        '_stdout': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stdout) stdout = object.stdout;\n            return stdout;\n          }\x2C\n          set(value) { stdout = value; }\n        }\x2C\n        '_stderr': {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          get() {\n            if (!stderr) { stderr = object.stderr; }\n            return stderr;\n          }\x2C\n          set(value) { stderr = value; }\n        }\n      });\n    }\n  }\x2C\n  [kBindProperties]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(ignoreErrors\x2C colorMode\x2C groupIndentation = 2) {\n      ObjectDefineProperties(this\x2C {\n        '_stdoutErrorHandler': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: createWriteErrorHandler(this\x2C kUseStdout)\n        }\x2C\n        '_stderrErrorHandler': {\n          ...consolePropAttributes\x2C\n          __proto__: null\x2C\n          value: createWriteErrorHandler(this\x2C kUseStderr)\n        }\x2C\n        '_ignoreErrors': {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: Boolean(ignoreErrors)\n        }\x2C\n        '_times': { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        // Corresponds to https://console.spec.whatwg.org/#count-map\n        [kCounts]: { __proto__: null\x2C ...consolePropAttributes\x2C value: new SafeMap() }\x2C\n        [kColorMode]: { __proto__: null\x2C ...consolePropAttributes\x2C value: colorMode }\x2C\n        [kIsConsole]: { __proto__: null\x2C ...consolePropAttributes\x2C value: true }\x2C\n        [kGroupIndent]: { __proto__: null\x2C ...consolePropAttributes\x2C value: '' }\x2C\n        [kGroupIndentationWidth]: {\n          __proto__: null\x2C\n          ...consolePropAttributes\x2C\n          value: groupIndentation\n        }\x2C\n        [SymbolToStringTag]: {\n          __proto__: null\x2C\n          writable: false\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          value: 'console'\n        }\n      });\n    }\n  }\x2C\n  [kWriteToConsole]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(streamSymbol\x2C string) {\n      const ignoreErrors = this._ignoreErrors;\n      const groupIndent = this[kGroupIndent];\n\n      const useStdout = streamSymbol === kUseStdout;\n      const stream = useStdout ? this._stdout : this._stderr;\n      const errorHandler = useStdout ?\n        this._stdoutErrorHandler : this._stderrErrorHandler;\n\n      if (groupIndent.length !== 0) {\n        if (StringPrototypeIncludes(string\x2C '\\n')) {\n          string = RegExpPrototypeSymbolReplace(/\\n/g\x2C string\x2C `\\n${groupIndent}`);\n        }\n        string = groupIndent + string;\n      }\n      string += '\\n';\n\n      if (ignoreErrors === false) return stream.write(string);\n\n      // There may be an error occurring synchronously (e.g. for files or TTYs\n      // on POSIX systems) or asynchronously (e.g. pipes on POSIX systems)\x2C so\n      // handle both situations.\n      try {\n        // Add and later remove a noop error handler to catch synchronous\n        // errors.\n        if (stream.listenerCount('error') === 0)\n          stream.once('error'\x2C noop);\n\n        stream.write(string\x2C errorHandler);\n      } catch (e) {\n        // Console is a debugging utility\x2C so it swallowing errors is not\n        // desirable even in edge cases such as low stack space.\n        if (isStackOverflowError(e))\n          throw e;\n        // Sorry\x2C there's no proper way to pass along the error here.\n      } finally {\n        stream.removeListener('error'\x2C noop);\n      }\n    }\n  }\x2C\n  [kGetInspectOptions]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(stream) {\n      let color = this[kColorMode];\n      if (color === 'auto') {\n        color = stream.isTTY && (\n          typeof stream.getColorDepth === 'function' ?\n            stream.getColorDepth() > 2 : true);\n      }\n\n      const options = optionsMap.get(this);\n      if (options) {\n        if (options.colors === undefined) {\n          options.colors = color;\n        }\n        return options;\n      }\n\n      return color ? kColorInspectOptions : kNoColorInspectOptions;\n    }\n  }\x2C\n  [kFormatForStdout]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stdout);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\n  }\x2C\n  [kFormatForStderr]: {\n    __proto__: null\x2C\n    ...consolePropAttributes\x2C\n    value: function(args) {\n      const opts = this[kGetInspectOptions](this._stderr);\n      ArrayPrototypeUnshift(args\x2C opts);\n      return ReflectApply(formatWithOptions\x2C null\x2C args);\n    }\n  }\x2C\n});\n\n// Make a function that can serve as the callback passed to `stream.write()`.\nfunction createWriteErrorHandler(instance\x2C streamSymbol) {\n  return (err) => {\n    // This conditional evaluates to true if and only if there was an error\n    // that was not already emitted (which happens when the _write callback\n    // is invoked asynchronously).\n    const stream = streamSymbol === kUseStdout ?\n      instance._stdout : instance._stderr;\n    if (err !== null && !stream._writableState.errorEmitted) {\n      // If there was an error\x2C it will be emitted on `stream` as\n      // an `error` event. Adding a `once` listener will keep that error\n      // from becoming an uncaught exception\x2C but since the handler is\n      // removed after the event\x2C non-console.* writes won't be affected.\n      // we are only adding noop if there is no one else listening for 'error'\n      if (stream.listenerCount('error') === 0) {\n        stream.once('error'\x2C noop);\n      }\n    }\n  };\n}\n\nconst consoleMethods = {\n  log(...args) {\n    this[kWriteToConsole](kUseStdout\x2C this[kFormatForStdout](args));\n  }\x2C\n\n\n  warn(...args) {\n    this[kWriteToConsole](kUseStderr\x2C this[kFormatForStderr](args));\n  }\x2C\n\n\n  dir(object\x2C options) {\n    this[kWriteToConsole](kUseStdout\x2C inspect(object\x2C {\n      customInspect: false\x2C\n      ...this[kGetInspectOptions](this._stdout)\x2C\n      ...options\n    }));\n  }\x2C\n\n  time(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    if (this._times.has(label)) {\n      process.emitWarning(`Label '${label}' already exists for console.time()`);\n      return;\n    }\n    trace(kTraceBegin\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    this._times.set(label\x2C process.hrtime());\n  }\x2C\n\n  timeEnd(label = 'default') {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    const found = timeLogImpl(this\x2C 'timeEnd'\x2C label);\n    trace(kTraceEnd\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n    if (found) {\n      this._times.delete(label);\n    }\n  }\x2C\n\n  timeLog(label = 'default'\x2C ...data) {\n    // Coerces everything other than Symbol to a string\n    label = `${label}`;\n    timeLogImpl(this\x2C 'timeLog'\x2C label\x2C data);\n    trace(kTraceInstant\x2C kTraceConsoleCategory\x2C `time::${label}`\x2C 0);\n  }\x2C\n\n  trace: function trace(...args) {\n    const err = {\n      name: 'Trace'\x2C\n      message: this[kFormatForStderr](args)\n    };\n    ErrorCaptureStackTrace(err\x2C trace);\n    this.error(err.stack);\n  }\x2C\n\n  assert(expression\x2C ...args) {\n    if (!expression) {\n      args[0] = `Assertion failed${args.length === 0 ? '' : `: ${args[0]}`}`;\n      // The arguments will be formatted in warn() again\n      ReflectApply(this.warn\x2C this\x2C args);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#clear\n  clear() {\n    // It only makes sense to clear if _stdout is a TTY.\n    // Otherwise\x2C do nothing.\n    if (this._stdout.isTTY && process.env.TERM !== 'dumb') {\n      // The require is here intentionally to avoid readline being\n      // required too early when console is first loaded.\n      const {\n        cursorTo\x2C\n        clearScreenDown\x2C\n      } = require('internal/readline/callbacks');\n      cursorTo(this._stdout\x2C 0\x2C 0);\n      clearScreenDown(this._stdout);\n    }\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#count\n  count(label = 'default') {\n    // Ensures that label is a string\x2C and only things that can be\n    // coerced to strings. e.g. Symbol is not allowed\n    label = `${label}`;\n    const counts = this[kCounts];\n    let count = counts.get(label);\n    if (count === undefined)\n      count = 1;\n    else\n      count++;\n    counts.set(label\x2C count);\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C count);\n    this.log(`${label}: ${count}`);\n  }\x2C\n\n  // Defined by: https://console.spec.whatwg.org/#countreset\n  countReset(label = 'default') {\n    const counts = this[kCounts];\n    if (!counts.has(label)) {\n      process.emitWarning(`Count for '${label}' does not exist`);\n      return;\n    }\n    trace(kTraceCount\x2C kTraceConsoleCategory\x2C `count::${label}`\x2C 0\x2C 0);\n    counts.delete(`${label}`);\n  }\x2C\n\n  group(...data) {\n    if (data.length > 0) {\n      ReflectApply(this.log\x2C this\x2C data);\n    }\n    this[kGroupIndent] +=\n      StringPrototypeRepeat(' '\x2C this[kGroupIndentationWidth]);\n  }\x2C\n\n  groupEnd() {\n    this[kGroupIndent] = StringPrototypeSlice(\n      this[kGroupIndent]\x2C\n      0\x2C\n      this[kGroupIndent].length - this[kGroupIndentationWidth]\n    );\n  }\x2C\n\n  // https://console.spec.whatwg.org/#table\n  table(tabularData\x2C properties) {\n    if (properties !== undefined)\n      validateArray(properties\x2C 'properties');\n\n    if (tabularData === null || typeof tabularData !== 'object')\n      return this.log(tabularData);\n\n    cliTable ??= require('internal/cli_table');\n    const final = (k\x2C v) => this.log(cliTable(k\x2C v));\n\n    const _inspect = (v) => {\n      const depth = v !== null &&\n                    typeof v === 'object' &&\n                    !isArray(v) &&\n                    ObjectKeys(v).length > 2 ? -1 : 0;\n      const opt = {\n        depth\x2C\n        maxArrayLength: 3\x2C\n        breakLength: Infinity\x2C\n        ...this[kGetInspectOptions](this._stdout)\n      };\n      return inspect(v\x2C opt);\n    };\n    const getIndexArray = (length) => ArrayFrom(\n      { length }\x2C (_\x2C i) => _inspect(i));\n\n    const mapIter = isMapIterator(tabularData);\n    let isKeyValue = false;\n    let i = 0;\n    if (mapIter) {\n      const res = previewEntries(tabularData\x2C true);\n      tabularData = res[0];\n      isKeyValue = res[1];\n    }\n\n    if (isKeyValue || isMap(tabularData)) {\n      const keys = [];\n      const values = [];\n      let length = 0;\n      if (mapIter) {\n        for (; i < tabularData.length / 2; ++i) {\n          ArrayPrototypePush(keys\x2C _inspect(tabularData[i * 2]));\n          ArrayPrototypePush(values\x2C _inspect(tabularData[i * 2 + 1]));\n          length++;\n        }\n      } else {\n        for (const { 0: k\x2C 1: v } of tabularData) {\n          ArrayPrototypePush(keys\x2C _inspect(k));\n          ArrayPrototypePush(values\x2C _inspect(v));\n          length++;\n        }\n      }\n      return final([\n        iterKey\x2C keyKey\x2C valuesKey\x2C\n      ]\x2C [\n        getIndexArray(length)\x2C\n        keys\x2C\n        values\x2C\n      ]);\n    }\n\n    const setIter = isSetIterator(tabularData);\n    if (setIter)\n      tabularData = previewEntries(tabularData);\n\n    const setlike = setIter || mapIter || isSet(tabularData);\n    if (setlike) {\n      const values = [];\n      let length = 0;\n      for (const v of tabularData) {\n        ArrayPrototypePush(values\x2C _inspect(v));\n        length++;\n      }\n      return final([iterKey\x2C valuesKey]\x2C [getIndexArray(length)\x2C values]);\n    }\n\n    const map = ObjectCreate(null);\n    let hasPrimitives = false;\n    const valuesKeyArray = [];\n    const indexKeyArray = ObjectKeys(tabularData);\n\n    for (; i < indexKeyArray.length; i++) {\n      const item = tabularData[indexKeyArray[i]];\n      const primitive = item === null ||\n          (typeof item !== 'function' && typeof item !== 'object');\n      if (properties === undefined && primitive) {\n        hasPrimitives = true;\n        valuesKeyArray[i] = _inspect(item);\n      } else {\n        const keys = properties || ObjectKeys(item);\n        for (const key of keys) {\n          map[key] ??= [];\n          if ((primitive && properties) ||\n               !ObjectPrototypeHasOwnProperty(item\x2C key))\n            map[key][i] = '';\n          else\n            map[key][i] = _inspect(item[key]);\n        }\n      }\n    }\n\n    const keys = ObjectKeys(map);\n    const values = ObjectValues(map);\n    if (hasPrimitives) {\n      ArrayPrototypePush(keys\x2C valuesKey);\n      ArrayPrototypePush(values\x2C valuesKeyArray);\n    }\n    ArrayPrototypeUnshift(keys\x2C indexKey);\n    ArrayPrototypeUnshift(values\x2C indexKeyArray);\n\n    return final(keys\x2C values);\n  }\x2C\n};\n\n// Returns true if label was found\nfunction timeLogImpl(self\x2C name\x2C label\x2C data) {\n  const time = self._times.get(label);\n  if (time === undefined) {\n    process.emitWarning(`No such label '${label}' for console.${name}()`);\n    return false;\n  }\n  const duration = process.hrtime(time);\n  const ms = duration[0] * 1000 + duration[1] / 1e6;\n\n  const formatted = formatTime(ms);\n\n  if (data === undefined) {\n    self.log('%s: %s'\x2C label\x2C formatted);\n  } else {\n    self.log('%s: %s'\x2C label\x2C formatted\x2C ...new SafeArrayIterator(data));\n  }\n  return true;\n}\n\nfunction pad(value) {\n  return StringPrototypePadStart(`${value}`\x2C 2\x2C '0');\n}\n\nfunction formatTime(ms) {\n  let hours = 0;\n  let minutes = 0;\n  let seconds = 0;\n\n  if (ms >= kSecond) {\n    if (ms >= kMinute) {\n      if (ms >= kHour) {\n        hours = MathFloor(ms / kHour);\n        ms = ms % kHour;\n      }\n      minutes = MathFloor(ms / kMinute);\n      ms = ms % kMinute;\n    }\n    seconds = ms / kSecond;\n  }\n\n  if (hours !== 0 || minutes !== 0) {\n    ({ 0: seconds\x2C 1: ms } = StringPrototypeSplit(\n      NumberPrototypeToFixed(seconds\x2C 3)\x2C\n      '.'\n    ));\n    const res = hours !== 0 ? `${hours}:${pad(minutes)}` : minutes;\n    return `${res}:${pad(seconds)}.${ms} (${hours !== 0 ? 'h:m' : ''}m:ss.mmm)`;\n  }\n\n  if (seconds !== 0) {\n    return `${NumberPrototypeToFixed(seconds\x2C 3)}s`;\n  }\n\n  return `${Number(NumberPrototypeToFixed(ms\x2C 3))}ms`;\n}\n\nconst keyKey = 'Key';\nconst valuesKey = 'Values';\nconst indexKey = '(index)';\nconst iterKey = '(iteration index)';\n\nconst isArray = (v) => ArrayIsArray(v) || isTypedArray(v) || isBuffer(v);\n\nfunction noop() {}\n\nfor (const method of ReflectOwnKeys(consoleMethods))\n  Console.prototype[method] = consoleMethods[method];\n\nConsole.prototype.debug = Console.prototype.log;\nConsole.prototype.info = Console.prototype.log;\nConsole.prototype.dirxml = Console.prototype.log;\nConsole.prototype.error = Console.prototype.warn;\nConsole.prototype.groupCollapsed = Console.prototype.group;\n\nfunction initializeGlobalConsole(globalConsole) {\n  globalConsole[kBindStreamsLazy](process);\n  globalConsole[kBindProperties](true\x2C 'auto');\n}\n\nmodule.exports = {\n  Console\x2C\n  kBindStreamsLazy\x2C\n  kBindProperties\x2C\n  initializeGlobalConsole\x2C\n  formatTime // exported for tests\n};\n
code-source-info,0xb46f7dfd420,107,20398,20509,C0O20418C2O20432C4O20431C11O20449C16O20462C18O20476C20O20475C29O20492C36O20508,,
tick,0x7ff805ede98c,71364,0,0x0,3,0x102d5e910,0xb46f7df71bc,0xb46f7df2e25,0xb46f7dee5f7
tick,0x10280e197,71372,0,0x0,3,0x102d5e910,0xb46f7df71bc,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,71396,0xb46f7dfedf8,94,value node:internal/console/constructor:200:20,0xb462a871448,~
code-source-info,0xb46f7dfedf8,107,5722,6356,C0O5722C15O5743C16O5743C18O5761C19O5761C21O5775C33O5825C38O5923C46O6030C60O6091C65O6189C73O6300C87O5775C93O6355,,
code-creation,LazyCompile,10,71550,0xb46f7dff490,414,value node:internal/console/constructor:230:20,0xb462a8714d0,~
code-source-info,0xb46f7dff490,107,6455,7849,C17O6511C27O6573C34O6615C52O6685C55O6655C73O6754C86O6851C89O6821C104O6899C111O6941C126O6981C129O6981C144O7032C151O7054C166O7088C169O7084C187O7179C191O7189C198O7211C213O7245C216O7241C235O7267C239O7280C246O7302C261O7332C275O7354C279O7367C286O7389C300O7419C314O7436C318O7451C325O7473C340O7503C354O7518C358O7543C365O7585C380O7625C394O7662C398O7682C407O6511C413O7848,,
code-creation,LazyCompile,10,71626,0xb46f7dff8f0,18,createWriteErrorHandler node:internal/console/constructor:354:33,0xb462a871778,~
code-source-info,0xb46f7dff8f0,107,10641,11498,C0O10641C13O10670C17O11496,,
new,MemoryChunk,0xb469fbc0000,262144
code-creation,LazyCompile,10,71726,0xb46f7dffae0,27,SafeMap node:internal/per_context/primordials:366:16,0xb4665145fc8,~
script-source,12,node:internal/per_context/primordials,'use strict';\n\n/* eslint-disable node-core/prefer-primordials */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy\x2C which can be mutated by users.\n\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\n// benchmark all changes made in performance-sensitive areas of the codebase.\n// See: https://github.com/nodejs/node/pull/38248\n\nconst {\n  defineProperty: ReflectDefineProperty\x2C\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\n  ownKeys: ReflectOwnKeys\x2C\n} = Reflect;\n\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.call` after it may have been mutated by users.\nconst { apply\x2C bind\x2C call } = Function.prototype;\nconst uncurryThis = bind.bind(call);\nprimordials.uncurryThis = uncurryThis;\n\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\n// and `Function.prototype.apply` after it may have been mutated by users.\nconst applyBind = bind.bind(apply);\nprimordials.applyBind = applyBind;\n\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\n// destructuring.\nconst varargsMethods = [\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\n  // on its own for arrays and array-likes with a truthy\n  // @@isConcatSpreadable symbol property.\n  'ArrayOf'\x2C\n  'ArrayPrototypePush'\x2C\n  'ArrayPrototypeUnshift'\x2C\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\n  // and 'FunctionPrototypeApply'.\n  'MathHypot'\x2C\n  'MathMax'\x2C\n  'MathMin'\x2C\n  'StringPrototypeConcat'\x2C\n  'TypedArrayOf'\x2C\n];\n\nfunction getNewKey(key) {\n  return typeof key === 'symbol' ?\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\n    `${key[0].toUpperCase()}${key.slice(1)}`;\n}\n\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\n    __proto__: null\x2C\n    value: uncurryThis(get)\x2C\n    enumerable\n  });\n  if (set !== undefined) {\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\n      __proto__: null\x2C\n      value: uncurryThis(set)\x2C\n      enumerable\n    });\n  }\n}\n\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          // `src` is bound as the `this` so that the static `this` points\n          // to the object it was defined on\x2C\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\n          value: applyBind(desc.value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = value.bind(src);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value\x2C src)\x2C\n        });\n      }\n    }\n  }\n}\n\nfunction copyPrototype(src\x2C dest\x2C prefix) {\n  for (const key of ReflectOwnKeys(src)) {\n    const newKey = getNewKey(key);\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\n    if ('get' in desc) {\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\n    } else {\n      const { value } = desc;\n      if (typeof value === 'function') {\n        desc.value = uncurryThis(value);\n      }\n\n      const name = `${prefix}${newKey}`;\n      ReflectDefineProperty(dest\x2C name\x2C { __proto__: null\x2C ...desc });\n      if (varargsMethods.includes(name)) {\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\n          __proto__: null\x2C\n          value: applyBind(value)\x2C\n        });\n      }\n    }\n  }\n}\n\n// Create copies of configurable value properties of the global object\n[\n  'Proxy'\x2C\n  'globalThis'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  primordials[name] = globalThis[name];\n});\n\n// Create copies of URI handling functions\n[\n  decodeURI\x2C\n  decodeURIComponent\x2C\n  encodeURI\x2C\n  encodeURIComponent\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of legacy functions\n[\n  escape\x2C\n  eval\x2C\n  unescape\x2C\n].forEach((fn) => {\n  primordials[fn.name] = fn;\n});\n\n// Create copies of the namespace objects\n[\n  'JSON'\x2C\n  'Math'\x2C\n  'Proxy'\x2C\n  'Reflect'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  copyPropsRenamed(globalThis[name]\x2C primordials\x2C name);\n});\n\n// Create copies of intrinsic objects\n[\n  'AggregateError'\x2C\n  'Array'\x2C\n  'ArrayBuffer'\x2C\n  'BigInt'\x2C\n  'BigInt64Array'\x2C\n  'BigUint64Array'\x2C\n  'Boolean'\x2C\n  'DataView'\x2C\n  'Date'\x2C\n  'Error'\x2C\n  'EvalError'\x2C\n  'FinalizationRegistry'\x2C\n  'Float32Array'\x2C\n  'Float64Array'\x2C\n  'Function'\x2C\n  'Int16Array'\x2C\n  'Int32Array'\x2C\n  'Int8Array'\x2C\n  'Map'\x2C\n  'Number'\x2C\n  'Object'\x2C\n  'RangeError'\x2C\n  'ReferenceError'\x2C\n  'RegExp'\x2C\n  'Set'\x2C\n  'String'\x2C\n  'Symbol'\x2C\n  'SyntaxError'\x2C\n  'TypeError'\x2C\n  'URIError'\x2C\n  'Uint16Array'\x2C\n  'Uint32Array'\x2C\n  'Uint8Array'\x2C\n  'Uint8ClampedArray'\x2C\n  'WeakMap'\x2C\n  'WeakRef'\x2C\n  'WeakSet'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamed(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise'\x2C\n].forEach((name) => {\n  // eslint-disable-next-line no-restricted-globals\n  const original = globalThis[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n// Create copies of abstract intrinsic objects that are not directly exposed\n// on the global object.\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\n[\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\n  { name: 'ArrayIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n  { name: 'StringIterator'\x2C original: {\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\n  } }\x2C\n].forEach(({ name\x2C original }) => {\n  primordials[name] = original;\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\n  // as they need a subclass constructor as the receiver:\n  copyPrototype(original\x2C primordials\x2C name);\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\n});\n\n/* eslint-enable node-core/prefer-primordials */\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  FinalizationRegistry\x2C\n  FunctionPrototypeCall\x2C\n  Map\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  Set\x2C\n  SymbolIterator\x2C\n  WeakMap\x2C\n  WeakRef\x2C\n  WeakSet\x2C\n} = primordials;\n\n// Because these functions are used by `makeSafe`\x2C which is exposed\n// on the `primordials` object\x2C it's important to use const references\n// to the primordials that they use:\nconst createSafeIterator = (factory\x2C next) => {\n  class SafeIterator {\n    constructor(iterable) {\n      this._iterator = factory(iterable);\n    }\n    next() {\n      return next(this._iterator);\n    }\n    [SymbolIterator]() {\n      return this;\n    }\n  }\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\n  ObjectFreeze(SafeIterator.prototype);\n  ObjectFreeze(SafeIterator);\n  return SafeIterator;\n};\n\nprimordials.SafeArrayIterator = createSafeIterator(\n  primordials.ArrayPrototypeSymbolIterator\x2C\n  primordials.ArrayIteratorPrototypeNext\n);\nprimordials.SafeStringIterator = createSafeIterator(\n  primordials.StringPrototypeSymbolIterator\x2C\n  primordials.StringIteratorPrototypeNext\n);\n\nconst copyProps = (src\x2C dest) => {\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\n      ReflectDefineProperty(\n        dest\x2C\n        key\x2C\n        { __proto__: null\x2C ...ReflectGetOwnPropertyDescriptor(src\x2C key) });\n    }\n  });\n};\n\n/**\n * @type {typeof primordials.makeSafe}\n */\nconst makeSafe = (unsafe\x2C safe) => {\n  if (SymbolIterator in unsafe.prototype) {\n    const dummy = new unsafe();\n    let next; // We can reuse the same `next` method.\n\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\n        if (\n          typeof desc.value === 'function' &&\n          desc.value.length === 0 &&\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\n        ) {\n          const createIterator = uncurryThis(desc.value);\n          next ??= uncurryThis(createIterator(dummy).next);\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\n          desc.value = function() {\n            return new SafeIterator(this);\n          };\n        }\n        ReflectDefineProperty(safe.prototype\x2C key\x2C { __proto__: null\x2C ...desc });\n      }\n    });\n  } else {\n    copyProps(unsafe.prototype\x2C safe.prototype);\n  }\n  copyProps(unsafe\x2C safe);\n\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\n  ObjectFreeze(safe.prototype);\n  ObjectFreeze(safe);\n  return safe;\n};\nprimordials.makeSafe = makeSafe;\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\n// Defining the `constructor` is necessary here to avoid the default\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\nprimordials.SafeMap = makeSafe(\n  Map\x2C\n  class SafeMap extends Map {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap\x2C\n  class SafeWeakMap extends WeakMap {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeSet = makeSafe(\n  Set\x2C\n  class SafeSet extends Set {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\nprimordials.SafeWeakSet = makeSafe(\n  WeakSet\x2C\n  class SafeWeakSet extends WeakSet {\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  }\n);\n\nprimordials.SafeFinalizationRegistry = makeSafe(\n  FinalizationRegistry\x2C\n  class SafeFinalizationRegistry extends FinalizationRegistry {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(cleanupCallback) { super(cleanupCallback); }\n  }\n);\nprimordials.SafeWeakRef = makeSafe(\n  WeakRef\x2C\n  class SafeWeakRef extends WeakRef {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(target) { super(target); }\n  }\n);\n\nconst SafePromise = makeSafe(\n  Promise\x2C\n  class SafePromise extends Promise {\n    // eslint-disable-next-line no-useless-constructor\n    constructor(executor) { super(executor); }\n  }\n);\n\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\n\n/**\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\n * rejected). The resolved value cannot be modified from the callback.\n * Prefer using async functions when possible.\n * @param {Promise<any>} thisPromise\n * @param {() => void) | undefined | null} onFinally The callback to execute\n *        when the Promise is settled (fulfilled or rejected).\n * @returns {Promise} A Promise for the completion of the callback.\n */\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\n      .finally(onFinally)\n      .then(a\x2C b)\n  );\n\nprimordials.AsyncIteratorPrototype =\n  primordials.ReflectGetPrototypeOf(\n    primordials.ReflectGetPrototypeOf(\n      async function* () {}).prototype);\n\nconst arrayToSafePromiseIterable = (promises\x2C mapFn) =>\n  new primordials.SafeArrayIterator(\n    ArrayPrototypeMap(\n      promises\x2C\n      (promise\x2C i) =>\n        new SafePromise((a\x2C b) => PromisePrototypeThen(mapFn == null ? promise : mapFn(promise\x2C i)\x2C a\x2C b))\n    )\n  );\n\n/**\n * @param {Promise<any>[]} promises\n * @param {(v: Promise<any>\x2C k: number) => Promise<any>} [mapFn]\n * @returns {Promise<any[]>}\n */\nprimordials.SafePromiseAll = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.all(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\n  );\n\n/**\n * @param {Promise<any>[]} promises\n * @param {(v: Promise<any>\x2C k: number) => Promise<any>} [mapFn]\n * @returns {Promise<PromiseSettledResult<any>[]>}\n */\nprimordials.SafePromiseAllSettled = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.allSettled(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\n  );\n\n/**\n * @param {Promise<any>[]} promises\n * @param {(v: Promise<any>\x2C k: number) => Promise<any>} [mapFn]\n * @returns {Promise<any>}\n */\nprimordials.SafePromiseAny = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.any(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\n  );\n\n/**\n * @param {Promise<any>[]} promises\n * @param {(v: Promise<any>\x2C k: number) => Promise<any>} [mapFn]\n * @returns {Promise<any>}\n */\nprimordials.SafePromiseRace = (promises\x2C mapFn) =>\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\n  // prototype to user-land.\n  new Promise((a\x2C b) =>\n    SafePromise.race(arrayToSafePromiseIterable(promises\x2C mapFn)).then(a\x2C b)\n  );\n\n\nObjectSetPrototypeOf(primordials\x2C null);\nObjectFreeze(primordials);\n
code-source-info,0xb46f7dffae0,12,10601,10618,C3O10607C7O10613C11O10607C26O10617,,
tick,0x7ff805db17b2,73511,0,0x0,3,0x102d5e910,0xb46f7dff539,0xb46f7dfd43d,0xb46f7df71bc,0xb46f7df2e25,0xb46f7dee5f7
tick,0x1030e25c2,73623,0,0x0,0,0xb46f7dff539,0xb46f7dfd43d,0xb46f7df71bc,0xb46f7df2e25,0xb46f7dee5f7
code-creation,LazyCompile,10,73684,0xb469fbc21e8,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:157:33,0xb46f7df0730,~
code-source-info,0xb469fbc21e8,389,4990,5238,C16O5042C21O5042C26O5068C28O5085C36O5115C43O5201C49O5219C56O5085C62O5237,,
code-creation,LazyCompile,10,73743,0xb469fbc2350,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:335:33,0xb46f7df0b50,~
code-source-info,0xb469fbc2350,389,10062,10289,C0O10104C6O10104C11O10077C16O10176C22O10176C27O10147C32O10218C35O10243C40O10218C45O10288,,
code-creation,LazyCompile,10,73792,0xb469fbc24e8,77,toggleTraceCategoryState node:internal/process/per_thread:397:34,0xb46d2c8a1d8,~
code-source-info,0xb469fbc24e8,36,11365,11662,C0O11389C4O11418C10O11453C16O11484C21O11528C26O11529C33O11474C39O11553C44O11574C49O11574C55O11593C61O11625C66O11646C71O11646C76O11661,,
code-creation,LazyCompile,10,73831,0xb469fbc2698,42,setupPerfHooks node:internal/bootstrap/pre_execution:341:24,0xb46f7df0ba0,~
code-source-info,0xb469fbc2698,389,10314,10434,C0O10321C6O10321C11O10357C16O10358C20O10381C26O10381C31O10411C36O10412C41O10433,,
code-creation,LazyCompile,10,73875,0xb469fbc2820,42,refreshTimeOrigin node:internal/perf/performance:217:27,0xb462a87e1f0,~
script-source,115,node:internal/perf/performance,'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\n\nconst {\n  EventTarget\x2C\n} = require('internal/event_target');\n\nconst { now } = require('internal/perf/utils');\n\nconst { markResourceTiming } = require('internal/perf/resource_timing');\n\nconst {\n  mark\x2C\n  measure\x2C\n  clearMarkTimings\x2C\n} = require('internal/perf/usertiming');\nconst {\n  clearEntriesFromBuffer\x2C\n  filterBufferMapByNameAndType\x2C\n} = require('internal/perf/observe');\n\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\nconst nodeTiming = require('internal/perf/nodetiming');\nconst timerify = require('internal/perf/timerify');\nconst { customInspectSymbol: kInspect } = require('internal/util');\nconst { inspect } = require('util');\n\nconst {\n  getTimeOriginTimestamp\n} = internalBinding('performance');\n\nclass Performance extends EventTarget {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0) return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `Performance ${inspect({\n      nodeTiming: this.nodeTiming\x2C\n      timeOrigin: this.timeOrigin\x2C\n    }\x2C opts)}`;\n  }\n}\n\nfunction toJSON() {\n  return {\n    nodeTiming: this.nodeTiming\x2C\n    timeOrigin: this.timeOrigin\x2C\n    eventLoopUtilization: this.eventLoopUtilization()\n  };\n}\n\nfunction clearMarks(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearMarkTimings(name);\n  clearEntriesFromBuffer('mark'\x2C name);\n}\n\nfunction clearMeasures(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('measure'\x2C name);\n}\n\nfunction clearResourceTimings(name) {\n  if (name !== undefined) {\n    name = `${name}`;\n  }\n  clearEntriesFromBuffer('resource'\x2C name);\n}\n\nfunction getEntries() {\n  return filterBufferMapByNameAndType();\n}\n\nfunction getEntriesByName(name) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('name');\n  }\n  name = `${name}`;\n  return filterBufferMapByNameAndType(name\x2C undefined);\n}\n\nfunction getEntriesByType(type) {\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('type');\n  }\n  type = `${type}`;\n  return filterBufferMapByNameAndType(undefined\x2C type);\n}\n\nclass InternalPerformance extends EventTarget {}\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\n\nObjectDefineProperties(Performance.prototype\x2C {\n  clearMarks: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMarks\x2C\n  }\x2C\n  clearMeasures: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearMeasures\x2C\n  }\x2C\n  clearResourceTimings: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: clearResourceTimings\x2C\n  }\x2C\n  eventLoopUtilization: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: eventLoopUtilization\x2C\n  }\x2C\n  getEntries: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntries\x2C\n  }\x2C\n  getEntriesByName: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByName\x2C\n  }\x2C\n  getEntriesByType: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: getEntriesByType\x2C\n  }\x2C\n  mark: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: mark\x2C\n  }\x2C\n  measure: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: measure\x2C\n  }\x2C\n  nodeTiming: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: nodeTiming\x2C\n  }\x2C\n  // In the browser\x2C this function is not public.  However\x2C it must be used inside fetch\n  // which is a Node.js dependency\x2C not a internal module\n  markResourceTiming: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: markResourceTiming\x2C\n  }\x2C\n  now: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: now\x2C\n  }\x2C\n  timerify: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: false\x2C\n    value: timerify\x2C\n  }\x2C\n  // This would be updated during pre-execution in case\n  // the process is launched from a snapshot.\n  // TODO(joyeecheung): we may want to warn about access to\n  // this during snapshot building.\n  timeOrigin: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  }\x2C\n  toJSON: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: toJSON\x2C\n  }\n});\n\nfunction refreshTimeOrigin() {\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    value: getTimeOriginTimestamp()\x2C\n  });\n}\n\nmodule.exports = {\n  InternalPerformance\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0xb469fbc2820,115,4753,4931,C0O4760C7O4781C10O4793C25O4898C28O4898C35O4760C41O4930,,
code-creation,LazyCompile,10,74515,0xb469fbc3078,19,refreshTimeOrigin node:internal/perf/utils:25:27,0xb46d2cb0e48,~
script-source,50,node:internal/perf/utils,'use strict';\n\nconst binding = internalBinding('performance');\nconst {\n  milestones\x2C\n  getTimeOrigin\x2C\n} = binding;\n\n// TODO(joyeecheung): we may want to warn about access to\n// this during snapshot building.\nlet timeOrigin = getTimeOrigin();\n\nfunction now() {\n  const hr = process.hrtime();\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\n}\n\nfunction getMilestoneTimestamp(milestoneIdx) {\n  const ns = milestones[milestoneIdx];\n  if (ns === -1)\n    return ns;\n  return ns / 1e6 - timeOrigin;\n}\n\nfunction refreshTimeOrigin() {\n  timeOrigin = getTimeOrigin();\n}\n\nmodule.exports = {\n  now\x2C\n  getMilestoneTimestamp\x2C\n  refreshTimeOrigin\n};\n
code-source-info,0xb469fbc3078,50,525,563,C0O532C5O545C11O543C18O562,,
code-creation,LazyCompile,10,74630,0xb469fbc32e8,62,setupInspectorHooks node:internal/bootstrap/pre_execution:346:29,0xb46f7df0bf0,~
code-source-info,0xb469fbc32e8,389,10464,11017,C0O10807C6O10811C11O10836C17O10901C23O10901C28O10871C33O10885C38O10947C44O10947C49O10975C54O10976C61O11016,,
code-creation,Eval,10,74733,0xb469fbc3688,5, node:internal/inspector_async_hook:1:1,0xb469fbc34d0,~
script-source,390,node:internal/inspector_async_hook,'use strict';\n\nlet hook;\nlet config;\n\nconst {\n  SafeSet\x2C\n} = primordials;\n\nfunction lazyHookCreation() {\n  const inspector = internalBinding('inspector');\n  const { createHook } = require('async_hooks');\n  config = internalBinding('config');\n\n  hook = createHook({\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\n    // therefore we mark all tasks as recurring. Based on the discussion\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\n    // this should be fine as long as we call asyncTaskCanceled() too.\n      const recurring = true;\n      if (type === 'PROMISE')\n        this.promiseIds.add(asyncId);\n      else\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\n    }\x2C\n\n    before(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskStarted(asyncId);\n    }\x2C\n\n    after(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return;\n      inspector.asyncTaskFinished(asyncId);\n    }\x2C\n\n    destroy(asyncId) {\n      if (this.promiseIds.has(asyncId))\n        return this.promiseIds.delete(asyncId);\n      inspector.asyncTaskCanceled(asyncId);\n    }\x2C\n  });\n\n  hook.promiseIds = new SafeSet();\n}\n\nfunction enable() {\n  if (hook === undefined) lazyHookCreation();\n  if (config.bits < 64) {\n    // V8 Inspector stores task ids as (void*) pointers.\n    // async_hooks store ids as 64bit numbers.\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\n    // ids on 32bit platforms.\n    process.emitWarning(\n      'Warning: Async stack traces in debugger are not available ' +\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\n      {\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\n      });\n  } else {\n    hook.enable();\n  }\n}\n\nfunction disable() {\n  if (hook === undefined) lazyHookCreation();\n  hook.disable();\n}\n\nmodule.exports = {\n  enable\x2C\n  disable\n};\n
code-source-info,0xb469fbc3688,390,0,1972,C0O0C4O1972,,
code-creation,Function,10,75017,0xb469fbc38a8,79, node:internal/inspector_async_hook:1:1,0xb469fbc3600,~
code-source-info,0xb469fbc38a8,390,0,1972,C0O0C42O19C43O19C45O29C46O29C48O48C54O1930C61O1951C67O1961C73O1945C78O1971,,
tick,0x7ff805e2d43e,75047,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0xb46f7dee877,0xb469fbc32ff,0xb46f7df2e38,0xb46f7dee5f7
code-creation,LazyCompile,10,75116,0xb469fbc3da0,69,setupWarningHandler node:internal/bootstrap/pre_execution:170:29,0xb46f7df0780,~
code-source-info,0xb469fbc3da0,389,5268,5465,C0O5303C6O5303C11O5287C16O5342C24O5346C33O5390C38O5394C45O5411C50O5426C53O5434C61O5434C68O5464,,
new,MemoryChunk,0xb46bbe40000,262144
new,MemoryChunk,0x113240000,262144
code-creation,Function,11,75324,0x113243080,556,getOptionValue node:internal/options:44:24,0xb46806bdc78,^
code-source-info,0x113243080,88,985,1228,,,
code-creation,Function,11,75353,0x113243340,104,isPosixPathSeparator node:path:56:30,0xb46806ac8e8,^
code-source-info,0x113243340,71,1854,1902,,,
code-creation,Function,11,75403,0x113243440,3008,normalizeString node:path:66:25,0xb46806ac988,^
code-source-info,0x113243440,71,2161,4085,,,
code-creation,Function,11,75427,0x113244080,628,nativeModuleRequire node:internal/bootstrap/loaders:349:29,0xb466514b8b0,^
code-source-info,0x113244080,15,10778,11121,,,
code-creation,LazyCompile,10,75514,0xb469fbc4238,20,addListener node:events:604:58,0xb469fce2ed0,~
script-source,29,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Boolean\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  PromiseReject\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeSplit\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolAsyncIterator\x2C\n} = primordials;\nconst kRejection = SymbolFor('nodejs.rejection');\n\nconst { kEmptyObject } = require('internal/util');\n\nconst {\n  inspect\x2C\n  identicalSequenceRange\x2C\n} = require('internal/util/inspect');\n\nlet spliceOne;\n\nconst {\n  AbortError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_UNHANDLED_ERROR\n  }\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\n\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\nlet EventEmitterAsyncResource;\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\n// is loaded so early in the bootstrap process\x2C before async_hooks is available.\n//\n// This implementation was adapted straight from addaleax's\n// eventemitter-asyncresource MIT-licensed userland module.\n// https://github.com/addaleax/eventemitter-asyncresource\nfunction lazyEventEmitterAsyncResource() {\n  if (EventEmitterAsyncResource === undefined) {\n    const {\n      AsyncResource\n    } = require('async_hooks');\n\n    const kEventEmitter = Symbol('kEventEmitter');\n    const kAsyncResource = Symbol('kAsyncResource');\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\n      /**\n       * @param {EventEmitter} ee\n       * @param {string} [type]\n       * @param {{\n       *   triggerAsyncId?: number\x2C\n       *   requireManualDestroy?: boolean\x2C\n       * }} [options]\n       */\n      constructor(ee\x2C type\x2C options) {\n        super(type\x2C options);\n        this[kEventEmitter] = ee;\n      }\n\n      /**\n       * @type {EventEmitter}\n       */\n      get eventEmitter() {\n        if (this[kEventEmitter] === undefined)\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\n        return this[kEventEmitter];\n      }\n    }\n\n    EventEmitterAsyncResource =\n      class EventEmitterAsyncResource extends EventEmitter {\n        /**\n         * @param {{\n         *   name?: string\x2C\n         *   triggerAsyncId?: number\x2C\n         *   requireManualDestroy?: boolean\x2C\n         * }} [options]\n         */\n        constructor(options = undefined) {\n          let name;\n          if (typeof options === 'string') {\n            name = options;\n            options = undefined;\n          } else {\n            if (new.target === EventEmitterAsyncResource) {\n              validateString(options?.name\x2C 'options.name');\n            }\n            name = options?.name || new.target.name;\n          }\n          super(options);\n\n          this[kAsyncResource] =\n            new EventEmitterReferencingAsyncResource(this\x2C name\x2C options);\n        }\n\n        /**\n         * @param {symbol\x2Cstring} event\n         * @param  {...any} args\n         * @returns {boolean}\n         */\n        emit(event\x2C ...args) {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          const { asyncResource } = this;\n          ArrayPrototypeUnshift(args\x2C super.emit\x2C this\x2C event);\n          return ReflectApply(asyncResource.runInAsyncScope\x2C asyncResource\x2C\n                              args);\n        }\n\n        /**\n         * @returns {void}\n         */\n        emitDestroy() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          this.asyncResource.emitDestroy();\n        }\n\n        /**\n         * @type {number}\n         */\n        get asyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.asyncId();\n        }\n\n        /**\n         * @type {number}\n         */\n        get triggerAsyncId() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this.asyncResource.triggerAsyncId();\n        }\n\n        /**\n         * @type {EventEmitterReferencingAsyncResource}\n         */\n        get asyncResource() {\n          if (this[kAsyncResource] === undefined)\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\n          return this[kAsyncResource];\n        }\n      };\n  }\n  return EventEmitterAsyncResource;\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this\x2C opts);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\nmodule.exports.on = on;\nmodule.exports.getEventListeners = getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\n  __proto__: null\x2C\n  get() {\n    return EventEmitter.prototype[kCapture];\n  }\x2C\n  set(value) {\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  }\x2C\n  enumerable: true\n});\n\nObjectDefineProperty(EventEmitter\x2C 'EventEmitterAsyncResource'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get: lazyEventEmitterAsyncResource\x2C\n  set: undefined\x2C\n  configurable: true\x2C\n});\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\n  __proto__: null\x2C\n  value: false\x2C\n  writable: true\x2C\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\nlet isEventTarget;\n\nfunction checkListener(listener) {\n  validateFunction(listener\x2C 'listener');\n}\n\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get: function() {\n    return defaultMaxListeners;\n  }\x2C\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\n                                 'a non-negative number'\x2C\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter\x2C {\n  kMaxEventTargetListeners: {\n    __proto__: null\x2C\n    value: kMaxEventTargetListeners\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\x2C\n  kMaxEventTargetListenersWarned: {\n    __proto__: null\x2C\n    value: kMaxEventTargetListenersWarned\x2C\n    enumerable: false\x2C\n    configurable: false\x2C\n    writable: false\x2C\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      if (isEventTarget === undefined)\n        isEventTarget = require('internal/event_target').isEventTarget;\n\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets'\x2C\n            ['EventEmitter'\x2C 'EventTarget']\x2C\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition\x2C please also update any\n// re-definitions\x2C such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (opts?.captureRejections) {\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec\x2C then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise\x2C undefined\x2C function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\n      });\n    }\n  } catch (err) {\n    that.emit('error'\x2C err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err\x2C type\x2C ...args);\n  } else {\n    // We have to disable the capture rejections mechanism\x2C otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws\x2C it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error'\x2C err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nfunction enhanceStackTrace(err\x2C own) {\n  let ctorInfo = '';\n  try {\n    const { name } = this.constructor;\n    if (name !== 'EventEmitter')\n      ctorInfo = ` on ${name} instance`;\n  } catch {\n    // Continue regardless of error.\n  }\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\n\n  const errStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\n  const ownStack = ArrayPrototypeSlice(\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\n\n  const { len\x2C offset } = identicalSequenceRange(ownStack\x2C errStack);\n  if (len > 0) {\n    ArrayPrototypeSplice(ownStack\x2C offset + 1\x2C len - 2\x2C\n                         '    [... lines matching original stack trace ...]');\n  }\n\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\n}\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor\x2C ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\n          __proto__: null\x2C\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\n          configurable: true\n        });\n      } catch {\n        // Continue regardless of error.\n      }\n\n      // Note: The comments on the `throw` lines are intentional\x2C they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this\x2C args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this\x2C result\x2C type\x2C args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this\x2C args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this\x2C result\x2C type\x2C args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === "newListener"! Before\n    // adding it to the listeners\x2C first emit "newListener".\n    if (events.newListener !== undefined) {\n      target.emit('newListener'\x2C type\x2C\n                  listener.listener ?? listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element\x2C need to change to array.\n      existing = events[type] =\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\n      // If we've already got an array\x2C just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      const w = genericNodeError(\n        `Possible EventEmitter memory leak detected. ${existing.length} ${String(type)} listeners ` +\n        `added to ${inspect(target\x2C { depth: -1 })}. Use emitter.setMaxListeners() to increase limit`\x2C\n        { name: 'MaxListenersExceededWarning'\x2C emitter: target\x2C type: type\x2C count: existing.length });\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\n  return _addListener(this\x2C type\x2C listener\x2C false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type\x2C listener) {\n      return _addListener(this\x2C type\x2C listener\x2C true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type\x2C this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target\x2C arguments);\n  }\n}\n\nfunction _onceWrap(target\x2C type\x2C listener) {\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type\x2C listener) {\n  checkListener(listener);\n\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type\x2C listener) {\n      checkListener(listener);\n\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\n      return this;\n    };\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type\x2C listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          if (spliceOne === undefined)\n            spliceOne = require('internal/util').spliceOne;\n          spliceOne(list\x2C position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener'\x2C type\x2C listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener\x2C no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type\x2C listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type\x2C listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target\x2C type\x2C unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this\x2C type\x2C true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this\x2C type\x2C false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter\x2C type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3\x2C this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0]\x2C arr[1]];\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {EventEmitter | EventTarget} emitterOrTarget\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nfunction getEventListeners(emitterOrTarget\x2C type) {\n  // First check if EventEmitter\n  if (typeof emitterOrTarget.listeners === 'function') {\n    return emitterOrTarget.listeners(type);\n  }\n  // Require event target lazily to avoid always loading it\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\n  if (isEventTarget(emitterOrTarget)) {\n    const root = emitterOrTarget[kEvents].get(type);\n    const listeners = [];\n    let handler = root?.next;\n    while (handler?.listener !== undefined) {\n      const listener = handler.listener?.deref ?\n        handler.listener.deref() : handler.listener;\n      listeners.push(listener);\n      handler = handler.next;\n    }\n    return listeners;\n  }\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\n                                 emitterOrTarget);\n}\n\n/**\n * Creates a `Promise` that is fulfilled when the emitter\n * emits the given event.\n * @param {EventEmitter} emitter\n * @param {string} name\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {Promise}\n */\nasync function once(emitter\x2C name\x2C options = kEmptyObject) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n  return new Promise((resolve\x2C reject) => {\n    const errorListener = (err) => {\n      emitter.removeListener(name\x2C resolver);\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      reject(err);\n    };\n    const resolver = (...args) => {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error'\x2C errorListener);\n      }\n      if (signal != null) {\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\n      }\n      resolve(args);\n    };\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\n    if (name !== 'error' && typeof emitter.once === 'function') {\n      // EventTarget does not have `error` event semantics like Node\n      // EventEmitters\x2C we listen to `error` events only on EventEmitters.\n      emitter.once('error'\x2C errorListener);\n    }\n    function abortListener() {\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\n      reject(new AbortError(undefined\x2C { cause: signal?.reason }));\n    }\n    if (signal != null) {\n      eventTargetAgnosticAddListener(\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\n    }\n  });\n}\n\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf(async function* () {}).prototype);\n\nfunction createIterResult(value\x2C done) {\n  return { value\x2C done };\n}\n\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.removeListener === 'function') {\n    emitter.removeListener(name\x2C listener);\n  } else if (typeof emitter.removeEventListener === 'function') {\n    emitter.removeEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags?.once) {\n      emitter.once(name\x2C listener);\n    } else {\n      emitter.on(name\x2C listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    emitter.addEventListener(name\x2C listener\x2C flags);\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\n  }\n}\n\n/**\n * Returns an `AsyncIterator` that iterates `event` events.\n * @param {EventEmitter} emitter\n * @param {string | symbol} event\n * @param {{ signal: AbortSignal; }} [options]\n * @returns {AsyncIterator}\n */\nfunction on(emitter\x2C event\x2C options) {\n  const signal = options?.signal;\n  validateAbortSignal(signal\x2C 'options.signal');\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n\n  const unconsumedEvents = [];\n  const unconsumedPromises = [];\n  let error = null;\n  let finished = false;\n\n  const iterator = ObjectSetPrototypeOf({\n    next() {\n      // First\x2C we consume all unread events\n      const value = unconsumedEvents.shift();\n      if (value) {\n        return PromiseResolve(createIterResult(value\x2C false));\n      }\n\n      // Then we error\x2C if an error happened\n      // This happens one time if at all\x2C because after 'error'\n      // we stop listening\n      if (error) {\n        const p = PromiseReject(error);\n        // Only the first element errors\n        error = null;\n        return p;\n      }\n\n      // If the iterator is finished\x2C resolve to done\n      if (finished) {\n        return PromiseResolve(createIterResult(undefined\x2C true));\n      }\n\n      // Wait until an event happens\n      return new Promise(function(resolve\x2C reject) {\n        unconsumedPromises.push({ resolve\x2C reject });\n      });\n    }\x2C\n\n    return() {\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n\n      if (signal) {\n        eventTargetAgnosticRemoveListener(\n          signal\x2C\n          'abort'\x2C\n          abortListener\x2C\n          { once: true });\n      }\n\n      finished = true;\n\n      for (const promise of unconsumedPromises) {\n        promise.resolve(createIterResult(undefined\x2C true));\n      }\n\n      return PromiseResolve(createIterResult(undefined\x2C true));\n    }\x2C\n\n    throw(err) {\n      if (!err || !(err instanceof Error)) {\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\n                                       'Error'\x2C err);\n      }\n      error = err;\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\n    }\x2C\n\n    [SymbolAsyncIterator]() {\n      return this;\n    }\n  }\x2C AsyncIteratorPrototype);\n\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\n  if (event !== 'error' && typeof emitter.on === 'function') {\n    emitter.on('error'\x2C errorHandler);\n  }\n\n  if (signal) {\n    eventTargetAgnosticAddListener(\n      signal\x2C\n      'abort'\x2C\n      abortListener\x2C\n      { once: true });\n  }\n\n  return iterator;\n\n  function abortListener() {\n    errorHandler(new AbortError(undefined\x2C { cause: signal?.reason }));\n  }\n\n  function eventHandler(...args) {\n    const promise = ArrayPrototypeShift(unconsumedPromises);\n    if (promise) {\n      promise.resolve(createIterResult(args\x2C false));\n    } else {\n      unconsumedEvents.push(args);\n    }\n  }\n\n  function errorHandler(err) {\n    finished = true;\n\n    const toError = ArrayPrototypeShift(unconsumedPromises);\n\n    if (toError) {\n      toError.reject(err);\n    } else {\n      // The next time we call next()\n      error = err;\n    }\n\n    iterator.return();\n  }\n}\n
code-source-info,0xb469fbc4238,29,17710,17782,C0O17731C14O17738C19O17780,,
tick,0x7ff805e4dd18,79138,0,0x0,3,0x102d5e910,0xb469fbc3ddd,0xb46f7df2e3e,0xb46f7dee5f7
tick,0x7ff805ea4dea,79146,0,0x0,3,0x102d5e910,0xb469fbc3ddd,0xb46f7df2e3e,0xb46f7dee5f7
tick,0x7ff805dd2b69,79153,0,0x0,3,0x102d5e910,0xb469fbc3ddd,0xb46f7df2e3e,0xb46f7dee5f7
code-creation,LazyCompile,10,79193,0xb469fbc6890,378,_addListener node:events:541:22,0xb469fce2e30,~
code-source-info,0xb469fbc6890,29,15640,17512,C0O15682C2O15691C4O15705C6O15718C9O15718C13O15762C18O15773C20O15805C22O15831C27O15831C32O15829C39O15855C40O15875C46O16041C52O16083C60O16136C77O16083C82O16315C87O16334C89O16351C93O16366C97O16477C99O16490C103O16506C109O16515C115O16544C121O16649C129O16683C140O16694C149O16704C166O16717C175O16727C182O16673C193O16802C197O16832C202O16832C209O16879C214O16879C219O16937C222O16941C227O16971C228O16977C233O16993C240O17000C245O17017C251O17033C252O17049C256O17127C264O17209C281O17219C284O17219C304O17267C307O17275C312O17267C327O17245C338O17406C344O17420C348O17442C356O17127C362O17459C365O17467C370O17467C375O17496C377O17510,,
code-creation,LazyCompile,10,79266,0xb469fbc6ba8,15,checkListener node:events:265:23,0xb469fce2848,~
code-source-info,0xb469fbc6ba8,29,7730,7786,C0O7745C8O7745C14O7785,,
code-creation,LazyCompile,10,79296,0xb469fbc6c98,30, node:internal/validators:240:42,0xb466517a9d0,~
code-source-info,0xb469fbc6c98,22,7399,7515,C0O7420C6O7457C22O7463C27O7457C29O7514,,
code-creation,LazyCompile,10,79388,0xb469fbc6ef8,380,emit node:events:460:44,0xb469fce2d90,~
code-source-info,0xb469fbc6ef8,29,13327,15616,C0O13327C8O13361C10O13367C14O13404C19O13415C21O13447C27O13469C29O13468C34O13510C41O13515C51O13510C56O13544C60O13573C68O13604C72O13622C73O13635C74O13694C78O13717C80O13734C86O13741C91O13752C92O13761C96O13770C98O13788C100O13777C108O13833C110O13845C120O13890C126O13900C132O13845C137O13915C145O13940C157O14016C174O14016C186O13915C197O14338C199O14338C200O14390C205O14421C211O14437C219O14435C220O14470C225O14567C232O14567C238O14611C240O14623C244O14633C246O14633C247O14694C249O14700C253O14711C255O14742C256O14755C257O14759C263O14823C268O14823C275O14977C281O15030C296O15030C303O15107C308O15137C311O15137C316O15175C318O15180C320O15180C325O15215C327O15224C332O15228C337O15228C344O15490C350O15545C365O15545C370O15189C375O15162C378O15602C379O15614,,
code-creation,LazyCompile,10,79489,0xb469fbc7298,172,startListeningIfSignal node:internal/process/signal:22:32,0xb46634f98e0,~
script-source,129,node:internal/process/signal,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n} = require('internal/errors');\n\nconst { signals } = internalBinding('constants').os;\n\nlet Signal;\nconst signalWraps = new SafeMap();\n\nfunction isSignal(event) {\n  return typeof event === 'string' && signals[event] !== undefined;\n}\n\n// Detect presence of a listener for the special signal types\nfunction startListeningIfSignal(type) {\n  if (isSignal(type) && !signalWraps.has(type)) {\n    if (Signal === undefined)\n      Signal = internalBinding('signal_wrap').Signal;\n    const wrap = new Signal();\n\n    wrap.unref();\n\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\n\n    const signum = signals[type];\n    const err = wrap.start(signum);\n    if (err) {\n      wrap.close();\n      throw errnoException(err\x2C 'uv_signal_start');\n    }\n\n    signalWraps.set(type\x2C wrap);\n  }\n}\n\nfunction stopListeningIfSignal(type) {\n  const wrap = signalWraps.get(type);\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\n    wrap.close();\n    signalWraps.delete(type);\n  }\n}\n\nmodule.exports = {\n  startListeningIfSignal\x2C\n  stopListeningIfSignal\n};\n
code-source-info,0xb469fbc7298,129,429,904,C0O440C3O444C11O463C14O475C19O475C26O492C32O524C38O533C43O563C50O531C56O589C61O589C67O613C72O613C76O627C78O643C84O673C98O643C103O641C107O721C114O728C118O757C123O757C129O776C131O798C136O798C140O813C148O819C153O813C154O870C159O882C164O882C171O903,,
code-creation,LazyCompile,10,79677,0xb469fbc7658,19,isSignal node:internal/process/signal:17:18,0xb46634f9778,~
code-source-info,0xb469fbc7658,129,255,334,C0O267C8O303C13O310C17O318C18O332,,
code-creation,LazyCompile,10,79737,0xb469fbc7a58,202,setupFetch node:internal/bootstrap/pre_execution:181:20,0xb46f7df07d0,~
code-source-info,0xb469fbc7a58,389,5520,6677,C0O5520C24O5527C29O5539C34O5546C39O5556C49O5589C55O5589C61O5638C62O5645C63O5657C64O5657C66O5961C77O5977C86O5961C91O6253C102O6276C113O6304C124O6344C135O6383C146O6423C154O6253C159O6566C167O6566C172O6540C177O6602C185O6602C190O6633C195O6634C201O6676,,
code-creation,LazyCompile,10,79797,0xb469fbc7cc8,5,get node:internal/bootstrap/node:139:6,0xb466514f468,~
script-source,16,node:internal/bootstrap/node,// Hello\x2C and welcome to hacking node.js!\n//\n// This file is invoked by `node::RunBootstrapping()` in `src/node.cc`\x2C and is\n// responsible for setting up node.js core before executing main scripts\n// under `lib/internal/main/`.\n//\n// This file is expected not to perform any asynchronous operations itself\n// when being executed - those should be done in either\n// `lib/internal/bootstrap/pre_execution.js` or in main scripts. The majority\n// of the code here focuses on setting up the global proxy and the process\n// object in a synchronous manner.\n// As special caution is given to the performance of the startup process\x2C\n// many dependencies are invoked lazily.\n//\n// Scripts run before this file:\n// - `lib/internal/per_context/primordials.js`: to save copies of JavaScript\n//   builtins that won't be affected by user land monkey-patching for internal\n//   modules to use.\n// - `lib/internal/bootstrap/loaders.js`: to setup internal binding and\n//   module loaders\x2C including `process.binding()`\x2C `process._linkedBinding()`\x2C\n//   `internalBinding()` and `NativeModule`.\n//\n// This file is run to bootstrap both the main thread and the worker threads.\n// After this file is run\x2C certain properties are setup according to the\n// configuration of the Node.js instance using the files in\n// `lib/internal/bootstrap/switches/`.\n//\n// Then\x2C depending on how the Node.js instance is launched\x2C one of the main\n// scripts in `lib/internal/main` will be selected by C++ to start the actual\n// execution. They may run additional setups exported by\n// `lib/internal/bootstrap/pre_execution.js` depending on the runtime states.\n\n'use strict';\n\n// This file is compiled as if it's wrapped in a function with arguments\n// passed by node::RunBootstrapping()\n/* global process\x2C require\x2C internalBinding\x2C primordials */\n\nsetupPrepareStackTrace();\n\nconst {\n  Array\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFill\x2C\n  FunctionPrototypeCall\x2C\n  JSONParse\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPreventExtensions\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectGet\x2C\n  ReflectSet\x2C\n  SymbolToStringTag\x2C\n  globalThis\x2C\n} = primordials;\nconst config = internalBinding('config');\nconst internalTimers = require('internal/timers');\nconst {\n  defineOperation\x2C\n  deprecate\x2C\n  exposeInterface\x2C\n} = require('internal/util');\n\nsetupProcessObject();\n\nsetupGlobalProxy();\nsetupBuffer();\n\nprocess.domain = null;\nprocess._exiting = false;\n\n// process.config is serialized config.gypi\nconst nativeModule = internalBinding('native_module');\n\n// TODO(@jasnell): Once this has gone through one full major\n// release cycle\x2C remove the Proxy and setter and update the\n// getter to either return a read-only object or always return\n// a freshly parsed version of nativeModule.config.\n\nconst deprecationHandler = {\n  warned: false\x2C\n  message: 'Setting process.config is deprecated. ' +\n           'In the future the property will be read-only.'\x2C\n  code: 'DEP0150'\x2C\n  maybeWarn() {\n    if (!this.warned) {\n      process.emitWarning(this.message\x2C {\n        type: 'DeprecationWarning'\x2C\n        code: this.code\n      });\n      this.warned = true;\n    }\n  }\x2C\n\n  defineProperty(target\x2C key\x2C descriptor) {\n    this.maybeWarn();\n    return ObjectDefineProperty(target\x2C key\x2C descriptor);\n  }\x2C\n\n  deleteProperty(target\x2C key) {\n    this.maybeWarn();\n    delete target[key];\n  }\x2C\n\n  preventExtensions(target) {\n    this.maybeWarn();\n    return ObjectPreventExtensions(target);\n  }\x2C\n\n  set(target\x2C key\x2C value) {\n    this.maybeWarn();\n    return ReflectSet(target\x2C key\x2C value);\n  }\x2C\n\n  get(target\x2C key\x2C receiver) {\n    const val = ReflectGet(target\x2C key\x2C receiver);\n    if (val != null && typeof val === 'object') {\n      // eslint-disable-next-line node-core/prefer-primordials\n      return new Proxy(val\x2C deprecationHandler);\n    }\n    return val;\n  }\x2C\n\n  setPrototypeOf(target\x2C proto) {\n    this.maybeWarn();\n    return ObjectSetPrototypeOf(target\x2C proto);\n  }\n};\n\n// eslint-disable-next-line node-core/prefer-primordials\nlet processConfig = new Proxy(\n  JSONParse(nativeModule.config)\x2C\n  deprecationHandler);\n\nObjectDefineProperty(process\x2C 'config'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  configurable: true\x2C\n  get() { return processConfig; }\x2C\n  set(value) {\n    deprecationHandler.maybeWarn();\n    processConfig = value;\n  }\n});\n\nrequire('internal/worker/js_transferable').setup();\n\n// Bootstrappers for all threads\x2C including worker threads and main thread\nconst perThreadSetup = require('internal/process/per_thread');\nconst rawMethods = internalBinding('process_methods');\n\n// Set up methods on the process object for all threads\n{\n  process.dlopen = rawMethods.dlopen;\n  process.uptime = rawMethods.uptime;\n\n  // TODO(joyeecheung): either remove them or make them public\n  process._getActiveRequests = rawMethods._getActiveRequests;\n  process._getActiveHandles = rawMethods._getActiveHandles;\n\n  process.getActiveResourcesInfo = function() {\n    const timerCounts = internalTimers.getTimerCounts();\n    return ArrayPrototypeConcat(\n      rawMethods._getActiveRequestsInfo()\x2C\n      rawMethods._getActiveHandlesInfo()\x2C\n      ArrayPrototypeFill(new Array(timerCounts.timeoutCount)\x2C 'Timeout')\x2C\n      ArrayPrototypeFill(new Array(timerCounts.immediateCount)\x2C 'Immediate'));\n  };\n\n  // TODO(joyeecheung): remove these\n  process.reallyExit = rawMethods.reallyExit;\n  process._kill = rawMethods._kill;\n\n  const wrapped = perThreadSetup.wrapProcessMethods(rawMethods);\n  process._rawDebug = wrapped._rawDebug;\n  process.cpuUsage = wrapped.cpuUsage;\n  process.resourceUsage = wrapped.resourceUsage;\n  process.memoryUsage = wrapped.memoryUsage;\n  process.kill = wrapped.kill;\n  process.exit = wrapped.exit;\n\n  process.hrtime = perThreadSetup.hrtime;\n  process.hrtime.bigint = perThreadSetup.hrtimeBigInt;\n\n  process.openStdin = function() {\n    process.stdin.resume();\n    return process.stdin;\n  };\n}\n\nconst credentials = internalBinding('credentials');\nif (credentials.implementsPosixCredentials) {\n  process.getuid = credentials.getuid;\n  process.geteuid = credentials.geteuid;\n  process.getgid = credentials.getgid;\n  process.getegid = credentials.getegid;\n  process.getgroups = credentials.getgroups;\n}\n\n// Setup the callbacks that node::AsyncWrap will call when there are hooks to\n// process. They use the same functions as the JS embedder API. These callbacks\n// are setup immediately to prevent async_wrap.setupHooks() from being hijacked\n// and the cost of doing so is negligible.\nconst { nativeHooks } = require('internal/async_hooks');\ninternalBinding('async_wrap').setupHooks(nativeHooks);\n\nconst {\n  setupTaskQueue\x2C\n  queueMicrotask\n} = require('internal/process/task_queues');\n\n// Non-standard extensions:\nconst { BroadcastChannel } = require('internal/worker/io');\nexposeInterface(globalThis\x2C 'BroadcastChannel'\x2C BroadcastChannel);\n\ndefineOperation(globalThis\x2C 'queueMicrotask'\x2C queueMicrotask);\n\nconst timers = require('timers');\ndefineOperation(globalThis\x2C 'clearImmediate'\x2C timers.clearImmediate);\ndefineOperation(globalThis\x2C 'setImmediate'\x2C timers.setImmediate);\n\nconst {\n  structuredClone\x2C\n} = require('internal/structured_clone');\ndefineOperation(globalThis\x2C 'structuredClone'\x2C structuredClone);\n\n// Set the per-Environment callback that will be called\n// when the TrackingTraceStateObserver updates trace state.\n// Note that when NODE_USE_V8_PLATFORM is true\x2C the observer is\n// attached to the per-process TracingController.\nconst { setTraceCategoryStateUpdateHandler } = internalBinding('trace_events');\nsetTraceCategoryStateUpdateHandler(perThreadSetup.toggleTraceCategoryState);\n\n// process.allowedNodeEnvironmentFlags\nObjectDefineProperty(process\x2C 'allowedNodeEnvironmentFlags'\x2C {\n  __proto__: null\x2C\n  get() {\n    const flags = perThreadSetup.buildAllowedFlags();\n    process.allowedNodeEnvironmentFlags = flags;\n    return process.allowedNodeEnvironmentFlags;\n  }\x2C\n  // If the user tries to set this to another value\x2C override\n  // this completely to that value.\n  set(value) {\n    ObjectDefineProperty(this\x2C 'allowedNodeEnvironmentFlags'\x2C {\n      __proto__: null\x2C\n      value\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      writable: true\n    });\n  }\x2C\n  enumerable: true\x2C\n  configurable: true\n});\n\n// process.assert\nprocess.assert = deprecate(\n  perThreadSetup.assert\x2C\n  'process.assert() is deprecated. Please use the `assert` module instead.'\x2C\n  'DEP0100');\n\n// TODO(joyeecheung): this property has not been well-maintained\x2C should we\n// deprecate it in favor of a better API?\nconst { isDebugBuild\x2C hasOpenSSL\x2C hasInspector } = config;\nconst features = {\n  inspector: hasInspector\x2C\n  debug: isDebugBuild\x2C\n  uv: true\x2C\n  ipv6: true\x2C  // TODO(bnoordhuis) ping libuv\n  tls_alpn: hasOpenSSL\x2C\n  tls_sni: hasOpenSSL\x2C\n  tls_ocsp: hasOpenSSL\x2C\n  tls: hasOpenSSL\x2C\n  // This needs to be dynamic because --no-node-snapshot disables the\n  // code cache even if the binary is built with embedded code cache.\n  get cached_builtins() {\n    return nativeModule.hasCachedBuiltins();\n  }\n};\n\nObjectDefineProperty(process\x2C 'features'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  writable: false\x2C\n  configurable: false\x2C\n  value: features\n});\n\n{\n  const {\n    onGlobalUncaughtException\x2C\n    setUncaughtExceptionCaptureCallback\x2C\n    hasUncaughtExceptionCaptureCallback\n  } = require('internal/process/execution');\n\n  // For legacy reasons this is still called `_fatalException`\x2C even\n  // though it is now a global uncaught exception handler.\n  // The C++ land node::errors::TriggerUncaughtException grabs it\n  // from the process object because it has been monkey-patchable.\n  // TODO(joyeecheung): investigate whether process._fatalException\n  // can be deprecated.\n  process._fatalException = onGlobalUncaughtException;\n  process.setUncaughtExceptionCaptureCallback =\n    setUncaughtExceptionCaptureCallback;\n  process.hasUncaughtExceptionCaptureCallback =\n    hasUncaughtExceptionCaptureCallback;\n}\n\nconst { emitWarning } = require('internal/process/warning');\nprocess.emitWarning = emitWarning;\n\n// We initialize the tick callbacks and the timer callbacks last during\n// bootstrap to make sure that any operation done before this are synchronous.\n// If any ticks or timers are scheduled before this they are unlikely to work.\n{\n  const { nextTick\x2C runNextTicks } = setupTaskQueue();\n  process.nextTick = nextTick;\n  // Used to emulate a tick manually in the JS land.\n  // A better name for this function would be `runNextTicks` but\n  // it has been exposed to the process object so we keep this legacy name\n  // TODO(joyeecheung): either remove it or make it public\n  process._tickCallback = runNextTicks;\n\n  const { setupTimers } = internalBinding('timers');\n  const {\n    processImmediate\x2C\n    processTimers\x2C\n  } = internalTimers.getTimerCallbacks(runNextTicks);\n  // Sets two per-Environment callbacks that will be run from libuv:\n  // - processImmediate will be run in the callback of the per-Environment\n  //   check handle.\n  // - processTimers will be run in the callback of the per-Environment timer.\n  setupTimers(processImmediate\x2C processTimers);\n  // Note: only after this point are the timers effective\n}\n\n// Preload modules so that they are included in the builtin snapshot.\nrequire('fs');\nrequire('v8');\nrequire('vm');\nrequire('url');\nrequire('internal/options');\nif (config.hasOpenSSL) {\n  require('crypto');\n}\n\nfunction setupPrepareStackTrace() {\n  const {\n    setEnhanceStackForFatalException\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  const {\n    prepareStackTrace\x2C\n    fatalExceptionStackEnhancers: {\n      beforeInspector\x2C\n      afterInspector\n    }\n  } = require('internal/errors');\n  // Tell our PrepareStackTraceCallback passed to the V8 API\n  // to call prepareStackTrace().\n  setPrepareStackTraceCallback(prepareStackTrace);\n  // Set the function used to enhance the error stack for printing\n  setEnhanceStackForFatalException(beforeInspector\x2C afterInspector);\n}\n\nfunction setupProcessObject() {\n  const EventEmitter = require('events');\n  const origProcProto = ObjectGetPrototypeOf(process);\n  ObjectSetPrototypeOf(origProcProto\x2C EventEmitter.prototype);\n  FunctionPrototypeCall(EventEmitter\x2C process);\n  ObjectDefineProperty(process\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    writable: true\x2C\n    configurable: false\x2C\n    value: 'process'\n  });\n\n  // Create global.process as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _process = process;\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _process;\n    }\x2C\n    set(value) {\n      _process = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n\nfunction setupGlobalProxy() {\n  ObjectDefineProperty(globalThis\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    value: 'global'\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\n  });\n  globalThis.global = globalThis;\n}\n\nfunction setupBuffer() {\n  const {\n    Buffer\x2C\n  } = require('buffer');\n  const bufferBinding = internalBinding('buffer');\n\n  // Only after this point can C++ use Buffer::New()\n  bufferBinding.setBufferPrototype(Buffer.prototype);\n  delete bufferBinding.setBufferPrototype;\n  delete bufferBinding.zeroFill;\n\n  // Create global.Buffer as getters so that we have a\n  // deprecation path for these in ES Modules.\n  // See https://github.com/nodejs/node/pull/26334.\n  let _Buffer = Buffer;\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\n    __proto__: null\x2C\n    get() {\n      return _Buffer;\n    }\x2C\n    set(value) {\n      _Buffer = value;\n    }\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n  });\n}\n
code-source-info,0xb469fbc7cc8,16,4167,4195,C0O4172C4O4193,,
tick,0x7ff805e4dde4,81369,0,0x0,3,0x102d5e910,0xb469fbc7a75,0xb46f7df2e44,0xb46f7dee5f7
tick,0x7ff805f12098,81377,0,0x0,3,0x102d5e910,0xb469fbc7a75,0xb46f7df2e44,0xb46f7dee5f7
code-creation,LazyCompile,10,81422,0xb469fbc8b70,52,get node:internal/bootstrap/node:115:6,0xb466514f3c8,~
code-source-info,0xb469fbc8b70,16,3534,3798,C0O3576C14O3576C20O3615C29O3730C35O3752C43O3737C48O3772C49O3783C51O3794,,
code-creation,LazyCompile,10,81541,0xb469fbc8d78,29,defineOperation node:internal/util:472:25,0xb4665177c70,~
script-source,21,node:internal/util,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  Error\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectFreeze\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst {\n  hideStackFrames\x2C\n  codes: {\n    ERR_NO_CRYPTO\x2C\n    ERR_UNKNOWN_SIGNAL\n  }\x2C\n  uvErrmapGet\x2C\n  overrideStackTrace\x2C\n} = require('internal/errors');\nconst { signals } = internalBinding('constants').os;\nconst {\n  getHiddenValue\x2C\n  setHiddenValue\x2C\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\n  sleep: _sleep\x2C\n  toUSVString: _toUSVString\x2C\n} = internalBinding('util');\nconst { isNativeError } = internalBinding('types');\n\nconst noCrypto = !process.versions.openssl;\n\nconst experimentalWarnings = new SafeSet();\n\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\n\nconst unpairedSurrogateRe =\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\nfunction toUSVString(val) {\n  const str = `${val}`;\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\n  // slower than `unpairedSurrogateRe.exec()`.\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\n  if (!match)\n    return str;\n  return _toUSVString(str\x2C match.index);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nfunction removeColors(str) {\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\n}\n\nfunction isError(e) {\n  // An error could be an instance of Error while not being a native error\n  // or could be from a different realm and not be instance of Error but still\n  // be a native error.\n  return isNativeError(e) || e instanceof Error;\n}\n\n// Keep a list of deprecation codes that have been warned on so we only warn on\n// each one once.\nconst codesWarned = new SafeSet();\n\nlet validateString;\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set\x2C then it is a no-op.\nfunction deprecate(fn\x2C msg\x2C code) {\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Lazy-load to avoid a circular dependency.\n  if (validateString === undefined)\n    ({ validateString } = require('internal/validators'));\n\n  if (code !== undefined)\n    validateString(code\x2C 'code');\n\n  let warned = false;\n  function deprecated(...args) {\n    if (!warned) {\n      warned = true;\n      if (code !== undefined) {\n        if (!codesWarned.has(code)) {\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\n          codesWarned.add(code);\n        }\n      } else {\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\n      }\n    }\n    if (new.target) {\n      return ReflectConstruct(fn\x2C args\x2C new.target);\n    }\n    return ReflectApply(fn\x2C this\x2C args);\n  }\n\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\n  ObjectSetPrototypeOf(deprecated\x2C fn);\n  if (fn.prototype) {\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\n    // that calling the unwrapped constructor gives an instanceof the wrapped\n    // constructor.\n    deprecated.prototype = fn.prototype;\n  }\n\n  return deprecated;\n}\n\nfunction decorateErrorStack(err) {\n  if (!(isError(err) && err.stack) ||\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\n    return;\n\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\n\n  if (arrow) {\n    err.stack = arrow + err.stack;\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\n  }\n}\n\nfunction assertCrypto() {\n  if (noCrypto)\n    throw new ERR_NO_CRYPTO();\n}\n\n// Return undefined if there is no match.\n// Move the "slow cases" to a separate function to make sure this function gets\n// inlined properly. That prioritizes the common case.\nfunction normalizeEncoding(enc) {\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\n  return slowCases(enc);\n}\n\nfunction slowCases(enc) {\n  switch (enc.length) {\n    case 4:\n      if (enc === 'UTF8') return 'utf8';\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf8') return 'utf8';\n      if (enc === 'ucs2') return 'utf16le';\n      break;\n    case 3:\n      if (enc === 'hex' || enc === 'HEX' ||\n          `${enc}`.toLowerCase() === 'hex')\n        return 'hex';\n      break;\n    case 5:\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      if (enc === 'UTF-8') return 'utf8';\n      if (enc === 'ASCII') return 'ascii';\n      if (enc === 'UCS-2') return 'utf16le';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'utf-8') return 'utf8';\n      if (enc === 'ascii') return 'ascii';\n      if (enc === 'ucs-2') return 'utf16le';\n      break;\n    case 6:\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      if (enc === 'BASE64') return 'base64';\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\n      enc = `${enc}`.toLowerCase();\n      if (enc === 'base64') return 'base64';\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\n      break;\n    case 7:\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\n          `${enc}`.toLowerCase() === 'utf16le')\n        return 'utf16le';\n      break;\n    case 8:\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\n        `${enc}`.toLowerCase() === 'utf-16le')\n        return 'utf16le';\n      break;\n    case 9:\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\n          `${enc}`.toLowerCase() === 'base64url')\n        return 'base64url';\n      break;\n    default:\n      if (enc === '') return 'utf8';\n  }\n}\n\nfunction emitExperimentalWarning(feature) {\n  if (experimentalWarnings.has(feature)) return;\n  const msg = `${feature} is an experimental feature. This feature could ` +\n       'change at any time';\n  experimentalWarnings.add(feature);\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\n}\n\nfunction filterDuplicateStrings(items\x2C low) {\n  const map = new SafeMap();\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const key = StringPrototypeToLowerCase(item);\n    if (low) {\n      map.set(key\x2C key);\n    } else {\n      map.set(key\x2C item);\n    }\n  }\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\n}\n\nfunction cachedResult(fn) {\n  let result;\n  return () => {\n    if (result === undefined)\n      result = fn();\n    return ArrayPrototypeSlice(result);\n  };\n}\n\n// Useful for Wrapping an ES6 Class with a constructor Function that\n// does not require the new keyword. For instance:\n//   class A { constructor(x) {this.x = x;}}\n//   const B = createClassWrapper(A);\n//   B() instanceof A // true\n//   B() instanceof B // true\nfunction createClassWrapper(type) {\n  function fn(...args) {\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\n  }\n  // Mask the wrapper function name and length values\n  ObjectDefineProperties(fn\x2C {\n    name: { __proto__: null\x2C value: type.name }\x2C\n    length: { __proto__: null\x2C value: type.length }\x2C\n  });\n  ObjectSetPrototypeOf(fn\x2C type);\n  fn.prototype = type.prototype;\n  return fn;\n}\n\nlet signalsToNamesMapping;\nfunction getSignalsToNamesMapping() {\n  if (signalsToNamesMapping !== undefined)\n    return signalsToNamesMapping;\n\n  signalsToNamesMapping = ObjectCreate(null);\n  for (const key in signals) {\n    signalsToNamesMapping[signals[key]] = key;\n  }\n\n  return signalsToNamesMapping;\n}\n\nfunction convertToValidSignal(signal) {\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\n    return signal;\n\n  if (typeof signal === 'string') {\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\n    if (signalName) return signalName;\n  }\n\n  throw new ERR_UNKNOWN_SIGNAL(signal);\n}\n\nfunction getConstructorOf(obj) {\n  while (obj) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '') {\n      return descriptor.value;\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n  }\n\n  return null;\n}\n\nfunction getSystemErrorName(err) {\n  const entry = uvErrmapGet(err);\n  return entry ? entry[0] : `Unknown system error ${err}`;\n}\n\nfunction getSystemErrorMap() {\n  return lazyUv().getErrorMap();\n}\n\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\n\nlet validateFunction;\n\nfunction promisify(original) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateFunction === undefined)\n    ({ validateFunction } = require('internal/validators'));\n\n  validateFunction(original\x2C 'original');\n\n  if (original[kCustomPromisifiedSymbol]) {\n    const fn = original[kCustomPromisifiedSymbol];\n\n    validateFunction(fn\x2C 'util.promisify.custom');\n\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n      __proto__: null\x2C\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n    });\n  }\n\n  // Names to create an object from in case the callback receives multiple\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\n\n  function fn(...args) {\n    return new Promise((resolve\x2C reject) => {\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\n        if (err) {\n          return reject(err);\n        }\n        if (argumentNames !== undefined && values.length > 1) {\n          const obj = {};\n          for (let i = 0; i < argumentNames.length; i++)\n            obj[argumentNames[i]] = values[i];\n          resolve(obj);\n        } else {\n          resolve(values[0]);\n        }\n      });\n      ReflectApply(original\x2C this\x2C args);\n    });\n  }\n\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\n\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\n    __proto__: null\x2C\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\n  });\n  return ObjectDefineProperties(\n    fn\x2C\n    ObjectGetOwnPropertyDescriptors(original)\n  );\n}\n\npromisify.custom = kCustomPromisifiedSymbol;\n\n// The built-in Array#join is slower in v8 6.0\nfunction join(output\x2C separator) {\n  let str = '';\n  if (output.length !== 0) {\n    const lastIndex = output.length - 1;\n    for (let i = 0; i < lastIndex; i++) {\n      // It is faster not to use a template string here\n      str += output[i];\n      str += separator;\n    }\n    str += output[lastIndex];\n  }\n  return str;\n}\n\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\n// between 1.5-10x faster than the two-arg version of Array#splice()\nfunction spliceOne(list\x2C index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\n\nlet getStructuredStack;\n\nfunction isInsideNodeModules() {\n  if (getStructuredStack === undefined) {\n    // Lazy-load to avoid a circular dependency.\n    const { runInNewContext } = require('vm');\n    // Use `runInNewContext()` to get something tamper-proof and\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\n    // the perf implications should be okay.\n    getStructuredStack = runInNewContext(`(function() {\n      try { Error.stackTraceLimit = Infinity; } catch {}\n      return function structuredStack() {\n        const e = new Error();\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\n        return e.stack;\n      };\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\n  }\n\n  const stack = getStructuredStack();\n\n  // Iterate over all stack frames and look for the first one not coming\n  // from inside Node.js itself:\n  if (ArrayIsArray(stack)) {\n    for (const frame of stack) {\n      const filename = frame.getFileName();\n      // If a filename does not start with / or contain \\\x2C\n      // it's likely from Node.js core.\n      if (RegExpPrototypeExec(/^\\/|\\\\/\x2C filename) === null)\n        continue;\n      return RegExpPrototypeExec(kNodeModulesRE\x2C filename) !== null;\n    }\n  }\n  return false;\n}\n\nfunction once(callback) {\n  let called = false;\n  return function(...args) {\n    if (called) return;\n    called = true;\n    ReflectApply(callback\x2C this\x2C args);\n  };\n}\n\nlet validateUint32;\n\nfunction sleep(msec) {\n  // Lazy-load to avoid a circular dependency.\n  if (validateUint32 === undefined)\n    ({ validateUint32 } = require('internal/validators'));\n\n  validateUint32(msec\x2C 'msec');\n  _sleep(msec);\n}\n\nfunction createDeferredPromise() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res\x2C rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return { promise\x2C resolve\x2C reject };\n}\n\n// https://heycam.github.io/webidl/#define-the-operations\nfunction defineOperation(target\x2C name\x2C method) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: true\x2C\n    configurable: true\x2C\n    value: method\n  });\n}\n\n// https://heycam.github.io/webidl/#es-interfaces\nfunction exposeInterface(target\x2C name\x2C interfaceObject) {\n  ObjectDefineProperty(target\x2C name\x2C {\n    __proto__: null\x2C\n    writable: true\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: interfaceObject\n  });\n}\n\nlet _DOMException;\nconst lazyDOMExceptionClass = () => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return _DOMException;\n};\n\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\n  _DOMException ??= internalBinding('messaging').DOMException;\n  return new _DOMException(message\x2C name);\n});\n\nconst kEnumerableProperty = ObjectCreate(null);\nkEnumerableProperty.enumerable = true;\nObjectFreeze(kEnumerableProperty);\n\nconst kEmptyObject = ObjectFreeze(ObjectCreate(null));\n\nmodule.exports = {\n  assertCrypto\x2C\n  cachedResult\x2C\n  convertToValidSignal\x2C\n  createClassWrapper\x2C\n  createDeferredPromise\x2C\n  decorateErrorStack\x2C\n  defineOperation\x2C\n  deprecate\x2C\n  emitExperimentalWarning\x2C\n  exposeInterface\x2C\n  filterDuplicateStrings\x2C\n  getConstructorOf\x2C\n  getSystemErrorMap\x2C\n  getSystemErrorName\x2C\n  isError\x2C\n  isInsideNodeModules\x2C\n  join\x2C\n  lazyDOMException\x2C\n  lazyDOMExceptionClass\x2C\n  normalizeEncoding\x2C\n  once\x2C\n  promisify\x2C\n  sleep\x2C\n  spliceOne\x2C\n  toUSVString\x2C\n  removeColors\x2C\n\n  // Symbol used to customize promisify conversion\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n\n  // Symbol used to provide a custom inspect function for an object as an\n  // alternative to using 'inspect'\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\n\n  // Used by the buffer module to capture an internal reference to the\n  // default isEncoding implementation\x2C just in case userland overrides it.\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\x2C\n\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n};\n
code-source-info,0xb469fbc8d78,21,13112,13288,C0O13139C5O13168C12O13274C22O13139C28O13287,,
tick,0x7ff805dd2bcd,83255,0,0x0,3,0x102d5e910,0xb469fbc7aae,0xb46f7df2e44,0xb46f7dee5f7
code-creation,LazyCompile,10,83264,0xb469fbca128,33,lazyInterface node:internal/bootstrap/pre_execution:204:25,0xb469fbc78b0,~
code-source-info,0xb469fbca128,389,6031,6249,C0O6031C9O6044C14O6110C22O6168C32O6245,,
tick,0x1027c823e,83667,1,0x10266e4e0,2,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbc7aff,0xb46f7df2e44,0xb46f7dee5f7
code-creation,Eval,10,84360,0xb469fbca640,5, node:internal/wasm_web_api:1:1,0xb469fbca498,~
script-source,391,node:internal/wasm_web_api,'use strict';\n\nconst {\n  PromiseResolve\x2C\n} = primordials;\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_WEBASSEMBLY_RESPONSE\x2C\n} = require('internal/errors').codes;\n\nlet undici;\nfunction lazyUndici() {\n  return undici ??= require('internal/deps/undici/undici');\n}\n\n// This is essentially an implementation of a v8::WasmStreamingCallback\x2C except\n// that it is implemented in JavaScript because the fetch() implementation is\n// difficult to use from C++. See lib/internal/bootstrap/pre_execution.js and\n// src/node_wasm_web_api.cc that interact with this function.\nfunction wasmStreamingCallback(streamState\x2C source) {\n  (async () => {\n    const response = await PromiseResolve(source);\n    if (!(response instanceof lazyUndici().Response)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'source'\x2C ['Response'\x2C 'Promise resolving to Response']\x2C response);\n    }\n\n    const contentType = response.headers.get('Content-Type');\n    if (contentType !== 'application/wasm') {\n      throw new ERR_WEBASSEMBLY_RESPONSE(\n        `has unsupported MIME type '${contentType}'`);\n    }\n\n    if (!response.ok) {\n      throw new ERR_WEBASSEMBLY_RESPONSE(\n        `has status code ${response.status}`);\n    }\n\n    if (response.bodyUsed !== false) {\n      throw new ERR_WEBASSEMBLY_RESPONSE('body has already been used');\n    }\n\n    if (response.url) {\n      streamState.setURL(response.url);\n    }\n\n    // Pass all data from the response body to the WebAssembly compiler.\n    const { body } = response;\n    if (body != null) {\n      for await (const chunk of body) {\n        streamState.push(chunk);\n      }\n    }\n  })().then(() => {\n    // No error occurred. Tell the implementation that the stream has ended.\n    streamState.finish();\n  }\x2C (err) => {\n    // An error occurred\x2C either because the given object was not a valid\n    // and usable Response or because a network error occurred.\n    streamState.abort(err);\n  });\n}\n\nmodule.exports = {\n  wasmStreamingCallback\n};\n
code-source-info,0xb469fbca640,391,0,1949,C0O0C4O1949,,
code-creation,Function,10,84587,0xb469fbca7d8,88, node:internal/wasm_web_api:1:1,0xb469fbca5b8,~
code-source-info,0xb469fbca7d8,391,0,1949,C0O0C32O25C38O122C44O122C49O148C54O68C60O92C66O161C67O161C69O1903C76O1924C82O1918C87O1948,,
code-creation,LazyCompile,10,84700,0xb469fbcb188,256,setupWebCrypto node:internal/bootstrap/pre_execution:231:24,0xb46f7df0880,~
code-source-info,0xb469fbcb188,389,6806,7632,C0O6806C8O6813C13O6825C18O6832C23O6842C33O6876C39O6876C45O6933C46O6940C47O6952C48O6952C50O6965C61O6986C76O7053C107O7053C120O6965C125O7326C133O7330C138O7355C144O7374C158O7388C162O7384C164O7430C175O7446C184O7478C189O7430C194O7491C205O7507C214O7542C219O7491C224O7558C235O7574C244O7612C249O7558C255O7631,,
code-creation,LazyCompile,10,84765,0xb469fbcb490,74,setupCustomEvent node:internal/bootstrap/pre_execution:255:26,0xb46f7df08f8,~
code-source-info,0xb469fbcb490,389,7765,8026,C0O7772C3O7784C8O7791C13O7801C21O7835C27O7835C33O7894C34O7901C35O7932C41O7932C46O7916C51O7968C58O7984C67O7968C73O8025,,
code-creation,LazyCompile,10,84811,0xb469fbcb688,75,setupDebugEnv node:internal/bootstrap/pre_execution:307:23,0xb46f7df0a60,~
code-source-info,0xb469fbcb688,389,9312,9522,C0O9319C6O9319C11O9352C19O9380C24O9384C29O9353C34O9399C42O9403C48O9447C54O9447C59O9484C64O9497C69O9498C74O9521,,
tick,0x102d48ec4,85093,0,0x0,2,0x102d5e910,0xb469fbcb6a5,0xb46f7df2e84,0xb46f7dee5f7
tick,0x102ca768f,86258,0,0x0,2,0x102d5e910,0xb469fbcb6a5,0xb46f7df2e84,0xb46f7dee5f7
code-creation,LazyCompile,10,86692,0xb469fbcba20,159,initializeDebugEnv node:internal/util/debuglog:22:28,0xb469fcd9ae0,~
script-source,28,node:internal/util/debuglog,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\n\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\nlet debugImpls;\nlet testEnabled;\n\n\n// `debugEnv` is initial value of process.env.NODE_DEBUG\nfunction initializeDebugEnv(debugEnv) {\n  debugImpls = ObjectCreate(null);\n  if (debugEnv) {\n    // This is run before any user code\x2C it's OK not to use primordials.\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\n      .replaceAll('*'\x2C '.*')\n      .replaceAll('\x2C'\x2C '$|^');\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\n  } else {\n    testEnabled = () => false;\n  }\n}\n\n// Emits warning when user sets\n// NODE_DEBUG=http or NODE_DEBUG=http2.\nfunction emitWarningIfNeeded(set) {\n  if ('HTTP' === set || 'HTTP2' === set) {\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\n      'data (such as passwords\x2C tokens and authentication headers) ' +\n      'in the resulting log.');\n  }\n}\n\nconst noop = () => {};\n\nfunction debuglogImpl(enabled\x2C set) {\n  if (debugImpls[set] === undefined) {\n    if (enabled) {\n      const pid = process.pid;\n      emitWarningIfNeeded(set);\n      debugImpls[set] = function debug(...args) {\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\n        const msg = formatWithOptions({ colors }\x2C ...args);\n        const coloredPID = inspect(pid\x2C { colors });\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\n      };\n    } else {\n      debugImpls[set] = noop;\n    }\n  }\n  return debugImpls[set];\n}\n\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\n// so it needs to be called lazily in top scopes of internal modules\n// that may be loaded before these run time states are allowed to\n// be accessed.\nfunction debuglog(set\x2C cb) {\n  function init() {\n    set = StringPrototypeToUpperCase(set);\n    enabled = testEnabled(set);\n  }\n  let debug = (...args) => {\n    init();\n    // Only invokes debuglogImpl() when the debug function is\n    // called for the first time.\n    debug = debuglogImpl(enabled\x2C set);\n    if (typeof cb === 'function')\n      cb(debug);\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  let enabled;\n  let test = () => {\n    init();\n    test = () => enabled;\n    return enabled;\n  };\n  const logger = (...args) => {\n    switch (args.length) {\n      case 1: return debug(args[0]);\n      case 2: return debug(args[0]\x2C args[1]);\n      default: return debug(...new SafeArrayIterator(args));\n    }\n  };\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\n    __proto__: null\x2C\n    get() {\n      return test();\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n  return logger;\n}\n\nmodule.exports = {\n  debuglog\x2C\n  initializeDebugEnv\n};\n
code-source-info,0xb469fbcba20,28,546,991,C0O561C7O574C14O572C20O596C31O709C44O709C51O753C62O754C69O782C80O783C88O833C100O848C116O833C121O833C123O871C132O883C144O959C151O971C158O990,,
code-creation,LazyCompile,10,87115,0xb469fbcc030,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:285:40,0xb46f7df0998,~
code-source-info,0xb469fbcc030,389,8856,9042,C0O8863C8O8868C14O8908C15O8915C16O8949C22O8949C27O8930C32O8999C38O9032C43O9032C48O9041,,
code-creation,LazyCompile,10,87159,0xb469fbcc250,62,initializeReport node:internal/bootstrap/pre_execution:295:26,0xb46f7df09e8,~
code-source-info,0xb469fbcc250,389,9069,9288,C0O9069C8O9095C16O9095C21O9084C27O9133C42O9154C47O9246C55O9133C61O9287,,
code-creation,Eval,10,87275,0xb469fbcc7c8,5, node:internal/process/report:1:1,0xb469fbcc5d0,~
script-source,392,node:internal/process/report,'use strict';\nconst {\n  ERR_SYNTHETIC\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateObject\x2C\n  validateSignalName\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst nr = internalBinding('report');\nconst {\n  JSONParse\x2C\n} = primordials;\nconst report = {\n  writeReport(file\x2C err) {\n    if (typeof file === 'object' && file !== null) {\n      err = file;\n      file = undefined;\n    } else if (file !== undefined) {\n      validateString(file\x2C 'file');\n    }\n\n    if (err === undefined) {\n      err = new ERR_SYNTHETIC();\n    } else {\n      validateObject(err\x2C 'err');\n    }\n\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\n  }\x2C\n  getReport(err) {\n    if (err === undefined)\n      err = new ERR_SYNTHETIC();\n    else\n      validateObject(err\x2C 'err');\n\n    return JSONParse(nr.getReport(err));\n  }\x2C\n  get directory() {\n    return nr.getDirectory();\n  }\x2C\n  set directory(dir) {\n    validateString(dir\x2C 'directory');\n    nr.setDirectory(dir);\n  }\x2C\n  get filename() {\n    return nr.getFilename();\n  }\x2C\n  set filename(name) {\n    validateString(name\x2C 'filename');\n    nr.setFilename(name);\n  }\x2C\n  get compact() {\n    return nr.getCompact();\n  }\x2C\n  set compact(b) {\n    validateBoolean(b\x2C 'compact');\n    nr.setCompact(b);\n  }\x2C\n  get signal() {\n    return nr.getSignal();\n  }\x2C\n  set signal(sig) {\n    validateSignalName(sig\x2C 'signal');\n    removeSignalHandler();\n    addSignalHandler(sig);\n    nr.setSignal(sig);\n  }\x2C\n  get reportOnFatalError() {\n    return nr.shouldReportOnFatalError();\n  }\x2C\n  set reportOnFatalError(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnFatalError(trigger);\n  }\x2C\n  get reportOnSignal() {\n    return nr.shouldReportOnSignal();\n  }\x2C\n  set reportOnSignal(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnSignal(trigger);\n    removeSignalHandler();\n    addSignalHandler();\n  }\x2C\n  get reportOnUncaughtException() {\n    return nr.shouldReportOnUncaughtException();\n  }\x2C\n  set reportOnUncaughtException(trigger) {\n    validateBoolean(trigger\x2C 'trigger');\n\n    nr.setReportOnUncaughtException(trigger);\n  }\n};\n\nfunction addSignalHandler(sig) {\n  if (nr.shouldReportOnSignal()) {\n    if (typeof sig !== 'string')\n      sig = nr.getSignal();\n\n    process.on(sig\x2C signalHandler);\n  }\n}\n\nfunction removeSignalHandler() {\n  const sig = nr.getSignal();\n\n  if (sig)\n    process.removeListener(sig\x2C signalHandler);\n}\n\nfunction signalHandler(sig) {\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\n}\n\nmodule.exports = {\n  addSignalHandler\x2C\n  report\n};\n
code-source-info,0xb469fbcc7c8,392,0,2545,C0O0C4O2545,,
code-creation,Function,10,87631,0xb469fbcd2d8,306, node:internal/process/report:1:1,0xb469fbcc740,~
code-source-info,0xb469fbcd2d8,392,0,2545,C0O0C48O42C51O42C56O68C61O24C67O165C70O165C75O86C81O105C87O123C93O145C99O208C102O208C106O208C108O245C114O288C119O292C127O678C281O2494C288O2515C294O2535C300O2509C305O2544,,
tick,0x7ff805e4dd52,87669,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbcc260,0xb46f7df2e90,0xb46f7dee5f7
code-creation,LazyCompile,10,87785,0xb469fbcef18,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:315:40,0xb46f7df0ab0,~
code-source-info,0xb469fbcef18,389,9623,9719,C0O9659C6O9659C11O9638C16O9698C20O9718,,
code-creation,LazyCompile,10,87829,0xb469fbcf020,57,addSignalHandler node:internal/process/report:98:26,0xb469fbcc7f8,~
code-source-info,0xb469fbcf020,392,2144,2290,C0O2154C5O2161C10O2161C16O2191C22O2226C27O2235C32O2235C38O2253C41O2261C49O2261C56O2289,,
code-creation,LazyCompile,10,87873,0xb469fbcf5f0,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:321:46,0xb46f7df0b00,~
code-source-info,0xb469fbcf5f0,389,9766,10028,C0O9766C8O9788C18O9788C23O9832C25O9849C26O9856C27O9860C35O9860C40O9890C45O9891C50O9951C58O9951C63O9929C69O9969C74O9977C79O9980C84O9977C91O10027,,
code-creation,LazyCompile,10,87927,0xb469fbcf880,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:425:37,0xb46f7df0c90,~
code-source-info,0xb469fbcf880,389,13201,13730,C0O13208C3O13220C8O13224C14O13262C20O13262C25O13306C33O13329C38O13333C46O13306C52O13359C53O13369C57O13359C61O13450C64O13465C73O13523C76O13531C81O13535C90O13582C93O13597C102O13639C108O13639C113O13663C118O13664C124O13703C127O13718C132O13703C137O13729,,
code-creation,LazyCompile,10,88029,0xb469fbcfc80,455,initializePolicy node:internal/bootstrap/pre_execution:453:26,0xb46f7df0d30,~
code-source-info,0xb469fbcfc80,389,14029,15827,C0O14063C10O14063C15O14106C17O14136C21O14144C35O14144C41O14269C49O14269C55O14246C60O14261C65O14388C67O14405C75O14409C81O14424C87O14425C94O14465C100O14497C108O14479C116O14554C120O14576C126O14576C132O14554C138O14590C149O14606C153O14620C161O14634C167O14692C175O14692C180O14726C190O14726C197O14801C207O14801C212O14843C214O14896C222O14896C227O14974C235O14974C241O14942C246O14954C251O15023C257O15023C263O15073C269O15073C275O15132C277O15158C279O15182C283O15163C288O15272C290O15288C295O15223C300O15251C305O15314C311O15350C317O15350C322O15391C328O15391C334O15420C340O15440C344O15427C349O15460C356O15507C358O15536C360O15577C366O15599C376O15599C383O15577C389O15191C394O15145C397O15634C401O15661C415O15667C420O15661C421O15750C429O15750C435O15791C441O15815C447O15792C454O15826,,
code-creation,LazyCompile,10,88112,0xb469fbd0070,63,initializeClusterIPC node:internal/bootstrap/pre_execution:444:30,0xb46f7df0ce0,~
code-source-info,0xb469fbd0070,389,13761,14002,C0O13768C3O13780C10O13784C18O13799C23O13803C29O13841C35O13841C40O13873C45O13873C49O13962C52O13977C62O14001,,
code-creation,LazyCompile,10,88150,0xb469fbd01e0,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:548:38,0xb46f7df0e70,~
code-source-info,0xb469fbd01e0,389,17560,17709,C0O17604C6O17604C11O17575C16O17655C21O17684C26O17708,,
code-creation,Eval,10,88433,0xb469fbd0d08,5, node:internal/source_map/source_map_cache:1:1,0xb469fbd0970,~
script-source,393,node:internal/source_map/source_map_cache,'use strict';\n\nconst {\n  ArrayPrototypeMap\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolSplit\x2C\n  SafeMap\x2C\n  StringPrototypeSplit\x2C\n} = primordials;\n\nfunction ObjectGetValueSafe(obj\x2C key) {\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\n}\n\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\nconst { Buffer } = require('buffer');\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\n  debug = fn;\n});\nconst fs = require('fs');\nconst { getOptionValue } = require('internal/options');\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\nconst {\n  normalizeReferrerURL\x2C\n} = require('internal/modules/cjs/helpers');\nconst { validateBoolean } = require('internal/validators');\nconst { setMaybeCacheGeneratedSourceMap } = internalBinding('errors');\n\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\n// be purged automatically:\nconst cjsSourceMapCache = new IterableWeakMap();\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\nconst esmSourceMapCache = new SafeMap();\n// The generated sources is not mutable\x2C so we can use a Map without memory concerns:\nconst generatedSourceMapCache = new SafeMap();\nconst kLeadingProtocol = /^\\w+:\\/\\//;\n\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\nlet SourceMap;\n\nlet sourceMapsEnabled;\nfunction getSourceMapsEnabled() {\n  if (sourceMapsEnabled === undefined) {\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\n  }\n  return sourceMapsEnabled;\n}\n\nfunction setSourceMapsEnabled(val) {\n  validateBoolean(val\x2C 'val');\n\n  const {\n    setSourceMapsEnabled\x2C\n    setPrepareStackTraceCallback\n  } = internalBinding('errors');\n  setSourceMapsEnabled(val);\n  if (val) {\n    const {\n      prepareStackTrace\n    } = require('internal/source_map/prepare_stack_trace');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  } else if (sourceMapsEnabled !== undefined) {\n    // Reset prepare stack trace callback only when disabling source maps.\n    const {\n      prepareStackTrace\x2C\n    } = require('internal/errors');\n    setPrepareStackTraceCallback(prepareStackTrace);\n  }\n\n  sourceMapsEnabled = val;\n}\n\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance\x2C isGeneratedSource) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n  try {\n    filename = normalizeReferrerURL(filename);\n  } catch (err) {\n    // This is most likely an invalid filename in sourceURL of [eval]-wrapper.\n    debug(err);\n    return;\n  }\n  const match = RegExpPrototypeExec(\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\x2C\n    content\x2C\n  );\n  if (match) {\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\n    const url = data ? null : match.groups.sourceMappingURL;\n    if (cjsModuleInstance) {\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\n        filename\x2C\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else if (isGeneratedSource) {\n      generatedSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    } else {\n      // If there is no cjsModuleInstance and is not generated source assume we are in a\n      // "modules/esm" context.\n      esmSourceMapCache.set(filename\x2C {\n        lineLengths: lineLengths(content)\x2C\n        data\x2C\n        url\n      });\n    }\n  }\n}\n\nfunction maybeCacheGeneratedSourceMap(content) {\n  const sourceMapsEnabled = getSourceMapsEnabled();\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\n\n  const matchSourceURL = RegExpPrototypeExec(\n    /\\/[*/]#\\s+sourceURL=(?<sourceURL>[^\\s]+)/\x2C\n    content\n  );\n  if (matchSourceURL == null) {\n    return;\n  }\n  let sourceURL = matchSourceURL.groups.sourceURL;\n  if (RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  try {\n    maybeCacheSourceMap(sourceURL\x2C content\x2C null\x2C true);\n  } catch (err) {\n    // This can happen if the filename is not a valid URL.\n    // If we fail to cache the source map\x2C we should not fail the whole process.\n    debug(err);\n  }\n}\nsetMaybeCacheGeneratedSourceMap(maybeCacheGeneratedSourceMap);\n\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\n  try {\n    const url = new URL(sourceMappingURL);\n    switch (url.protocol) {\n      case 'data:':\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\n      default:\n        debug(`unknown protocol ${url.protocol}`);\n        return null;\n    }\n  } catch (err) {\n    debug(err);\n    // If no scheme is present\x2C we assume we are dealing with a file path.\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\n    return sourceMapFromFile(mapURL);\n  }\n}\n\n// Cache the length of each line in the file that a source map was extracted\n// from. This allows translation from byte offset V8 coverage reports\x2C\n// to line/column offset Source Map V3.\nfunction lineLengths(content) {\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\n  // account in coverage calculations.\n  return ArrayPrototypeMap(RegExpPrototypeSymbolSplit(/\\n|\\u2028|\\u2029/\x2C content)\x2C (line) => {\n    return line.length;\n  });\n}\n\nfunction sourceMapFromFile(mapURL) {\n  try {\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\n    const data = JSONParse(content);\n    return sourcesToAbsolute(mapURL\x2C data);\n  } catch (err) {\n    debug(err);\n    return null;\n  }\n}\n\n// data:[<mediatype>][;base64]\x2C<data> see:\n// https://tools.ietf.org/html/rfc2397#section-2\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\n  const contentType = splitFormat[0];\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\n  if (contentType === 'application/json') {\n    const decodedData = base64 ?\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\n    try {\n      const parsedData = JSONParse(decodedData);\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\n    } catch (err) {\n      debug(err);\n      return null;\n    }\n  } else {\n    debug(`unknown content-type ${contentType}`);\n    return null;\n  }\n}\n\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\n// the sources are resolved relative to the SourceMap (like resolving script\n// src in a html document).\nfunction sourcesToAbsolute(baseURL\x2C data) {\n  data.sources = data.sources.map((source) => {\n    source = (data.sourceRoot || '') + source;\n    return new URL(source\x2C baseURL).href;\n  });\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\n  // be updated to noop.\n  data.sourceRoot = '';\n  return data;\n}\n\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\n// it important that they do not call out to any user-provided code\x2C including\n// built-in prototypes that might have been tampered with.\n\n// Get serialized representation of source-map cache\x2C this is used\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\nfunction sourceMapCacheToObject() {\n  const obj = ObjectCreate(null);\n\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\n    obj[k] = v;\n  }\n\n  appendCJSCache(obj);\n\n  if (ObjectKeys(obj).length === 0) {\n    return undefined;\n  }\n  return obj;\n}\n\nfunction appendCJSCache(obj) {\n  for (const value of cjsSourceMapCache) {\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\n      url: ObjectGetValueSafe(value\x2C 'url')\n    };\n  }\n}\n\nfunction findSourceMap(sourceURL\x2C isGenerated) {\n  if (RegExpPrototypeExec(kLeadingProtocol\x2C sourceURL) === null) {\n    sourceURL = pathToFileURL(sourceURL).href;\n  }\n  if (!SourceMap) {\n    SourceMap = require('internal/source_map/source_map').SourceMap;\n  }\n  let sourceMap;\n  if (isGenerated) {\n    sourceMap = generatedSourceMapCache.get(sourceURL);\n  } else {\n    sourceMap = esmSourceMapCache.get(sourceURL);\n    if (sourceMap === undefined) {\n      for (const value of cjsSourceMapCache) {\n        const filename = ObjectGetValueSafe(value\x2C 'filename');\n        if (sourceURL === filename) {\n          sourceMap = {\n            data: ObjectGetValueSafe(value\x2C 'data')\n          };\n        }\n      }\n    }\n  }\n  if (sourceMap && sourceMap.data) {\n    return new SourceMap(sourceMap.data);\n  }\n  return undefined;\n}\n\nmodule.exports = {\n  findSourceMap\x2C\n  getSourceMapsEnabled\x2C\n  setSourceMapsEnabled\x2C\n  maybeCacheSourceMap\x2C\n  sourceMapCacheToObject\x2C\n};\n
code-source-info,0xb469fbd0d08,393,0,9046,C0O0C4O9046,,
code-creation,Function,10,89526,0xb469fbd13f0,482, node:internal/source_map/source_map_cache:1:1,0xb469fbd0c80,~
code-source-info,0xb469fbd13f0,393,0,9046,C0O0C164O25C170O46C176O59C182O75C188O89C194O123C200O156C206O179C212O209C217O220C223O532C229O532C234O521C240O563C246O563C251O596C264O597C270O563C272O659C278O659C282O659C284O701C290O701C295O682C301O758C307O758C312O738C317O838C323O838C328O812C334O907C340O907C345O887C351O983C357O983C362O947C367O1215C369O1215C374O1215C376O1342C378O1342C383O1342C385O1475C387O1475C392O1475C394O1515C398O1515C400O1575C406O1575C411O1537C417O1552C423O1567C429O1604C430O1604C432O1620C433O1620C435O4462C439O8910C446O8931C452O8948C458O8972C464O8996C470O9019C476O8925C481O9045,,
tick,0x7ff805f105d0,89593,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd01e6,0xb46f7df2eb4,0xb46f7dee5f7
code-creation,LazyCompile,10,89677,0xb469fbd2380,82,debuglog node:internal/util/debuglog:71:18,0xb469fcd9d68,~
code-source-info,0xb469fbd2380,28,2232,3240,C0O2232C28O2357C32O2357C34O2759C35O2759C37O2781C41O2781C43O2869C48O3068C58O3089C63O3135C74O3068C79O3224C81O3238,,
tick,0x1027c8256,89961,1,0x10266e4e0,2,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd1523,0xb46f7def627,0x1132442e1,0xb469fbd01e6,0xb46f7df2eb4,0xb46f7dee5f7
code-creation,Eval,10,90740,0xb469fbd28f0,5, node:internal/util/iterable_weak_map:1:1,0xb469fbd2690,~
script-source,394,node:internal/util/iterable_weak_map,'use strict';\n\nconst {\n  ObjectFreeze\x2C\n  SafeFinalizationRegistry\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SymbolIterator\x2C\n} = primordials;\n\n// This class is modified from the example code in the WeakRefs specification:\n// https://github.com/tc39/proposal-weakrefs\n// Licensed under ECMA's MIT-style license\x2C see:\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\nclass IterableWeakMap {\n  #weakMap = new SafeWeakMap();\n  #refSet = new SafeSet();\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\n\n  set(key\x2C value) {\n    const entry = this.#weakMap.get(key);\n    if (entry) {\n      // If there's already an entry for the object represented by "key"\x2C\n      // the value can be updated without creating a new WeakRef:\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\n    } else {\n      const ref = new SafeWeakRef(key);\n      this.#weakMap.set(key\x2C { value\x2C ref });\n      this.#refSet.add(ref);\n      this.#finalizationGroup.register(key\x2C {\n        set: this.#refSet\x2C\n        ref\n      }\x2C ref);\n    }\n  }\n\n  get(key) {\n    return this.#weakMap.get(key)?.value;\n  }\n\n  has(key) {\n    return this.#weakMap.has(key);\n  }\n\n  delete(key) {\n    const entry = this.#weakMap.get(key);\n    if (!entry) {\n      return false;\n    }\n    this.#weakMap.delete(key);\n    this.#refSet.delete(entry.ref);\n    this.#finalizationGroup.unregister(entry.ref);\n    return true;\n  }\n\n  [SymbolIterator]() {\n    const iterator = this.#refSet[SymbolIterator]();\n\n    const next = () => {\n      const result = iterator.next();\n      if (result.done) return result;\n      const key = result.value.deref();\n      if (key == null) return next();\n      const { value } = this.#weakMap.get(key);\n      return { done: false\x2C value };\n    };\n\n    return {\n      [SymbolIterator]() { return this; }\x2C\n      next\x2C\n    };\n  }\n}\n\nfunction cleanup({ set\x2C ref }) {\n  set.delete(ref);\n}\n\nObjectFreeze(IterableWeakMap.prototype);\n\nmodule.exports = {\n  IterableWeakMap\x2C\n};\n
code-source-info,0xb469fbd28f0,394,0,1958,C0O0C4O1958,,
code-creation,Function,10,90988,0xb469fbd3050,196, node:internal/util/iterable_weak_map:1:1,0xb469fbd2868,~
code-source-info,0xb469fbd3050,394,0,1958,C0O0C26O25C31O41C37O69C43O80C49O95C55O110C134O1392C168O1904C173O1875C177O1917C184O1938C190O1932C195O1957,,
code-creation,Function,10,91013,0xb469fbd31d0,66,<instance_members_initializer> node:internal/util/iterable_weak_map:16:1,0xb469fbd2b78,~
code-source-info,0xb469fbd31d0,394,373,1818,C3O410C10O410C22O441C29O441C41O479C55O479C65O1818,,
tick,0x1027cfc57,91216,1,0x10266e4e0,2,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd1533,0xb46f7def627,0x1132442e1,0xb469fbd01e6,0xb46f7df2eb4,0xb46f7dee5f7
code-creation,Eval,10,91332,0xb469fbd3e08,5, node:internal/modules/cjs/helpers:1:1,0xb469fbd3b50,~
script-source,395,node:internal/modules/cjs/helpers,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeSome\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_UNKNOWN_BUILTIN_MODULE\n} = require('internal/errors').codes;\nconst { NativeModule } = require('internal/bootstrap/loaders');\n\nconst { validateString } = require('internal/validators');\nconst path = require('path');\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\n\nconst { getOptionValue } = require('internal/options');\nconst userConditions = getOptionValue('--conditions');\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\n\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\nconst cjsConditions = new SafeSet([\n  'require'\x2C\n  'node'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nfunction loadNativeModule(filename\x2C request) {\n  const mod = NativeModule.map.get(filename);\n  if (mod?.canBeRequiredByUsers) {\n    debug('load native module %s'\x2C request);\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\n    mod.compileForPublicLoader();\n    return mod;\n  }\n}\n\n// Invoke with makeRequireFunction(module) where |module| is the Module object\n// to use as the context for the require() function.\n// Use redirects to set up a mapping from a policy and restrict dependencies\nconst urlToFileCache = new SafeMap();\nfunction makeRequireFunction(mod\x2C redirects) {\n  const Module = mod.constructor;\n\n  let require;\n  if (redirects) {\n    const id = mod.filename || mod.id;\n    const conditions = cjsConditions;\n    const { resolve\x2C reaction } = redirects;\n    require = function require(specifier) {\n      let missing = true;\n      const destination = resolve(specifier\x2C conditions);\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        if (destination.protocol === 'node:') {\n          const specifier = destination.pathname;\n          const mod = loadNativeModule(specifier\x2C href);\n          if (mod && mod.canBeRequiredByUsers) {\n            return mod.exports;\n          }\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\n        } else if (destination.protocol === 'file:') {\n          let filepath;\n          if (urlToFileCache.has(href)) {\n            filepath = urlToFileCache.get(href);\n          } else {\n            filepath = fileURLToPath(destination);\n            urlToFileCache.set(href\x2C filepath);\n          }\n          return mod.require(filepath);\n        }\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          id\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\n        ));\n      }\n      return mod.require(specifier);\n    };\n  } else {\n    require = function require(path) {\n      return mod.require(path);\n    };\n  }\n\n  function resolve(request\x2C options) {\n    validateString(request\x2C 'request');\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\n  }\n\n  require.resolve = resolve;\n\n  function paths(request) {\n    validateString(request\x2C 'request');\n    return Module._resolveLookupPaths(request\x2C mod);\n  }\n\n  resolve.paths = paths;\n\n  require.main = process.mainModule;\n\n  // Enable support to add extra extension types.\n  require.extensions = Module._extensions;\n\n  require.cache = Module._cache;\n\n  return require;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n * because the buffer-to-string conversion in `fs.readFileSync()`\n * translates it to FEFF\x2C the UTF-16 BOM.\n */\nfunction stripBOM(content) {\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\n    content = StringPrototypeSlice(content\x2C 1);\n  }\n  return content;\n}\n\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\n  // Make built-in modules available directly (loaded lazily).\n  const Module = require('internal/modules/cjs/loader').Module;\n  const { builtinModules } = Module;\n\n  // To require built-in modules in user-land and ignore modules whose\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\n  // use `require()` directly.\n  const dummyModule = new Module(dummyModuleName);\n\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\n    // 'fs/promises') or ones that are already defined.\n    if (StringPrototypeStartsWith(name\x2C '_') ||\n        StringPrototypeIncludes(name\x2C '/') ||\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\n      return;\n    }\n    // Goals of this mechanism are:\n    // - Lazy loading of built-in modules\n    // - Having all built-in modules available as non-enumerable properties\n    // - Allowing the user to re-assign these variables as if there were no\n    //   pre-existing globals with the same name.\n\n    const setReal = (val) => {\n      // Deleting the property before re-assigning it disables the\n      // getter/setter mechanism.\n      delete object[name];\n      object[name] = val;\n    };\n\n    ObjectDefineProperty(object\x2C name\x2C {\n      __proto__: null\x2C\n      get: () => {\n        const lib = dummyModule.require(name);\n\n        // Disable the current getter/setter and set up a new\n        // non-enumerable property.\n        delete object[name];\n        ObjectDefineProperty(object\x2C name\x2C {\n          __proto__: null\x2C\n          get: () => lib\x2C\n          set: setReal\x2C\n          configurable: true\x2C\n          enumerable: false\n        });\n\n        return lib;\n      }\x2C\n      set: setReal\x2C\n      configurable: true\x2C\n      enumerable: false\n    });\n  });\n}\n\n/**\n *\n * @param {string | URL} referrer\n * @returns {string}\n */\nfunction normalizeReferrerURL(referrer) {\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\n    return pathToFileURL(referrer).href;\n  }\n  return new URL(referrer).href;\n}\n\n// For error messages only - used to check if ESM syntax is in use.\nfunction hasEsmSyntax(code) {\n  debug('Checking for ESM syntax');\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\n  let root;\n  try {\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\n  } catch {\n    return false;\n  }\n\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\n    stmt.type === 'ExportDefaultDeclaration' ||\n    stmt.type === 'ExportNamedDeclaration' ||\n    stmt.type === 'ImportDeclaration' ||\n    stmt.type === 'ExportAllDeclaration');\n}\n\nmodule.exports = {\n  addBuiltinLibsToObject\x2C\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n};\n
code-source-info,0xb469fbd3e08,395,0,6862,C0O0C4O6862,,
code-creation,Function,10,92103,0xb469fbd4388,536, node:internal/modules/cjs/helpers:1:1,0xb469fbd3d80,~
code-source-info,0xb469fbd4388,395,0,6862,C0O0C104O25C110O50C116O72C122O94C128O118C134O151C139O162C144O173C150O202C156O229C162O253C168O373C174O373C179O399C184O307C190O342C196O432C202O432C207O415C213O499C219O499C224O480C230O544C236O544C240O544C242O607C248O607C253O569C259O584C265O599C271O660C277O660C282O641C287O712C290O712C295O757C301O757C306O790C319O791C325O757C327O856C330O856C335O911C346O1041C353O1083C354O1083C410O1105C465O1041C470O1041C472O1665C474O1665C479O1665C481O6702C488O6723C494O6749C500O6766C506O6782C512O6802C518O6825C524O6849C530O6717C535O6861,,
code-creation,LazyCompile,10,92240,0xb469fbd5020,27,SafeSet node:internal/per_context/primordials:379:16,0xb4665146108,~
code-source-info,0xb469fbd5020,12,10928,10945,C3O10934C7O10940C11O10934C26O10944,,
code-creation,LazyCompile,10,92295,0xb469fbd51e8,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0xb469fbd2970,~
code-source-info,0xb469fbd51e8,394,373,373,C0O373C15O373,,
code-creation,LazyCompile,10,92325,0xb469fbd5568,27,SafeWeakMap node:internal/per_context/primordials:372:16,0xb4665146068,~
code-source-info,0xb469fbd5568,12,10772,10789,C3O10778C7O10784C11O10778C26O10788,,
code-creation,LazyCompile,10,92366,0xb469fbd5668,27,SafeFinalizationRegistry node:internal/per_context/primordials:393:16,0xb4665146248,~
code-source-info,0xb469fbd5668,12,11378,11423,C3O11398C7O11404C11O11398C26O11422,,
code-creation,LazyCompile,10,92517,0xb469fbd5da8,358,initializeDeprecations node:internal/bootstrap/pre_execution:364:32,0xb46f7df0c40,~
tick,0x7ff805ea4a11,92621,0,0x0,3,0x102d5e910,0xb46f7df2eba,0xb46f7dee5f7
code-source-info,0xb469fbd5da8,389,11243,13163,C0O11272C6O11272C11O11258C16O11327C24O11327C29O11518C35O11518C40O11559C46O11559C51O11612C80O11604C108O11604C111O11930C122O11950C126O11992C137O12066C148O12156C159O12111C168O11977C177O12215C180O11948C184O11593C249O12492C255O12492C260O12471C265O12521C267O12549C278O12570C285O12711C289O12549C294O12743C298O12773C304O12809C314O12886C321O12791C326O12789C330O12972C336O13014C347O12996C352O12994C357O13162,,
code-creation,LazyCompile,10,92695,0xb469fbd60f0,53,initializeWASI node:internal/bootstrap/pre_execution:502:24,0xb46f7df0d80,~
code-source-info,0xb469fbd60f0,389,15852,16058,C0O15884C6O15884C11O15867C16O15950C21O15954C29O15954C35O15969C37O16000C43O16000C47O15994C52O16057,,
code-creation,LazyCompile,10,92749,0xb469fbd6240,53,runDeserializeCallbacks node:internal/v8/startup_snapshot:31:33,0xb466517e620,~
script-source,82,node:internal/v8/startup_snapshot,'use strict';\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\nconst {\n  ERR_NOT_BUILDING_SNAPSHOT\x2C\n  ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION\n} = require('internal/errors');\n\nconst {\n  setSerializeCallback\x2C\n  setDeserializeCallback\x2C\n  setDeserializeMainFunction: _setDeserializeMainFunction\x2C\n  markBootstrapComplete\n} = internalBinding('mksnapshot');\n\nfunction isBuildingSnapshot() {\n  // For now this is the only way to build a snapshot.\n  return require('internal/options').getOptionValue('--build-snapshot');\n}\n\nfunction throwIfNotBuildingSnapshot() {\n  if (!isBuildingSnapshot()) {\n    throw new ERR_NOT_BUILDING_SNAPSHOT();\n  }\n}\n\nconst deserializeCallbacks = [];\nlet deserializeCallbackIsSet = false;\nfunction runDeserializeCallbacks() {\n  while (deserializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = deserializeCallbacks.shift();\n    callback(data);\n  }\n}\n\nfunction addDeserializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  if (!deserializeCallbackIsSet) {\n    // TODO(joyeecheung): when the main function handling is done in JS\x2C\n    // the deserialize callbacks can always be invoked. For now only\n    // store it in C++ when it's actually used to avoid unnecessary\n    // C++ -> JS costs.\n    setDeserializeCallback(runDeserializeCallbacks);\n    deserializeCallbackIsSet = true;\n  }\n  deserializeCallbacks.push([callback\x2C data]);\n}\n\nconst serializeCallbacks = [];\nfunction runSerializeCallbacks() {\n  while (serializeCallbacks.length > 0) {\n    const { 0: callback\x2C 1: data } = serializeCallbacks.shift();\n    callback(data);\n  }\n  // Remove the hooks from the snapshot.\n  require('v8').startupSnapshot = undefined;\n}\n\nfunction addSerializeCallback(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  validateFunction(callback\x2C 'callback');\n  serializeCallbacks.push([callback\x2C data]);\n}\n\nfunction initializeCallbacks() {\n  // Only run the serialize callbacks in snapshot building mode\x2C otherwise\n  // they throw.\n  if (isBuildingSnapshot()) {\n    setSerializeCallback(runSerializeCallbacks);\n  }\n}\n\nlet deserializeMainIsSet = false;\nfunction setDeserializeMainFunction(callback\x2C data) {\n  throwIfNotBuildingSnapshot();\n  // TODO(joyeecheung): In lib/internal/bootstrap/node.js\x2C create a default\n  // main function to run the lib/internal/main scripts and make sure that\n  // the main function set in the snapshot building process takes precedence.\n  validateFunction(callback\x2C 'callback');\n  if (deserializeMainIsSet) {\n    throw new ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION();\n  }\n  deserializeMainIsSet = true;\n\n  _setDeserializeMainFunction(function deserializeMain() {\n    const {\n      prepareMainThreadExecution\n    } = require('internal/bootstrap/pre_execution');\n\n    // This should be in sync with run_main_module.js until we make that\n    // a built-in main function.\n    prepareMainThreadExecution(true);\n    markBootstrapComplete();\n    callback(data);\n  });\n}\n\nmodule.exports = {\n  initializeCallbacks\x2C\n  runDeserializeCallbacks\x2C\n  // Exposed to require('v8').startupSnapshot\n  namespace: {\n    addDeserializeCallback\x2C\n    addSerializeCallback\x2C\n    setDeserializeMainFunction\x2C\n    isBuildingSnapshot\n  }\n};\n
code-source-info,0xb469fbd6240,82,760,901,C0O802C5O795C11O802C16O846C21O867C26O867C31O824C37O837C44O880C48O767C52O900,,
code-creation,LazyCompile,10,93148,0xb469fbd67d0,66,initializeCJSLoader node:internal/bootstrap/pre_execution:509:29,0xb46f7df0dd0,~
code-source-info,0xb469fbd67d0,389,16088,16403,C0O16113C6O16113C11O16155C16O16160C20O16180C26O16218C31O16225C36O16225C40O16321C51O16342C56O16378C60O16336C65O16402,,
tick,0x102a6020d,93949,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,94478,0xb469fbd94c8,5, node:internal/modules/cjs/loader:1:1,0xb469fbd7f80,~
script-source,396,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypeUnshiftApply\x2C\n  ArrayPrototypeFlatMap\x2C\n  Boolean\x2C\n  Error\x2C\n  JSONParse\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototype\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Proxy\x2C\n  ReflectApply\x2C\n  ReflectSet\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeCharAt\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\n// Map used to store CJS parsing data.\nconst cjsParseCache = new SafeWeakMap();\n\n// Set first due to cycle with ESM loader functions.\nmodule.exports = {\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\n};\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  maybeCacheSourceMap\x2C\n} = require('internal/source_map/source_map_cache');\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\nconst { deprecate\x2C kEmptyObject } = require('internal/util');\nconst vm = require('vm');\nconst assert = require('internal/assert');\nconst fs = require('fs');\nconst internalFS = require('internal/fs/utils');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = internalBinding('fs');\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst { safeGetenv } = internalBinding('credentials');\nconst {\n  cjsConditions\x2C\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  makeRequireFunction\x2C\n  normalizeReferrerURL\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst { getOptionValue } = require('internal/options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\n\n// Whether any user-provided CJS modules had been loaded (executed).\n// Used for internal assertions.\nlet hasLoadedAnyUserCJSModule = false;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_MODULE_SPECIFIER\x2C\n    ERR_REQUIRE_ESM\x2C\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  }\x2C\n  setArrowMessage\x2C\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_COLON\n} = require('internal/constants');\n\nconst {\n  isProxy\n} = require('internal/util/types');\n\nconst asyncESM = require('internal/process/esm_loader');\nconst { enrichCJSError } = require('internal/modules/esm/translators');\nconst { kEvaluated } = internalBinding('module_wrap');\nconst {\n  encodedSepRegEx\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\n} = require('internal/modules/esm/resolve');\n\nconst isWindows = process.platform === 'win32';\n\nconst relativeResolveCache = ObjectCreate(null);\n\nlet requireDepth = 0;\nlet statCache = null;\nlet isPreloading = false;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename\x2C result);\n  }\n  return result;\n}\n\nfunction updateChildren(parent\x2C child\x2C scan) {\n  const children = parent?.children;\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\n    ArrayPrototypePush(children\x2C child);\n}\n\nconst moduleParentCache = new SafeWeakMap();\nfunction Module(id = ''\x2C parent) {\n  this.id = id;\n  this.path = path.dirname(id);\n  this.exports = {};\n  moduleParentCache.set(this\x2C parent);\n  updateChildren(parent\x2C this\x2C false);\n  this.filename = null;\n  this.loaded = false;\n  this.children = [];\n}\n\nconst builtinModules = [];\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\n  if (mod.canBeRequiredByUsers &&\n    NativeModule.canBeRequiredWithoutScheme(id)) {\n    ArrayPrototypePush(builtinModules\x2C id);\n  }\n}\n\nconst allBuiltins = new SafeSet(\n  ArrayPrototypeFlatMap(builtinModules\x2C (bm) => [bm\x2C `node:${bm}`])\n);\nNativeModule.getSchemeOnlyModuleNames().forEach((builtin) => allBuiltins.add(`node:${builtin}`));\n\nObjectFreeze(builtinModules);\nModule.builtinModules = builtinModules;\n\nModule._cache = ObjectCreate(null);\nModule._pathCache = ObjectCreate(null);\nModule._extensions = ObjectCreate(null);\nlet modulePaths = [];\nModule.globalPaths = [];\n\nlet patched = false;\n\n// eslint-disable-next-line func-style\nlet wrap = function(script) {\n  return Module.wrapper[0] + script + Module.wrapper[1];\n};\n\nconst wrapper = [\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\n  '\\n});'\x2C\n];\n\nlet wrapperProxy = new Proxy(wrapper\x2C {\n  __proto__: null\x2C\n\n  set(target\x2C property\x2C value\x2C receiver) {\n    patched = true;\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\n  }\x2C\n\n  defineProperty(target\x2C property\x2C descriptor) {\n    patched = true;\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrap;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrap = value;\n  }\n});\n\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\n  __proto__: null\x2C\n  get() {\n    return wrapperProxy;\n  }\x2C\n\n  set(value) {\n    patched = true;\n    wrapperProxy = value;\n  }\n});\n\nconst isPreloadingDesc = { get() { return isPreloading; } };\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\n\nfunction getModuleParent() {\n  return moduleParentCache.get(this);\n}\n\nfunction setModuleParent(value) {\n  moduleParentCache.set(this\x2C value);\n}\n\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  get: pendingDeprecation ? deprecate(\n    getModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : getModuleParent\x2C\n  set: pendingDeprecation ? deprecate(\n    setModuleParent\x2C\n    'module.parent is deprecated due to accuracy issues. Please use ' +\n      'require.main to find program entry point instead.'\x2C\n    'DEP0144'\n  ) : setModuleParent\x2C\n});\n\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\n  debug = fn;\n});\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\n\n// Given a module name\x2C and a list of paths to test\x2C returns the first\n// matching file in the following precedence.\n//\n// require("a.<ext>")\n//   -> a.<ext>\n//\n// require("a")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath\x2C false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name\x2C\n      main: parsed.main\x2C\n      exports: parsed.exports\x2C\n      imports: parsed.imports\x2C\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath\x2C filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson\x2C\n      path: checkPath\x2C\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\n  const pkg = readPackage(requestPath)?.main;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n  }\n\n  const filename = path.resolve(requestPath\x2C pkg);\n  let actual = tryFile(filename\x2C isMain) ||\n    tryExtensions(filename\x2C exts\x2C isMain) ||\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid "main" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath\x2C 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author'\x2C\n        'DeprecationWarning'\x2C\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls\x2C\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false\x2C\n// keep symlinks intact\x2C otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath\x2C isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath\x2C {\n    [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\n// Given a path\x2C check if the file exists with any of the set extensions\nfunction tryExtensions(p\x2C exts\x2C isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i]\x2C isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\n// Find the longest (possibly multi-dot) extension registered in\n// Module._extensions\nfunction findLongestRegisteredExtension(filename) {\n  const name = path.basename(filename);\n  let currentExtension;\n  let index;\n  let startIndex = 0;\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\n    startIndex = index + 1;\n    if (index === 0) continue; // Skip dotfiles like .gitignore\n    currentExtension = StringPrototypeSlice(name\x2C index);\n    if (Module._extensions[currentExtension]) return currentExtension;\n  }\n  return '.js';\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath\x2C request) {\n  if (!parentPath) return false;\n\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C parentPath\x2C pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath\x2C request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name\x2C 2: expansion = '' } =\n    RegExpPrototypeExec(EXPORTS_PATTERN\x2C request) || kEmptyObject;\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath\x2C name);\n  const pkg = readPackage(pkgPath);\n  if (pkg?.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\n        cjsConditions)\x2C null\x2C pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nModule._findPath = function(request\x2C paths\x2C isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\n  const entry = Module._pathCache[cacheKey];\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeExec(trailingSlashRegex\x2C request) !== null;\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath\x2C request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const basePath = path.resolve(curPath\x2C request);\n    let filename;\n\n    const rc = stat(basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working\x2C as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said\x2C in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at "index"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\n    }\n\n    if (filename) {\n      Module._pathCache[cacheKey] = filename;\n      return filename;\n    }\n  }\n\n  return false;\n};\n\n// 'node_modules' character codes reversed\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\nconst nmLen = nmChars.length;\nif (isWindows) {\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n\n    // return root node_modules when path is 'D:\\\\'.\n    // path.resolve will make sure from.length >=3 in Windows.\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\n          CHAR_BACKWARD_SLASH &&\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\n      return [from + 'node_modules'];\n\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      // The path segment separator check ('\\' and '/') was used to get\n      // node_modules path for every path segment.\n      // Use colon as an extra condition since we can get node_modules\n      // path for drive root like 'C:\\node_modules' and don't need to\n      // parse drive name.\n      if (code === CHAR_BACKWARD_SLASH ||\n          code === CHAR_FORWARD_SLASH ||\n          code === CHAR_COLON) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    return paths;\n  };\n} else { // posix\n  // 'from' is the __dirname of the module.\n  Module._nodeModulePaths = function(from) {\n    // Guarantee that 'from' is absolute.\n    from = path.resolve(from);\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\n    if (from === '/')\n      return ['/node_modules'];\n\n    // note: this approach *only* works when the path is guaranteed\n    // to be absolute.  Doing a fully-edge-case-correct path.split\n    // that works on both Windows and Posix is non-trivial.\n    const paths = [];\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\n      const code = StringPrototypeCharCodeAt(from\x2C i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (p !== nmLen)\n          ArrayPrototypePush(\n            paths\x2C\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\n          );\n        last = i;\n        p = 0;\n      } else if (p !== -1) {\n        if (nmChars[p] === code) {\n          ++p;\n        } else {\n          p = -1;\n        }\n      }\n    }\n\n    // Append /node_modules to handle root paths.\n    ArrayPrototypePush(paths\x2C '/node_modules');\n\n    return paths;\n  };\n}\n\nModule._resolveLookupPaths = function(request\x2C parent) {\n  if (NativeModule.canBeRequiredByUsers(request) &&\n      NativeModule.canBeRequiredWithoutScheme(request)) {\n    debug('looking for %j in []'\x2C request);\n    return null;\n  }\n\n  // Check for node modules paths.\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\n      (request.length > 1 &&\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\n\n    let paths = modulePaths;\n    if (parent?.paths?.length) {\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\n    }\n\n    debug('looking for %j in %j'\x2C request\x2C paths);\n    return paths.length > 0 ? paths : null;\n  }\n\n  // In REPL\x2C parent.filename is null.\n  if (!parent || !parent.id || !parent.filename) {\n    // Make require('./path/to/foo') work - normally the path is taken\n    // from realpath(__filename) but in REPL there is no filename\n    const mainPaths = ['.'];\n\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\n    return mainPaths;\n  }\n\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\n\n  const parentDir = [path.dirname(parent.filename)];\n  debug('looking for %j'\x2C parentDir);\n  return parentDir;\n};\n\nfunction emitCircularRequireWarning(prop) {\n  process.emitWarning(\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\n    'inside circular dependency'\n  );\n}\n\n// A Proxy that can be used as the prototype of a module.exports object and\n// warns when non-existent properties are accessed.\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\n  __proto__: null\x2C\n\n  get(target\x2C prop) {\n    // Allow __esModule access in any case because it is used in the output\n    // of transpiled code to determine whether something comes from an\n    // ES module\x2C and is not used as a regular key of `module.exports`.\n    if (prop in target || prop === '__esModule') return target[prop];\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\x2C\n\n  getOwnPropertyDescriptor(target\x2C prop) {\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\n    emitCircularRequireWarning(prop);\n    return undefined;\n  }\n});\n\nfunction getExportsForCircularRequire(module) {\n  if (module.exports &&\n      !isProxy(module.exports) &&\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\n      // Exclude transpiled ES6 modules / TypeScript code because those may\n      // employ unusual patterns for accessing 'module.exports'. That should\n      // be okay because ES6 modules have a different approach to circular\n      // dependencies anyway.\n      !module.exports.__esModule) {\n    // This is later unset once the module is done loading.\n    ObjectSetPrototypeOf(\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\n  }\n\n  return module.exports;\n}\n\n// Check the cache for the requested file.\n// 1. If a module already exists in the cache: return its exports object.\n// 2. If the module is native: call\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\n//    Then have it load  the file contents before returning its exports\n//    object.\nModule._load = function(request\x2C parent\x2C isMain) {\n  let relResolveCacheIdentifier;\n  if (parent) {\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\n    // caching is required to allow cache invalidation without changing the old\n    // cache key names.\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\n    if (filename !== undefined) {\n      const cachedModule = Module._cache[filename];\n      if (cachedModule !== undefined) {\n        updateChildren(parent\x2C cachedModule\x2C true);\n        if (!cachedModule.loaded)\n          return getExportsForCircularRequire(cachedModule);\n        return cachedModule.exports;\n      }\n      delete relativeResolveCache[relResolveCacheIdentifier];\n    }\n  }\n\n  if (StringPrototypeStartsWith(request\x2C 'node:')) {\n    // Slice 'node:' prefix\n    const id = StringPrototypeSlice(request\x2C 5);\n\n    const module = loadNativeModule(id\x2C request);\n    if (!module?.canBeRequiredByUsers) {\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(request);\n    }\n\n    return module.exports;\n  }\n\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\n  const cachedModule = Module._cache[filename];\n  if (cachedModule !== undefined) {\n    updateChildren(parent\x2C cachedModule\x2C true);\n    if (!cachedModule.loaded) {\n      const parseCachedModule = cjsParseCache.get(cachedModule);\n      if (!parseCachedModule || parseCachedModule.loaded)\n        return getExportsForCircularRequire(cachedModule);\n      parseCachedModule.loaded = true;\n    } else {\n      return cachedModule.exports;\n    }\n  }\n\n  const mod = loadNativeModule(filename\x2C request);\n  if (mod?.canBeRequiredByUsers &&\n      NativeModule.canBeRequiredWithoutScheme(filename)) {\n    return mod.exports;\n  }\n\n  // Don't call updateChildren()\x2C Module constructor already does.\n  const module = cachedModule || new Module(filename\x2C parent);\n\n  if (isMain) {\n    process.mainModule = module;\n    module.id = '.';\n  }\n\n  Module._cache[filename] = module;\n  if (parent !== undefined) {\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\n  }\n\n  let threw = true;\n  try {\n    module.load(filename);\n    threw = false;\n  } finally {\n    if (threw) {\n      delete Module._cache[filename];\n      if (parent !== undefined) {\n        delete relativeResolveCache[relResolveCacheIdentifier];\n        const children = parent?.children;\n        if (ArrayIsArray(children)) {\n          const index = ArrayPrototypeIndexOf(children\x2C module);\n          if (index !== -1) {\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\n          }\n        }\n      }\n    } else if (module.exports &&\n               !isProxy(module.exports) &&\n               ObjectGetPrototypeOf(module.exports) ===\n                 CircularRequirePrototypeWarningProxy) {\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\n    }\n  }\n\n  return module.exports;\n};\n\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\n  if (\n    (\n      StringPrototypeStartsWith(request\x2C 'node:') &&\n      NativeModule.canBeRequiredByUsers(StringPrototypeSlice(request\x2C 5))\n    ) || (\n      NativeModule.canBeRequiredByUsers(request) &&\n      NativeModule.canBeRequiredWithoutScheme(request)\n    )\n  ) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\n          StringPrototypeStartsWith(request\x2C '../') ||\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module(''\x2C null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request\x2C parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request\x2C parent);\n  }\n\n  if (request[0] === '#' && (parent?.filename || parent?.id === '<repl>')) {\n    const parentPath = parent?.filename ?? process.cwd() + path.sep;\n    const pkg = readPackageScope(parentPath) || {};\n    if (pkg.data?.imports != null) {\n      try {\n        return finalizeEsmResolution(\n          packageImportsResolve(request\x2C pathToFileURL(parentPath)\x2C\n                                cjsConditions)\x2C parentPath\x2C\n          pkg.path);\n      } catch (e) {\n        if (e.code === 'ERR_MODULE_NOT_FOUND')\n          throw createEsmNotFoundErr(request);\n        throw e;\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath\x2C request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first\x2C since that's the cache key.\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\n  if (RegExpPrototypeExec(encodedSepRegEx\x2C resolved) !== null)\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename\x2C\n                                   path.resolve(pkgPath\x2C 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request\x2C path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n// Given a file name\x2C pass it to the proper extension handler.\nModule.prototype.load = function(filename) {\n  debug('load %j for module %j'\x2C filename\x2C this.id);\n\n  assert(!this.loaded);\n  this.filename = filename;\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\n\n  const extension = findLongestRegisteredExtension(filename);\n  // allow .mjs to be overridden\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\n\n  Module._extensions[extension](this\x2C filename);\n  this.loaded = true;\n\n  const esmLoader = asyncESM.esmLoader;\n  // Create module entry at load time to snapshot exports correctly\n  const exports = this.exports;\n  // Preemptively cache\n  if ((module?.module === undefined ||\n       module.module.getStatus() < kEvaluated) &&\n      !esmLoader.cjsCache.has(this))\n    esmLoader.cjsCache.set(this\x2C exports);\n};\n\n\n// Loads a module at the given file path. Returns that module's\n// `exports` property.\nModule.prototype.require = function(id) {\n  validateString(id\x2C 'id');\n  if (id === '') {\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\n                                    'must be a non-empty string');\n  }\n  requireDepth++;\n  try {\n    return Module._load(id\x2C this\x2C /* isMain */ false);\n  } finally {\n    requireDepth--;\n  }\n};\n\n\n// Resolved path to process.argv[1] will be lazily placed here\n// (needed for setting breakpoint when called with --inspect-brk)\nlet resolvedArgv;\nlet hasPausedEntry = false;\n\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\n  if (patched) {\n    const wrapper = Module.wrap(content);\n    return vm.runInThisContext(wrapper\x2C {\n      filename\x2C\n      lineOffset: 0\x2C\n      displayErrors: true\x2C\n      importModuleDynamically: async (specifier\x2C _\x2C importAssertions) => {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\n                             importAssertions);\n      }\x2C\n    });\n  }\n  try {\n    return vm.compileFunction(content\x2C [\n      'exports'\x2C\n      'require'\x2C\n      'module'\x2C\n      '__filename'\x2C\n      '__dirname'\x2C\n    ]\x2C {\n      filename\x2C\n      importModuleDynamically(specifier\x2C _\x2C importAssertions) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\n                             importAssertions);\n      }\x2C\n    });\n  } catch (err) {\n    if (process.mainModule === cjsModuleInstance)\n      enrichCJSError(err\x2C content);\n    throw err;\n  }\n}\n\n// Run the file contents in the correct scope or sandbox. Expose\n// the correct helper variables (require\x2C module\x2C exports) to\n// the file.\n// Returns exception\x2C if any.\nModule.prototype._compile = function(content\x2C filename) {\n  let moduleURL;\n  let redirects;\n  if (policy?.manifest) {\n    moduleURL = pathToFileURL(filename);\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  maybeCacheSourceMap(filename\x2C content\x2C this);\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\n\n  let inspectorWrapper = null;\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\n    if (!resolvedArgv) {\n      // We enter the repl if we're not given a filename argument.\n      if (process.argv[1]) {\n        try {\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\n        } catch {\n          // We only expect this codepath to be reached in the case of a\n          // preloaded module (it will fail earlier with the main entry)\n          assert(ArrayIsArray(getOptionValue('--require')));\n        }\n      } else {\n        resolvedArgv = 'repl';\n      }\n    }\n\n    // Set breakpoint on module start\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\n      hasPausedEntry = true;\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\n    }\n  }\n  const dirname = path.dirname(filename);\n  const require = makeRequireFunction(this\x2C redirects);\n  let result;\n  const exports = this.exports;\n  const thisValue = exports;\n  const module = this;\n  if (requireDepth === 0) statCache = new SafeMap();\n  if (inspectorWrapper) {\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\n                              require\x2C module\x2C filename\x2C dirname);\n  } else {\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\n  }\n  hasLoadedAnyUserCJSModule = true;\n  if (requireDepth === 0) statCache = null;\n  return result;\n};\n\n// Native extension for .js\nModule._extensions['.js'] = function(module\x2C filename) {\n  // If already analyzed the source\x2C then it will be cached.\n  const cached = cjsParseCache.get(module);\n  let content;\n  if (cached?.source) {\n    content = cached.source;\n    cached.source = undefined;\n  } else {\n    content = fs.readFileSync(filename\x2C 'utf8');\n  }\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\n    const pkg = readPackageScope(filename);\n    // Function require shouldn't be used in ES modules.\n    if (pkg?.data?.type === 'module') {\n      const parent = moduleParentCache.get(module);\n      const parentPath = parent?.filename;\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\n      const usesEsm = hasEsmSyntax(content);\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\n                                      packageJsonPath);\n      // Attempt to reconstruct the parent require frame.\n      if (Module._cache[parentPath]) {\n        let parentSource;\n        try {\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\n        } catch {\n          // Continue regardless of error.\n        }\n        if (parentSource) {\n          const errLine = StringPrototypeSplit(\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\n          const { 1: line\x2C 2: col } =\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\n          if (line && col) {\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\n            setArrowMessage(err\x2C frame);\n          }\n        }\n      }\n      throw err;\n    }\n  }\n  module._compile(content\x2C filename);\n};\n\n\n// Native extension for .json\nModule._extensions['.json'] = function(module\x2C filename) {\n  const content = fs.readFileSync(filename\x2C 'utf8');\n\n  if (policy?.manifest) {\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n\n  try {\n    module.exports = JSONParse(stripBOM(content));\n  } catch (err) {\n    err.message = filename + ': ' + err.message;\n    throw err;\n  }\n};\n\n\n// Native extension for .node\nModule._extensions['.node'] = function(module\x2C filename) {\n  if (policy?.manifest) {\n    const content = fs.readFileSync(filename);\n    const moduleURL = pathToFileURL(filename);\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\n  }\n  // Be aware this doesn't use `content`\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\n};\n\nfunction createRequireFromPath(filename) {\n  // Allow a directory to be passed as the filename\n  const trailingSlash =\n    StringPrototypeEndsWith(filename\x2C '/') ||\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\n\n  const proxyPath = trailingSlash ?\n    path.join(filename\x2C 'noop.js') :\n    filename;\n\n  const m = new Module(proxyPath);\n  m.filename = proxyPath;\n\n  m.paths = Module._nodeModulePaths(m.path);\n  return makeRequireFunction(m\x2C null);\n}\n\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\n  'absolute path string';\n\nfunction createRequire(filename) {\n  let filepath;\n\n  if (isURLInstance(filename) ||\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\n    try {\n      filepath = fileURLToPath(filename);\n    } catch {\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\n                                      createRequireError);\n    }\n  } else if (typeof filename !== 'string') {\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\n  } else {\n    filepath = filename;\n  }\n  return createRequireFromPath(filepath);\n}\n\nModule.createRequire = createRequire;\n\nModule._initPaths = function() {\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\n\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\n  const prefixDir = isWindows ?\n    path.resolve(process.execPath\x2C '..') :\n    path.resolve(process.execPath\x2C '..'\x2C '..');\n\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\n\n  if (homeDir) {\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\n  }\n\n  if (nodePath) {\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\n      Boolean\n    ));\n  }\n\n  modulePaths = paths;\n\n  // Clone as a shallow copy\x2C for introspection.\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\n};\n\nModule._preloadModules = function(requests) {\n  if (!ArrayIsArray(requests))\n    return;\n\n  isPreloading = true;\n\n  // Preloaded modules have a dummy parent module which is deemed to exist\n  // in the current working directory. This seeds the search path for\n  // preloaded modules.\n  const parent = new Module('internal/preload'\x2C null);\n  try {\n    parent.paths = Module._nodeModulePaths(process.cwd());\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      isPreloading = false;\n      throw e;\n    }\n  }\n  for (let n = 0; n < requests.length; n++)\n    parent.require(requests[n]);\n  isPreloading = false;\n};\n\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\n  for (const mod of NativeModule.map.values()) {\n    if (mod.canBeRequiredByUsers &&\n        NativeModule.canBeRequiredWithoutScheme(mod.id)) {\n      mod.syncExports();\n    }\n  }\n};\n\nModule.isBuiltin = function isBuiltin(moduleName) {\n  return allBuiltins.has(moduleName);\n};\n\n// Backwards compatibility\nModule.Module = Module;\n
code-source-info,0xb469fbd94c8,396,0,40985,C0O0C4O40985,,
code-creation,Function,10,99304,0xb469fbdb398,2678, node:internal/modules/cjs/loader:1:1,0xb469fbd9440,~
code-source-info,0xb469fbdb398,396,0,40985,C0O0C446O1159C452O1175C458O1199C464O1223C470O1249C476O1274C482O1296C488O1318C494O1341C500O1365C506O1390C512O1420C517O1445C523O1456C529O1465C535O1478C540O1494C546O1518C551O1534C557O1568C563O1592C569O1606C575O1625C581O1658C587O1682C592O1691C598O1707C604O1721C610O1744C616O1755C621O1766C626O1781C632O1791C638O1816C644O1845C650O1872C656O1902C662O1928C668O1953C674O1977C680O2001C686O2107C688O2107C693O2107C695O2180C707O2201C713O2211C719O2219C725O2231C731O2249C761O2195C765O2365C769O2365C775O2348C781O2439C785O2439C791O2414C797O2544C801O2544C807O2496C813O2511C819O2526C825O2605C829O2605C835O2577C840O2588C846O2642C850O2642C854O2642C856O2672C860O2672C864O2672C866O2711C870O2711C874O2711C876O2745C880O2745C884O2745C886O2788C890O2788C894O2788C896O2821C900O2813C906O2858C914O2858C920O2835C926O2907C930O2907C934O2907C936O2979C944O2979C950O2964C956O3135C960O3135C966O3021C972O3038C978O3054C984O3074C990O3097C996O3121C1002O3203C1006O3203C1012O3184C1018O3257C1026O3257C1030O3257C1032O3325C1040O3325C1044O3325C1046O3435C1054O3435C1064O3479C1071O3435C1073O3659C1074O3659C1076O3828C1080O3828C1086O3828C1092O3690C1098O3717C1104O3751C1110O3772C1116O3807C1122O3883C1126O3883C1132O3864C1138O3942C1146O3942C1151O4054C1155O4054C1161O3994C1167O4016C1173O4039C1179O4108C1183O4108C1189O4096C1195O4158C1199O4158C1203O4158C1205O4225C1209O4225C1215O4206C1221O4293C1229O4293C1235O4278C1241O4405C1245O4405C1251O4335C1257O4354C1263O4379C1269O4465C1273O4473C1281O4482C1284O4465C1286O4525C1289O4525C1293O4525C1295O4565C1296O4565C1298O4584C1299O4584C1301O4609C1302O4609C1304O5253C1306O5253C1311O5253C1313O5549C1316O5598C1320O5598C1354O5580C1385O5569C1393O5576C1402O5615C1412O5656C1418O5656C1425O5694C1429O5694C1434O5553C1505O5798C1511O5776C1520O5761C1530O5761C1532O5845C1536O5858C1546O5858C1556O5884C1572O5885C1582O5944C1590O5974C1596O5996C1604O6015C1611O6031C1619O6029C1627O6051C1634O6071C1642O6069C1650O6091C1657O6112C1665O6110C1673O6150C1677O6150C1679O6154C1687O6173C1695O6194C1696O6194C1698O6252C1702O6252C1704O6348C1712O6462C1721O6495C1733O6622C1750O6452C1760O6452C1762O6761C1774O6782C1783O6821C1795O6854C1807O6761C1817O6914C1829O6935C1838O6977C1850O7018C1862O6914C1872O7111C1881O7113C1896O7147C1904O7175C1921O7147C1931O7221C1939O7255C1956O7221C1966O7447C1974O7475C1999O7524C2007O7647C2022O7545C2036O7728C2046O7752C2054O7875C2069O7773C2083O7956C2091O7447C2101O7990C2105O7990C2115O8023C2135O8024C2147O7990C2149O8071C2165O8087C2175O8085C2183O8400C2187O8400C2197O8400C2199O11203C2203O11203C2213O11203C2215O13823C2222O13823C2224O14607C2231O14607C2233O14625C2241O14642C2249O17327C2256O17327C2258O17404C2262O17412C2270O17404C2272O17420C2276O17483C2284O17507C2294O19091C2302O19115C2310O20261C2318O20288C2326O21894C2338O21932C2350O22309C2364O21894C2374O21894C2376O23597C2384O23610C2392O26607C2400O26631C2408O30695C2412O30702C2426O30717C2434O31631C2438O31638C2452O31656C2460O32094C2461O32094C2463O32129C2464O32129C2466O33322C2470O33329C2484O33348C2492O35230C2496O35237C2510O35256C2518O37052C2522O37059C2536O37080C2544O37480C2548O37487C2562O37508C2570O38321C2576O38371C2582O38321C2584O38955C2590O38976C2598O38994C2606O39012C2614O39981C2622O40004C2630O40591C2638O40620C2646O40840C2654O40857C2662O40961C2668O40975C2677O40984,,
tick,0x7ff805dd2b58,99534,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x103b6a350,99544,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805e4dde4,99551,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805e4dd52,99557,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,99727,0xb469fbdf5d8,5, node:internal/modules/package_json_reader:1:1,0xb469fbdf430,~
script-source,397,node:internal/modules/package_json_reader,'use strict';\n\nconst { SafeMap } = primordials;\nconst { internalModuleReadJSON } = internalBinding('fs');\nconst { pathToFileURL } = require('url');\nconst { toNamespacedPath } = require('path');\n\nconst cache = new SafeMap();\n\nlet manifest;\n\n/**\n *\n * @param {string} jsonPath\n */\nfunction read(jsonPath) {\n  if (cache.has(jsonPath)) {\n    return cache.get(jsonPath);\n  }\n\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\n    toNamespacedPath(jsonPath)\n  );\n  const result = { string\x2C containsKeys };\n  const { getOptionValue } = require('internal/options');\n  if (string !== undefined) {\n    if (manifest === undefined) {\n      manifest = getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').manifest :\n        null;\n    }\n    if (manifest !== null) {\n      const jsonURL = pathToFileURL(jsonPath);\n      manifest.assertIntegrity(jsonURL\x2C string);\n    }\n  }\n  cache.set(jsonPath\x2C result);\n  return result;\n}\n\nmodule.exports = { read };\n
code-source-info,0xb469fbdf5d8,397,0,983,C0O0C4O983,,
code-creation,Function,10,99862,0xb469fbdf728,113, node:internal/modules/package_json_reader:1:1,0xb469fbdf550,~
code-source-info,0xb469fbdf728,397,0,983,C0O0C29O23C34O83C37O83C42O56C48O132C54O132C59O114C65O177C71O177C76O156C82O209C84O209C89O209C91O229C92O229C94O956C101O975C107O971C112O982,,
code-creation,Eval,10,99994,0xb469fbdfef0,5, node:internal/process/esm_loader:1:1,0xb469fbdfce8,~
script-source,398,node:internal/process/esm_loader,'use strict';\n\nconst {\n  ObjectCreate\x2C\n} = primordials;\n\nconst {\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\n} = require('internal/errors').codes;\nconst { ESMLoader } = require('internal/modules/esm/loader');\nconst {\n  hasUncaughtExceptionCaptureCallback\x2C\n} = require('internal/process/execution');\nconst { pathToFileURL } = require('internal/url');\nconst {\n  getModuleFromWrap\x2C\n} = require('internal/vm/module');\n\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { initializeImportMeta } = callbackMap.get(wrap);\n    if (initializeImportMeta !== undefined) {\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\n    }\n  }\n};\n\nexports.importModuleDynamicallyCallback =\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\n  const { callbackMap } = internalBinding('module_wrap');\n  if (callbackMap.has(wrap)) {\n    const { importModuleDynamically } = callbackMap.get(wrap);\n    if (importModuleDynamically !== undefined) {\n      return importModuleDynamically(\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\n    }\n  }\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\n};\n\nconst esmLoader = new ESMLoader();\nexports.esmLoader = esmLoader;\n\n// Module.runMain() causes loadESM() to re-run (which it should do); however\x2C this should NOT cause\n// ESM to be re-initialised; doing so causes duplicate custom loaders to be added to the public\n// esmLoader.\nlet isESMInitialized = false;\n\n/**\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\n * @returns {void}\n */\nasync function initializeLoader() {\n  if (isESMInitialized) { return; }\n\n  const { getOptionValue } = require('internal/options');\n  const customLoaders = getOptionValue('--experimental-loader');\n\n  if (customLoaders.length === 0) return;\n\n  let cwd;\n  try {\n    cwd = process.cwd() + '/';\n  } catch {\n    cwd = 'file:///';\n  }\n\n  // A separate loader instance is necessary to avoid cross-contamination\n  // between internal Node.js and userland. For example\x2C a module with internal\n  // state (such as a counter) should be independent.\n  const internalEsmLoader = new ESMLoader();\n\n  // Importation must be handled by internal loader to avoid poluting userland\n  const keyedExportsList = await internalEsmLoader.import(\n    customLoaders\x2C\n    pathToFileURL(cwd).href\x2C\n    ObjectCreate(null)\x2C\n  );\n\n  // Hooks must then be added to external/public loader\n  // (so they're triggered in userland)\n  await esmLoader.addCustomLoaders(keyedExportsList);\n\n  isESMInitialized = true;\n}\n\nexports.loadESM = async function loadESM(callback) {\n  try {\n    await initializeLoader();\n    await callback(esmLoader);\n  } catch (err) {\n    if (hasUncaughtExceptionCaptureCallback()) {\n      process._fatalException(err);\n      return;\n    }\n    internalBinding('errors').triggerUncaughtException(\n      err\x2C\n      true /* fromPromise */\n    );\n  }\n};\n
code-source-info,0xb469fbdfef0,398,0,2985,C0O0C4O2985,,
code-creation,Function,10,100379,0xb469fbe0190,188, node:internal/process/esm_loader:1:1,0xb469fbdfe68,~
code-source-info,0xb469fbe0190,398,0,2985,C0O0C47O25C53O111C59O111C64O137C69O67C75O167C81O167C86O153C92O258C98O258C103O217C109O323C115O323C120O305C126O381C132O381C137O358C143O413C147O448C151O749C155O789C159O1259C162O1259C167O1259C169O1276C171O1294C175O1541C176O1541C178O2630C182O2646C187O2984,,
tick,0x10280e170,100423,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,100778,0xb469fbe1818,5, node:internal/modules/esm/loader:1:1,0xb469fbe12f8,~
script-source,399,node:internal/modules/esm/loader,'use strict';\n\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\nrequire('internal/modules/cjs/loader');\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseAll\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeWeakMap\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToUpperCase\x2C\n  globalThis\x2C\n} = primordials;\nconst { MessageChannel } = require('internal/worker/io');\n\nconst {\n  ERR_LOADER_CHAIN_INCOMPLETE\x2C\n  ERR_INTERNAL_ASSERTION\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\n  ERR_INVALID_RETURN_VALUE\x2C\n  ERR_UNKNOWN_MODULE_FORMAT\x2C\n} = require('internal/errors').codes;\nconst { pathToFileURL\x2C isURLInstance\x2C URL } = require('internal/url');\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst ModuleMap = require('internal/modules/esm/module_map');\nconst ModuleJob = require('internal/modules/esm/module_job');\n\nconst {\n  defaultResolve\x2C\n  DEFAULT_CONDITIONS\x2C\n} = require('internal/modules/esm/resolve');\nconst {\n  initializeImportMeta\n} = require('internal/modules/esm/initialize_import_meta');\nconst { defaultLoad } = require('internal/modules/esm/load');\nconst { translators } = require(\n  'internal/modules/esm/translators');\nconst { getOptionValue } = require('internal/options');\n\n/**\n * @typedef {object} ExportedHooks\n * @property {Function} globalPreload\n * @property {Function} resolve\n * @property {Function} load\n */\n\n/**\n * @typedef {Record<string\x2C any>} ModuleExports\n */\n\n/**\n * @typedef {object} KeyedExports\n * @property {ModuleExports} exports\n * @property {URL['href']} url\n */\n\n/**\n * @typedef {object} KeyedHook\n * @property {Function} fn\n * @property {URL['href']} url\n */\n\n/**\n * @typedef {'builtin'|'commonjs'|'json'|'module'|'wasm'} ModuleFormat\n */\n\n/**\n * @typedef {ArrayBuffer|TypedArray|string} ModuleSource\n */\n\n// [2] `validate...()`s throw the wrong error\n\nlet emittedSpecifierResolutionWarning = false;\n\n/**\n * A utility function to iterate through a hook chain\x2C track advancement in the\n * chain\x2C and generate and supply the `next<HookName>` argument to the custom\n * hook.\n * @param {KeyedHook[]} chain The whole hook chain.\n * @param {object} meta Properties that change as the current hook advances\n * along the chain.\n * @param {boolean} meta.chainFinished Whether the end of the chain has been\n * reached AND invoked.\n * @param {string} meta.hookErrIdentifier A user-facing identifier to help\n *  pinpoint where an error occurred. Ex "file:///foo.mjs 'resolve'".\n * @param {number} meta.hookIndex A non-negative integer tracking the current\n * position in the hook chain.\n * @param {string} meta.hookName The kind of hook the chain is (ex 'resolve')\n * @param {boolean} meta.shortCircuited Whether a hook signaled a short-circuit.\n * @param {(hookErrIdentifier\x2C hookArgs) => void} validate A wrapper function\n *  containing all validation of a custom loader hook's intermediary output. Any\n *  validation within MUST throw.\n * @returns {function next<HookName>(...hookArgs)} The next hook in the chain.\n */\nfunction nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput }) {\n  // First\x2C prepare the current\n  const { hookName } = meta;\n  const {\n    fn: hook\x2C\n    url: hookFilePath\x2C\n  } = chain[meta.hookIndex];\n\n  // ex 'nextResolve'\n  const nextHookName = `next${\n    StringPrototypeToUpperCase(hookName[0]) +\n    StringPrototypeSlice(hookName\x2C 1)\n  }`;\n\n  // When hookIndex is 0\x2C it's reached the default\x2C which does not call next()\n  // so feed it a noop that blows up if called\x2C so the problem is obvious.\n  const generatedHookIndex = meta.hookIndex;\n  let nextNextHook;\n  if (meta.hookIndex > 0) {\n    // Now\x2C prepare the next: decrement the pointer so the next call to the\n    // factory generates the next link in the chain.\n    meta.hookIndex--;\n\n    nextNextHook = nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput });\n  } else {\n    // eslint-disable-next-line func-name-matching\n    nextNextHook = function chainAdvancedTooFar() {\n      throw new ERR_INTERNAL_ASSERTION(\n        `ESM custom loader '${hookName}' advanced beyond the end of the chain.`\n      );\n    };\n  }\n\n  return ObjectDefineProperty(\n    async (...args) => {\n      // Update only when hook is invoked to avoid fingering the wrong filePath\n      meta.hookErrIdentifier = `${hookFilePath} '${hookName}'`;\n\n      validateArgs(`${meta.hookErrIdentifier} hook's ${nextHookName}()`\x2C args);\n\n      const outputErrIdentifier = `${chain[generatedHookIndex].url} '${hookName}' hook's ${nextHookName}()`;\n\n      // Set when next<HookName> is actually called\x2C not just generated.\n      if (generatedHookIndex === 0) { meta.chainFinished = true; }\n\n      // `context` is an optional argument that only needs to be passed when changed\n      switch (args.length) {\n        case 1: // It was omitted\x2C so supply the cached value\n          ArrayPrototypePush(args\x2C meta.context);\n          break;\n        case 2: // Overrides were supplied\x2C so update cached value\n          ObjectAssign(meta.context\x2C args[1]);\n          break;\n      }\n\n      ArrayPrototypePush(args\x2C nextNextHook);\n      const output = await ReflectApply(hook\x2C undefined\x2C args);\n\n      validateOutput(outputErrIdentifier\x2C output);\n\n      if (output?.shortCircuit === true) { meta.shortCircuited = true; }\n      return output;\n\n    }\x2C\n    'name'\x2C\n    { __proto__: null\x2C value: nextHookName }\x2C\n  );\n}\n\n/**\n * An ESMLoader instance is used as the main entry point for loading ES modules.\n * Currently\x2C this is a singleton -- there is only one used for loading\n * the main module and everything in its dependency graph.\n */\nclass ESMLoader {\n  /**\n   * Prior to ESM loading. These are called once before any modules are started.\n   * @private\n   * @property {KeyedHook[]} globalPreloaders Last-in-first-out\n   *  list of preload hooks.\n   */\n  #globalPreloaders = [];\n\n  /**\n   * Phase 2 of 2 in ESM loading.\n   * @private\n   * @property {KeyedHook[]} loaders Last-in-first-out\n   *  collection of loader hooks.\n   */\n  #loaders = [\n    {\n      fn: defaultLoad\x2C\n      url: 'node:internal/modules/esm/load'\x2C\n    }\x2C\n  ];\n\n  /**\n   * Phase 1 of 2 in ESM loading.\n   * @private\n   * @property {KeyedHook[]} resolvers Last-in-first-out\n   *  collection of resolver hooks.\n   */\n  #resolvers = [\n    {\n      fn: defaultResolve\x2C\n      url: 'node:internal/modules/esm/resolve'\x2C\n    }\x2C\n  ];\n\n  #importMetaInitializer = initializeImportMeta;\n\n  /**\n   * Map of already-loaded CJS modules to use\n   */\n  cjsCache = new SafeWeakMap();\n\n  /**\n   * The index for assigning unique URLs to anonymous module evaluation\n   */\n  evalIndex = 0;\n\n  /**\n   * Registry of loaded modules\x2C akin to `require.cache`\n   */\n  moduleMap = new ModuleMap();\n\n  /**\n   * Methods which translate input code or other information into ES modules\n   */\n  translators = translators;\n\n  constructor() {\n    if (getOptionValue('--experimental-loader').length > 0) {\n      emitExperimentalWarning('Custom ESM Loaders');\n    }\n    if (getOptionValue('--experimental-network-imports')) {\n      emitExperimentalWarning('Network Imports');\n    }\n    if (\n      !emittedSpecifierResolutionWarning &&\n      getOptionValue('--experimental-specifier-resolution') === 'node'\n    ) {\n      process.emitWarning(\n        'The Node.js specifier resolution flag is experimental. It could change or be removed at any time.'\x2C\n        'ExperimentalWarning'\n      );\n      emittedSpecifierResolutionWarning = true;\n    }\n  }\n\n  /**\n   *\n   * @param {ModuleExports} exports\n   * @returns {ExportedHooks}\n   */\n  static pluckHooks({\n    globalPreload\x2C\n    resolve\x2C\n    load\x2C\n    // obsolete hooks:\n    dynamicInstantiate\x2C\n    getFormat\x2C\n    getGlobalPreloadCode\x2C\n    getSource\x2C\n    transformSource\x2C\n  }) {\n    const obsoleteHooks = [];\n    const acceptedHooks = ObjectCreate(null);\n\n    if (getGlobalPreloadCode) {\n      globalPreload ??= getGlobalPreloadCode;\n\n      process.emitWarning(\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\n      );\n    }\n    if (dynamicInstantiate) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'dynamicInstantiate'\n    );\n    if (getFormat) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getFormat'\x2C\n    );\n    if (getSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'getSource'\x2C\n    );\n    if (transformSource) ArrayPrototypePush(\n      obsoleteHooks\x2C\n      'transformSource'\x2C\n    );\n\n    if (obsoleteHooks.length) process.emitWarning(\n      `Obsolete loader hook(s) supplied and will be ignored: ${\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\n      }`\x2C\n      'DeprecationWarning'\x2C\n    );\n\n    // Use .bind() to avoid giving access to the Loader instance when called.\n    if (globalPreload) {\n      acceptedHooks.globalPreloader =\n        FunctionPrototypeBind(globalPreload\x2C null);\n    }\n    if (resolve) {\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve\x2C null);\n    }\n    if (load) {\n      acceptedHooks.loader = FunctionPrototypeBind(load\x2C null);\n    }\n\n    return acceptedHooks;\n  }\n\n  /**\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\n   * calls global preload hook(s).\n   * @param {KeyedExports} customLoaders\n   *  A list of exports from user-defined loaders (as returned by\n   *  ESMLoader.import()).\n   */\n  async addCustomLoaders(\n    customLoaders = []\x2C\n  ) {\n    for (let i = 0; i < customLoaders.length; i++) {\n      const {\n        exports\x2C\n        url\x2C\n      } = customLoaders[i];\n      const {\n        globalPreloader\x2C\n        resolver\x2C\n        loader\x2C\n      } = ESMLoader.pluckHooks(exports);\n\n      if (globalPreloader) {\n        ArrayPrototypePush(\n          this.#globalPreloaders\x2C\n          {\n            fn: FunctionPrototypeBind(globalPreloader)\x2C // [1]\n            url\x2C\n          }\x2C\n        );\n      }\n      if (resolver) {\n        ArrayPrototypePush(\n          this.#resolvers\x2C\n          {\n            fn: FunctionPrototypeBind(resolver)\x2C // [1]\n            url\x2C\n          }\x2C\n        );\n      }\n      if (loader) {\n        ArrayPrototypePush(\n          this.#loaders\x2C\n          {\n            fn: FunctionPrototypeBind(loader)\x2C // [1]\n            url\x2C\n          }\x2C\n        );\n      }\n    }\n\n    // [1] ensure hook function is not bound to ESMLoader instance\n\n    this.preload();\n  }\n\n  async eval(\n    source\x2C\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\n  ) {\n    const evalInstance = (url) => {\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n      callbackMap.set(module\x2C {\n        importModuleDynamically: (specifier\x2C { url }\x2C importAssertions) => {\n          return this.import(specifier\x2C url\x2C importAssertions);\n        }\n      });\n\n      return module;\n    };\n    const job = new ModuleJob(\n      this\x2C url\x2C undefined\x2C evalInstance\x2C false\x2C false);\n    this.moduleMap.set(url\x2C undefined\x2C job);\n    const { module } = await job.run();\n\n    return {\n      namespace: module.getNamespace()\x2C\n    };\n  }\n\n  /**\n   * Get a (possibly still pending) module job from the cache\x2C\n   * or create one and return its Promise.\n   * @param {string} specifier The string after `from` in an `import` statement\x2C\n   *                           or the first parameter of an `import()`\n   *                           expression\n   * @param {string | undefined} parentURL The URL of the module importing this\n   *                                     one\x2C unless this is the Node.js entry\n   *                                     point.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  async getModuleJob(specifier\x2C parentURL\x2C importAssertions) {\n    let importAssertionsForResolve;\n\n    // By default\x2C `this.#loaders` contains just the Node default load hook\n    if (this.#loaders.length !== 1) {\n      // We can skip cloning if there are no user-provided loaders because\n      // the Node.js default resolve hook does not use import assertions.\n      importAssertionsForResolve = ObjectAssign(\n        ObjectCreate(null)\x2C\n        importAssertions\x2C\n      );\n    }\n\n    const { format\x2C url } =\n      await this.resolve(specifier\x2C parentURL\x2C importAssertionsForResolve);\n\n    let job = this.moduleMap.get(url\x2C importAssertions.type);\n\n    // CommonJS will set functions for lazy job evaluation.\n    if (typeof job === 'function') {\n      this.moduleMap.set(url\x2C undefined\x2C job = job());\n    }\n\n    if (job === undefined) {\n      job = this.#createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format);\n    }\n\n    return job;\n  }\n\n  /**\n   * Create and cache an object representing a loaded module.\n   * @param {string} url The absolute URL that was resolved for this module\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @param {string} [parentURL] The absolute URL of the module importing this\n   *                             one\x2C unless this is the Node.js entry point\n   * @param {string} [format] The format hint possibly returned by the\n   *                          `resolve` hook\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\n   */\n  #createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format) {\n    const moduleProvider = async (url\x2C isMain) => {\n      const {\n        format: finalFormat\x2C\n        responseURL\x2C\n        source\x2C\n      } = await this.load(url\x2C {\n        format\x2C\n        importAssertions\x2C\n      });\n\n      const translator = translators.get(finalFormat);\n\n      if (!translator) {\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat\x2C responseURL);\n      }\n\n      return FunctionPrototypeCall(translator\x2C this\x2C responseURL\x2C source\x2C isMain);\n    };\n\n    const inspectBrk = (\n      parentURL === undefined &&\n      getOptionValue('--inspect-brk')\n    );\n\n    const job = new ModuleJob(\n      this\x2C\n      url\x2C\n      importAssertions\x2C\n      moduleProvider\x2C\n      parentURL === undefined\x2C\n      inspectBrk\n    );\n\n    this.moduleMap.set(url\x2C importAssertions.type\x2C job);\n\n    return job;\n  }\n\n  /**\n   * This method is usually called indirectly as part of the loading processes.\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\n   *\n   * This method must NOT be renamed: it functions as a dynamic import on a\n   * loader module.\n   *\n   * @param {string | string[]} specifiers Path(s) to the module.\n   * @param {string} parentURL Path of the parent importing the module.\n   * @param {Record<string\x2C string>} importAssertions Validations for the\n   *                                                  module import.\n   * @returns {Promise<ExportedHooks | KeyedExports[]>}\n   *  A collection of module export(s) or a list of collections of module\n   *  export(s).\n   */\n  async import(specifiers\x2C parentURL\x2C importAssertions) {\n    // For loaders\x2C `import` is passed multiple things to process\x2C it returns a\n    // list pairing the url and exports collected. This is especially useful for\n    // error messaging\x2C to identity from where an export came. But\x2C in most\n    // cases\x2C only a single url is being "imported" (ex `import()`)\x2C so there is\n    // only 1 possible url from which the exports were collected and it is\n    // already known to the caller. Nesting that in a list would only ever\n    // create redundant work for the caller\x2C so it is later popped off the\n    // internal list.\n    const wasArr = ArrayIsArray(specifiers);\n    if (!wasArr) { specifiers = [specifiers]; }\n\n    const count = specifiers.length;\n    const jobs = new Array(count);\n\n    for (let i = 0; i < count; i++) {\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL\x2C importAssertions)\n        .then((job) => job.run())\n        .then(({ module }) => module.getNamespace());\n    }\n\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\n\n    if (!wasArr) { return namespaces[0]; } // We can skip the pairing below\n\n    for (let i = 0; i < count; i++) {\n      const namespace = ObjectCreate(null);\n      namespace.url = specifiers[i];\n      namespace.exports = namespaces[i];\n\n      namespaces[i] = namespace;\n    }\n\n    return namespaces;\n  }\n\n  /**\n   * Provide source that is understood by one of Node's translators.\n   *\n   * Internally\x2C this behaves like a backwards iterator\x2C wherein the stack of\n   * hooks starts at the top and each call to `nextLoad()` moves down 1 step\n   * until it reaches the bottom or short-circuits.\n   *\n   * @param {URL['href']} url The URL/path of the module to be loaded\n   * @param {object} context Metadata about the module\n   * @returns {{ format: ModuleFormat\x2C source: ModuleSource }}\n   */\n  async load(url\x2C context = {}) {\n    const chain = this.#loaders;\n    const meta = {\n      chainFinished: null\x2C\n      context\x2C\n      hookErrIdentifier: ''\x2C\n      hookIndex: chain.length - 1\x2C\n      hookName: 'load'\x2C\n      shortCircuited: false\x2C\n    };\n\n    const validateArgs = (hookErrIdentifier\x2C { 0: nextUrl\x2C 1: ctx }) => {\n      if (typeof nextUrl !== 'string') {\n        // non-strings can be coerced to a url string\n        // validateString() throws a less-specific error\n        throw new ERR_INVALID_ARG_TYPE(\n          `${hookErrIdentifier} url`\x2C\n          'a url string'\x2C\n          nextUrl\x2C\n        );\n      }\n\n      // Try to avoid expensive URL instantiation for known-good urls\n      if (!this.moduleMap.has(nextUrl)) {\n        try {\n          new URL(nextUrl);\n        } catch {\n          throw new ERR_INVALID_ARG_VALUE(\n            `${hookErrIdentifier} url`\x2C\n            nextUrl\x2C\n            'should be a url string'\x2C\n          );\n        }\n      }\n\n      if (ctx) validateObject(ctx\x2C `${hookErrIdentifier} context`);\n    };\n    const validateOutput = (hookErrIdentifier\x2C output) => {\n      if (typeof output !== 'object' || output === null) { // [2]\n        throw new ERR_INVALID_RETURN_VALUE(\n          'an object'\x2C\n          hookErrIdentifier\x2C\n          output\x2C\n        );\n      }\n    };\n\n    const nextLoad = nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput });\n\n    const loaded = await nextLoad(url\x2C context);\n    const { hookErrIdentifier } = meta; // Retrieve the value after all settled\n\n    validateOutput(hookErrIdentifier\x2C loaded);\n\n    if (loaded?.shortCircuit === true) { meta.shortCircuited = true; }\n\n    if (!meta.chainFinished && !meta.shortCircuited) {\n      throw new ERR_LOADER_CHAIN_INCOMPLETE(hookErrIdentifier);\n    }\n\n    const {\n      format\x2C\n      source\x2C\n    } = loaded;\n    let responseURL = loaded.responseURL;\n\n    if (responseURL === undefined) {\n      responseURL = url;\n    }\n\n    let responseURLObj;\n    if (typeof responseURL === 'string') {\n      try {\n        responseURLObj = new URL(responseURL);\n      } catch {\n        // responseURLObj not defined will throw in next branch.\n      }\n    }\n\n    if (responseURLObj?.href !== responseURL) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'undefined or a fully resolved URL string'\x2C\n        hookErrIdentifier\x2C\n        'responseURL'\x2C\n        responseURL\x2C\n      );\n    }\n\n    if (format == null) {\n      const dataUrl = RegExpPrototypeExec(\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n        url\x2C\n      );\n\n      throw new ERR_UNKNOWN_MODULE_FORMAT(\n        dataUrl ? dataUrl[1] : format\x2C\n        url);\n    }\n\n    if (typeof format !== 'string') { // [2]\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a string'\x2C\n        hookErrIdentifier\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (\n      source != null &&\n      typeof source !== 'string' &&\n      !isAnyArrayBuffer(source) &&\n      !isArrayBufferView(source)\n    ) {\n      throw ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\n        hookErrIdentifier\x2C\n        'source'\x2C\n        source\n      );\n    }\n\n    return {\n      format\x2C\n      responseURL\x2C\n      source\x2C\n    };\n  }\n\n  preload() {\n    for (let i = this.#globalPreloaders.length - 1; i >= 0; i--) {\n      const channel = new MessageChannel();\n      const {\n        port1: insidePreload\x2C\n        port2: insideLoader\x2C\n      } = channel;\n\n      insidePreload.unref();\n      insideLoader.unref();\n\n      const {\n        fn: preloader\x2C\n        url: specifier\x2C\n      } = this.#globalPreloaders[i];\n\n      const preload = preloader({\n        port: insideLoader\x2C\n      });\n\n      if (preload == null) { return; }\n\n      const hookErrIdentifier = `${specifier} globalPreload`;\n\n      if (typeof preload !== 'string') { // [2]\n        throw new ERR_INVALID_RETURN_VALUE(\n          'a string'\x2C\n          hookErrIdentifier\x2C\n          preload\x2C\n        );\n      }\n      const { compileFunction } = require('vm');\n      const preloadInit = compileFunction(\n        preload\x2C\n        ['getBuiltin'\x2C 'port'\x2C 'setImportMetaCallback']\x2C\n        {\n          filename: '<preload>'\x2C\n        }\n      );\n      const { NativeModule } = require('internal/bootstrap/loaders');\n      // We only allow replacing the importMetaInitializer during preload\x2C\n      // after preload is finished\x2C we disable the ability to replace it\n      //\n      // This exposes accidentally setting the initializer too late by\n      // throwing an error.\n      let finished = false;\n      let replacedImportMetaInitializer = false;\n      let next = this.#importMetaInitializer;\n      try {\n        // Calls the compiled preload source text gotten from the hook\n        // Since the parameters are named we use positional parameters\n        // see compileFunction above to cross reference the names\n        FunctionPrototypeCall(\n          preloadInit\x2C\n          globalThis\x2C\n          // Param getBuiltin\n          (builtinName) => {\n            if (NativeModule.canBeRequiredByUsers(builtinName) &&\n                NativeModule.canBeRequiredWithoutScheme(builtinName)) {\n              return require(builtinName);\n            }\n            throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\n          }\x2C\n          // Param port\n          insidePreload\x2C\n          // Param setImportMetaCallback\n          (fn) => {\n            if (finished || typeof fn !== 'function') {\n              throw new ERR_INVALID_ARG_TYPE('fn'\x2C fn);\n            }\n            replacedImportMetaInitializer = true;\n            const parent = next;\n            next = (meta\x2C context) => {\n              return fn(meta\x2C context\x2C parent);\n            };\n          });\n      } finally {\n        finished = true;\n        if (replacedImportMetaInitializer) {\n          this.#importMetaInitializer = next;\n        }\n      }\n    }\n  }\n\n  importMetaInitialize(meta\x2C context) {\n    this.#importMetaInitializer(meta\x2C context);\n  }\n\n  /**\n   * Resolve the location of the module.\n   *\n   * Internally\x2C this behaves like a backwards iterator\x2C wherein the stack of\n   * hooks starts at the top and each call to `nextResolve()` moves down 1 step\n   * until it reaches the bottom or short-circuits.\n   *\n   * @param {string} originalSpecifier The specified URL path of the module to\n   *                                   be resolved.\n   * @param {string} [parentURL] The URL path of the module's parent.\n   * @param {ImportAssertions} [importAssertions] Assertions from the import\n   *                                              statement or expression.\n   * @returns {{ format: string\x2C url: URL['href'] }}\n   */\n  async resolve(\n    originalSpecifier\x2C\n    parentURL\x2C\n    importAssertions = ObjectCreate(null)\n  ) {\n    const isMain = parentURL === undefined;\n\n    if (\n      !isMain &&\n      typeof parentURL !== 'string' &&\n      !isURLInstance(parentURL)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'parentURL'\x2C\n        ['string'\x2C 'URL']\x2C\n        parentURL\x2C\n      );\n    }\n    const chain = this.#resolvers;\n    const context = {\n      conditions: DEFAULT_CONDITIONS\x2C\n      importAssertions\x2C\n      parentURL\x2C\n    };\n    const meta = {\n      chainFinished: null\x2C\n      context\x2C\n      hookErrIdentifier: ''\x2C\n      hookIndex: chain.length - 1\x2C\n      hookName: 'resolve'\x2C\n      shortCircuited: false\x2C\n    };\n\n    const validateArgs = (hookErrIdentifier\x2C { 0: suppliedSpecifier\x2C 1: ctx }) => {\n      validateString(\n        suppliedSpecifier\x2C\n        `${hookErrIdentifier} specifier`\x2C\n      ); // non-strings can be coerced to a url string\n\n      if (ctx) validateObject(ctx\x2C `${hookErrIdentifier} context`);\n    };\n    const validateOutput = (hookErrIdentifier\x2C output) => {\n      if (typeof output !== 'object' || output === null) { // [2]\n        throw new ERR_INVALID_RETURN_VALUE(\n          'an object'\x2C\n          hookErrIdentifier\x2C\n          output\x2C\n        );\n      }\n    };\n\n    const nextResolve = nextHookFactory(chain\x2C meta\x2C { validateArgs\x2C validateOutput });\n\n    const resolution = await nextResolve(originalSpecifier\x2C context);\n    const { hookErrIdentifier } = meta; // Retrieve the value after all settled\n\n    validateOutput(hookErrIdentifier\x2C resolution);\n\n    if (resolution?.shortCircuit === true) { meta.shortCircuited = true; }\n\n    if (!meta.chainFinished && !meta.shortCircuited) {\n      throw new ERR_LOADER_CHAIN_INCOMPLETE(hookErrIdentifier);\n    }\n\n    const {\n      format\x2C\n      url\x2C\n    } = resolution;\n\n    if (\n      format != null &&\n      typeof format !== 'string' // [2]\n    ) {\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a string'\x2C\n        hookErrIdentifier\x2C\n        'format'\x2C\n        format\x2C\n      );\n    }\n\n    if (typeof url !== 'string') {\n      // non-strings can be coerced to a url string\n      // validateString() throws a less-specific error\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n        'a url string'\x2C\n        hookErrIdentifier\x2C\n        'url'\x2C\n        url\x2C\n      );\n    }\n\n    // Try to avoid expensive URL instantiation for known-good urls\n    if (!this.moduleMap.has(url)) {\n      try {\n        new URL(url);\n      } catch {\n        throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n          'a url string'\x2C\n          hookErrIdentifier\x2C\n          'url'\x2C\n          url\x2C\n        );\n      }\n    }\n\n    return {\n      format\x2C\n      url\x2C\n    };\n  }\n}\n\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\n\nexports.ESMLoader = ESMLoader;\n
code-source-info,0xb469fbe1818,399,0,26516,C0O0C4O26516,,
code-creation,Function,10,103769,0xb469fbe2138,730, node:internal/modules/esm/loader:1:1,0xb469fbe1790,~
code-source-info,0xb469fbe2138,399,0,26516,C0O0C149O79C155O79C159O130C165O139C171O155C177O177C183O199C189O224C195O249C201O265C207O281C213O305C218O329C224O343C230O359C236O382C242O403C248O418C254O442C260O472C266O528C272O528C277O509C283O772C289O772C294O798C299O570C305O601C311O627C317O651C323O676C329O713C335O741C341O852C347O852C352O814C358O829C364O844C370O913C376O913C381O885C387O992C393O992C398O949C404O969C410O1072C416O1072C421O1034C427O1052C433O1122C439O1122C443O1122C445O1184C451O1184C455O1184C457O1281C463O1281C468O1239C474O1257C480O1357C486O1357C491O1332C497O1437C503O1437C508O1421C514O1499C520O1499C525O1483C531O1574C537O1574C542O1555C548O2246C549O2246C710O26466C717O26435C722O26485C724O26503C729O26515,,
code-creation,Function,10,103839,0xb469fbe26d0,145,<instance_members_initializer> node:internal/modules/esm/loader:191:1,0xb469fbe1c38,~
code-source-info,0xb469fbe26d0,399,5923,26433,C3O6163C12O6330C28O6348C49O6587C65O6605C86O6709C96O6803C103O6803C112O6921C117O7008C124O7008C133O7131C144O26433,,
tick,0x7ff805e4dd52,103870,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805f105d0,103881,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x102daee2a,103932,1,0x10266e4e0,6,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,104320,0xb469fbe49a0,5, node:internal/modules/esm/module_map:1:1,0xb469fbe47a0,~
script-source,400,node:internal/modules/esm/module_map,'use strict';\n\nconst ModuleJob = require('internal/modules/esm/module_job');\nconst { kImplicitAssertType } = require('internal/modules/esm/assert');\nconst {\n  ObjectCreate\x2C\n  SafeMap\x2C\n} = primordials;\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\nconst { validateString } = require('internal/validators');\n\n// Tracks the state of the loader-level module cache\nclass ModuleMap extends SafeMap {\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\n  get(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type];\n  }\n  set(url\x2C type = kImplicitAssertType\x2C job) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    if (job instanceof ModuleJob !== true &&\n        typeof job !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\n    }\n    debug(`Storing ${url} (${\n      type === kImplicitAssertType ? 'implicit type' : type\n    }) in ModuleMap`);\n    const cachedJobsForUrl = super.get(url) ?? ObjectCreate(null);\n    cachedJobsForUrl[type] = job;\n    return super.set(url\x2C cachedJobsForUrl);\n  }\n  has(url\x2C type = kImplicitAssertType) {\n    validateString(url\x2C 'url');\n    validateString(type\x2C 'type');\n    return super.get(url)?.[type] !== undefined;\n  }\n}\nmodule.exports = ModuleMap;\n
code-source-info,0xb469fbe49a0,400,0,1444,C0O0C4O1444,,
code-creation,Function,10,104504,0xb469fbe4dd8,175, node:internal/modules/esm/module_map:1:1,0xb469fbe4918,~
code-source-info,0xb469fbe4dd8,400,0,1444,C0O0C23O33C26O33C30O33C32O109C35O109C40O85C46O159C52O175C57O213C60O213C65O246C78O247C84O213C86O324C89O324C94O350C99O299C105O385C108O385C113O366C123O495C167O1416C169O1431C174O1443,,
code-creation,Eval,10,104698,0xb469fbe58f0,5, node:internal/modules/esm/module_job:1:1,0xb469fbe5628,~
script-source,401,node:internal/modules/esm/module_job,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSome\x2C\n  FunctionPrototype\x2C\n  ObjectCreate\x2C\n  ObjectSetPrototypeOf\x2C\n  PromiseResolve\x2C\n  PromisePrototypeCatch\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafePromiseAll\x2C\n  SafeSet\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst { ModuleWrap } = internalBinding('module_wrap');\n\nconst { decorateErrorStack } = require('internal/util');\nconst {\n  getSourceMapsEnabled\x2C\n} = require('internal/source_map/source_map_cache');\nconst assert = require('internal/assert');\nconst resolvedPromise = PromiseResolve();\n\nconst noop = FunctionPrototype;\n\nlet hasPausedEntry = false;\n\nconst CJSGlobalLike = [\n  'require'\x2C\n  'module'\x2C\n  'exports'\x2C\n  '__filename'\x2C\n  '__dirname'\x2C\n];\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\n  ArrayPrototypeSome(\n    CJSGlobalLike\x2C\n    (globalLike) => errorMessage === `${globalLike} is not defined`\n  );\n\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\n * its dependencies\x2C over time. */\nclass ModuleJob {\n  // `loader` is the Loader instance used for loading dependencies.\n  // `moduleProvider` is a function\n  constructor(loader\x2C url\x2C importAssertions = ObjectCreate(null)\x2C\n              moduleProvider\x2C isMain\x2C inspectBrk) {\n    this.loader = loader;\n    this.importAssertions = importAssertions;\n    this.isMain = isMain;\n    this.inspectBrk = inspectBrk;\n\n    this.module = undefined;\n    // Expose the promise to the ModuleWrap directly for linking below.\n    // `this.module` is also filled in below.\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\n\n    // Wait for the ModuleWrap instance being linked with all dependencies.\n    const link = async () => {\n      this.module = await this.modulePromise;\n      assert(this.module instanceof ModuleWrap);\n\n      // Explicitly keeping track of dependency jobs is needed in order\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\n      // so that circular dependencies can't cause a deadlock by two of\n      // these `link` callbacks depending on each other.\n      const dependencyJobs = [];\n      const promises = this.module.link(async (specifier\x2C assertions) => {\n        const jobPromise = this.loader.getModuleJob(specifier\x2C url\x2C assertions);\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\n        const job = await jobPromise;\n        return job.modulePromise;\n      });\n\n      if (promises !== undefined)\n        await SafePromiseAll(promises);\n\n      return SafePromiseAll(dependencyJobs);\n    };\n    // Promise for the list of all dependencyJobs.\n    this.linked = link();\n    // This promise is awaited later anyway\x2C so silence\n    // 'unhandled rejection' warnings.\n    PromisePrototypeCatch(this.linked\x2C noop);\n\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\n    // and module wrapper is instantiated.\n    this.instantiated = undefined;\n  }\n\n  instantiate() {\n    if (this.instantiated === undefined) {\n      this.instantiated = this._instantiate();\n    }\n    return this.instantiated;\n  }\n\n  async _instantiate() {\n    const jobsInGraph = new SafeSet();\n    const addJobsToDependencyGraph = async (moduleJob) => {\n      if (jobsInGraph.has(moduleJob)) {\n        return;\n      }\n      jobsInGraph.add(moduleJob);\n      const dependencyJobs = await moduleJob.linked;\n      return SafePromiseAll(dependencyJobs\x2C addJobsToDependencyGraph);\n    };\n    await addJobsToDependencyGraph(this);\n\n    try {\n      if (!hasPausedEntry && this.inspectBrk) {\n        hasPausedEntry = true;\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\n        initWrapper(this.module.instantiate\x2C this.module);\n      } else {\n        this.module.instantiate();\n      }\n    } catch (e) {\n      decorateErrorStack(e);\n      // TODO(@bcoe): Add source map support to exception that occurs as result\n      // of missing named export. This is currently not possible because\n      // stack trace originates in module_job\x2C not the file itself. A hidden\n      // symbol with filename could be set in node_errors.cc to facilitate this.\n      if (!getSourceMapsEnabled() &&\n          StringPrototypeIncludes(e.message\x2C\n                                  ' does not provide an export named')) {\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\n        const parentFileUrl = RegExpPrototypeSymbolReplace(\n          /:\\d+$/\x2C\n          splitStack[0]\x2C\n          ''\n        );\n        const { 1: childSpecifier\x2C 2: name } = RegExpPrototypeExec(\n          /module '(.*)' does not provide an export named '(.+)'/\x2C\n          e.message);\n        const { url: childFileURL } = await this.loader.resolve(\n          childSpecifier\x2C parentFileUrl\x2C\n        );\n        let format;\n        try {\n          // This might throw for non-CommonJS modules because we aren't passing\n          // in the import assertions and some formats require them; but we only\n          // care about CommonJS for the purposes of this error message.\n          ({ format } =\n            await this.loader.load(childFileURL));\n        } catch {\n          // Continue regardless of error.\n        }\n\n        if (format === 'commonjs') {\n          const importStatement = splitStack[1];\n          // TODO(@ctavan): The original error stack only provides the single\n          // line which causes the error. For multi-line import statements we\n          // cannot generate an equivalent object destructuring assignment by\n          // just parsing the error stack.\n          const oneLineNamedImports = RegExpPrototypeExec(/{.*}/\x2C importStatement);\n          const destructuringAssignment = oneLineNamedImports &&\n            RegExpPrototypeSymbolReplace(/\\s+as\\s+/g\x2C oneLineNamedImports\x2C ': ');\n          e.message = `Named export '${name}' not found. The requested module` +\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\n            'always be imported via the default export\x2C for example using:' +\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\n              destructuringAssignment ?\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\n          newStack[3] = `SyntaxError: ${e.message}`;\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\n        }\n      }\n      throw e;\n    }\n\n    for (const dependencyJob of jobsInGraph) {\n      // Calling `this.module.instantiate()` instantiates not only the\n      // ModuleWrap in this module\x2C but all modules in the graph.\n      dependencyJob.instantiated = resolvedPromise;\n    }\n  }\n\n  async run() {\n    await this.instantiate();\n    const timeout = -1;\n    const breakOnSigint = false;\n    try {\n      await this.module.evaluate(timeout\x2C breakOnSigint);\n    } catch (e) {\n      if (e?.name === 'ReferenceError' &&\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\n        e.message += ' in ES module scope';\n\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\n          e.message += '\x2C you can use import instead';\n        }\n\n        const packageConfig =\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\n            RegExpPrototypeExec(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) !== null &&\n            require('internal/modules/esm/resolve')\n              .getPackageScopeConfig(this.module.url);\n        if (packageConfig.type === 'module') {\n          e.message +=\n            '\\nThis file is being treated as an ES module because it has a ' +\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\n            'to use the \\'.cjs\\' file extension.';\n        }\n      }\n      throw e;\n    }\n    return { module: this.module };\n  }\n}\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\nmodule.exports = ModuleJob;\n
code-source-info,0xb469fbe58f0,401,0,8059,C0O0C4O8059,,
code-creation,Function,10,105611,0xb469fbe5dd0,316, node:internal/modules/esm/module_job:1:1,0xb469fbe5868,~
code-source-info,0xb469fbe5dd0,401,0,8059,C0O0C79O25C85O47C91O69C97O91C102O112C108O128C113O152C118O170C124O195C130O211C136O234C142O266C148O284C154O295C160O322C166O346C172O414C178O414C183O399C189O478C195O478C200O455C206O540C212O540C217O514C223O604C229O604C233O604C235O656C238O656C240O688C242O688C244O729C245O729C247O759C251O759C253O877C257O877C296O8013C303O7982C308O8031C310O8046C315O8058,,
tick,0x7ff805f105d0,105663,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe4df2,0xb46f7def627,0x1132442e1,0xb469fbe22ef,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,105810,0xb469fbe79c8,5, node:internal/modules/esm/assert:1:1,0xb469fbe77d0,~
script-source,402,node:internal/modules/esm/assert,'use strict';\n\nconst {\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ObjectCreate\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n} = primordials;\nconst { validateString } = require('internal/validators');\n\nconst {\n  ERR_IMPORT_ASSERTION_TYPE_FAILED\x2C\n  ERR_IMPORT_ASSERTION_TYPE_MISSING\x2C\n  ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED\x2C\n} = require('internal/errors').codes;\n\n// The HTML spec has an implied default type of `'javascript'`.\nconst kImplicitAssertType = 'javascript';\n\n/**\n * Define a map of module formats to import assertion types (the value of\n * `type` in `assert { type: 'json' }`).\n * @type {Map<string\x2C string>}\n */\nconst formatTypeMap = {\n  '__proto__': null\x2C\n  'builtin': kImplicitAssertType\x2C\n  'commonjs': kImplicitAssertType\x2C\n  'json': 'json'\x2C\n  'module': kImplicitAssertType\x2C\n  'wasm': kImplicitAssertType\x2C // It's unclear whether the HTML spec will require an assertion type or not for Wasm; see https://github.com/WebAssembly/esm-integration/issues/42\n};\n\n/**\n * The HTML spec disallows the default type to be explicitly specified\n * (for now); so `import './file.js'` is okay but\n * `import './file.js' assert { type: 'javascript' }` throws.\n * @type {Array<string\x2C string>}\n */\nconst supportedAssertionTypes = ArrayPrototypeFilter(\n  ObjectValues(formatTypeMap)\x2C\n  (type) => type !== kImplicitAssertType);\n\n\n/**\n * Test a module's import assertions.\n * @param {string} url The URL of the imported module\x2C for error reporting.\n * @param {string} format One of Node's supported translators\n * @param {Record<string\x2C string>} importAssertions Validations for the\n *                                                  module import.\n * @returns {true}\n * @throws {TypeError} If the format and assertion type are incompatible.\n */\nfunction validateAssertions(url\x2C format\x2C\n                            importAssertions = ObjectCreate(null)) {\n  const validType = formatTypeMap[format];\n\n  switch (validType) {\n    case undefined:\n      // Ignore assertions for module formats we don't recognize\x2C to allow new\n      // formats in the future.\n      return true;\n\n    case kImplicitAssertType:\n      // This format doesn't allow an import assertion type\x2C so the property\n      // must not be set on the import assertions object.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        return true;\n      }\n      return handleInvalidType(url\x2C importAssertions.type);\n\n    case importAssertions.type:\n      // The asserted type is the valid type for this format.\n      return true;\n\n    default:\n      // There is an expected type for this format\x2C but the value of\n      // `importAssertions.type` might not have been it.\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\n        // `type` wasn't specified at all.\n        throw new ERR_IMPORT_ASSERTION_TYPE_MISSING(url\x2C validType);\n      }\n      handleInvalidType(url\x2C importAssertions.type);\n  }\n}\n\n/**\n * Throw the correct error depending on what's wrong with the type assertion.\n * @param {string} url The resolved URL for the module to be imported\n * @param {string} type The value of the import assertion `type` property\n */\nfunction handleInvalidType(url\x2C type) {\n  // `type` might have not been a string.\n  validateString(type\x2C 'type');\n\n  // `type` might not have been one of the types we understand.\n  if (!ArrayPrototypeIncludes(supportedAssertionTypes\x2C type)) {\n    throw new ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED(type);\n  }\n\n  // `type` was the wrong value for this format.\n  throw new ERR_IMPORT_ASSERTION_TYPE_FAILED(url\x2C type);\n}\n\n\nmodule.exports = {\n  kImplicitAssertType\x2C\n  validateAssertions\x2C\n};\n
code-source-info,0xb469fbe79c8,402,0,3624,C0O0C4O3624,,
code-creation,Function,10,106241,0xb469fbe7ca0,201, node:internal/modules/esm/assert:1:1,0xb469fbe7940,~
code-source-info,0xb469fbe7ca0,402,0,3624,C0O0C46O25C51O49C57O75C63O91C68O107C74O182C77O182C82O163C88O341C91O341C96O367C101O225C107O261C113O298C119O468C121O468C123O659C130O695C136O730C142O781C148O812C154O659C156O1240C159O1264C169O1240C174O1240C176O3557C183O3578C189O3601C195O3572C200O3623,,
code-creation,LazyCompile,10,106331,0xb469fbe82b0,9, node:internal/modules/esm/assert:43:3,0xb469fbe7a98,~
code-source-info,0xb469fbe82b0,402,1295,1333,C0O1310C2O1314C4O1310C8O1333,,
tick,0x102ce1eb4,106602,1,0x10266e4e0,2,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,107169,0xb469fbeab48,5, node:internal/modules/esm/resolve:1:1,0xb469fbe9690,~
script-source,403,node:internal/modules/esm/resolve,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeConcat\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeShift\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectFreeze\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeLastIndexOf\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst internalFS = require('internal/fs/utils');\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  realpathSync\x2C\n  statSync\x2C\n  Stats\x2C\n} = require('fs');\nconst { getOptionValue } = require('internal/options');\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst { sep\x2C relative\x2C resolve } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst typeFlag = getOptionValue('--input-type');\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_MODULE_SPECIFIER\x2C\n  ERR_INVALID_PACKAGE_CONFIG\x2C\n  ERR_INVALID_PACKAGE_TARGET\x2C\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\n\nconst packageJsonReader = require('internal/modules/package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst noAddons = getOptionValue('--no-addons');\nconst addonConditions = noAddons ? [] : ['node-addons'];\n\nconst DEFAULT_CONDITIONS = ObjectFreeze([\n  'node'\x2C\n  'import'\x2C\n  ...addonConditions\x2C\n  ...userConditions\x2C\n]);\n\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\n/**\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\n * @typedef {'module' | 'commonjs'} PackageType\n * @typedef {{\n *   pjsonPath: string\x2C\n *   exports?: ExportConfig\x2C\n *   name?: string\x2C\n *   main?: string\x2C\n *   type?: PackageType\x2C\n * }} PackageConfig\n */\n\nconst emittedPackageWarnings = new SafeSet();\n\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +\n    `"exports" field module resolution of the package at ${pjsonPath}${\n      base ? ` imported from ${fileURLToPath(base)}` :\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\n    'DeprecationWarning'\x2C\n    'DEP0155'\n  );\n}\n\n/**\n * @param {URL} url\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @param {string} main\n * @returns {void}\n */\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\n  const format = defaultGetFormatWithoutErrors(url);\n  if (format !== 'module')\n    return;\n  const path = fileURLToPath(url);\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\n  const basePath = fileURLToPath(base);\n  if (main)\n    process.emitWarning(\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\n      `excluding the full filename and extension to the resolved file at "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\n      'deprecated for ES modules.'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n  else\n    process.emitWarning(\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\n      } resolving the main entry point "${\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\n      'DeprecationWarning'\x2C\n      'DEP0151'\n    );\n}\n\n/**\n * @param {string[]} [conditions]\n * @returns {Set<string>}\n */\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap(); /* string -> PackageConfig */\n\n/**\n * @param {string | URL} path\n * @returns {import('fs').Stats}\n */\nconst tryStatSync =\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\n\n/**\n * @param {string} path\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {PackageConfig}\n */\nfunction getPackageConfig(path\x2C specifier\x2C base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path\x2C\n      exists: false\x2C\n      main: undefined\x2C\n      name: undefined\x2C\n      type: 'none'\x2C\n      exports: undefined\x2C\n      imports: undefined\x2C\n    };\n    packageJSONCache.set(path\x2C packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path\x2C\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\n      error.message\n    );\n  }\n\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path\x2C\n    exists: true\x2C\n    main\x2C\n    name\x2C\n    type\x2C\n    exports\x2C\n    imports\x2C\n  };\n  packageJSONCache.set(path\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {URL | string} resolved\n * @returns {PackageConfig}\n */\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check "/package.json" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath\x2C\n    exists: false\x2C\n    main: undefined\x2C\n    name: undefined\x2C\n    type: 'none'\x2C\n    exports: undefined\x2C\n    imports: undefined\x2C\n  };\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\n  return packageConfig;\n}\n\n/**\n * @param {string | URL} url\n * @returns {boolean}\n */\nfunction fileExists(url) {\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\n}\n\n/**\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\n * 5. NOT_FOUND\n * @param {URL} packageJSONUrl\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @returns {URL}\n */\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\n                                   packageJSONUrl))) {\n      return guess;\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\n                                          packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\n                                        packageJSONUrl)));\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\n                                        packageJSONUrl)));\n    else guess = undefined;\n    if (guess) {\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\n                                 packageConfig.main);\n      return guess;\n    }\n    // Fallthrough.\n  }\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\n  // So fs.\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\n  else guess = undefined;\n  if (guess) {\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\n    return guess;\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensionsWithTryExactName(search) {\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveExtensions(search) {\n  for (let i = 0; i < extensions.length; i++) {\n    const extension = extensions[i];\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/**\n * @param {URL} search\n * @returns {URL | undefined}\n */\nfunction resolveDirectoryEntry(search) {\n  const dirPath = fileURLToPath(search);\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\n  if (fileExists(pkgJsonPath)) {\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\n    if (pkgJson.containsKeys) {\n      const { main } = JSONParse(pkgJson.string);\n      if (main != null) {\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\n        return resolveExtensionsWithTryExactName(mainUrl);\n      }\n    }\n  }\n  return resolveExtensions(new URL('index'\x2C search));\n}\n\nconst encodedSepRegEx = /%2F|%5C/i;\n/**\n * @param {URL} resolved\n * @param {string | URL | undefined} base\n * @param {boolean} preserveSymlinks\n * @returns {URL | undefined}\n */\nfunction finalizeResolution(resolved\x2C base\x2C preserveSymlinks) {\n  if (RegExpPrototypeExec(encodedSepRegEx\x2C resolved.pathname) !== null)\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\n      fileURLToPath(base));\n\n  let path = fileURLToPath(resolved);\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\n    let file = resolveExtensionsWithTryExactName(resolved);\n\n    // Directory\n    if (file === undefined) {\n      file = StringPrototypeEndsWith(path\x2C '/') ?\n        (resolveDirectoryEntry(resolved) || resolved) : resolveDirectoryEntry(new URL(`${resolved}/`));\n\n      if (file === resolved) return file;\n\n      if (file === undefined) {\n        throw new ERR_MODULE_NOT_FOUND(\n          resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\n      }\n    }\n\n    path = file;\n  }\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\n    StringPrototypeSlice(path\x2C -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\n  }\n\n  if (!preserveSymlinks) {\n    const real = realpathSync(path\x2C {\n      [internalFS.realpathCacheKey]: realpathCache\n    });\n    const { search\x2C hash } = resolved;\n    resolved =\n        pathToFileURL(real + (StringPrototypeEndsWith(path\x2C sep) ? '/' : ''));\n    resolved.search = search;\n    resolved.hash = hash;\n  }\n\n  return resolved;\n}\n\n/**\n * @param {string} specifier\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\n    fileURLToPath(base));\n}\n\n/**\n * @param {string} subpath\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n */\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\n    base && fileURLToPath(base));\n}\n\n/**\n *\n * @param {string | URL} subpath\n * @param {URL} packageJSONUrl\n * @param {boolean} internal\n * @param {string | URL | undefined} base\n */\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\n  const reason = `request is not a valid subpath for the "${internal ?\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target\x2C null\x2C '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\n    internal\x2C base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\n\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (!StringPrototypeStartsWith(target\x2C './')) {\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\n        !StringPrototypeStartsWith(target\x2C '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {\n        // Continue regardless of error.\n      }\n      if (!isURL) {\n        const exportTarget = pattern ?\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\n          target + subpath;\n        return packageResolve(\n          exportTarget\x2C packageJSONUrl\x2C conditions);\n      }\n    }\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (RegExpPrototypeExec(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)) !== null)\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  const resolved = new URL(target\x2C packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeExec(invalidSegmentRegEx\x2C subpath) !== null) {\n    const request = pattern ?\n      StringPrototypeReplace(match\x2C '*'\x2C () => subpath) : match + subpath;\n    throwInvalidSubpath(request\x2C packageJSONUrl\x2C internal\x2C base);\n  }\n\n  if (pattern) {\n    return new URL(\n      RegExpPrototypeSymbolReplace(\n        patternRegEx\x2C\n        resolved.href\x2C\n        () => subpath\n      )\n    );\n  }\n\n  return new URL(subpath\x2C resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\n                              base\x2C pattern\x2C internal\x2C conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0) {\n      return null;\n    }\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolveResult;\n      try {\n        resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\n          internal\x2C conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET') {\n          continue;\n        }\n        throw e;\n      }\n      if (resolveResult === undefined) {\n        continue;\n      }\n      if (resolveResult === null) {\n        lastException = null;\n        continue;\n      }\n      return resolveResult;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\n          '"exports" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\n          pattern\x2C internal\x2C conditions);\n        if (resolveResult === undefined)\n          continue;\n        return resolveResult;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\n                            base);\n}\n\n/**\n *\n * @param {Exports} exports\n * @param {URL} packageJSONUrl\n * @param {string | URL | undefined} base\n * @returns {boolean}\n */\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {PackageConfig} packageConfig\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageExportsResolve(\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\n    const target = exports[packageSubpath];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\n    );\n\n    if (resolveResult == null) {\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n\n    return resolveResult;\n  }\n\n  let bestMatch = '';\n  let bestMatchSubpath;\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n    if (patternIndex !== -1 &&\n        StringPrototypeStartsWith(packageSubpath\x2C\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\n      // When this reaches EOL\x2C this can throw at the top of the whole function:\n      //\n      // if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n      //   throwInvalidSubpath(packageSubpath)\n      //\n      // To match "imports" and the spec.\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\n                                            base);\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n      if (packageSubpath.length >= key.length &&\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n        bestMatch = key;\n        bestMatchSubpath = StringPrototypeSlice(\n          packageSubpath\x2C patternIndex\x2C\n          packageSubpath.length - patternTrailer.length);\n      }\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const resolveResult = resolvePackageTarget(\n      packageJSONUrl\x2C\n      target\x2C\n      bestMatchSubpath\x2C\n      bestMatch\x2C\n      base\x2C\n      true\x2C\n      false\x2C\n      conditions);\n\n    if (resolveResult == null) {\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n    }\n    return resolveResult;\n  }\n\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\n}\n\nfunction patternKeyCompare(a\x2C b) {\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\n  if (baseLenA > baseLenB) return -1;\n  if (baseLenB > baseLenA) return 1;\n  if (aPatternIndex === -1) return 1;\n  if (bPatternIndex === -1) return -1;\n  if (a.length > b.length) return -1;\n  if (b.length > a.length) return 1;\n  return 0;\n}\n\n/**\n * @param {string} name\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/') ||\n      StringPrototypeEndsWith(name\x2C '/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\n          !StringPrototypeIncludes(name\x2C '*')) {\n        const resolveResult = resolvePackageTarget(\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\n        );\n        if (resolveResult != null) {\n          return resolveResult;\n        }\n      } else {\n        let bestMatch = '';\n        let bestMatchSubpath;\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\n          if (patternIndex !== -1 &&\n              StringPrototypeStartsWith(name\x2C\n                                        StringPrototypeSlice(key\x2C 0\x2C\n                                                             patternIndex))) {\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\n            if (name.length >= key.length &&\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\n              bestMatch = key;\n              bestMatchSubpath = StringPrototypeSlice(\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\n            }\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const resolveResult = resolvePackageTarget(packageJSONUrl\x2C target\x2C\n                                                     bestMatchSubpath\x2C\n                                                     bestMatch\x2C base\x2C true\x2C\n                                                     true\x2C conditions);\n          if (resolveResult != null) {\n            return resolveResult;\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\n}\n\n/**\n * @param {URL} url\n * @returns {PackageType}\n */\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\n */\nfunction parsePackageName(specifier\x2C base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier\x2C '/'\x2C separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // \\\\ separators.\n  if (RegExpPrototypeExec(invalidPackageNameRegEx\x2C packageName) !== null)\n    validPackageName = false;\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier\x2C separatorIndex));\n\n  return { packageName\x2C packageSubpath\x2C isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @returns {resolved: URL\x2C format? : string}\n */\nfunction packageResolve(specifier\x2C base\x2C conditions) {\n  if (NativeModule.canBeRequiredByUsers(specifier) &&\n      NativeModule.canBeRequiredWithoutScheme(specifier)) {\n    return new URL('node:' + specifier);\n  }\n\n  const { packageName\x2C packageSubpath\x2C isScoped } =\n    parsePackageName(specifier\x2C base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json'\x2C packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\n    }\n    if (packageSubpath === '.') {\n      return legacyMainResolve(\n        packageJSONUrl\x2C\n        packageConfig\x2C\n        base\n      );\n    }\n\n    return new URL(packageSubpath\x2C packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\n}\n\n/**\n * @param {string} specifier\n * @returns {boolean}\n */\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {string | URL | undefined} base\n * @param {Set<string>} conditions\n * @param {boolean} preserveSymlinks\n * @returns {url: URL\x2C format?: string}\n */\nfunction moduleResolve(specifier\x2C base\x2C conditions\x2C preserveSymlinks) {\n  const isRemote = base.protocol === 'http:' ||\n    base.protocol === 'https:';\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier\x2C base);\n  } else if (!isRemote && specifier[0] === '#') {\n    resolved = packageImportsResolve(specifier\x2C base\x2C conditions);\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      if (!isRemote) {\n        resolved = packageResolve(specifier\x2C base\x2C conditions);\n      }\n    }\n  }\n  if (resolved.protocol !== 'file:') {\n    return resolved;\n  }\n  return finalizeResolution(resolved\x2C base\x2C preserveSymlinks);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent\x2C null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent\x2C found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\n      const index = StringPrototypeIndexOf(found\x2C pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found\x2C index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\n                                           found\x2C '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\n// TODO(@JakobJingleheimer): de-dupe `specifier` & `parsed`\nfunction checkIfDisallowedImport(specifier\x2C parsed\x2C parsedParentURL) {\n  if (parsedParentURL) {\n    if (\n      parsedParentURL.protocol === 'http:' ||\n      parsedParentURL.protocol === 'https:'\n    ) {\n      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n        // data: and blob: disallowed due to allowing file: access via\n        // indirection\n        if (parsed &&\n          parsed.protocol !== 'https:' &&\n          parsed.protocol !== 'http:'\n        ) {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            specifier\x2C\n            parsedParentURL\x2C\n            'remote imports cannot import from a local location.'\n          );\n        }\n\n        return { url: parsed.href };\n      }\n      if (NativeModule.canBeRequiredByUsers(specifier) &&\n          NativeModule.canBeRequiredWithoutScheme(specifier)) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          specifier\x2C\n          parsedParentURL\x2C\n          'remote imports cannot import from a local location.'\n        );\n      }\n\n      throw new ERR_NETWORK_IMPORT_DISALLOWED(\n        specifier\x2C\n        parsedParentURL\x2C\n        'only relative and absolute specifiers are supported.'\n      );\n    }\n  }\n}\n\nfunction throwIfUnsupportedURLProtocol(url) {\n  if (url.protocol !== 'file:' && url.protocol !== 'data:' &&\n      url.protocol !== 'node:') {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url);\n  }\n}\n\nfunction throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports) {\n  if (\n    parsed &&\n    parsed.protocol !== 'file:' &&\n    parsed.protocol !== 'data:' &&\n    (\n      !experimentalNetworkImports ||\n      (\n        parsed.protocol !== 'https:' &&\n        parsed.protocol !== 'http:'\n      )\n    )\n  ) {\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C ArrayPrototypeConcat(\n      'file'\x2C\n      'data'\x2C\n      experimentalNetworkImports ? ['https'\x2C 'http'] : []\x2C\n    ));\n  }\n}\n\nasync function defaultResolve(specifier\x2C context = {}) {\n  let { parentURL\x2C conditions } = context;\n  if (parentURL && policy?.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve\x2C reaction } = redirects;\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        // Prevent network requests from firing if resolution would be banned.\n        // Network requests can extract data by doing things like putting\n        // secrets in query params\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL\x2C\n          specifier\x2C\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\n        );\n      }\n    }\n  }\n\n  let parsedParentURL;\n  if (parentURL) {\n    try {\n      parsedParentURL = new URL(parentURL);\n    } catch {\n      // Ignore exception\n    }\n  }\n\n  let parsed;\n  try {\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      parsed = new URL(specifier\x2C parsedParentURL);\n    } else {\n      parsed = new URL(specifier);\n    }\n\n    if (parsed.protocol === 'data:' ||\n      (experimentalNetworkImports &&\n        (\n          parsed.protocol === 'https:' ||\n          parsed.protocol === 'http:'\n        )\n      )\n    ) {\n      return { url: parsed.href };\n    }\n  } catch {\n    // Ignore exception\n  }\n\n  // There are multiple deep branches that can either throw or return; instead\n  // of duplicating that deeply nested logic for the possible returns\x2C DRY and\n  // check for a return. This seems the least gnarly.\n  const maybeReturn = checkIfDisallowedImport(\n    specifier\x2C\n    parsed\x2C\n    parsedParentURL\x2C\n  );\n\n  if (maybeReturn) return maybeReturn;\n\n  // This must come after checkIfDisallowedImport\n  if (parsed && parsed.protocol === 'node:') return { url: specifier };\n\n  throwIfUnsupportedURLScheme(parsed\x2C experimentalNetworkImports);\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program\x2C and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\n    // input\x2C to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\n    // entry point\x2C etc.).\n    if (typeFlag) throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(\n      specifier\x2C\n      parentURL\x2C\n      conditions\x2C\n      isMain ? preserveSymlinksMain : preserveSymlinks\n    );\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines\x2C '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  throwIfUnsupportedURLProtocol(url);\n\n  return {\n    // Do NOT cast `url` to a string: that will work even when there are real\n    // problems\x2C silencing them\n    url: url.href\x2C\n    format: defaultGetFormatWithoutErrors(url\x2C context)\x2C\n  };\n}\n\nmodule.exports = {\n  DEFAULT_CONDITIONS\x2C\n  defaultResolve\x2C\n  encodedSepRegEx\x2C\n  getPackageScopeConfig\x2C\n  getPackageType\x2C\n  packageExportsResolve\x2C\n  packageImportsResolve\x2C\n};\n\n// cycle\nconst {\n  defaultGetFormatWithoutErrors\x2C\n} = require('internal/modules/esm/get_format');\n\nif (policy) {\n  const $defaultResolve = defaultResolve;\n  module.exports.defaultResolve = async function defaultResolve(\n    specifier\x2C\n    context\n  ) {\n    const ret = await $defaultResolve(specifier\x2C context);\n    // This is a preflight check to avoid data exfiltration by query params etc.\n    policy.manifest.mightAllow(ret.url\x2C () =>\n      new ERR_MANIFEST_DEPENDENCY_MISSING(\n        context.parentURL\x2C\n        specifier\x2C\n        context.conditions\n      )\n    );\n    return ret;\n  };\n}\n
code-source-info,0xb469fbeab48,403,0,39474,C0O0C4O39474,,
code-creation,Function,10,111606,0xb469fbebc18,1164, node:internal/modules/esm/resolve:1:1,0xb469fbeaac0,~
code-source-info,0xb469fbebc18,403,0,39474,C0O0C403O25C409O41C415O65C421O87C427O110C433O123C439O140C444O156C450O185C456O218C462O228C468O251C474O283C479O294C485O305C491O315C497O342C503O369C509O395C515O425C521O451C527O475C533O499C539O562C542O562C546O562C548O617C551O617C556O600C562O705C565O705C570O666C576O682C582O694C588O747C591O747C596O728C602O842C608O842C617O886C624O842C626O966C629O966C634O939C640O944C646O954C652O1008C658O1008C662O1008C664O1076C670O1076C674O1076C676O1157C682O1157C686O1157C688O1224C694O1224C698O1224C700O1302C703O1302C708O1264C714O1269C720O1284C726O1709C729O1709C734O1735C739O1337C745O1367C751O1392C757O1424C763O1454C769O1484C775O1519C781O1543C787O1577C793O1610C799O1640C805O1673C811O1773C814O1773C819O1759C825O1840C828O1840C832O1840C834O1912C840O1912C845O1961C851O1961C856O2016C867O2077C874O2119C875O2119C929O2141C980O2077C984O2077C986O2193C994O2193C999O2193C1001O2534C1004O2534C1009O2534C1011O4823C1013O4823C1018O4823C1020O4863C1022O4863C1027O4863C1029O5002C1033O5002C1035O10313C1039O10313C1041O11287C1045O11287C1047O14606C1051O14606C1053O14809C1057O14809C1059O14842C1063O14842C1065O38706C1072O38727C1078O38749C1084O38767C1090O38786C1096O38811C1102O38829C1108O38854C1114O38721C1118O38935C1121O38935C1126O38900C1132O38980C1143O39020C1145O39020C1147O39045C1156O39068C1163O39473,,
tick,0x7ff805e4dd51,111721,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805ede983,111734,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805f12098,111744,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x102589446,111755,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,111939,0xb469fbef4d8,5, node:internal/modules/esm/get_format:1:1,0xb469fbef250,~
script-source,404,node:internal/modules/esm/get_format,'use strict';\nconst {\n  RegExpPrototypeExec\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\nconst { basename\x2C extname\x2C relative } = require('path');\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\nconst {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  mimeToFormat\x2C\n} = require('internal/modules/esm/formats');\n\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\nconst experimentalSpecifierResolution =\n  getOptionValue('--experimental-specifier-resolution');\nconst { getPackageType\x2C getPackageScopeConfig } = require('internal/modules/esm/resolve');\nconst { URL\x2C fileURLToPath } = require('internal/url');\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\n\nconst protocolHandlers = ObjectAssign(ObjectCreate(null)\x2C {\n  'data:': getDataProtocolModuleFormat\x2C\n  'file:': getFileProtocolModuleFormat\x2C\n  'http:': getHttpProtocolModuleFormat\x2C\n  'https:': getHttpProtocolModuleFormat\x2C\n  'node:'() { return 'builtin'; }\x2C\n});\n\n/**\n * @param {URL} parsed\n * @returns {string | null}\n */\nfunction getDataProtocolModuleFormat(parsed) {\n  const { 1: mime } = RegExpPrototypeExec(\n    /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\n    parsed.pathname\x2C\n  ) || [ null\x2C null\x2C null ];\n\n  return mimeToFormat(mime);\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @param {boolean} ignoreErrors\n * @returns {string}\n */\nfunction getFileProtocolModuleFormat(url\x2C context\x2C ignoreErrors) {\n  const filepath = fileURLToPath(url);\n  const ext = extname(filepath);\n  if (ext === '.js') {\n    return getPackageType(url) === 'module' ? 'module' : 'commonjs';\n  }\n\n  const format = extensionFormatMap[ext];\n  if (format) return format;\n\n  if (experimentalSpecifierResolution !== 'node') {\n    // Explicit undefined return indicates load hook should rerun format check\n    if (ignoreErrors) return undefined;\n    let suggestion = '';\n    if (getPackageType(url) === 'module' && ext === '') {\n      const config = getPackageScopeConfig(url);\n      const fileBasename = basename(filepath);\n      const relativePath = StringPrototypeSlice(relative(config.pjsonPath\x2C filepath)\x2C 1);\n      suggestion = 'Loading extensionless files is not supported inside of ' +\n        '"type":"module" package.json contexts. The package.json file ' +\n        `${config.pjsonPath} caused this "type":"module" context. Try ` +\n        `changing ${filepath} to have a file extension. Note the "bin" ` +\n        'field of package.json can point to a file with an extension\x2C for example ' +\n        `{"type":"module"\x2C"bin":{"${fileBasename}":"${relativePath}.js"}}`;\n    }\n    throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C filepath\x2C suggestion);\n  }\n\n  return getLegacyExtensionFormat(ext) ?? null;\n}\n\n/**\n * @param {URL} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | undefined} only works when enabled\n */\nfunction getHttpProtocolModuleFormat(url\x2C context) {\n  if (experimentalNetworkImports) {\n    return PromisePrototypeThen(\n      PromiseResolve(fetchModule(url\x2C context))\x2C\n      (entry) => {\n        return mimeToFormat(entry.headers['content-type']);\n      }\n    );\n  }\n}\n\n/**\n * @param {URL | URL['href']} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormatWithoutErrors(url\x2C context) {\n  const parsed = new URL(url);\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol))\n    return null;\n  return protocolHandlers[parsed.protocol](parsed\x2C context\x2C true);\n}\n\n/**\n * @param {URL | URL['href']} url\n * @param {{parentURL: string}} context\n * @returns {Promise<string> | string | undefined} only works when enabled\n */\nfunction defaultGetFormat(url\x2C context) {\n  const parsed = new URL(url);\n  return ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol) ?\n    protocolHandlers[parsed.protocol](parsed\x2C context\x2C false) :\n    null;\n}\n\nmodule.exports = {\n  defaultGetFormat\x2C\n  defaultGetFormatWithoutErrors\x2C\n  extensionFormatMap\x2C\n};\n
code-source-info,0xb469fbef4d8,404,0,4193,C0O0C4O4193,,
code-creation,Function,10,112435,0xb469fbef958,368, node:internal/modules/esm/get_format:1:1,0xb469fbef450,~
code-source-info,0xb469fbef958,404,0,4193,C0O0C90O24C96O47C101O63C106O79C112O112C118O136C124O154C130O233C133O233C138O201C144O211C150O220C156O277C159O277C164O258C169O330C172O330C177O314C183O454C186O454C191O386C197O408C203O436C209O533C212O533C216O533C218O625C221O625C225O625C227O730C230O730C235O688C241O704C247O802C250O802C255O779C261O784C267O866C270O866C275O892C280O835C286O926C288O939C300O972C306O1012C312O1052C318O1093C322O1124C330O926C335O926C337O4096C344O4117C350O4137C356O4170C362O4111C367O4192,,
code-creation,Eval,10,112654,0xb469fbf0810,5, node:internal/modules/esm/fetch_module:1:1,0xb469fbf0528,~
script-source,405,node:internal/modules/esm/fetch_module,'use strict';\nconst {\n  ObjectPrototypeHasOwnProperty\x2C\n  PromisePrototypeThen\x2C\n  SafeMap\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\nconst {\n  Buffer: { concat: BufferConcat }\x2C\n} = require('buffer');\nconst {\n  ERR_NETWORK_IMPORT_DISALLOWED\x2C\n  ERR_NETWORK_IMPORT_BAD_RESPONSE\x2C\n  ERR_MODULE_NOT_FOUND\x2C\n} = require('internal/errors').codes;\nconst { URL } = require('internal/url');\nconst net = require('net');\nconst { once } = require('events');\nconst { compose } = require('stream');\n/**\n * @typedef CacheEntry\n * @property {Promise<string> | string} resolvedHREF\n * @property {Record<string\x2C string>} headers\n * @property {Promise<Buffer> | Buffer} body\n */\n\n/**\n * Only for GET requests\x2C other requests would need new Map\n * HTTP cache semantics keep diff caches\n *\n * It caches either the promise or the cache entry since import.meta.url needs\n * the value synchronously for the response location after all redirects.\n *\n * Maps HREF to pending cache entry\n * @type {Map<string\x2C Promise<CacheEntry> | CacheEntry>}\n */\nconst cacheForGET = new SafeMap();\n\n// [1] The V8 snapshot doesn't like some C++ APIs to be loaded eagerly. Do it\n// lazily/at runtime and not top level of an internal module.\n\n// [2] Creating a new agent instead of using the gloabl agent improves\n// performance and precludes the agent becoming tainted.\n\nlet HTTPSAgent;\nfunction HTTPSGet(url\x2C opts) {\n  const https = require('https'); // [1]\n  HTTPSAgent ??= new https.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return https.get(url\x2C {\n    agent: HTTPSAgent\x2C\n    ...opts\x2C\n  });\n}\n\nlet HTTPAgent;\nfunction HTTPGet(url\x2C opts) {\n  const http = require('http'); // [1]\n  HTTPAgent ??= new http.Agent({ // [2]\n    keepAlive: true\x2C\n  });\n  return http.get(url\x2C {\n    agent: HTTPAgent\x2C\n    ...opts\x2C\n  });\n}\n\nfunction dnsLookup(name\x2C opts) {\n  // eslint-disable-next-line no-func-assign\n  dnsLookup = require('dns/promises').lookup;\n  return dnsLookup(name\x2C opts);\n}\n\nlet zlib;\nfunction createBrotliDecompress() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createBrotliDecompress = zlib.createBrotliDecompress;\n  return createBrotliDecompress();\n}\n\nfunction createUnzip() {\n  zlib ??= require('zlib'); // [1]\n  // eslint-disable-next-line no-func-assign\n  createUnzip = zlib.createUnzip;\n  return createUnzip();\n}\n\n/**\n * Redirection status code as per section 6.4 of RFC 7231:\n * https://datatracker.ietf.org/doc/html/rfc7231#section-6.4\n * and RFC 7238:\n * https://datatracker.ietf.org/doc/html/rfc7238\n * @param {number} statusCode\n * @returns {boolean}\n */\nfunction isRedirect(statusCode) {\n  switch (statusCode) {\n    case 300: // Multiple Choices\n    case 301: // Moved Permanently\n    case 302: // Found\n    case 303: // See Other\n    case 307: // Temporary Redirect\n    case 308: // Permanent Redirect\n      return true;\n    default:\n      return false;\n  }\n}\n\n/**\n * @param {URL} parsed\n * @returns {Promise<CacheEntry> | CacheEntry}\n */\nfunction fetchWithRedirects(parsed) {\n  const existing = cacheForGET.get(parsed.href);\n  if (existing) {\n    return existing;\n  }\n  const handler = parsed.protocol === 'http:' ? HTTPGet : HTTPSGet;\n  const result = (async () => {\n    const req = handler(parsed\x2C {\n      headers: { Accept: '*/*' }\x2C\n    });\n    // Note that `once` is used here to handle `error` and that it hits the\n    // `finally` on network error/timeout.\n    const { 0: res } = await once(req\x2C 'response');\n    try {\n      const hasLocation = ObjectPrototypeHasOwnProperty(res.headers\x2C 'location');\n      if (isRedirect(res.statusCode) && hasLocation) {\n        const location = new URL(res.headers.location\x2C parsed);\n        if (location.protocol !== 'http:' && location.protocol !== 'https:') {\n          throw new ERR_NETWORK_IMPORT_DISALLOWED(\n            res.headers.location\x2C\n            parsed.href\x2C\n            'cannot redirect to non-network location'\n          );\n        }\n        const entry = await fetchWithRedirects(location);\n        cacheForGET.set(parsed.href\x2C entry);\n        return entry;\n      }\n      if (res.statusCode === 404) {\n        const err = new ERR_MODULE_NOT_FOUND(parsed.href\x2C null);\n        err.message = `Cannot find module '${parsed.href}'\x2C HTTP 404`;\n        throw err;\n      }\n      // This condition catches all unsupported status codes\x2C including\n      // 3xx redirection codes without `Location` HTTP header.\n      if (res.statusCode < 200 || res.statusCode >= 300) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          res.headers.location\x2C\n          parsed.href\x2C\n          'cannot redirect to non-network location');\n      }\n      const { headers } = res;\n      const contentType = headers['content-type'];\n      if (!contentType) {\n        throw new ERR_NETWORK_IMPORT_BAD_RESPONSE(\n          parsed.href\x2C\n          "the 'Content-Type' header is required"\n        );\n      }\n      /**\n       * @type {CacheEntry}\n       */\n      const entry = {\n        resolvedHREF: parsed.href\x2C\n        headers: {\n          'content-type': res.headers['content-type']\x2C\n        }\x2C\n        body: (async () => {\n          let bodyStream = res;\n          if (res.headers['content-encoding'] === 'br') {\n            bodyStream = compose(res\x2C createBrotliDecompress());\n          } else if (\n            res.headers['content-encoding'] === 'gzip' ||\n            res.headers['content-encoding'] === 'deflate'\n          ) {\n            bodyStream = compose(res\x2C createUnzip());\n          }\n          const buffers = await bodyStream.toArray();\n          const body = BufferConcat(buffers);\n          entry.body = body;\n          return body;\n        })()\x2C\n      };\n      cacheForGET.set(parsed.href\x2C entry);\n      await entry.body;\n      return entry;\n    } finally {\n      req.destroy();\n    }\n  })();\n  cacheForGET.set(parsed.href\x2C result);\n  return result;\n}\n\nconst allowList = new net.BlockList();\nallowList.addAddress('::1'\x2C 'ipv6');\nallowList.addRange('127.0.0.1'\x2C '127.255.255.255');\n\n/**\n * Returns if an address has local status by if it is going to a local\n * interface or is an address resolved by DNS to be a local interface\n * @param {string} hostname url.hostname to test\n * @returns {Promise<boolean>}\n */\nasync function isLocalAddress(hostname) {\n  try {\n    if (\n      StringPrototypeStartsWith(hostname\x2C '[') &&\n      StringPrototypeEndsWith(hostname\x2C ']')\n    ) {\n      hostname = StringPrototypeSlice(hostname\x2C 1\x2C -1);\n    }\n    const addr = await dnsLookup(hostname\x2C { verbatim: true });\n    const ipv = addr.family === 4 ? 'ipv4' : 'ipv6';\n    return allowList.check(addr.address\x2C ipv);\n  } catch {\n    // If it errored\x2C the answer is no.\n  }\n  return false;\n}\n\n/**\n * Fetches a location with a shared cache following redirects.\n * Does not respect HTTP cache headers.\n *\n * This splits the header and body Promises so that things only needing\n * headers don't need to wait on the body.\n *\n * In cases where the request & response have already settled\x2C this returns the\n * cache value synchronously.\n *\n * @param {URL} parsed\n * @param {ESModuleContext} context\n * @returns {ReturnType<typeof fetchWithRedirects>}\n */\nfunction fetchModule(parsed\x2C { parentURL }) {\n  const { href } = parsed;\n  const existing = cacheForGET.get(href);\n  if (existing) {\n    return existing;\n  }\n  if (parsed.protocol === 'http:') {\n    return PromisePrototypeThen(isLocalAddress(parsed.hostname)\x2C (is) => {\n      if (is !== true) {\n        throw new ERR_NETWORK_IMPORT_DISALLOWED(\n          href\x2C\n          parentURL\x2C\n          'http can only be used to load local resources (use https instead).'\n        );\n      }\n      return fetchWithRedirects(parsed);\n    });\n  }\n  return fetchWithRedirects(parsed);\n}\n\nmodule.exports = {\n  fetchModule\x2C\n};\n
code-source-info,0xb469fbf0810,405,0,7752,C0O0C4O7752,,
code-creation,Function,10,113721,0xb469fbf0cc8,355, node:internal/modules/esm/fetch_module:1:1,0xb469fbf0788,~
code-source-info,0xb469fbf0cc8,405,0,7752,C0O0C113O24C119O57C125O81C130O92C136O119C142O143C148O235C154O235C159O235C164O215C170O358C176O358C181O384C186O264C192O297C198O332C204O408C210O408C215O400C221O445C227O445C232O478C238O478C243O469C249O517C255O517C260O505C266O1093C268O1093C273O1093C275O1383C276O1383C278O1611C279O1611C281O1990C282O1990C284O5892C289O5884C294O5884C296O5905C299O5915C310O5915C316O5942C319O5952C330O5952C336O7715C343O7736C349O7730C354O7751,,
tick,0x10266ea69,113777,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x102ce1e9f,114051,1,0x10266e4e0,2,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbf0dab,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,115016,0xb469fbf4260,5, node:net:1:1,0xb469fbf2d40,~
script-source,406,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeIndexOf\x2C\n  Boolean\x2C\n  Number\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n  ObjectCreate\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst stream = require('stream');\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\n  debug = fn;\n});\nconst {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  normalizedArgsSymbol\x2C\n  makeSyncWrite\n} = require('internal/net');\nconst assert = require('internal/assert');\nconst {\n  UV_EADDRINUSE\x2C\n  UV_EINVAL\x2C\n  UV_ENOTCONN\n} = internalBinding('uv');\n\nconst { Buffer } = require('buffer');\nconst { guessHandleType } = internalBinding('util');\nconst { ShutdownWrap } = internalBinding('stream_wrap');\nconst {\n  TCP\x2C\n  TCPConnectWrap\x2C\n  constants: TCPConstants\n} = internalBinding('tcp_wrap');\nconst {\n  Pipe\x2C\n  PipeConnectWrap\x2C\n  constants: PipeConstants\n} = internalBinding('pipe_wrap');\nconst {\n  newAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst {\n  writevGeneric\x2C\n  writeGeneric\x2C\n  onStreamRead\x2C\n  kAfterAsyncWrite\x2C\n  kHandle\x2C\n  kUpdateTimer\x2C\n  setStreamTimeout\x2C\n  kBuffer\x2C\n  kBufferCb\x2C\n  kBufferGen\n} = require('internal/stream_base_commons');\nconst {\n  codes: {\n    ERR_INVALID_ADDRESS_FAMILY\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FD_TYPE\x2C\n    ERR_INVALID_IP_ADDRESS\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_SERVER_ALREADY_LISTEN\x2C\n    ERR_SERVER_NOT_RUNNING\x2C\n    ERR_SOCKET_CLOSED\x2C\n    ERR_MISSING_ARGS\x2C\n  }\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  genericNodeError\x2C\n  uvExceptionWithHostPort\x2C\n} = require('internal/errors');\nconst { isUint8Array } = require('internal/util/types');\nconst {\n  validateAbortSignal\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateNumber\x2C\n  validatePort\x2C\n  validateString\n} = require('internal/validators');\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\nconst {\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n} = require('internal/dtrace');\n\n// Lazy loaded to improve startup performance.\nlet cluster;\nlet dns;\nlet BlockList;\nlet SocketAddress;\n\nconst { clearTimeout } = require('timers');\nconst { kTimeout } = require('internal/timers');\n\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\nconst DEFAULT_IPV6_ADDR = '::';\n\nconst isWindows = process.platform === 'win32';\n\nconst noop = () => {};\n\nconst kPerfHooksNetConnectContext = Symbol('kPerfHooksNetConnectContext');\nconst {\n  hasObserver\x2C\n  startPerf\x2C\n  stopPerf\x2C\n} = require('internal/perf/observe');\n\nfunction getFlags(ipv6Only) {\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\n}\n\nfunction createHandle(fd\x2C is_server) {\n  validateInt32(fd\x2C 'fd'\x2C 0);\n  const type = guessHandleType(fd);\n  if (type === 'PIPE') {\n    return new Pipe(\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\n    );\n  }\n\n  if (type === 'TCP') {\n    return new TCP(\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\n    );\n  }\n\n  throw new ERR_INVALID_FD_TYPE(type);\n}\n\n\nfunction getNewAsyncId(handle) {\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\n    newAsyncId() : handle.getAsyncId();\n}\n\n\nfunction isPipeName(s) {\n  return typeof s === 'string' && toNumber(s) === false;\n}\n\n/**\n * Creates a new TCP or IPC server\n * @param {{\n *   allowHalfOpen?: boolean;\n *   pauseOnConnect?: boolean;\n *   }} [options]\n * @param {Function} [connectionListener]\n * @returns {Server}\n */\n\nfunction createServer(options\x2C connectionListener) {\n  return new Server(options\x2C connectionListener);\n}\n\n\n// Target API:\n//\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\n//   ...\n// });\n//\n// There are various forms:\n//\n// connect(options\x2C [cb])\n// connect(port\x2C [host]\x2C [cb])\n// connect(path\x2C [cb]);\n//\nfunction connect(...args) {\n  const normalized = normalizeArgs(args);\n  const options = normalized[0];\n  debug('createConnection'\x2C normalized);\n  const socket = new Socket(options);\n\n  if (options.timeout) {\n    socket.setTimeout(options.timeout);\n  }\n\n  return socket.connect(normalized);\n}\n\n\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\n// cb is either a function or null.\n// Used to normalize arguments of Socket.prototype.connect() and\n// Server.prototype.listen(). Possible combinations of parameters:\n//   (options[...][\x2C cb])\n//   (path[...][\x2C cb])\n//   ([port][\x2C host][...][\x2C cb])\n// For Socket.prototype.connect()\x2C the [...] part is ignored\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\n// but will not be handled here (handled in listen())\nfunction normalizeArgs(args) {\n  let arr;\n\n  if (args.length === 0) {\n    arr = [{}\x2C null];\n    arr[normalizedArgsSymbol] = true;\n    return arr;\n  }\n\n  const arg0 = args[0];\n  let options = {};\n  if (typeof arg0 === 'object' && arg0 !== null) {\n    // (options[...][\x2C cb])\n    options = arg0;\n  } else if (isPipeName(arg0)) {\n    // (path[...][\x2C cb])\n    options.path = arg0;\n  } else {\n    // ([port][\x2C host][...][\x2C cb])\n    options.port = arg0;\n    if (args.length > 1 && typeof args[1] === 'string') {\n      options.host = args[1];\n    }\n  }\n\n  const cb = args[args.length - 1];\n  if (typeof cb !== 'function')\n    arr = [options\x2C null];\n  else\n    arr = [options\x2C cb];\n\n  arr[normalizedArgsSymbol] = true;\n  return arr;\n}\n\n\n// Called when creating new Socket\x2C or when re-using a closed Socket\nfunction initSocketHandle(self) {\n  self._undestroy();\n  self._sockname = null;\n\n  // Handle creation may be deferred to bind() or connect() time.\n  if (self._handle) {\n    self._handle[owner_symbol] = self;\n    self._handle.onread = onStreamRead;\n    self[async_id_symbol] = getNewAsyncId(self._handle);\n\n    let userBuf = self[kBuffer];\n    if (userBuf) {\n      const bufGen = self[kBufferGen];\n      if (bufGen !== null) {\n        userBuf = bufGen();\n        if (!isUint8Array(userBuf))\n          return;\n        self[kBuffer] = userBuf;\n      }\n      self._handle.useUserBuffer(userBuf);\n    }\n  }\n}\n\n\nconst kBytesRead = Symbol('kBytesRead');\nconst kBytesWritten = Symbol('kBytesWritten');\nconst kSetNoDelay = Symbol('kSetNoDelay');\nconst kSetKeepAlive = Symbol('kSetKeepAlive');\nconst kSetKeepAliveInitialDelay = Symbol('kSetKeepAliveInitialDelay');\n\nfunction Socket(options) {\n  if (!(this instanceof Socket)) return new Socket(options);\n  if (options?.objectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      'options.objectMode'\x2C\n      options.objectMode\x2C\n      'is not supported'\n    );\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\n    throw new ERR_INVALID_ARG_VALUE(\n      `options.${\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\n      }`\x2C\n      options.readableObjectMode || options.writableObjectMode\x2C\n      'is not supported'\n    );\n  }\n  if (typeof options?.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options?.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this.connecting = false;\n  // Problem with this is that users can supply their own handle\x2C that may not\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\n  // probably be supplied by async_hooks.\n  this[async_id_symbol] = -1;\n  this._hadError = false;\n  this[kHandle] = null;\n  this._parent = null;\n  this._host = null;\n  this[kLastWriteQueueSize] = 0;\n  this[kTimeout] = null;\n  this[kBuffer] = null;\n  this[kBufferCb] = null;\n  this[kBufferGen] = null;\n\n  if (typeof options === 'number')\n    options = { fd: options }; // Legacy interface.\n  else\n    options = { ...options };\n\n  // Default to *not* allowing half open sockets.\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\n  // For backwards compat do not emit close on destroy.\n  options.emitClose = false;\n  options.autoDestroy = true;\n  // Handle strings directly.\n  options.decodeStrings = false;\n  stream.Duplex.call(this\x2C options);\n\n  if (options.handle) {\n    this._handle = options.handle; // private\n    this[async_id_symbol] = getNewAsyncId(this._handle);\n  } else if (options.fd !== undefined) {\n    const { fd } = options;\n    let err;\n\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\n    // a valid `PIPE` or `TCP` descriptor\n    this._handle = createHandle(fd\x2C false);\n\n    err = this._handle.open(fd);\n\n    // While difficult to fabricate\x2C in some architectures\n    // `open` may return an error code for valid file descriptors\n    // which cannot be opened. This is difficult to test as most\n    // un-openable fds will throw on `createHandle`\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    this[async_id_symbol] = this._handle.getAsyncId();\n\n    if ((fd === 1 || fd === 2) &&\n        (this._handle instanceof Pipe) && isWindows) {\n      // Make stdout and stderr blocking on Windows\n      err = this._handle.setBlocking(true);\n      if (err)\n        throw errnoException(err\x2C 'setBlocking');\n\n      this._writev = null;\n      this._write = makeSyncWrite(fd);\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\n      // we need to let it do that by turning it into a writable\x2C own\n      // property.\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\n        __proto__: null\x2C\n        value: 0\x2C writable: true\n      });\n    }\n  }\n\n  const onread = options.onread;\n  if (onread !== null && typeof onread === 'object' &&\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\n      typeof onread.callback === 'function') {\n    if (typeof onread.buffer === 'function') {\n      this[kBuffer] = true;\n      this[kBufferGen] = onread.buffer;\n    } else {\n      this[kBuffer] = onread.buffer;\n    }\n    this[kBufferCb] = onread.callback;\n  }\n\n  this[kSetNoDelay] = Boolean(options.noDelay);\n  this[kSetKeepAlive] = Boolean(options.keepAlive);\n  this[kSetKeepAliveInitialDelay] = ~~(options.keepAliveInitialDelay / 1000);\n\n  // Shut down the socket when we're finished with it.\n  this.on('end'\x2C onReadableStreamEnd);\n\n  initSocketHandle(this);\n\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  // If we have a handle\x2C then start the flow of data into the\n  // buffer.  if not\x2C then this will happen when we connect\n  if (this._handle && options.readable !== false) {\n    if (options.pauseOnCreate) {\n      // Stop the handle from reading and pause the stream\n      this._handle.reading = false;\n      this._handle.readStop();\n      this.readableFlowing = false;\n    } else if (!options.manualStart) {\n      this.read(0);\n    }\n  }\n\n  // Reserve properties\n  this.server = null;\n  this._server = null;\n\n  // Used after `.destroy()`\n  this[kBytesRead] = 0;\n  this[kBytesWritten] = 0;\n}\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\n\n// Refresh existing timeouts.\nSocket.prototype._unrefTimer = function _unrefTimer() {\n  for (let s = this; s !== null; s = s._parent) {\n    if (s[kTimeout])\n      s[kTimeout].refresh();\n  }\n};\n\n\n// The user has called .end()\x2C and all the bytes have been\n// sent out to the other side.\nSocket.prototype._final = function(cb) {\n  // If still connecting - defer handling `_final` until 'connect' will happen\n  if (this.pending) {\n    debug('_final: not yet connected');\n    return this.once('connect'\x2C () => this._final(cb));\n  }\n\n  if (!this._handle)\n    return cb();\n\n  debug('_final: not ended\x2C call shutdown()');\n\n  const req = new ShutdownWrap();\n  req.oncomplete = afterShutdown;\n  req.handle = this._handle;\n  req.callback = cb;\n  const err = this._handle.shutdown(req);\n\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\n    return cb();\n  else if (err !== 0)\n    return cb(errnoException(err\x2C 'shutdown'));\n};\n\nfunction afterShutdown() {\n  const self = this.handle[owner_symbol];\n\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed\x2C\n        self._readableState);\n\n  this.callback();\n}\n\n// Provide a better error message when we call end() as a result\n// of the other side sending a FIN.  The standard 'write after end'\n// is overly vague\x2C and makes it seem like the user's code is to blame.\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\n  if (!this.writableEnded) {\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  const er = genericNodeError(\n    'This socket has been ended by the other party'\x2C\n    { code: 'EPIPE' }\n  );\n  if (typeof cb === 'function') {\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\n  }\n  this.destroy(er);\n\n  return false;\n}\n\nSocket.prototype.setTimeout = setStreamTimeout;\n\n\nSocket.prototype._onTimeout = function() {\n  const handle = this._handle;\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\n  if (lastWriteQueueSize > 0 && handle) {\n    // `lastWriteQueueSize !== writeQueueSize` means there is\n    // an active write in progress\x2C so we suppress the timeout.\n    const { writeQueueSize } = handle;\n    if (lastWriteQueueSize !== writeQueueSize) {\n      this[kLastWriteQueueSize] = writeQueueSize;\n      this._unrefTimer();\n      return;\n    }\n  }\n  debug('_onTimeout');\n  this.emit('timeout');\n};\n\n\nSocket.prototype.setNoDelay = function(enable) {\n  // Backwards compatibility: assume true when `enable` is omitted\n  enable = Boolean(enable === undefined ? true : enable);\n\n  if (!this._handle) {\n    this[kSetNoDelay] = enable;\n    return this;\n  }\n\n  if (this._handle.setNoDelay && enable !== this[kSetNoDelay]) {\n    this[kSetNoDelay] = enable;\n    this._handle.setNoDelay(enable);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.setKeepAlive = function(enable\x2C initialDelayMsecs) {\n  enable = Boolean(enable);\n  const initialDelay = ~~(initialDelayMsecs / 1000);\n\n  if (!this._handle) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    return this;\n  }\n\n  if (!this._handle.setKeepAlive) {\n    return this;\n  }\n\n  if (enable !== this[kSetKeepAlive] ||\n      (\n        enable &&\n        this[kSetKeepAliveInitialDelay] !== initialDelay\n      )\n  ) {\n    this[kSetKeepAlive] = enable;\n    this[kSetKeepAliveInitialDelay] = initialDelay;\n    this._handle.setKeepAlive(enable\x2C initialDelay);\n  }\n\n  return this;\n};\n\n\nSocket.prototype.address = function() {\n  return this._getsockname();\n};\n\n\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this.connecting;\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\n  __proto__: null\x2C\n  get() {\n    return !this._handle || this.connecting;\n  }\x2C\n  configurable: true\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (this.connecting) {\n      return 'opening';\n    } else if (this.readable && this.writable) {\n      return 'open';\n    } else if (this.readable && !this.writable) {\n      return 'readOnly';\n    } else if (!this.readable && this.writable) {\n      return 'writeOnly';\n    }\n    return 'closed';\n  }\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (this._handle) {\n      return this.writableLength;\n    }\n  }\n});\n\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this._unrefTimer;\n  }\n});\n\n\nfunction tryReadStart(socket) {\n  // Not already reading\x2C start the flow\n  debug('Socket._handle.readStart');\n  socket._handle.reading = true;\n  const err = socket._handle.readStart();\n  if (err)\n    socket.destroy(errnoException(err\x2C 'read'));\n}\n\n// Just call handle.readStart until we have enough in the buffer\nSocket.prototype._read = function(n) {\n  debug('_read');\n\n  if (this.connecting || !this._handle) {\n    debug('_read wait for connection');\n    this.once('connect'\x2C () => this._read(n));\n  } else if (!this._handle.reading) {\n    tryReadStart(this);\n  }\n};\n\n\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\n  stream.Duplex.prototype.end.call(this\x2C\n                                   data\x2C encoding\x2C callback);\n  DTRACE_NET_STREAM_END(this);\n  return this;\n};\n\nSocket.prototype.resetAndDestroy = function() {\n  if (this._handle) {\n    if (!(this._handle instanceof TCP))\n      throw new ERR_INVALID_HANDLE_TYPE();\n    if (this.connecting) {\n      debug('reset wait for connection');\n      this.once('connect'\x2C () => this._reset());\n    } else {\n      this._reset();\n    }\n  } else {\n    this.destroy(new ERR_SOCKET_CLOSED());\n  }\n  return this;\n};\n\nSocket.prototype.pause = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      this._handle.reading) {\n    this._handle.reading = false;\n    if (!this.destroyed) {\n      const err = this._handle.readStop();\n      if (err)\n        this.destroy(errnoException(err\x2C 'read'));\n    }\n  }\n  return stream.Duplex.prototype.pause.call(this);\n};\n\n\nSocket.prototype.resume = function() {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.resume.call(this);\n};\n\n\nSocket.prototype.read = function(n) {\n  if (this[kBuffer] && !this.connecting && this._handle &&\n      !this._handle.reading) {\n    tryReadStart(this);\n  }\n  return stream.Duplex.prototype.read.call(this\x2C n);\n};\n\n\n// Called when the 'end' event is emitted.\nfunction onReadableStreamEnd() {\n  if (!this.allowHalfOpen) {\n    this.write = writeAfterFIN;\n  }\n}\n\n\nSocket.prototype.destroySoon = function() {\n  if (this.writable)\n    this.end();\n\n  if (this.writableFinished)\n    this.destroy();\n  else\n    this.once('finish'\x2C this.destroy);\n};\n\n\nSocket.prototype._destroy = function(exception\x2C cb) {\n  debug('destroy');\n\n  this.connecting = false;\n\n  for (let s = this; s !== null; s = s._parent) {\n    clearTimeout(s[kTimeout]);\n  }\n\n  debug('close');\n  if (this._handle) {\n    if (this !== process.stderr)\n      debug('close handle');\n    const isException = exception ? true : false;\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\n    this[kBytesRead] = this._handle.bytesRead;\n    this[kBytesWritten] = this._handle.bytesWritten;\n\n    if (this.resetAndClosing) {\n      this.resetAndClosing = false;\n      const err = this._handle.reset(() => {\n        debug('emit close');\n        this.emit('close'\x2C isException);\n      });\n      if (err)\n        this.emit('error'\x2C errnoException(err\x2C 'reset'));\n    } else {\n      this._handle.close(() => {\n        debug('emit close');\n        this.emit('close'\x2C isException);\n      });\n    }\n    this._handle.onread = noop;\n    this._handle = null;\n    this._sockname = null;\n    cb(exception);\n  } else {\n    cb(exception);\n    process.nextTick(emitCloseNT\x2C this);\n  }\n\n  if (this._server) {\n    debug('has server');\n    this._server._connections--;\n    if (this._server._emitCloseIfDrained) {\n      this._server._emitCloseIfDrained();\n    }\n  }\n};\n\nSocket.prototype._reset = function() {\n  debug('reset connection');\n  this.resetAndClosing = true;\n  return this.destroy();\n};\n\nSocket.prototype._getpeername = function() {\n  if (!this._handle || !this._handle.getpeername || this.connecting) {\n    return this._peername || {};\n  } else if (!this._peername) {\n    const out = {};\n    const err = this._handle.getpeername(out);\n    if (err) return out;\n    this._peername = out;\n  }\n  return this._peername;\n};\n\nfunction protoGetter(name\x2C callback) {\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: callback\n  });\n}\n\nprotoGetter('bytesRead'\x2C function bytesRead() {\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\n});\n\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\n  return this._getpeername().address;\n});\n\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\n  return this._getpeername().family;\n});\n\nprotoGetter('remotePort'\x2C function remotePort() {\n  return this._getpeername().port;\n});\n\n\nSocket.prototype._getsockname = function() {\n  if (!this._handle || !this._handle.getsockname) {\n    return {};\n  } else if (!this._sockname) {\n    this._sockname = {};\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\n    this._handle.getsockname(this._sockname);\n  }\n  return this._sockname;\n};\n\n\nprotoGetter('localAddress'\x2C function localAddress() {\n  return this._getsockname().address;\n});\n\n\nprotoGetter('localPort'\x2C function localPort() {\n  return this._getsockname().port;\n});\n\n\nSocket.prototype[kAfterAsyncWrite] = function() {\n  this[kLastWriteQueueSize] = 0;\n};\n\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\n  // If we are still connecting\x2C then buffer this for later.\n  // The Writable logic will buffer up any more writes while\n  // waiting for this one to be done.\n  if (this.connecting) {\n    this._pendingData = data;\n    this._pendingEncoding = encoding;\n    this.once('connect'\x2C function connect() {\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\n    });\n    return;\n  }\n  this._pendingData = null;\n  this._pendingEncoding = '';\n\n  if (!this._handle) {\n    cb(new ERR_SOCKET_CLOSED());\n    return false;\n  }\n\n  this._unrefTimer();\n\n  let req;\n  if (writev)\n    req = writevGeneric(this\x2C data\x2C cb);\n  else\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\n  if (req.async)\n    this[kLastWriteQueueSize] = req.bytes;\n};\n\n\nSocket.prototype._writev = function(chunks\x2C cb) {\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\n};\n\n\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\n};\n\n\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\n// really hurt anyone either. This can probably be removed safely if desired.\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\n});\n\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\n  let bytes = this._bytesDispatched;\n  const data = this._pendingData;\n  const encoding = this._pendingEncoding;\n  const writableBuffer = this.writableBuffer;\n\n  if (!writableBuffer)\n    return undefined;\n\n  for (const el of writableBuffer) {\n    bytes += el.chunk instanceof Buffer ?\n      el.chunk.length :\n      Buffer.byteLength(el.chunk\x2C el.encoding);\n  }\n\n  if (ArrayIsArray(data)) {\n    // Was a writev\x2C iterate over chunks to get total length\n    for (let i = 0; i < data.length; i++) {\n      const chunk = data[i];\n\n      if (data.allBuffers || chunk instanceof Buffer)\n        bytes += chunk.length;\n      else\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\n    }\n  } else if (data) {\n    // Writes are either a string or a Buffer.\n    if (typeof data !== 'string')\n      bytes += data.length;\n    else\n      bytes += Buffer.byteLength(data\x2C encoding);\n  }\n\n  return bytes;\n});\n\n\nfunction checkBindError(err\x2C port\x2C handle) {\n  // EADDRINUSE may not be reported until we call listen() or connect().\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\n  // bound to the expected port before calling listen() or connect().\n  //\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\n  // really support pipes anyway.\n  if (err === 0 && port > 0 && handle.getsockname) {\n    const out = {};\n    err = handle.getsockname(out);\n    if (err === 0 && port !== out.port) {\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\n      err = UV_EADDRINUSE;\n    }\n  }\n  return err;\n}\n\n\nfunction internalConnect(\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\n  // TODO return promise from Socket.prototype.connect which\n  // wraps _connectReq.\n\n  assert(self.connecting);\n\n  let err;\n\n  if (localAddress || localPort) {\n    if (addressType === 4) {\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\n      err = self._handle.bind(localAddress\x2C localPort);\n    } else { // addressType === 6\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\n    }\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\n          localAddress\x2C localPort\x2C addressType);\n\n    err = checkBindError(err\x2C localPort\x2C self._handle);\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\n      self.destroy(ex);\n      return;\n    }\n  }\n\n  if (addressType === 6 || addressType === 4) {\n    const req = new TCPConnectWrap();\n    req.oncomplete = afterConnect;\n    req.address = address;\n    req.port = port;\n    req.localAddress = localAddress;\n    req.localPort = localPort;\n\n    if (addressType === 4)\n      err = self._handle.connect(req\x2C address\x2C port);\n    else\n      err = self._handle.connect6(req\x2C address\x2C port);\n  } else {\n    const req = new PipeConnectWrap();\n    req.address = address;\n    req.oncomplete = afterConnect;\n\n    err = self._handle.connect(req\x2C address\x2C afterConnect);\n  }\n\n  if (err) {\n    const sockname = self._getsockname();\n    let details;\n\n    if (sockname) {\n      details = sockname.address + ':' + sockname.port;\n    }\n\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\n    self.destroy(ex);\n  } else if ((addressType === 6 || addressType === 4) && hasObserver('net')) {\n    startPerf(self\x2C kPerfHooksNetConnectContext\x2C { type: 'net'\x2C name: 'connect'\x2C detail: { host: address\x2C port } });\n  }\n}\n\n\nSocket.prototype.connect = function(...args) {\n  let normalized;\n  // If passed an array\x2C it's treated as an array of arguments that have\n  // already been normalized (so we don't normalize more than once). This has\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\n  // reverted as it had unintended side effects.\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\n    normalized = args[0];\n  } else {\n    normalized = normalizeArgs(args);\n  }\n  const options = normalized[0];\n  const cb = normalized[1];\n\n  // options.port === null will be checked later.\n  if (options.port === undefined && options.path == null)\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\n\n  if (this.write !== Socket.prototype.write)\n    this.write = Socket.prototype.write;\n\n  if (this.destroyed) {\n    this._handle = null;\n    this._peername = null;\n    this._sockname = null;\n  }\n\n  const { path } = options;\n  const pipe = !!path;\n  debug('pipe'\x2C pipe\x2C path);\n\n  if (!this._handle) {\n    this._handle = pipe ?\n      new Pipe(PipeConstants.SOCKET) :\n      new TCP(TCPConstants.SOCKET);\n    initSocketHandle(this);\n  }\n\n  if (cb !== null) {\n    this.once('connect'\x2C cb);\n  }\n\n  this._unrefTimer();\n\n  this.connecting = true;\n\n  if (pipe) {\n    validateString(path\x2C 'options.path');\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\n    );\n  } else {\n    lookupAndConnect(this\x2C options);\n  }\n  return this;\n};\n\n\nfunction lookupAndConnect(self\x2C options) {\n  const { localAddress\x2C localPort } = options;\n  const host = options.host || 'localhost';\n  let { port } = options;\n\n  if (localAddress && !isIP(localAddress)) {\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\n  }\n\n  if (localPort) {\n    validateNumber(localPort\x2C 'options.localPort');\n  }\n\n  if (typeof port !== 'undefined') {\n    if (typeof port !== 'number' && typeof port !== 'string') {\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\n                                     ['number'\x2C 'string']\x2C port);\n    }\n    validatePort(port);\n  }\n  port |= 0;\n\n  // If host is an IP\x2C skip performing a lookup\n  const addressType = isIP(host);\n  if (addressType) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\n      if (self.connecting)\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n    });\n    return;\n  }\n\n  if (options.lookup !== undefined)\n    validateFunction(options.lookup\x2C 'options.lookup');\n\n  if (dns === undefined) dns = require('dns');\n  const dnsopts = {\n    family: options.family\x2C\n    hints: options.hints || 0\n  };\n\n  if (!isWindows &&\n      dnsopts.family !== 4 &&\n      dnsopts.family !== 6 &&\n      dnsopts.hints === 0) {\n    dnsopts.hints = dns.ADDRCONFIG;\n  }\n\n  debug('connect: find host'\x2C host);\n  debug('connect: dns options'\x2C dnsopts);\n  self._host = host;\n  const lookup = options.lookup || dns.lookup;\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\n\n      // It's possible we were destroyed while looking this up.\n      // XXX it would be great if we could cancel the promise returned by\n      // the look up.\n      if (!self.connecting) return;\n\n      if (err) {\n        // net.createConnection() creates a net.Socket object and immediately\n        // calls net.Socket.connect() on it (that's us). There are no event\n        // listeners registered yet so defer the error event to the next tick.\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (!isIP(ip)) {\n        err = new ERR_INVALID_IP_ADDRESS(ip);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else if (addressType !== 4 && addressType !== 6) {\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\n                                             options.host\x2C\n                                             options.port);\n        process.nextTick(connectErrorNT\x2C self\x2C err);\n      } else {\n        self._unrefTimer();\n        defaultTriggerAsyncIdScope(\n          self[async_id_symbol]\x2C\n          internalConnect\x2C\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\n        );\n      }\n    });\n  });\n}\n\n\nfunction connectErrorNT(self\x2C err) {\n  self.destroy(err);\n}\n\n\nSocket.prototype.ref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.ref);\n    return this;\n  }\n\n  if (typeof this._handle.ref === 'function') {\n    this._handle.ref();\n  }\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  if (!this._handle) {\n    this.once('connect'\x2C this.unref);\n    return this;\n  }\n\n  if (typeof this._handle.unref === 'function') {\n    this._handle.unref();\n  }\n\n  return this;\n};\n\n\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\n  const self = handle[owner_symbol];\n\n  // Callback may come after call to destroy\n  if (self.destroyed) {\n    return;\n  }\n\n  debug('afterConnect');\n\n  assert(self.connecting);\n  self.connecting = false;\n  self._sockname = null;\n\n  if (status === 0) {\n    if (self.readable && !readable) {\n      self.push(null);\n      self.read();\n    }\n    if (self.writable && !writable) {\n      self.end();\n    }\n    self._unrefTimer();\n\n    if (self[kSetNoDelay] && self._handle.setNoDelay) {\n      self._handle.setNoDelay(true);\n    }\n\n    if (self[kSetKeepAlive] && self._handle.setKeepAlive) {\n      self._handle.setKeepAlive(true\x2C self[kSetKeepAliveInitialDelay]);\n    }\n\n    self.emit('connect');\n    self.emit('ready');\n\n    // Start the first read\x2C or get an immediate EOF.\n    // this doesn't actually consume any bytes\x2C because len=0.\n    if (readable && !self.isPaused())\n      self.read(0);\n    if (self[kPerfHooksNetConnectContext] && hasObserver('net')) {\n      stopPerf(self\x2C kPerfHooksNetConnectContext);\n    }\n  } else {\n    let details;\n    if (req.localAddress && req.localPort) {\n      details = req.localAddress + ':' + req.localPort;\n    }\n    const ex = exceptionWithHostPort(status\x2C\n                                     'connect'\x2C\n                                     req.address\x2C\n                                     req.port\x2C\n                                     details);\n    if (details) {\n      ex.localAddress = req.localAddress;\n      ex.localPort = req.localPort;\n    }\n    self.destroy(ex);\n  }\n}\n\nfunction addAbortSignalOption(self\x2C options) {\n  if (options?.signal === undefined) {\n    return;\n  }\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const { signal } = options;\n  const onAborted = () => {\n    self.close();\n  };\n  if (signal.aborted) {\n    process.nextTick(onAborted);\n  } else {\n    signal.addEventListener('abort'\x2C onAborted);\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n  }\n}\n\nfunction Server(options\x2C connectionListener) {\n  if (!(this instanceof Server))\n    return new Server(options\x2C connectionListener);\n\n  EventEmitter.call(this);\n\n  if (typeof options === 'function') {\n    connectionListener = options;\n    options = {};\n    this.on('connection'\x2C connectionListener);\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n\n    if (typeof connectionListener === 'function') {\n      this.on('connection'\x2C connectionListener);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n  }\n  if (typeof options.keepAliveInitialDelay !== 'undefined') {\n    validateNumber(\n      options.keepAliveInitialDelay\x2C 'options.keepAliveInitialDelay'\n    );\n\n    if (options.keepAliveInitialDelay < 0) {\n      options.keepAliveInitialDelay = 0;\n    }\n  }\n\n  this._connections = 0;\n\n  this[async_id_symbol] = -1;\n  this._handle = null;\n  this._usingWorkers = false;\n  this._workers = [];\n  this._unref = false;\n\n  this.allowHalfOpen = options.allowHalfOpen || false;\n  this.pauseOnConnect = !!options.pauseOnConnect;\n  this.noDelay = Boolean(options.noDelay);\n  this.keepAlive = Boolean(options.keepAlive);\n  this.keepAliveInitialDelay = ~~(options.keepAliveInitialDelay / 1000);\n}\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Server\x2C EventEmitter);\n\n\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\n\n// Returns handle if it can be created\x2C or error code if it can't\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  let err = 0;\n  // Assign handle in listen\x2C and clean up if bind or listen fails\n  let handle;\n\n  let isTCP = false;\n  if (typeof fd === 'number' && fd >= 0) {\n    try {\n      handle = createHandle(fd\x2C true);\n    } catch (e) {\n      // Not a fd we can listen on.  This will trigger an error.\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\n      return UV_EINVAL;\n    }\n\n    err = handle.open(fd);\n    if (err)\n      return err;\n\n    assert(!address && !port);\n  } else if (port === -1 && addressType === -1) {\n    handle = new Pipe(PipeConstants.SERVER);\n    if (isWindows) {\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\n      if (!NumberIsNaN(instances)) {\n        handle.setPendingInstances(instances);\n      }\n    }\n  } else {\n    handle = new TCP(TCPConstants.SERVER);\n    isTCP = true;\n  }\n\n  if (address || port || isTCP) {\n    debug('bind to'\x2C address || 'any');\n    if (!address) {\n      // Try binding to ipv6 first\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\n      if (err) {\n        handle.close();\n        // Fallback to ipv4\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\n      }\n    } else if (addressType === 6) {\n      err = handle.bind6(address\x2C port\x2C flags);\n    } else {\n      err = handle.bind(address\x2C port);\n    }\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\n\n  // If there is not yet a handle\x2C we need to create one and bind.\n  // In the case of a server sent via IPC\x2C we don't need to do this.\n  if (this._handle) {\n    debug('setupListenHandle: have a handle already');\n  } else {\n    debug('setupListenHandle: create a handle');\n\n    let rval = null;\n\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\n    if (!address && typeof fd !== 'number') {\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\n\n      if (typeof rval === 'number') {\n        rval = null;\n        address = DEFAULT_IPV4_ADDR;\n        addressType = 4;\n      } else {\n        address = DEFAULT_IPV6_ADDR;\n        addressType = 6;\n      }\n    }\n\n    if (rval === null)\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n    if (typeof rval === 'number') {\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\n      process.nextTick(emitErrorNT\x2C this\x2C error);\n      return;\n    }\n    this._handle = rval;\n  }\n\n  this[async_id_symbol] = getNewAsyncId(this._handle);\n  this._handle.onconnection = onconnection;\n  this._handle[owner_symbol] = this;\n\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\n  // which will thus give us a backlog of 512 entries.\n  const err = this._handle.listen(backlog || 511);\n\n  if (err) {\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\n    this._handle.close();\n    this._handle = null;\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               emitErrorNT\x2C\n                               this\x2C\n                               ex);\n    return;\n  }\n\n  // Generate connection key\x2C this should be unique to the connection\n  this._connectionKey = addressType + ':' + address + ':' + port;\n\n  // Unref the handle if the server was unref'ed prior to listening\n  if (this._unref)\n    this.unref();\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitListeningNT\x2C\n                             this);\n}\n\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\n\nfunction emitErrorNT(self\x2C err) {\n  self.emit('error'\x2C err);\n}\n\n\nfunction emitListeningNT(self) {\n  // Ensure handle hasn't closed\n  if (self._handle)\n    self.emit('listening');\n}\n\n\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\n                         backlog\x2C fd\x2C exclusive\x2C flags\x2C options) {\n  exclusive = !!exclusive;\n\n  if (cluster === undefined) cluster = require('cluster');\n\n  if (cluster.isPrimary || exclusive) {\n    // Will create a new handle\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n    return;\n  }\n\n  const serverQuery = {\n    address: address\x2C\n    port: port\x2C\n    addressType: addressType\x2C\n    fd: fd\x2C\n    flags\x2C\n    backlog\x2C\n    ...options\x2C\n  };\n  // Get the primary's server handle\x2C and listen on it\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\n\n  function listenOnPrimaryHandle(err\x2C handle) {\n    err = checkBindError(err\x2C port\x2C handle);\n\n    if (err) {\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\n      return server.emit('error'\x2C ex);\n    }\n\n    // Reuse primary's server handle\n    server._handle = handle;\n    // _listen2 sets up the listened handle\x2C it is still named like this\n    // to avoid breaking code that wraps this method\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\n  }\n}\n\n\nServer.prototype.listen = function(...args) {\n  const normalized = normalizeArgs(args);\n  let options = normalized[0];\n  const cb = normalized[1];\n\n  if (this._handle) {\n    throw new ERR_SERVER_ALREADY_LISTEN();\n  }\n\n  if (cb !== null) {\n    this.once('listening'\x2C cb);\n  }\n  const backlogFromArgs =\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\n    toNumber(args.length > 1 && args[1]) ||\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\n\n  options = options._handle || options.handle || options;\n  const flags = getFlags(options.ipv6Only);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\n  if (options instanceof TCP) {\n    this._handle = options;\n    this[async_id_symbol] = this._handle.getAsyncId();\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\n    return this;\n  }\n  addAbortSignalOption(this\x2C options);\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\n  if (typeof options.fd === 'number' && options.fd >= 0) {\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\n    return this;\n  }\n\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\n  // null\x2C bind to an arbitrary unused port\n  if (args.length === 0 || typeof args[0] === 'function' ||\n      (typeof options.port === 'undefined' && 'port' in options) ||\n      options.port === null) {\n    options.port = 0;\n  }\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\n  // or (options[\x2C cb]) where options.port is specified\n  // or if options.port is normalized as 0 before\n  let backlog;\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\n    validatePort(options.port\x2C 'options.port');\n    backlog = options.backlog || backlogFromArgs;\n    // start TCP server listening on host:port\n    if (options.host) {\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\n                      options.exclusive\x2C flags);\n    } else { // Undefined host\x2C listens on unspecified address\n      // Default addressType 4 will be used to search for primary server\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\n                      backlog\x2C undefined\x2C options.exclusive);\n    }\n    return this;\n  }\n\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\n  // where path or options.path is a UNIX domain socket or Windows pipe\n  if (options.path && isPipeName(options.path)) {\n    const pipeName = this._pipeName = options.path;\n    backlog = options.backlog || backlogFromArgs;\n    listenInCluster(this\x2C\n                    pipeName\x2C\n                    -1\x2C\n                    -1\x2C\n                    backlog\x2C\n                    undefined\x2C\n                    options.exclusive\x2C\n                    undefined\x2C\n                    {\n                      readableAll: options.readableAll\x2C\n                      writableAll: options.writableAll\x2C\n                    });\n\n    if (!this._handle) {\n      // Failed and an error shall be emitted in the next tick.\n      // Therefore\x2C we directly return.\n      return this;\n    }\n\n    let mode = 0;\n    if (options.readableAll === true)\n      mode |= PipeConstants.UV_READABLE;\n    if (options.writableAll === true)\n      mode |= PipeConstants.UV_WRITABLE;\n    if (mode !== 0) {\n      const err = this._handle.fchmod(mode);\n      if (err) {\n        this._handle.close();\n        this._handle = null;\n        throw errnoException(err\x2C 'uv_pipe_chmod');\n      }\n    }\n    return this;\n  }\n\n  if (!(('port' in options) || ('path' in options))) {\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\n                                    'must have the property "port" or "path"');\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\n};\n\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\n  if (dns === undefined) dns = require('dns');\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\n    if (err) {\n      self.emit('error'\x2C err);\n    } else {\n      addressType = ip ? addressType : 4;\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\n    }\n  });\n}\n\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return !!this._handle;\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\n});\n\nServer.prototype.address = function() {\n  if (this._handle && this._handle.getsockname) {\n    const out = {};\n    const err = this._handle.getsockname(out);\n    if (err) {\n      throw errnoException(err\x2C 'address');\n    }\n    return out;\n  } else if (this._pipeName) {\n    return this._pipeName;\n  }\n  return null;\n};\n\nfunction onconnection(err\x2C clientHandle) {\n  const handle = this;\n  const self = handle[owner_symbol];\n\n  debug('onconnection');\n\n  if (err) {\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\n    return;\n  }\n\n  if (self.maxConnections && self._connections >= self.maxConnections) {\n    if (clientHandle.getsockname || clientHandle.getpeername) {\n      const data = ObjectCreate(null);\n      if (clientHandle.getsockname) {\n        const localInfo = ObjectCreate(null);\n        clientHandle.getsockname(localInfo);\n        data.localAddress = localInfo.address;\n        data.localPort = localInfo.port;\n      }\n      if (clientHandle.getpeername) {\n        const remoteInfo = ObjectCreate(null);\n        clientHandle.getpeername(remoteInfo);\n        data.remoteAddress = remoteInfo.address;\n        data.remotePort = remoteInfo.port;\n        data.remoteFamily = remoteInfo.family;\n      }\n      self.emit('drop'\x2C data);\n    } else {\n      self.emit('drop');\n    }\n    clientHandle.close();\n    return;\n  }\n\n  const socket = new Socket({\n    handle: clientHandle\x2C\n    allowHalfOpen: self.allowHalfOpen\x2C\n    pauseOnCreate: self.pauseOnConnect\x2C\n    readable: true\x2C\n    writable: true\n  });\n\n  if (self.noDelay && clientHandle.setNoDelay) {\n    socket[kSetNoDelay] = true;\n    clientHandle.setNoDelay(true);\n  }\n  if (self.keepAlive && clientHandle.setKeepAlive) {\n    socket[kSetKeepAlive] = true;\n    socket[kSetKeepAliveInitialDelay] = self.keepAliveInitialDelay;\n    clientHandle.setKeepAlive(true\x2C self.keepAliveInitialDelay);\n  }\n\n  self._connections++;\n  socket.server = self;\n  socket._server = self;\n\n  DTRACE_NET_SERVER_CONNECTION(socket);\n  self.emit('connection'\x2C socket);\n}\n\n/**\n * Gets the number of concurrent connections on the server\n * @param {Function} cb\n * @returns {Server}\n */\n\nServer.prototype.getConnections = function(cb) {\n  const self = this;\n\n  function end(err\x2C connections) {\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\n                               process.nextTick\x2C\n                               cb\x2C\n                               err\x2C\n                               connections);\n  }\n\n  if (!this._usingWorkers) {\n    end(null\x2C this._connections);\n    return this;\n  }\n\n  // Poll workers\n  let left = this._workers.length;\n  let total = this._connections;\n\n  function oncount(err\x2C count) {\n    if (err) {\n      left = -1;\n      return end(err);\n    }\n\n    total += count;\n    if (--left === 0) return end(null\x2C total);\n  }\n\n  for (let n = 0; n < this._workers.length; n++) {\n    this._workers[n].getConnections(oncount);\n  }\n\n  return this;\n};\n\n\nServer.prototype.close = function(cb) {\n  if (typeof cb === 'function') {\n    if (!this._handle) {\n      this.once('close'\x2C function close() {\n        cb(new ERR_SERVER_NOT_RUNNING());\n      });\n    } else {\n      this.once('close'\x2C cb);\n    }\n  }\n\n  if (this._handle) {\n    this._handle.close();\n    this._handle = null;\n  }\n\n  if (this._usingWorkers) {\n    let left = this._workers.length;\n    const onWorkerClose = () => {\n      if (--left !== 0) return;\n\n      this._connections = 0;\n      this._emitCloseIfDrained();\n    };\n\n    // Increment connections to be sure that\x2C even if all sockets will be closed\n    // during polling of workers\x2C `close` event will be emitted only once.\n    this._connections++;\n\n    // Poll workers\n    for (let n = 0; n < this._workers.length; n++)\n      this._workers[n].close(onWorkerClose);\n  } else {\n    this._emitCloseIfDrained();\n  }\n\n  return this;\n};\n\nServer.prototype._emitCloseIfDrained = function() {\n  debug('SERVER _emitCloseIfDrained');\n\n  if (this._handle || this._connections) {\n    debug('SERVER handle? %j   connections? %d'\x2C\n          !!this._handle\x2C this._connections);\n    return;\n  }\n\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             emitCloseNT\x2C\n                             this);\n};\n\n\nfunction emitCloseNT(self) {\n  debug('SERVER: emit close');\n  self.emit('close');\n}\n\n\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\n  err\x2C event\x2C sock) {\n\n  switch (event) {\n    case 'connection':\n      sock.destroy(err);\n      break;\n    default:\n      this.emit('error'\x2C err);\n  }\n};\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\n  __proto__: null\x2C\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  __proto__: null\x2C\n  get() { return this[kHandle]; }\x2C\n  set(v) { return this[kHandle] = v; }\n});\n\nServer.prototype._setupWorker = function(socketList) {\n  this._usingWorkers = true;\n  this._workers.push(socketList);\n  socketList.once('exit'\x2C (socketList) => {\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\n    this._workers.splice(index\x2C 1);\n  });\n};\n\nServer.prototype.ref = function() {\n  this._unref = false;\n\n  if (this._handle)\n    this._handle.ref();\n\n  return this;\n};\n\nServer.prototype.unref = function() {\n  this._unref = true;\n\n  if (this._handle)\n    this._handle.unref();\n\n  return this;\n};\n\nlet _setSimultaneousAccepts;\nlet warnSimultaneousAccepts = true;\n\nif (isWindows) {\n  let simultaneousAccepts;\n\n  _setSimultaneousAccepts = function(handle) {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n    if (handle === undefined) {\n      return;\n    }\n\n    if (simultaneousAccepts === undefined) {\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\n                             process.env.NODE_MANY_ACCEPTS !== '0');\n    }\n\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\n      handle._simultaneousAccepts = simultaneousAccepts;\n    }\n  };\n} else {\n  _setSimultaneousAccepts = function() {\n    if (warnSimultaneousAccepts) {\n      process.emitWarning(\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\n        'DeprecationWarning'\x2C 'DEP0121');\n      warnSimultaneousAccepts = false;\n    }\n  };\n}\n\nmodule.exports = {\n  _createServerHandle: createServerHandle\x2C\n  _normalizeArgs: normalizeArgs\x2C\n  _setSimultaneousAccepts\x2C\n  get BlockList() {\n    BlockList ??= require('internal/blocklist').BlockList;\n    return BlockList;\n  }\x2C\n  get SocketAddress() {\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\n    return SocketAddress;\n  }\x2C\n  connect\x2C\n  createConnection: connect\x2C\n  createServer\x2C\n  isIP: isIP\x2C\n  isIPv4: isIPv4\x2C\n  isIPv6: isIPv6\x2C\n  Server\x2C\n  Socket\x2C\n  Stream: Socket\x2C // Legacy naming\n};\n
code-source-info,0xb469fbf4260,406,0,51974,C0O0C4O51974,,
tick,0x7ff805ede983,120843,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbf0dab,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805ea4dea,120863,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbf0dab,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x103b69f6c,120879,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbf0dab,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805f105d0,120895,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbf0dab,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805e4dde4,120910,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbf0dab,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Function,10,120926,0xb469fbf72b0,2694, node:net:1:1,0xb469fbf41d8,~
code-source-info,0xb469fbf72b0,406,0,51974,C0O0C435O1159C441O1175C447O1200C453O1211C459O1221C465O1236C471O1254C477O1278C482O1302C487O1312C493O1365C499O1365C503O1365C505O1399C511O1399C515O1399C517O1430C523O1430C528O1463C542O1464C548O1430C550O1588C556O1588C561O1518C567O1526C572O1536C577O1546C583O1570C589O1628C595O1628C599O1628C601O1712C604O1712C609O1666C615O1683C621O1696C627O1755C633O1755C638O1744C644O1802C647O1802C652O1782C658O1852C661O1852C666O1835C672O1947C675O1947C680O1894C686O1901C692O1930C698O2042C701O2042C706O1986C712O1994C718O2024C724O2173C730O2173C735O2082C741O2096C752O2137C758O2154C764O2371C770O2371C775O2216C781O2233C787O2249C793O2265C798O2285C804O2296C809O2312C814O2332C820O2343C826O2356C832O2801C838O2801C843O2801C848O2435C854O2467C860O2493C866O2520C872O2545C878O2573C884O2602C890O2633C896O2661C902O2684C908O2709C914O2727C920O2752C926O2772C932O2854C938O2854C943O2837C949O3009C955O3009C960O2896C966O2919C972O2939C978O2956C984O2974C990O2990C996O3069C999O3069C1003O3069C1005O3167C1011O3167C1016O3109C1022O3141C1028O3247C1029O3247C1031O3260C1032O3260C1034O3269C1035O3269C1037O3284C1038O3284C1040O3325C1046O3325C1051O3308C1057O3365C1063O3365C1068O3352C1074O3420C1076O3420C1078O3457C1080O3457C1082O3482C1085O3490C1092O3499C1095O3482C1097O3526C1101O3526C1103O3573C1106O3573C1110O3573C1112O3664C1118O3664C1123O3622C1129O3637C1135O3650C1141O7140C1144O7140C1148O7140C1150O7184C1153O7184C1157O7184C1159O7229C1162O7229C1166O7229C1168O7274C1171O7274C1175O7274C1177O7333C1180O7333C1184O7333C1186O11870C1189O11898C1197O11916C1202O11923C1207O11870C1212O11935C1218O11971C1223O11935C1228O12011C1231O12018C1240O12040C1244O12266C1247O12273C1256O12290C1260O13802C1263O13809C1270O13830C1274O13852C1277O13859C1286O13880C1290O14390C1293O14397C1302O14418C1306O14801C1309O14808C1318O14831C1322O15443C1325O15450C1334O15468C1338O15518C1344O15546C1358O15600C1366O15518C1371O15650C1377O15678C1391O15723C1399O15650C1404O15808C1410O15836C1424O15889C1432O15808C1437O16211C1443O16239C1457O16292C1465O16211C1470O16378C1476O16406C1481O16417C1487O16459C1498O16378C1503O16824C1506O16831C1515O16847C1519O17082C1522O17089C1531O17103C1535O17295C1538O17302C1547O17328C1555O17683C1558O17690C1567O17706C1575O18046C1578O18053C1587O18070C1595O18260C1598O18267C1607O18282C1615O18619C1618O18626C1627O18648C1635O18801C1638O18808C1647O18827C1655O20079C1658O20086C1667O20103C1675O20207C1678O20214C1687O20237C1695O20722C1703O20722C1713O20842C1721O20842C1731O20941C1739O20941C1749O21037C1757O21037C1767O21128C1770O21135C1779O21158C1787O21440C1795O21440C1805O21538C1813O21538C1823O21627C1826O21634C1831O21644C1835O21662C1843O21714C1846O21721C1855O21745C1863O22512C1866O22519C1875O22537C1883O22611C1886O22618C1895O22635C1903O22879C1911O22879C1921O23019C1929O23019C1939O26687C1942O26694C1951O26712C1959O31113C1962O31120C1971O31134C1979O31327C1982O31334C1991O31350C1999O34836C2002O34864C2014O34888C2023O34836C2033O34900C2039O34900C2049O38886C2052O38893C2063O38912C2071O40397C2074O40404C2087O40421C2095O44666C2101O44694C2122O44746C2134O44666C2144O44837C2147O44844C2160O44862C2168O46958C2171O46965C2184O46990C2192O47749C2195O47756C2208O47772C2216O48644C2219O48651C2232O48681C2240O49159C2243O49166C2255O49189C2268O49213C2276O49531C2282O49556C2303O49599C2315O49639C2327O49531C2337O49686C2343O49714C2360O49759C2372O49794C2384O49686C2394O49836C2397O49843C2410O49866C2418O50112C2421O50119C2434O50133C2442O50236C2445O50243C2458O50259C2466O50367C2468O50422C2469O50422C2471O50429C2482O50452C2483O50452C2485O50476C2494O51184C2499O51456C2509O51498C2519O51536C2529O51553C2539O51812C2549O51841C2559O51852C2569O51874C2579O51890C2589O51908C2599O51918C2609O51928C2619O51946C2684O51471C2693O51973,,
code-creation,Eval,10,121447,0xb469fbfd030,5, node:internal/net:1:1,0xb469fbfce68,~
script-source,407,node:internal/net,'use strict';\n\nconst {\n  RegExp\x2C\n  RegExpPrototypeTest\x2C\n  Symbol\x2C\n} = primordials;\n\nconst Buffer = require('buffer').Buffer;\nconst { writeBuffer } = internalBinding('fs');\nconst errors = require('internal/errors');\n\n// IPv4 Segment\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\n\n// IPv6 Segment\nconst v6Seg = '(?:[0-9a-fA-F]{1\x2C4})';\nconst IPv6Reg = new RegExp('^(' +\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1\x2C2}|:)|` +\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0\x2C1}:${v4Str}|(:${v6Seg}){1\x2C3}|:)|` +\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0\x2C2}:${v4Str}|(:${v6Seg}){1\x2C4}|:)|` +\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0\x2C3}:${v4Str}|(:${v6Seg}){1\x2C5}|:)|` +\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0\x2C4}:${v4Str}|(:${v6Seg}){1\x2C6}|:)|` +\n  `(?::((?::${v6Seg}){0\x2C5}:${v4Str}|(?::${v6Seg}){1\x2C7}|:))` +\n')(%[0-9a-zA-Z-.:]{1\x2C})?$');\n\nfunction isIPv4(s) {\n  return RegExpPrototypeTest(IPv4Reg\x2C s);\n}\n\nfunction isIPv6(s) {\n  return RegExpPrototypeTest(IPv6Reg\x2C s);\n}\n\nfunction isIP(s) {\n  if (isIPv4(s)) return 4;\n  if (isIPv6(s)) return 6;\n  return 0;\n}\n\nfunction makeSyncWrite(fd) {\n  return function(chunk\x2C enc\x2C cb) {\n    if (enc !== 'buffer')\n      chunk = Buffer.from(chunk\x2C enc);\n\n    this._handle.bytesWritten += chunk.length;\n\n    const ctx = {};\n    writeBuffer(fd\x2C chunk\x2C 0\x2C chunk.length\x2C null\x2C undefined\x2C ctx);\n    if (ctx.errno !== undefined) {\n      const ex = errors.uvException(ctx);\n      ex.errno = ctx.errno;\n      return cb(ex);\n    }\n    cb();\n  };\n}\n\nmodule.exports = {\n  isIP\x2C\n  isIPv4\x2C\n  isIPv6\x2C\n  makeSyncWrite\x2C\n  normalizedArgsSymbol: Symbol('normalizedArgs')\n};\n
code-source-info,0xb469fbfd030,407,0,1749,C0O0C4O1749,,
code-creation,Function,10,121715,0xb469fbfd420,617, node:internal/net:1:1,0xb469fbfcfa8,~
code-source-info,0xb469fbfd420,407,0,1749,C0O0C45O25C50O35C56O58C61O99C64O99C69O116C73O99C75O149C78O149C83O133C89O187C92O187C96O187C98O246C101O316C106O320C119O335C124O360C129O375C142O360C147O360C149O417C152O457C160O483C173O499C183O473C192O521C205O537C218O547C228O511C237O569C250O586C263O597C273O559C282O625C295O643C308O658C321O669C331O615C340O697C353O715C366O730C379O741C389O687C398O769C411O787C424O802C437O813C447O759C456O841C469O859C482O874C495O885C505O831C514O919C527O934C540O947C550O903C556O965C562O457C567O457C569O1633C576O1654C582O1662C588O1672C594O1682C601O1721C611O1648C616O1748,,
tick,0x1025895fa,121782,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbf74dc,0xb46f7def627,0x1132442e1,0xb469fbf0dab,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,122099,0xb46464fff88,5, node:internal/dtrace:1:1,0xb46464ffe40,~
script-source,408,node:internal/dtrace,'use strict';\n\nconst config = internalBinding('config');\n\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\n  DTRACE_NET_STREAM_END = () => {}\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\n\nmodule.exports = {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\n  DTRACE_NET_SERVER_CONNECTION\x2C\n  DTRACE_NET_STREAM_END\n};\n
code-source-info,0xb46464fff88,408,0,568,C0O0C4O568,,
code-creation,Function,10,122187,0xb46f0ebfc68,140, node:internal/dtrace:1:1,0xb46464fff00,~
code-source-info,0xb46f0ebfc68,408,0,568,C0O30C3O30C8O322C17O334C25O68C36O109C47O151C58O192C69O234C80O277C91O368C98O389C104O419C110O450C116O480C122O511C128O543C134O383C139O567,,
code-creation,LazyCompile,10,122441,0xb46bbe49cb0,34,protoGetter node:net:796:21,0xb469fbf46a0,~
code-source-info,0xb46bbe49cb0,406,20559,20720,C0O20580C8O20608C13O20619C20O20704C27O20580C33O20719,,
code-creation,LazyCompile,10,122522,0xb46bbe4e060,37,get BlockList node:net:1920:16,0xb469fbf66e8,~
code-source-info,0xb46bbe4e060,406,51593,51682,C0O51602C14O51616C19O51645C26O51612C32O51661C36O51678,,
code-creation,Eval,10,122651,0xb46bbe4e558,5, node:internal/blocklist:1:1,0xb46bbe4e370,~
script-source,409,node:internal/blocklist,'use strict';\n\nconst {\n  Boolean\x2C\n  ObjectSetPrototypeOf\x2C\n  Symbol\n} = primordials;\n\nconst {\n  BlockList: BlockListHandle\x2C\n} = internalBinding('block_list');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst {\n  SocketAddress\x2C\n  kHandle: kSocketAddressHandle\x2C\n} = require('internal/socketaddress');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst kHandle = Symbol('kHandle');\nconst { owner_symbol } = internalBinding('symbols');\n\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n} = require('internal/errors').codes;\n\nconst { validateInt32\x2C validateString } = require('internal/validators');\n\nclass BlockList extends JSTransferable {\n  constructor() {\n    super();\n    this[kHandle] = new BlockListHandle();\n    this[kHandle][owner_symbol] = this;\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `BlockList ${inspect({\n      rules: this.rules\n    }\x2C opts)}`;\n  }\n\n  addAddress(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      address = new SocketAddress({\n        address\x2C\n        family\x2C\n      });\n    }\n    this[kHandle].addAddress(address[kSocketAddressHandle]);\n  }\n\n  addRange(start\x2C end\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(start)) {\n      validateString(start\x2C 'start');\n      validateString(family\x2C 'family');\n      start = new SocketAddress({\n        address: start\x2C\n        family\x2C\n      });\n    }\n    if (!SocketAddress.isSocketAddress(end)) {\n      validateString(end\x2C 'end');\n      validateString(family\x2C 'family');\n      end = new SocketAddress({\n        address: end\x2C\n        family\x2C\n      });\n    }\n    const ret = this[kHandle].addRange(\n      start[kSocketAddressHandle]\x2C\n      end[kSocketAddressHandle]);\n    if (ret === false)\n      throw new ERR_INVALID_ARG_VALUE('start'\x2C start\x2C 'must come before end');\n  }\n\n  addSubnet(network\x2C prefix\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(network)) {\n      validateString(network\x2C 'network');\n      validateString(family\x2C 'family');\n      network = new SocketAddress({\n        address: network\x2C\n        family\x2C\n      });\n    }\n    switch (network.family) {\n      case 'ipv4':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 32);\n        break;\n      case 'ipv6':\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 128);\n        break;\n    }\n    this[kHandle].addSubnet(network[kSocketAddressHandle]\x2C prefix);\n  }\n\n  check(address\x2C family = 'ipv4') {\n    if (!SocketAddress.isSocketAddress(address)) {\n      validateString(address\x2C 'address');\n      validateString(family\x2C 'family');\n      try {\n        address = new SocketAddress({\n          address\x2C\n          family\x2C\n        });\n      } catch {\n        // Ignore the error. If it's not a valid address\x2C return false.\n        return false;\n      }\n    }\n    return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\n  }\n\n  get rules() {\n    return this[kHandle].getRules();\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/blocklist:InternalBlockList'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kHandle][owner_symbol] = this;\n  }\n}\n\nclass InternalBlockList extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n    if (handle !== undefined)\n      handle[owner_symbol] = this;\n  }\n}\n\nInternalBlockList.prototype.constructor = BlockList.prototype.constructor;\nObjectSetPrototypeOf(InternalBlockList.prototype\x2C BlockList.prototype);\n\nmodule.exports = {\n  BlockList\x2C\n  InternalBlockList\x2C\n};\n
code-source-info,0xb46bbe4e558,409,0,3877,C0O0C4O3877,,
code-creation,Function,10,123149,0xb46bbe4ef60,359, node:internal/blocklist:1:1,0xb46bbe4e4d0,~
code-source-info,0xb46bbe4ef60,409,0,3877,C0O0C35O25C41O36C46O60C51O127C54O127C59O106C65O204C68O204C73O190C78O293C81O293C86O241C92O267C98O385C101O385C106O339C111O357C116O367C121O450C124O450C129O438C135O501C138O501C142O501C144O545C147O545C152O528C158O611C161O611C166O637C171O584C177O688C180O688C185O654C191O669C197O745C204O884C241O3223C251O3384C278O3519C301O3691C306O3725C311O3735C315O3713C319O3787C324O3808C329O3748C334O3821C341O3842C347O3855C353O3836C358O3876,,
tick,0x7ff805e4dde4,123204,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb46bbe4e06e,0xb469fbf0de4,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,123359,0xb46bbe50850,5, node:internal/socketaddress:1:1,0xb46bbe50658,~
script-source,410,node:internal/socketaddress,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  SocketAddress: _SocketAddress\x2C\n  AF_INET\x2C\n  AF_INET6\x2C\n} = internalBinding('block_list');\n\nconst {\n  validateObject\x2C\n  validateString\x2C\n  validatePort\x2C\n  validateUint32\x2C\n} = require('internal/validators');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_VALUE\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  customInspectSymbol: kInspect\x2C\n} = require('internal/util');\n\nconst { inspect } = require('internal/util/inspect');\n\nconst {\n  JSTransferable\x2C\n  kClone\x2C\n  kDeserialize\x2C\n} = require('internal/worker/js_transferable');\n\nconst kHandle = Symbol('kHandle');\nconst kDetail = Symbol('kDetail');\n\nclass SocketAddress extends JSTransferable {\n  static isSocketAddress(value) {\n    return value?.[kHandle] !== undefined;\n  }\n\n  constructor(options = {}) {\n    super();\n    validateObject(options\x2C 'options');\n    let { family = 'ipv4' } = options;\n    const {\n      address = (family === 'ipv4' ? '127.0.0.1' : '::')\x2C\n      port = 0\x2C\n      flowlabel = 0\x2C\n    } = options;\n\n    let type;\n    if (typeof family?.toLowerCase === 'function')\n      family = family.toLowerCase();\n    switch (family) {\n      case 'ipv4':\n        type = AF_INET;\n        break;\n      case 'ipv6':\n        type = AF_INET6;\n        break;\n      default:\n        throw new ERR_INVALID_ARG_VALUE('options.family'\x2C options.family);\n    }\n\n    validateString(address\x2C 'options.address');\n    validatePort(port\x2C 'options.port');\n    validateUint32(flowlabel\x2C 'options.flowlabel'\x2C false);\n\n    this[kHandle] = new _SocketAddress(address\x2C port\x2C type\x2C flowlabel);\n    this[kDetail] = this[kHandle].detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  get address() {\n    return this[kDetail].address;\n  }\n\n  get port() {\n    return this[kDetail].port;\n  }\n\n  get family() {\n    return this[kDetail].family === AF_INET ? 'ipv4' : 'ipv6';\n  }\n\n  get flowlabel() {\n    // The flow label can be changed internally.\n    return this[kHandle].flowlabel();\n  }\n\n  [kInspect](depth\x2C options) {\n    if (depth < 0)\n      return this;\n\n    const opts = {\n      ...options\x2C\n      depth: options.depth == null ? null : options.depth - 1\n    };\n\n    return `SocketAddress ${inspect(this.toJSON()\x2C opts)}`;\n  }\n\n  [kClone]() {\n    const handle = this[kHandle];\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/socketaddress:InternalSocketAddress'\x2C\n    };\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kDetail] = handle.detail({\n      address: undefined\x2C\n      port: undefined\x2C\n      family: undefined\x2C\n      flowlabel: undefined\x2C\n    });\n  }\n\n  toJSON() {\n    return {\n      address: this.address\x2C\n      port: this.port\x2C\n      family: this.family\x2C\n      flowlabel: this.flowlabel\x2C\n    };\n  }\n}\n\nclass InternalSocketAddress extends JSTransferable {\n  constructor(handle) {\n    super();\n    this[kHandle] = handle;\n  }\n}\n\nInternalSocketAddress.prototype.constructor =\n  SocketAddress.prototype.constructor;\nObjectSetPrototypeOf(InternalSocketAddress.prototype\x2C SocketAddress.prototype);\n\nmodule.exports = {\n  SocketAddress\x2C\n  InternalSocketAddress\x2C\n  kHandle\x2C\n};\n
code-source-info,0xb46bbe50850,410,0,3207,C0O0C4O3207,,
code-creation,Function,10,123736,0xb46bbe51378,366, node:internal/socketaddress:1:1,0xb46bbe507c8,~
code-source-info,0xb46bbe51378,410,0,3207,C0O0C38O25C43O49C48O143C51O143C56O100C62O118C68O129C74O257C77O257C82O185C88O203C94O221C100O237C106O345C109O345C114O345C119O313C125O419C128O419C133O405C138O466C141O466C146O454C152O557C155O557C160O511C165O529C170O539C175O618C178O618C182O618C184O653C187O653C191O653C193O701C226O2071C236O2313C246O2482C279O2877C302O2988C307O3028C312O3038C316O3010C320O3094C325O3119C330O3051C335O3132C342O3153C348O3170C354O3195C360O3147C365O3206,,
code-creation,LazyCompile,10,123875,0xb46bbe51f40,72,BlockList node:internal/blocklist:40:14,0xb46bbe4e588,~
code-source-info,0xb46bbe51f40,409,775,879,C3O784C11O784C23O797C28O802C33O817C36O813C41O811C45O840C50O845C52O844C58O854C64O868C71O878,,
code-creation,LazyCompile,10,123934,0xb46bbe526e0,115,addAddress node:internal/blocklist:60:13,0xb46bbe4e628,~
code-source-info,0xb46bbe526e0,409,1149,1460,C14O1182C19O1201C24O1201C31O1235C39O1235C44O1277C52O1277C57O1317C69O1355C75O1372C81O1327C87O1400C89O1405C91O1404C95O1414C102O1433C104O1432C108O1414C114O1459,,
code-creation,LazyCompile,10,123977,0xb46bbe52860,20,isSocketAddress node:internal/socketaddress:43:25,0xb46bbe508d0,~
code-source-info,0xb46bbe52860,410,742,798,C0O756C9O771C11O770C18O780C19O794,,
code-creation,LazyCompile,10,124050,0xb46bbe52ff0,323,SocketAddress node:internal/socketaddress:47:14,0xb46bbe50880,~
code-source-info,0xb46bbe52ff0,410,813,1761,C7O813C13O834C21O834C33O847C41O847C46O893C58O940C69O958C81O998C89O1014C97O1055C99O1065C106O1082C117O1134C122O1134C127O1153C146O1198C151O1222C153O1256C158O1281C160O1311C168O1369C175O1317C180O1311C181O1389C189O1389C194O1437C202O1437C207O1477C220O1477C225O1537C230O1542C235O1557C252O1553C257O1551C261O1609C266O1614C274O1630C276O1629C280O1639C291O1663C296O1686C301O1711C306O1739C310O1639C315O1623C322O1760,,
code-creation,LazyCompile,10,124123,0xb46bbe53318,112, node:internal/validators:164:3,0xb466517a7a0,~
code-source-info,0xb46bbe53318,22,4714,5262,C0O4765C11O4765C17O4851C28O4851C34O4935C45O4935C51O4997C59O5044C63O5058C66O5058C80O5133C88O5198C104O5204C109O5198C111O5261,,
tick,0x7ff805dd2b69,124221,0,0x0,3,0x102d5e910,0xb46bbe53019,0xb46bbe52731,0xb469fbf0dfe,0xb46f7def627,0x1132442e1,0xb469fbefa04,0xb46f7def627,0x1132442e1,0xb469fbec079,0xb46f7def627,0x1132442e1,0xb469fbe2307,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,LazyCompile,10,124240,0xb46bbe534a0,27,getOwnPropertyValueOrDefault node:internal/validators:148:38,0xb466517a750,~
code-source-info,0xb46bbe534a0,22,4358,4502,C0O4391C7O4418C10O4418C23O4494C26O4500,,
code-creation,LazyCompile,10,124305,0xb46bbe535e8,129,validatePort node:internal/validators:220:22,0xb466517a930,~
code-source-info,0xb46bbe535e8,22,6733,7091,C24O6777C44O6874C47O6874C52O6899C58O6907C65O6923C70O6934C72O6940C75O6929C86O6961C92O6985C99O6995C101O7013C117O7019C122O7013C123O7073C125O7085C128O7089,,
code-creation,LazyCompile,10,124367,0xb46bbe53820,132, node:internal/validators:99:40,0xb466517a570,~
code-source-info,0xb46bbe53820,22,2777,3201,C0O2808C6O2845C22O2851C27O2845C28O2906C33O2911C39O2941C55O2947C60O2941C61O3014C71O3074C74O3091C76O3101C83O3116C88O3129C98O3168C111O3181C124O3135C129O3129C131O3200,,
code-creation,LazyCompile,10,124469,0xb46bbe53af8,229,addRange node:internal/blocklist:72:11,0xb46bbe4e678,~
code-source-info,0xb46bbe53af8,409,1472,2142,C17O1508C22O1527C27O1527C34O1559C42O1559C47O1597C55O1597C60O1637C72O1682C78O1697C84O1645C90O1725C95O1744C100O1744C107O1774C115O1774C120O1808C128O1808C133O1848C145O1891C151O1904C157O1854C163O1944C165O1949C167O1948C171O1958C178O1980C180O1979C186O2013C188O2012C192O1958C199O2041C200O2049C205O2066C221O2072C226O2066C228O2141,,
code-creation,Eval,10,124602,0xb46bbe540d0,5, node:internal/modules/esm/formats:1:1,0xb46bbe53f58,~
script-source,411,node:internal/modules/esm/formats,'use strict';\n\nconst {\n  RegExpPrototypeExec\x2C\n} = primordials;\nconst { getOptionValue } = require('internal/options');\n\n\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\n\nconst extensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'module'\x2C\n  '.json': 'json'\x2C\n  '.mjs': 'module'\x2C\n};\n\nconst legacyExtensionFormatMap = {\n  '__proto__': null\x2C\n  '.cjs': 'commonjs'\x2C\n  '.js': 'commonjs'\x2C\n  '.json': 'commonjs'\x2C\n  '.mjs': 'module'\x2C\n  '.node': 'commonjs'\x2C\n};\n\nif (experimentalWasmModules) {\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\n}\n\n/**\n * @param {string} mime\n * @returns {string | null}\n */\nfunction mimeToFormat(mime) {\n  if (\n    RegExpPrototypeExec(\n      /\\s*(text|application)\\/javascript\\s*(;\\s*charset=utf-?8\\s*)?/i\x2C\n      mime\n    ) !== null\n  ) return 'module';\n  if (mime === 'application/json') return 'json';\n  if (experimentalWasmModules && mime === 'application/wasm') return 'wasm';\n  return null;\n}\n\nfunction getLegacyExtensionFormat(ext) {\n  return legacyExtensionFormatMap[ext];\n}\n\nmodule.exports = {\n  extensionFormatMap\x2C\n  getLegacyExtensionFormat\x2C\n  legacyExtensionFormatMap\x2C\n  mimeToFormat\x2C\n};\n
code-source-info,0xb46bbe540d0,411,0,1199,C0O0C4O1199,,
code-creation,Function,10,124768,0xb46bbe54388,120, node:internal/modules/esm/formats:1:1,0xb46bbe54048,~
code-source-info,0xb46bbe54388,411,0,1199,C0O0C24O25C30O90C33O90C38O71C43O153C46O153C50O153C52O228C57O368C61O368C63O504C67O537C73O601C79O565C83O1083C90O1104C96O1126C102O1154C108O1182C114O1098C119O1198,,
code-creation,Eval,10,124891,0xb46bbe54d28,5, node:internal/modules/esm/initialize_import_meta:1:1,0xb46bbe54b90,~
script-source,412,node:internal/modules/esm/initialize_import_meta,'use strict';\n\nconst { getOptionValue } = require('internal/options');\nconst experimentalImportMetaResolve =\n  getOptionValue('--experimental-import-meta-resolve');\nconst {\n  PromisePrototypeThen\x2C\n  PromiseReject\x2C\n} = primordials;\nconst asyncESM = require('internal/process/esm_loader');\n\nfunction createImportMetaResolve(defaultParentUrl) {\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\n    return PromisePrototypeThen(\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\n      ({ url }) => url\x2C\n      (error) => (\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\n          error.url : PromiseReject(error))\n    );\n  };\n}\n\n/**\n * @param {object} meta\n * @param {{url: string}} context\n */\nfunction initializeImportMeta(meta\x2C context) {\n  const { url } = context;\n\n  // Alphabetical\n  if (experimentalImportMetaResolve) {\n    meta.resolve = createImportMetaResolve(url);\n  }\n\n  meta.url = url;\n}\n\nmodule.exports = {\n  initializeImportMeta\n};\n
code-source-info,0xb46bbe54d28,412,0,980,C0O0C4O980,,
code-creation,Function,10,125022,0xb46bbe54ef0,90, node:internal/modules/esm/initialize_import_meta:1:1,0xb46bbe54ca0,~
code-source-info,0xb46bbe54ef0,412,0,980,C0O0C28O42C31O42C36O23C41O111C44O111C48O111C50O175C56O199C62O248C65O248C69O248C71O935C78O956C84O950C89O979,,
code-creation,Eval,10,125152,0xb46bbe55568,5, node:internal/modules/esm/load:1:1,0xb46bbe55330,~
script-source,413,node:internal/modules/esm/load,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  RegExpPrototypeExec\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\nconst { validateAssertions } = require('internal/modules/esm/assert');\nconst { getOptionValue } = require('internal/options');\nconst { fetchModule } = require('internal/modules/esm/fetch_module');\n\n// Do not eagerly grab .manifest\x2C it may be in TDZ\nconst policy = getOptionValue('--experimental-policy') ?\n  require('internal/process/policy') :\n  null;\nconst experimentalNetworkImports =\n  getOptionValue('--experimental-network-imports');\n\nconst { Buffer: { from: BufferFrom } } = require('buffer');\n\nconst { readFile: readFileAsync } = require('internal/fs/promises').exports;\nconst { URL } = require('internal/url');\nconst {\n  ERR_INVALID_URL\x2C\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\n} = require('internal/errors').codes;\n\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\n\nasync function getSource(url\x2C context) {\n  const parsed = new URL(url);\n  let responseURL = url;\n  let source;\n  if (parsed.protocol === 'file:') {\n    source = await readFileAsync(parsed);\n  } else if (parsed.protocol === 'data:') {\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\n    if (!match) {\n      throw new ERR_INVALID_URL(url);\n    }\n    const { 1: base64\x2C 2: body } = match;\n    source = BufferFrom(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\n  } else if (experimentalNetworkImports && (\n    parsed.protocol === 'https:' ||\n    parsed.protocol === 'http:'\n  )) {\n    const res = await fetchModule(parsed\x2C context);\n    source = await res.body;\n    responseURL = res.resolvedHREF;\n  } else {\n    const supportedSchemes = ['file'\x2C 'data'];\n    if (experimentalNetworkImports) {\n      ArrayPrototypePush(supportedSchemes\x2C 'http'\x2C 'https');\n    }\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed\x2C supportedSchemes);\n  }\n  if (policy?.manifest) {\n    policy.manifest.assertIntegrity(parsed\x2C source);\n  }\n  return { responseURL\x2C source };\n}\n\n\n/**\n * Node.js default load hook.\n * @param {string} url\n * @param {object} context\n * @returns {object}\n */\nasync function defaultLoad(url\x2C context) {\n  let responseURL = url;\n  const { importAssertions } = context;\n  let {\n    format\x2C\n    source\x2C\n  } = context;\n\n  if (format == null) {\n    format = await defaultGetFormat(url\x2C context);\n  }\n\n  validateAssertions(url\x2C format\x2C importAssertions);\n\n  if (\n    format === 'builtin' ||\n    format === 'commonjs'\n  ) {\n    source = null;\n  } else if (source == null) {\n    ({ responseURL\x2C source } = await getSource(url\x2C context));\n  }\n\n  return {\n    format\x2C\n    responseURL\x2C\n    source\x2C\n  };\n}\n\nmodule.exports = {\n  defaultLoad\x2C\n};\n
code-source-info,0xb46bbe55568,413,0,2745,C0O0C4O2745,,
code-creation,Function,10,125539,0xb46bbe557a8,263, node:internal/modules/esm/load:1:1,0xb46bbe554e0,~
code-source-info,0xb46bbe557a8,413,0,2745,C0O0C58O25C64O47C70O70C76O137C79O137C84O116C90O212C93O212C98O189C104O279C107O279C112O260C117O332C120O332C125O316C131O445C134O445C143O489C150O445C152O571C155O571C159O571C161O663C164O663C169O663C174O646C180O719C183O719C188O750C193O701C199O776C202O776C207O768C213O866C216O866C221O892C226O811C232O830C238O926C242O926C244O2708C251O2729C257O2723C262O2744,,
tick,0x7ff805ede983,125591,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,126073,0xb46bbe57c50,5, node:internal/fs/promises:1:1,0xb46bbe56740,~
script-source,414,node:internal/fs/promises,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  Error\x2C\n  MathMax\x2C\n  MathMin\x2C\n  NumberIsSafeInteger\x2C\n  Promise\x2C\n  PromisePrototypeThen\x2C\n  PromiseResolve\x2C\n  PromiseReject\x2C\n  SafeArrayIterator\x2C\n  SafePromisePrototypeFinally\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  F_OK\x2C\n  O_SYMLINK\x2C\n  O_WRONLY\x2C\n  S_IFMT\x2C\n  S_IFREG\n} = constants;\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\n\nconst {\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_STATE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n  }\x2C\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n} = require('internal/errors');\nconst { isArrayBufferView } = require('internal/util/types');\nconst { rimrafPromises } = require('internal/fs/rimraf');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  copyObject\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getStatsFromBinding\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validateRmOptions\x2C\n  validateRmdirOptions\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\x2C\n} = require('internal/fs/utils');\nconst { opendir } = require('internal/fs/dir');\nconst {\n  parseFileMode\x2C\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateInteger\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst {\n  kEmptyObject\x2C\n  lazyDOMException\x2C\n  promisify\x2C\n} = require('internal/util');\nconst { EventEmitterMixin } = require('internal/event_target');\nconst { watch } = require('internal/fs/watchers');\nconst { isIterable } = require('internal/streams/utils');\nconst assert = require('internal/assert');\n\nconst kHandle = Symbol('kHandle');\nconst kFd = Symbol('kFd');\nconst kRefs = Symbol('kRefs');\nconst kClosePromise = Symbol('kClosePromise');\nconst kCloseResolve = Symbol('kCloseResolve');\nconst kCloseReject = Symbol('kCloseReject');\nconst kRef = Symbol('kRef');\nconst kUnref = Symbol('kUnref');\nconst kLocked = Symbol('kLocked');\n\nconst { kUsePromises } = binding;\nconst {\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\n} = require('internal/worker/js_transferable');\n\nconst {\n  newReadableStreamFromStreamBase\x2C\n} = require('internal/webstreams/adapters');\n\nconst {\n  readableStreamCancel\x2C\n} = require('internal/webstreams/readablestream');\n\nconst getDirectoryEntriesPromise = promisify(getDirents);\nconst validateRmOptionsPromise = promisify(validateRmOptions);\n\nlet cpPromises;\nfunction lazyLoadCpPromises() {\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\n}\n\n// Lazy loaded to avoid circular dependency.\nlet fsStreams;\nfunction lazyFsStreams() {\n  return fsStreams ??= require('internal/fs/streams');\n}\n\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\n  /**\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\n   */\n  constructor(filehandle) {\n    super();\n    this[kHandle] = filehandle;\n    this[kFd] = filehandle ? filehandle.fd : -1;\n\n    this[kRefs] = 1;\n    this[kClosePromise] = null;\n  }\n\n  getAsyncId() {\n    return this[kHandle].getAsyncId();\n  }\n\n  get fd() {\n    return this[kFd];\n  }\n\n  appendFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  chmod(mode) {\n    return fsCall(fchmod\x2C this\x2C mode);\n  }\n\n  chown(uid\x2C gid) {\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\n  }\n\n  datasync() {\n    return fsCall(fdatasync\x2C this);\n  }\n\n  sync() {\n    return fsCall(fsync\x2C this);\n  }\n\n  read(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  readv(buffers\x2C position) {\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\n  }\n\n  readFile(options) {\n    return fsCall(readFile\x2C this\x2C options);\n  }\n\n  stat(options) {\n    return fsCall(fstat\x2C this\x2C options);\n  }\n\n  truncate(len = 0) {\n    return fsCall(ftruncate\x2C this\x2C len);\n  }\n\n  utimes(atime\x2C mtime) {\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\n  }\n\n  write(buffer\x2C offset\x2C length\x2C position) {\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\n  }\n\n  writev(buffers\x2C position) {\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\n  }\n\n  writeFile(data\x2C options) {\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\n  }\n\n  close = () => {\n    if (this[kFd] === -1) {\n      return PromiseResolve();\n    }\n\n    if (this[kClosePromise]) {\n      return this[kClosePromise];\n    }\n\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        this[kHandle].close()\x2C\n        () => { this[kClosePromise] = undefined; }\n      );\n    } else {\n      this[kClosePromise] = SafePromisePrototypeFinally(\n        new Promise((resolve\x2C reject) => {\n          this[kCloseResolve] = resolve;\n          this[kCloseReject] = reject;\n        })\x2C () => {\n          this[kClosePromise] = undefined;\n          this[kCloseReject] = undefined;\n          this[kCloseResolve] = undefined;\n        }\n      );\n    }\n\n    this.emit('close');\n    return this[kClosePromise];\n  };\n\n  /**\n   * @typedef {import('../webstreams/readablestream').ReadableStream\n   * } ReadableStream\n   * @returns {ReadableStream}\n   */\n  readableWebStream() {\n    if (this[kFd] === -1)\n      throw new ERR_INVALID_STATE('The FileHandle is closed');\n    if (this[kClosePromise])\n      throw new ERR_INVALID_STATE('The FileHandle is closing');\n    if (this[kLocked])\n      throw new ERR_INVALID_STATE('The FileHandle is locked');\n    this[kLocked] = true;\n\n    const readable = newReadableStreamFromStreamBase(\n      this[kHandle]\x2C\n      undefined\x2C\n      { ondone: () => this[kUnref]() });\n\n    this[kRef]();\n    this.once('close'\x2C () => {\n      readableStreamCancel(readable);\n    });\n\n    return readable;\n  }\n\n  /**\n   * @typedef {import('./streams').ReadStream\n   * } ReadStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   end?: number;\n   *   highWaterMark?: number;\n   *   }} [options]\n   * @returns {ReadStream}\n   */\n  createReadStream(options = undefined) {\n    const { ReadStream } = lazyFsStreams();\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  /**\n   * @typedef {import('./streams').WriteStream\n   * } WriteStream\n   * @param {{\n   *   encoding?: string;\n   *   autoClose?: boolean;\n   *   emitClose?: boolean;\n   *   start: number;\n   *   }} [options]\n   * @returns {WriteStream}\n   */\n  createWriteStream(options = undefined) {\n    const { WriteStream } = lazyFsStreams();\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\n  }\n\n  [kTransfer]() {\n    if (this[kClosePromise] || this[kRefs] > 1) {\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\n                             'DataCloneError');\n    }\n\n    const handle = this[kHandle];\n    this[kFd] = -1;\n    this[kHandle] = null;\n    this[kRefs] = 0;\n\n    return {\n      data: { handle }\x2C\n      deserializeInfo: 'internal/fs/promises:FileHandle'\n    };\n  }\n\n  [kTransferList]() {\n    return [ this[kHandle] ];\n  }\n\n  [kDeserialize]({ handle }) {\n    this[kHandle] = handle;\n    this[kFd] = handle.fd;\n  }\n\n  [kRef]() {\n    this[kRefs]++;\n  }\n\n  [kUnref]() {\n    this[kRefs]--;\n    if (this[kRefs] === 0) {\n      this[kFd] = -1;\n      PromisePrototypeThen(\n        this[kHandle].close()\x2C\n        this[kCloseResolve]\x2C\n        this[kCloseReject]\n      );\n    }\n  }\n}\n\nasync function handleFdClose(fileOpPromise\x2C closeFunc) {\n  return PromisePrototypeThen(\n    fileOpPromise\x2C\n    (result) => PromisePrototypeThen(closeFunc()\x2C () => result)\x2C\n    (opError) =>\n      PromisePrototypeThen(\n        closeFunc()\x2C\n        () => PromiseReject(opError)\x2C\n        (closeError) => PromiseReject(aggregateTwoErrors(closeError\x2C opError))\n      )\n  );\n}\n\nasync function fsCall(fn\x2C handle\x2C ...args) {\n  assert(handle[kRefs] !== undefined\x2C\n         'handle must be an instance of FileHandle');\n\n  if (handle.fd === -1) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error('file closed');\n    err.code = 'EBADF';\n    err.syscall = fn.name;\n    throw err;\n  }\n\n  try {\n    handle[kRef]();\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\n  } finally {\n    handle[kUnref]();\n  }\n}\n\nfunction checkAborted(signal) {\n  if (signal?.aborted)\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\n}\n\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\n  checkAborted(signal);\n  if (isCustomIterable(data)) {\n    for await (const buf of data) {\n      checkAborted(signal);\n      const toWrite =\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\n      let remaining = toWrite.byteLength;\n      while (remaining > 0) {\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\n        const { bytesWritten } = await write(\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\n        remaining -= bytesWritten;\n        checkAborted(signal);\n      }\n    }\n    return;\n  }\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\n  let remaining = data.byteLength;\n  if (remaining === 0) return;\n  do {\n    checkAborted(signal);\n    const { bytesWritten } =\n      await write(filehandle\x2C data\x2C 0\x2C\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\n    remaining -= bytesWritten;\n    data = new Uint8Array(\n      data.buffer\x2C\n      data.byteOffset + bytesWritten\x2C\n      data.byteLength - bytesWritten\n    );\n  } while (remaining > 0);\n}\n\nasync function readFileHandle(filehandle\x2C options) {\n  const signal = options?.signal;\n\n  checkAborted(signal);\n\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\n\n  checkAborted(signal);\n\n  let size;\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\n    size = statFields[8/* size */];\n  } else {\n    size = 0;\n  }\n\n  if (size > kIoMaxLength)\n    throw new ERR_FS_FILE_TOO_LARGE(size);\n\n  let endOfFile = false;\n  let totalRead = 0;\n  const noSize = size === 0;\n  const buffers = [];\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\n  do {\n    checkAborted(signal);\n    let buffer;\n    let offset;\n    let length;\n    if (noSize) {\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\n      offset = 0;\n      length = kReadFileUnknownBufferLength;\n    } else {\n      buffer = fullBuffer;\n      offset = totalRead;\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\n    }\n\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\n                                          length\x2C -1\x2C kUsePromises)) || 0;\n    totalRead += bytesRead;\n    endOfFile = bytesRead === 0 || totalRead === size;\n    if (noSize && bytesRead > 0) {\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\n    }\n  } while (!endOfFile);\n\n  let result;\n  if (size > 0) {\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\n  } else {\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\n                                                               totalRead);\n  }\n\n  return options.encoding ? result.toString(options.encoding) : result;\n}\n\n// All of the functions are defined as async in order to ensure that errors\n// thrown cause promise rejections rather than being thrown synchronously.\nasync function access(path\x2C mode = F_OK) {\n  path = getValidatedPath(path);\n\n  mode = getValidMode(mode\x2C 'access');\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\n                        kUsePromises);\n}\n\nasync function cp(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\n}\n\nasync function copyFile(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n  mode = getValidMode(mode\x2C 'copyFile');\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\n                          pathModule.toNamespacedPath(dest)\x2C\n                          mode\x2C\n                          kUsePromises);\n}\n\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\n// fsPromises.open() uses the fs.FileHandle class.\nasync function open(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  return new FileHandle(\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\n                                 flagsNumber\x2C mode\x2C kUsePromises));\n}\n\nasync function read(handle\x2C bufferOrParams\x2C offset\x2C length\x2C position) {\n  let buffer = bufferOrParams;\n  if (!isArrayBufferView(buffer)) {\n    // This is fh.read(params)\n    ({\n      buffer = Buffer.alloc(16384)\x2C\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = bufferOrParams ?? kEmptyObject);\n\n    validateBuffer(buffer);\n  }\n\n  if (offset !== null && typeof offset === 'object') {\n    // This is fh.read(buffer\x2C options)\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = offset);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0)\n    return { bytesRead: length\x2C buffer };\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (!NumberIsSafeInteger(position))\n    position = -1;\n\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\n                                        position\x2C kUsePromises)) || 0;\n\n  return { bytesRead\x2C buffer };\n}\n\nasync function readv(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                               kUsePromises)) || 0;\n  return { bytesRead\x2C buffers };\n}\n\nasync function write(handle\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  if (buffer?.byteLength === 0)\n    return { bytesWritten: 0\x2C buffer };\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    const bytesWritten =\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\n                                 length\x2C position\x2C kUsePromises)) || 0;\n    return { bytesWritten\x2C buffer };\n  }\n\n  validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n  validateEncoding(buffer\x2C length);\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\n                                                  length\x2C kUsePromises)) || 0;\n  return { bytesWritten\x2C buffer };\n}\n\nasync function writev(handle\x2C buffers\x2C position) {\n  validateBufferArray(buffers);\n\n  if (typeof position !== 'number')\n    position = null;\n\n  if (buffers.length === 0) {\n    return { bytesWritten: 0\x2C buffers };\n  }\n\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\n                                                   kUsePromises)) || 0;\n  return { bytesWritten\x2C buffers };\n}\n\nasync function rename(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                        pathModule.toNamespacedPath(newPath)\x2C\n                        kUsePromises);\n}\n\nasync function truncate(path\x2C len = 0) {\n  const fd = await open(path\x2C 'r+');\n  return handleFdClose(ftruncate(fd\x2C len)\x2C fd.close);\n}\n\nasync function ftruncate(handle\x2C len = 0) {\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\n}\n\nasync function rm(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\n  return rimrafPromises(path\x2C options);\n}\n\nasync function rmdir(path\x2C options) {\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n  options = validateRmdirOptions(options);\n\n  if (options.recursive) {\n    emitRecursiveRmdirWarning();\n    const stats = await stat(path);\n    if (stats.isDirectory()) {\n      return rimrafPromises(path\x2C options);\n    }\n  }\n\n  return binding.rmdir(path\x2C kUsePromises);\n}\n\nasync function fdatasync(handle) {\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\n}\n\nasync function fsync(handle) {\n  return binding.fsync(handle.fd\x2C kUsePromises);\n}\n\nasync function mkdir(path\x2C options) {\n  if (typeof options === 'number' || typeof options === 'string') {\n    options = { mode: options };\n  }\n  const {\n    recursive = false\x2C\n    mode = 0o777\n  } = options || kEmptyObject;\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\n                       kUsePromises);\n}\n\nasync function readdir(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                       options.encoding\x2C\n                                       !!options.withFileTypes\x2C\n                                       kUsePromises);\n  return options.withFileTypes ?\n    getDirectoryEntriesPromise(path\x2C result) :\n    result;\n}\n\nasync function readlink(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                          options.encoding\x2C kUsePromises);\n}\n\nasync function symlink(target\x2C path\x2C type_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                         pathModule.toNamespacedPath(path)\x2C\n                         stringToSymlinkType(type)\x2C\n                         kUsePromises);\n}\n\nasync function fstat(handle\x2C options = { bigint: false }) {\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function lstat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                                     options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function stat(path\x2C options = { bigint: false }) {\n  path = getValidatedPath(path);\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\n                                    options.bigint\x2C kUsePromises);\n  return getStatsFromBinding(result);\n}\n\nasync function link(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                      pathModule.toNamespacedPath(newPath)\x2C\n                      kUsePromises);\n}\n\nasync function unlink(path) {\n  path = getValidatedPath(path);\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\n}\n\nasync function fchmod(handle\x2C mode) {\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\n}\n\nasync function chmod(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\n}\n\nasync function lchmod(path\x2C mode) {\n  if (O_SYMLINK === undefined)\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\n\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\n  return handleFdClose(fchmod(fd\x2C mode)\x2C fd.close);\n}\n\nasync function lchown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\n                        uid\x2C gid\x2C kUsePromises);\n}\n\nasync function fchown(handle\x2C uid\x2C gid) {\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\n}\n\nasync function chown(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\n                       uid\x2C gid\x2C kUsePromises);\n}\n\nasync function utimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                        toUnixTimestamp(atime)\x2C\n                        toUnixTimestamp(mtime)\x2C\n                        kUsePromises);\n}\n\nasync function futimes(handle\x2C atime\x2C mtime) {\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\n}\n\nasync function lutimes(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                         toUnixTimestamp(atime)\x2C\n                         toUnixTimestamp(mtime)\x2C\n                         kUsePromises);\n}\n\nasync function realpath(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function mkdtemp(prefix\x2C options) {\n  options = getOptions(options);\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix);\n  warnOnNonPortableTemplate(prefix);\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\n}\n\nasync function writeFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\n    validatePrimitiveStringAfterArrayBufferView(data\x2C 'data');\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\n  }\n\n  validateAbortSignal(options.signal);\n  if (path instanceof FileHandle)\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C options.mode);\n  return handleFdClose(\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\n}\n\nfunction isCustomIterable(obj) {\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\n}\n\nasync function appendFile(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n  options = copyObject(options);\n  options.flag = options.flag || 'a';\n  return writeFile(path\x2C data\x2C options);\n}\n\nasync function readFile(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const flag = options.flag || 'r';\n\n  if (path instanceof FileHandle)\n    return readFileHandle(path\x2C options);\n\n  checkAborted(options.signal);\n\n  const fd = await open(path\x2C flag\x2C 0o666);\n  return handleFdClose(readFileHandle(fd\x2C options)\x2C fd.close);\n}\n\nmodule.exports = {\n  exports: {\n    access\x2C\n    copyFile\x2C\n    cp\x2C\n    open\x2C\n    opendir: promisify(opendir)\x2C\n    rename\x2C\n    truncate\x2C\n    rm\x2C\n    rmdir\x2C\n    mkdir\x2C\n    readdir\x2C\n    readlink\x2C\n    symlink\x2C\n    lstat\x2C\n    stat\x2C\n    link\x2C\n    unlink\x2C\n    chmod\x2C\n    lchmod\x2C\n    lchown\x2C\n    chown\x2C\n    utimes\x2C\n    lutimes\x2C\n    realpath\x2C\n    mkdtemp\x2C\n    writeFile\x2C\n    appendFile\x2C\n    readFile\x2C\n    watch\x2C\n    constants\x2C\n  }\x2C\n\n  FileHandle\x2C\n  kRef\x2C\n  kUnref\x2C\n};\n
code-source-info,0xb46bbe57c50,414,0,24685,C0O0C4O24685,,
code-creation,Function,10,128962,0xb46bbe5a490,1812, node:internal/fs/promises:1:1,0xb46bbe57bc8,~
code-source-info,0xb46bbe5a490,414,0,24685,C0O0C518O25C524O47C530O56C536O67C542O78C548O101C554O112C560O136C566O154C572O171C578O192C584O223C589O233C595O289C599O289C605O275C610O329C616O337C622O350C628O362C634O372C640O412C644O412C648O412C650O454C658O454C664O443C670O647C678O647C684O647C690O497C696O524C702O551C708O574C714O609C720O623C726O705C734O705C740O683C746O764C754O764C760O745C766O1406C774O1406C780O1406C786O822C792O840C798O856C804O883C810O917C816O948C822O962C828O991C833O1005C839O1019C845O1042C851O1062C857O1078C863O1091C869O1123C875O1140C881O1163C887O1182C893O1205C899O1226C905O1254C911O1283C916O1304C922O1328C928O1375C934O1456C942O1456C948O1444C953O1630C961O1630C967O1494C973O1511C979O1534C985O1553C991O1571C997O1591C1003O1610C1009O1681C1017O1681C1021O1681C1023O1759C1031O1759C1037O1708C1043O1724C1049O1744C1054O1815C1062O1815C1068O1793C1073O1867C1081O1867C1087O1857C1092O1923C1100O1923C1106O1908C1112O1973C1120O1973C1124O1973C1126O2018C1130O2018C1134O2018C1136O2049C1140O2049C1144O2049C1146O2078C1150O2078C1154O2078C1156O2117C1160O2117C1164O2117C1166O2164C1170O2164C1174O2164C1176O2210C1180O2210C1184O2210C1186O2247C1190O2247C1194O2247C1196O2278C1200O2278C1204O2278C1206O2312C1210O2312C1214O2312C1216O2357C1220O2340C1226O2435C1234O2435C1240O2376C1245O2392C1250O2406C1255O2417C1260O2527C1268O2527C1274O2490C1280O2605C1288O2605C1294O2579C1300O2688C1304O2688C1306O2744C1310O2744C1312O2779C1313O2779C1315O2934C1316O2934C1318O3055C1446O6902C1456O7305C1466O7362C1478O7453C1488O7490C1520O3030C1522O24227C1528O24257C1536O24263C1542O24275C1548O24289C1554O24297C1558O24316C1568O24340C1574O24352C1580O24366C1586O24374C1592O24385C1598O24396C1604O24409C1610O24423C1616O24436C1622O24447C1628O24457C1634O24467C1640O24479C1646O24490C1652O24502C1662O24514C1672O24525C1682O24537C1692O24550C1702O24564C1712O24577C1722O24592C1732O24608C1742O24622C1752O24633C1772O24652C1782O24666C1792O24674C1802O24242C1811O24684,,
code-creation,Function,10,129113,0xb46bbe5aef8,19,<instance_members_initializer> node:internal/fs/promises:130:1,0xb46bbe592c8,~
code-source-info,0xb46bbe5aef8,414,3030,7707,C0O3030C9O4545C18O7707,,
tick,0x7ff805f105d0,129140,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805db16f0,129159,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x102daee2a,129259,1,0x10266e4e0,6,0x1027fed10,0xb46f7def606,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,129514,0xb46bbe5dc50,5, node:internal/fs/rimraf:1:1,0xb46bbe5d8e8,~
script-source,415,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\n// modified in the following ways:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Promise\x2C\n  SafeSet\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst fs = require('fs');\nconst {\n  chmod\x2C\n  chmodSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  unlink\x2C\n  unlinkSync\n} = fs;\nconst { sep } = require('path');\nconst { setTimeout } = require('timers');\nconst { sleep } = require('internal/util');\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\nconst retryErrorCodes = new SafeSet(\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\nconst isWindows = process.platform === 'win32';\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\nconst readdirEncoding = 'buffer';\nconst separator = Buffer.from(sep);\n\n\nfunction rimraf(path\x2C options\x2C callback) {\n  let retries = 0;\n\n  _rimraf(path\x2C options\x2C function CB(err) {\n    if (err) {\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\n        retries++;\n        const delay = retries * options.retryDelay;\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\n      }\n\n      // The file is already gone.\n      if (err.code === 'ENOENT')\n        err = null;\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rimraf(path\x2C options\x2C callback) {\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\n  // it's not a directory.\n  lstat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (err.code === 'ENOENT')\n        return callback(null);\n\n      // Windows can EPERM on stat.\n      if (isWindows && err.code === 'EPERM')\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\n    } else if (stats.isDirectory()) {\n      return _rmdir(path\x2C options\x2C err\x2C callback);\n    }\n\n    unlink(path\x2C (err) => {\n      if (err) {\n        if (err.code === 'ENOENT')\n          return callback(null);\n        if (err.code === 'EISDIR')\n          return _rmdir(path\x2C options\x2C err\x2C callback);\n        if (err.code === 'EPERM') {\n          return epermHandler(path\x2C options\x2C err\x2C callback);\n        }\n      }\n\n      return callback(err);\n    });\n  });\n}\n\n\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\n  chmod(path\x2C 0o666\x2C (err) => {\n    if (err)\n      return callback(err.code === 'ENOENT' ? null : originalErr);\n\n    stat(path\x2C (err\x2C stats) => {\n      if (err)\n        return callback(err.code === 'ENOENT' ? null : originalErr);\n\n      if (stats.isDirectory())\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\n      else\n        unlink(path\x2C callback);\n    });\n  });\n}\n\n\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\n  rmdir(path\x2C (err) => {\n    if (err) {\n      if (notEmptyErrorCodes.has(err.code))\n        return _rmchildren(path\x2C options\x2C callback);\n      if (err.code === 'ENOTDIR')\n        return callback(originalErr);\n    }\n\n    callback(err);\n  });\n}\n\n\nfunction _rmchildren(path\x2C options\x2C callback) {\n  const pathBuf = Buffer.from(path);\n\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\n    if (err)\n      return callback(err);\n\n    let numFiles = files.length;\n\n    if (numFiles === 0)\n      return rmdir(path\x2C callback);\n\n    let done = false;\n\n    ArrayPrototypeForEach(files\x2C (child) => {\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n      rimraf(childPath\x2C options\x2C (err) => {\n        if (done)\n          return;\n\n        if (err) {\n          done = true;\n          return callback(err);\n        }\n\n        numFiles--;\n        if (numFiles === 0)\n          rmdir(path\x2C callback);\n      });\n    });\n  });\n}\n\n\nfunction rimrafPromises(path\x2C options) {\n  return new Promise((resolve\x2C reject) => {\n    rimraf(path\x2C options\x2C (err) => {\n      if (err)\n        return reject(err);\n\n      resolve();\n    });\n  });\n}\n\n\nfunction rimrafSync(path\x2C options) {\n  let stats;\n\n  try {\n    stats = lstatSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    // Windows can EPERM on stat.\n    if (isWindows && err.code === 'EPERM')\n      fixWinEPERMSync(path\x2C options\x2C err);\n  }\n\n  try {\n    // SunOS lets the root user unlink directories.\n    if (stats?.isDirectory())\n      _rmdirSync(path\x2C options\x2C null);\n    else\n      _unlinkSync(path\x2C options);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'EPERM')\n      return epermHandlerSync(path\x2C options\x2C err);\n    if (err.code !== 'EISDIR')\n      throw err;\n\n    _rmdirSync(path\x2C options\x2C err);\n  }\n}\n\n\nfunction _unlinkSync(path\x2C options) {\n  const tries = options.maxRetries + 1;\n\n  for (let i = 1; i <= tries; i++) {\n    try {\n      return unlinkSync(path);\n    } catch (err) {\n      // Only sleep if this is not the last try\x2C and the delay is greater\n      // than zero\x2C and an error was encountered that warrants a retry.\n      if (retryErrorCodes.has(err.code) &&\n          i < tries &&\n          options.retryDelay > 0) {\n        sleep(i * options.retryDelay);\n      } else if (err.code === 'ENOENT') {\n        // The file is already gone.\n        return;\n      } else if (i === tries) {\n        throw err;\n      }\n    }\n  }\n}\n\n\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\n  try {\n    rmdirSync(path);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n    if (err.code === 'ENOTDIR') {\n      throw originalErr || err;\n    }\n\n    if (notEmptyErrorCodes.has(err.code)) {\n      // Removing failed. Try removing all children and then retrying the\n      // original removal. Windows has a habit of not closing handles promptly\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\n      // around that issue by retrying on Windows.\n      const pathBuf = Buffer.from(path);\n\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\n\n        rimrafSync(childPath\x2C options);\n      });\n\n      const tries = options.maxRetries + 1;\n\n      for (let i = 1; i <= tries; i++) {\n        try {\n          return fs.rmdirSync(path);\n        } catch (err) {\n          // Only sleep if this is not the last try\x2C and the delay is greater\n          // than zero\x2C and an error was encountered that warrants a retry.\n          if (retryErrorCodes.has(err.code) &&\n              i < tries &&\n              options.retryDelay > 0) {\n            sleep(i * options.retryDelay);\n          } else if (err.code === 'ENOENT') {\n            // The file is already gone.\n            return;\n          } else if (i === tries) {\n            throw err;\n          }\n        }\n      }\n    }\n\n    throw originalErr || err;\n  }\n}\n\n\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\n  try {\n    chmodSync(path\x2C 0o666);\n  } catch (err) {\n    if (err.code === 'ENOENT')\n      return;\n\n    throw originalErr;\n  }\n\n  let stats;\n\n  try {\n    stats = statSync(path\x2C { throwIfNoEntry: false });\n  } catch {\n    throw originalErr;\n  }\n\n  if (stats === undefined) return;\n\n  if (stats.isDirectory())\n    _rmdirSync(path\x2C options\x2C originalErr);\n  else\n    _unlinkSync(path\x2C options);\n}\n\n\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\n
code-source-info,0xb46bbe5dc50,415,0,7453,C0O0C4O7453,,
code-creation,Function,10,130375,0xb46bbe5e250,409, node:internal/fs/rimraf:1:1,0xb46bbe5dbc8,~
code-source-info,0xb46bbe5e250,415,0,7453,C0O0C139O368C145O393C151O404C156O450C159O450C164O439C170O480C173O480C177O480C179O642C182O505C188O514C194O527C200O536C206O549C212O560C218O575C224O584C230O597C236O605C242O617C248O627C254O662C257O662C262O654C267O702C270O702C275O687C281O739C284O739C289O729C295O792C302O792C307O792C309O863C316O863C321O863C323O958C330O967C333O950C335O1001C345O1001C347O1060C357O1060C359O1126C361O1126C363O1154C366O1161C371O1161C376O1154C378O7396C385O7415C391O7423C397O7439C403O7411C408O7452,,
tick,0x102c50c32,130547,0,0x0,2,0x102d5e910,0xb46bbe5e3c3,0xb46f7def627,0x1132442e1,0xb46bbe5a782,0xb46f7def627,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,LazyCompile,10,130859,0xb46bbe5f158,188,from node:buffer:301:28,0xb469fcee808,~
script-source,30,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  MathFloor\x2C\n  MathMin\x2C\n  MathTrunc\x2C\n  NumberIsNaN\x2C\n  NumberMAX_SAFE_INTEGER\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  SymbolSpecies\x2C\n  SymbolToPrimitive\x2C\n  TypedArrayPrototypeGetByteLength\x2C\n  TypedArrayPrototypeFill\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n  Uint8ArrayPrototype\x2C\n} = primordials;\n\nconst {\n  byteLengthUtf8\x2C\n  compare: _compare\x2C\n  compareOffset\x2C\n  createFromString\x2C\n  fill: bindingFill\x2C\n  indexOfBuffer\x2C\n  indexOfNumber\x2C\n  indexOfString\x2C\n  swap16: _swap16\x2C\n  swap32: _swap32\x2C\n  swap64: _swap64\x2C\n  kMaxLength\x2C\n  kStringMaxLength\n} = internalBinding('buffer');\nconst {\n  getOwnNonIndexProperties\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\x2C\n} = internalBinding('util');\nconst {\n  customInspectSymbol\x2C\n  isInsideNodeModules\x2C\n  lazyDOMException\x2C\n  normalizeEncoding\x2C\n  kIsEncodingSymbol\n} = require('internal/util');\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\nconst {\n  inspect: utilInspect\n} = require('internal/util/inspect');\nconst { encodings } = internalBinding('string_decoder');\n\nconst {\n  codes: {\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_BUFFER_SIZE\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_UNKNOWN_ENCODING\n  }\x2C\n  genericNodeError\x2C\n  hideStackFrames\x2C\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateBuffer\x2C\n  validateNumber\x2C\n  validateInteger\x2C\n  validateString\n} = require('internal/validators');\n// Provide validateInteger() but with kMaxLength as the default maximum value.\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\n  validateInteger(value\x2C name\x2C min\x2C max);\n\nconst {\n  FastBuffer\x2C\n  markAsUntransferable\x2C\n  addBufferPrototypeMethods\x2C\n  createUnsafeBuffer\n} = require('internal/buffer');\n\nconst {\n  Blob\x2C\n  resolveObjectURL\x2C\n} = require('internal/blob');\n\nFastBuffer.prototype.constructor = Buffer;\nBuffer.prototype = FastBuffer.prototype;\naddBufferPrototypeMethods(Buffer.prototype);\n\nconst constants = ObjectDefineProperties({}\x2C {\n  MAX_LENGTH: {\n    __proto__: null\x2C\n    value: kMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\x2C\n  MAX_STRING_LENGTH: {\n    __proto__: null\x2C\n    value: kStringMaxLength\x2C\n    writable: false\x2C\n    enumerable: true\n  }\n});\n\nBuffer.poolSize = 8 * 1024;\nlet poolSize\x2C poolOffset\x2C allocPool;\n\nconst encodingsMap = ObjectCreate(null);\nfor (let i = 0; i < encodings.length; ++i)\n  encodingsMap[encodings[i]] = i;\n\nfunction createPool() {\n  poolSize = Buffer.poolSize;\n  allocPool = createUnsafeBuffer(poolSize).buffer;\n  markAsUntransferable(allocPool);\n  poolOffset = 0;\n}\ncreatePool();\n\nfunction alignPool() {\n  // Ensure aligned slices\n  if (poolOffset & 0x7) {\n    poolOffset |= 0x7;\n    poolOffset++;\n  }\n}\n\nlet bufferWarningAlreadyEmitted = false;\nlet nodeModulesCheckCounter = 0;\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\n                      'issues. Please use the Buffer.alloc()\x2C ' +\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\n\nfunction showFlaggedDeprecation() {\n  if (bufferWarningAlreadyEmitted ||\n      ++nodeModulesCheckCounter > 10000 ||\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\n       isInsideNodeModules())) {\n    // We don't emit a warning\x2C because we either:\n    // - Already did so\x2C or\n    // - Already checked too many times whether a call is coming\n    //   from node_modules and want to stop slowing down things\x2C or\n    // - We aren't running with `--pending-deprecation` enabled\x2C\n    //   and the code is inside `node_modules`.\n    return;\n  }\n\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\n  bufferWarningAlreadyEmitted = true;\n}\n\nfunction toInteger(n\x2C defaultVal) {\n  n = +n;\n  if (!NumberIsNaN(n) &&\n      n >= NumberMIN_SAFE_INTEGER &&\n      n <= NumberMAX_SAFE_INTEGER) {\n    return ((n % 1) === 0 ? n : MathFloor(n));\n  }\n  return defaultVal;\n}\n\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (!isUint8Array(source))\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\n  if (!isUint8Array(target))\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n\n  if (targetStart === undefined) {\n    targetStart = 0;\n  } else {\n    targetStart = toInteger(targetStart\x2C 0);\n    if (targetStart < 0)\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\n  }\n\n  if (sourceStart === undefined) {\n    sourceStart = 0;\n  } else {\n    sourceStart = toInteger(sourceStart\x2C 0);\n    if (sourceStart < 0)\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\n  }\n\n  if (sourceEnd === undefined) {\n    sourceEnd = source.length;\n  } else {\n    sourceEnd = toInteger(sourceEnd\x2C 0);\n    if (sourceEnd < 0)\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\n  }\n\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\n    return 0;\n\n  if (sourceStart > source.length) {\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\n                               `<= ${source.length}`\x2C\n                               sourceStart);\n  }\n\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n}\n\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n  if (sourceEnd - sourceStart > target.length - targetStart)\n    sourceEnd = sourceStart + target.length - targetStart;\n\n  let nb = sourceEnd - sourceStart;\n  const sourceLen = source.length - sourceStart;\n  if (nb > sourceLen)\n    nb = sourceLen;\n\n  if (sourceStart !== 0 || sourceEnd < source.length)\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\n\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\n\n  return nb;\n}\n\n/**\n * The Buffer() constructor is deprecated in documentation and should not be\n * used moving forward. Rather\x2C developers should use one of the three new\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\n * their specific needs. There is no runtime deprecation because of the extent\n * to which the Buffer constructor is used in the ecosystem currently -- a\n * runtime deprecation would introduce too much breakage at this time. It's not\n * likely that the Buffer constructors would ever actually be removed.\n * Deprecation Code: DEP0005\n */\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\n  showFlaggedDeprecation();\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\n    }\n    return Buffer.alloc(arg);\n  }\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\n}\n\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  configurable: true\x2C\n  get() { return FastBuffer; }\n});\n\n/**\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[\x2C encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\n */\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\n  if (typeof value === 'string')\n    return fromString(value\x2C encodingOrOffset);\n\n  if (typeof value === 'object' && value !== null) {\n    if (isAnyArrayBuffer(value))\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\n\n    const valueOf = value.valueOf && value.valueOf();\n    if (valueOf != null &&\n        valueOf !== value &&\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\n      return from(valueOf\x2C encodingOrOffset\x2C length);\n    }\n\n    const b = fromObject(value);\n    if (b)\n      return b;\n\n    if (typeof value[SymbolToPrimitive] === 'function') {\n      const primitive = value[SymbolToPrimitive]('string');\n      if (typeof primitive === 'string') {\n        return fromString(primitive\x2C encodingOrOffset);\n      }\n    }\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'first argument'\x2C\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\n    value\n  );\n};\n\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\n// adding a `prototype` property and making the function a constructor.\n//\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\nconst of = (...items) => {\n  const newObj = createUnsafeBuffer(items.length);\n  for (let k = 0; k < items.length; k++)\n    newObj[k] = items[k];\n  return newObj;\n};\nBuffer.of = of;\n\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\n\n// The 'assertSize' method will remove itself from the callstack when an error\n// occurs. This is done simply to keep the internal details of the\n// implementation from bleeding out to users.\nconst assertSize = hideStackFrames((size) => {\n  validateNumber(size\x2C 'size');\n  if (!(size >= 0 && size <= kMaxLength)) {\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\n  }\n});\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[\x2C fill[\x2C encoding]])\n */\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\n  assertSize(size);\n  if (fill !== undefined && fill !== 0 && size > 0) {\n    const buf = createUnsafeBuffer(size);\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\n  }\n  return new FastBuffer(size);\n};\n\n/**\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafe = function allocUnsafe(size) {\n  assertSize(size);\n  return allocate(size);\n};\n\n/**\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\n * Buffer instance that is not allocated off the pre-initialized pool.\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\n */\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\n  assertSize(size);\n  return createUnsafeBuffer(size);\n};\n\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\n// buffer is returned.\nfunction SlowBuffer(length) {\n  assertSize(length);\n  return createUnsafeBuffer(length);\n}\n\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\n\nfunction allocate(size) {\n  if (size <= 0) {\n    return new FastBuffer();\n  }\n  if (size < (Buffer.poolSize >>> 1)) {\n    if (size > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\n    poolOffset += size;\n    alignPool();\n    return b;\n  }\n  return createUnsafeBuffer(size);\n}\n\nfunction fromStringFast(string\x2C ops) {\n  const length = ops.byteLength(string);\n\n  if (length >= (Buffer.poolSize >>> 1))\n    return createFromString(string\x2C ops.encodingVal);\n\n  if (length > (poolSize - poolOffset))\n    createPool();\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\n  if (actual !== length) {\n    // byteLength() may overestimate. That's a rare case\x2C though.\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\n  }\n  poolOffset += actual;\n  alignPool();\n  return b;\n}\n\nfunction fromString(string\x2C encoding) {\n  let ops;\n  if (typeof encoding !== 'string' || encoding.length === 0) {\n    if (string.length === 0)\n      return new FastBuffer();\n    ops = encodingOps.utf8;\n    encoding = undefined;\n  } else {\n    ops = getEncodingOps(encoding);\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (string.length === 0)\n      return new FastBuffer();\n  }\n  return fromStringFast(string\x2C ops);\n}\n\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\n  // Convert byteOffset to integer\n  if (byteOffset === undefined) {\n    byteOffset = 0;\n  } else {\n    byteOffset = +byteOffset;\n    if (NumberIsNaN(byteOffset))\n      byteOffset = 0;\n  }\n\n  const maxLength = obj.byteLength - byteOffset;\n\n  if (maxLength < 0)\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n\n  if (length === undefined) {\n    length = maxLength;\n  } else {\n    // Convert length to non-negative integer.\n    length = +length;\n    if (length > 0) {\n      if (length > maxLength)\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n    } else {\n      length = 0;\n    }\n  }\n\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\n}\n\nfunction fromArrayLike(obj) {\n  if (obj.length <= 0)\n    return new FastBuffer();\n  if (obj.length < (Buffer.poolSize >>> 1)) {\n    if (obj.length > (poolSize - poolOffset))\n      createPool();\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\n    poolOffset += obj.length;\n    alignPool();\n    return b;\n  }\n  return new FastBuffer(obj);\n}\n\nfunction fromObject(obj) {\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\n    if (typeof obj.length !== 'number') {\n      return new FastBuffer();\n    }\n    return fromArrayLike(obj);\n  }\n\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\n    return fromArrayLike(obj.data);\n  }\n}\n\n// Static methods\n\nBuffer.isBuffer = function isBuffer(b) {\n  return b instanceof Buffer;\n};\n\nBuffer.compare = function compare(buf1\x2C buf2) {\n  if (!isUint8Array(buf1)) {\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\n  }\n\n  if (!isUint8Array(buf2)) {\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\n  }\n\n  if (buf1 === buf2) {\n    return 0;\n  }\n\n  return _compare(buf1\x2C buf2);\n};\n\nBuffer.isEncoding = function isEncoding(encoding) {\n  return typeof encoding === 'string' && encoding.length !== 0 &&\n         normalizeEncoding(encoding) !== undefined;\n};\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\n\nBuffer.concat = function concat(list\x2C length) {\n  validateArray(list\x2C 'list');\n\n  if (list.length === 0)\n    return new FastBuffer();\n\n  if (length === undefined) {\n    length = 0;\n    for (let i = 0; i < list.length; i++) {\n      if (list[i].length) {\n        length += list[i].length;\n      }\n    }\n  } else {\n    validateOffset(length\x2C 'length');\n  }\n\n  const buffer = Buffer.allocUnsafe(length);\n  let pos = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    if (!isUint8Array(buf)) {\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\n      // Instead\x2C find the proper error code for this.\n      throw new ERR_INVALID_ARG_TYPE(\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\n    }\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\n  }\n\n  // Note: `length` is always equal to `buffer.length` at this point\n  if (pos < length) {\n    // Zero-fill the remaining bytes if the specified `length` was more than\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\n    // there were not initialized.\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\n  }\n\n  return buffer;\n};\n\nfunction base64ByteLength(str\x2C bytes) {\n  // Handle padding\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\n    bytes--;\n\n  // Base64 ratio: 3/4\n  return (bytes * 3) >>> 2;\n}\n\nconst encodingOps = {\n  utf8: {\n    encoding: 'utf8'\x2C\n    encodingVal: encodingsMap.utf8\x2C\n    byteLength: byteLengthUtf8\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\n  }\x2C\n  ucs2: {\n    encoding: 'ucs2'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  utf16le: {\n    encoding: 'utf16le'\x2C\n    encodingVal: encodingsMap.utf16le\x2C\n    byteLength: (string) => string.length * 2\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\n  }\x2C\n  latin1: {\n    encoding: 'latin1'\x2C\n    encodingVal: encodingsMap.latin1\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\n  }\x2C\n  ascii: {\n    encoding: 'ascii'\x2C\n    encodingVal: encodingsMap.ascii\x2C\n    byteLength: (string) => string.length\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\n                    byteOffset\x2C\n                    encodingsMap.ascii\x2C\n                    dir)\n  }\x2C\n  base64: {\n    encoding: 'base64'\x2C\n    encodingVal: encodingsMap.base64\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64\x2C\n                    dir)\n  }\x2C\n  base64url: {\n    encoding: 'base64url'\x2C\n    encodingVal: encodingsMap.base64url\x2C\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\n    write: (buf\x2C string\x2C offset\x2C len) =>\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\n                    byteOffset\x2C\n                    encodingsMap.base64url\x2C\n                    dir)\n  }\x2C\n  hex: {\n    encoding: 'hex'\x2C\n    encodingVal: encodingsMap.hex\x2C\n    byteLength: (string) => string.length >>> 1\x2C\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\n      indexOfBuffer(buf\x2C\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\n                    byteOffset\x2C\n                    encodingsMap.hex\x2C\n                    dir)\n  }\n};\nfunction getEncodingOps(encoding) {\n  encoding += '';\n  switch (encoding.length) {\n    case 4:\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf8') return encodingOps.utf8;\n      if (encoding === 'ucs2') return encodingOps.ucs2;\n      break;\n    case 5:\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'utf-8') return encodingOps.utf8;\n      if (encoding === 'ascii') return encodingOps.ascii;\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\n      break;\n    case 7:\n      if (encoding === 'utf16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\n        return encodingOps.utf16le;\n      break;\n    case 8:\n      if (encoding === 'utf-16le' ||\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\n        return encodingOps.utf16le;\n      break;\n    case 6:\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      encoding = StringPrototypeToLowerCase(encoding);\n      if (encoding === 'latin1' || encoding === 'binary')\n        return encodingOps.latin1;\n      if (encoding === 'base64') return encodingOps.base64;\n      break;\n    case 3:\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\n        return encodingOps.hex;\n      break;\n    case 9:\n      if (encoding === 'base64url' ||\n          StringPrototypeToLowerCase(encoding) === 'base64url')\n        return encodingOps.base64url;\n      break;\n  }\n}\n\nfunction byteLength(string\x2C encoding) {\n  if (typeof string !== 'string') {\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\n      return string.byteLength;\n    }\n\n    throw new ERR_INVALID_ARG_TYPE(\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\n    );\n  }\n\n  const len = string.length;\n  if (len === 0)\n    return 0;\n\n  if (encoding) {\n    const ops = getEncodingOps(encoding);\n    if (ops) {\n      return ops.byteLength(string);\n    }\n  }\n  return byteLengthUtf8(string);\n}\n\nBuffer.byteLength = byteLength;\n\n// For backwards compatibility.\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.buffer;\n  }\n});\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!(this instanceof Buffer))\n      return undefined;\n    return this.byteOffset;\n  }\n});\n\nBuffer.prototype.copy =\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\n  };\n\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\n// property of a typed array.\n// This behaves neither like String nor Uint8Array in that we set start/end\n// to their upper/lower bounds if the value passed is out of range.\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\n  if (arguments.length === 0) {\n    return this.utf8Slice(0\x2C this.length);\n  }\n\n  const len = this.length;\n\n  if (start <= 0)\n    start = 0;\n  else if (start >= len)\n    return '';\n  else\n    start |= 0;\n\n  if (end === undefined || end > len)\n    end = len;\n  else\n    end |= 0;\n\n  if (end <= start)\n    return '';\n\n  if (encoding === undefined)\n    return this.utf8Slice(start\x2C end);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n\n  return ops.slice(this\x2C start\x2C end);\n};\n\nBuffer.prototype.equals = function equals(otherBuffer) {\n  if (!isUint8Array(otherBuffer)) {\n    throw new ERR_INVALID_ARG_TYPE(\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\n  }\n\n  if (this === otherBuffer)\n    return true;\n\n  if (this.byteLength !== otherBuffer.byteLength)\n    return false;\n\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\n};\n\nlet INSPECT_MAX_BYTES = 50;\n// Override how buffers are presented by util.inspect().\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\n  const max = INSPECT_MAX_BYTES;\n  const actualMax = MathMin(max\x2C this.length);\n  const remaining = this.length - max;\n  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(\n    /(.{2})/g\x2C this.hexSlice(0\x2C actualMax)\x2C '$1 '));\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  // Inspect special properties as well\x2C if possible.\n  if (ctx) {\n    let extras = false;\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n    const obj = ObjectCreate(null);\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\n                          (key) => {\n                            extras = true;\n                            obj[key] = this[key];\n                          });\n    if (extras) {\n      if (this.length !== 0)\n        str += '\x2C ';\n      // '[Object: null prototype] {'.length === 26\n      // This is guarded with a test.\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\n        ...ctx\x2C\n        breakLength: Infinity\x2C\n        compact: true\n      })\x2C 27\x2C -2);\n    }\n  }\n  return `<${this.constructor.name} ${str}>`;\n};\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\n\nBuffer.prototype.compare = function compare(target\x2C\n                                            targetStart\x2C\n                                            targetEnd\x2C\n                                            sourceStart\x2C\n                                            sourceEnd) {\n  if (!isUint8Array(target)) {\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\n  }\n  if (arguments.length === 1)\n    return _compare(this\x2C target);\n\n  if (targetStart === undefined)\n    targetStart = 0;\n  else\n    validateOffset(targetStart\x2C 'targetStart');\n\n  if (targetEnd === undefined)\n    targetEnd = target.length;\n  else\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\n\n  if (sourceStart === undefined)\n    sourceStart = 0;\n  else\n    validateOffset(sourceStart\x2C 'sourceStart');\n\n  if (sourceEnd === undefined)\n    sourceEnd = this.length;\n  else\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\n\n  if (sourceStart >= sourceEnd)\n    return (targetStart >= targetEnd ? 0 : -1);\n  if (targetStart >= targetEnd)\n    return 1;\n\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\n                       sourceEnd);\n};\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string\x2C Buffer\x2C or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding\x2C relevant if val is a string\n// - dir - true for indexOf\x2C false for lastIndexOf\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\n  validateBuffer(buffer);\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = undefined;\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff;\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000;\n  }\n  // Coerce to Number. Values like null and [] become 0.\n  byteOffset = +byteOffset;\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\n  if (NumberIsNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\n  }\n  dir = !!dir;  // Cast to bool.\n\n  if (typeof val === 'number')\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\n\n  let ops;\n  if (encoding === undefined)\n    ops = encodingOps.utf8;\n  else\n    ops = getEncodingOps(encoding);\n\n  if (typeof val === 'string') {\n    if (ops === undefined)\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\n  }\n\n  if (isUint8Array(val)) {\n    const encodingVal =\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\n  );\n}\n\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\n};\n\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\n};\n\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\n};\n\n// Usage:\n//    buffer.fill(number[\x2C offset[\x2C end]])\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\n};\n\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\n  if (typeof value === 'string') {\n    if (offset === undefined || typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buf.length;\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buf.length;\n    }\n\n    const normalizedEncoding = normalizeEncoding(encoding);\n    if (normalizedEncoding === undefined) {\n      validateString(encoding\x2C 'encoding');\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    }\n\n    if (value.length === 0) {\n      // If value === '' default to zero.\n      value = 0;\n    } else if (value.length === 1) {\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\n      if (normalizedEncoding === 'utf8') {\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\n        if (code < 128) {\n          value = code;\n        }\n      } else if (normalizedEncoding === 'latin1') {\n        value = StringPrototypeCharCodeAt(value\x2C 0);\n      }\n    }\n  } else {\n    encoding = undefined;\n  }\n\n  if (offset === undefined) {\n    offset = 0;\n    end = buf.length;\n  } else {\n    validateOffset(offset\x2C 'offset');\n    // Invalid ranges are not set to a default\x2C so can range check early.\n    if (end === undefined) {\n      end = buf.length;\n    } else {\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\n    }\n    if (offset >= end)\n      return buf;\n  }\n\n\n  if (typeof value === 'number') {\n    // OOB check\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\n    const fillLength = end - offset;\n    if (offset > end || fillLength + offset > byteLen)\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\n  } else {\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\n    if (res < 0) {\n      if (res === -1)\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\n    }\n  }\n\n  return buf;\n}\n\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\n  // Buffer#write(string);\n  if (offset === undefined) {\n    return this.utf8Write(string\x2C 0\x2C this.length);\n  }\n  // Buffer#write(string\x2C encoding)\n  if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    length = this.length;\n    offset = 0;\n\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\n  } else {\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\n\n    const remaining = this.length - offset;\n\n    if (length === undefined) {\n      length = remaining;\n    } else if (typeof length === 'string') {\n      encoding = length;\n      length = remaining;\n    } else {\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\n      if (length > remaining)\n        length = remaining;\n    }\n  }\n\n  if (!encoding)\n    return this.utf8Write(string\x2C offset\x2C length);\n\n  const ops = getEncodingOps(encoding);\n  if (ops === undefined)\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  return ops.write(this\x2C string\x2C offset\x2C length);\n};\n\nBuffer.prototype.toJSON = function toJSON() {\n  if (this.length > 0) {\n    const data = new Array(this.length);\n    for (let i = 0; i < this.length; ++i)\n      data[i] = this[i];\n    return { type: 'Buffer'\x2C data };\n  }\n  return { type: 'Buffer'\x2C data: [] };\n};\n\nfunction adjustOffset(offset\x2C length) {\n  // Use Math.trunc() to convert offset to an integer value that can be larger\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\n  offset = MathTrunc(offset);\n  if (offset === 0) {\n    return 0;\n  }\n  if (offset < 0) {\n    offset += length;\n    return offset > 0 ? offset : 0;\n  }\n  if (offset < length) {\n    return offset;\n  }\n  return NumberIsNaN(offset) ? 0 : length;\n}\n\nBuffer.prototype.subarray = function subarray(start\x2C end) {\n  const srcLength = this.length;\n  start = adjustOffset(start\x2C srcLength);\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\n  const newLength = end > start ? end - start : 0;\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\n};\n\nBuffer.prototype.slice = function slice(start\x2C end) {\n  return this.subarray(start\x2C end);\n};\n\nfunction swap(b\x2C n\x2C m) {\n  const i = b[n];\n  b[n] = b[m];\n  b[m] = i;\n}\n\nBuffer.prototype.swap16 = function swap16() {\n  // For Buffer.length < 128\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 2 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\n  if (len < 128) {\n    for (let i = 0; i < len; i += 2)\n      swap(this\x2C i\x2C i + 1);\n    return this;\n  }\n  return _swap16(this);\n};\n\nBuffer.prototype.swap32 = function swap32() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 4 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 4) {\n      swap(this\x2C i\x2C i + 3);\n      swap(this\x2C i + 1\x2C i + 2);\n    }\n    return this;\n  }\n  return _swap32(this);\n};\n\nBuffer.prototype.swap64 = function swap64() {\n  // For Buffer.length < 192\x2C it's generally faster to\n  // do the swap in javascript. For larger buffers\x2C\n  // dropping down to the native code is faster.\n  const len = this.length;\n  if (len % 8 !== 0)\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\n  if (len < 192) {\n    for (let i = 0; i < len; i += 8) {\n      swap(this\x2C i\x2C i + 7);\n      swap(this\x2C i + 1\x2C i + 6);\n      swap(this\x2C i + 2\x2C i + 5);\n      swap(this\x2C i + 3\x2C i + 4);\n    }\n    return this;\n  }\n  return _swap64(this);\n};\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\n\nlet transcode;\nif (internalBinding('config').hasIntl) {\n  const {\n    icuErrName\x2C\n    transcode: _transcode\n  } = internalBinding('icu');\n\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\n  // Buffer instance.\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\n    if (!isUint8Array(source)) {\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\n    }\n    if (source.length === 0) return Buffer.alloc(0);\n\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\n    if (typeof result !== 'number')\n      return result;\n\n    const code = icuErrName(result);\n    const err = genericNodeError(\n      `Unable to transcode Buffer [${code}]`\x2C\n      { code: code\x2C errno: result }\n    );\n    throw err;\n  };\n}\n\nfunction btoa(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n  input = `${input}`;\n  for (let n = 0; n < input.length; n++) {\n    if (input[n].charCodeAt(0) > 0xff)\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n  }\n  const buf = Buffer.from(input\x2C 'latin1');\n  return buf.toString('base64');\n}\n\n// Refs: https://infra.spec.whatwg.org/#forgiving-base64-decode\nconst kForgivingBase64AllowedChars = [\n  // ASCII whitespace\n  // Refs: https://infra.spec.whatwg.org/#ascii-whitespace\n  0x09\x2C 0x0A\x2C 0x0C\x2C 0x0D\x2C 0x20\x2C\n\n  // Uppercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('A') + i)\x2C\n\n  // Lowercase letters\n  ...ArrayFrom({ length: 26 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('a') + i)\x2C\n\n  // Decimal digits\n  ...ArrayFrom({ length: 10 }\x2C (_\x2C i) => StringPrototypeCharCodeAt('0') + i)\x2C\n\n  0x2B\x2C // +\n  0x2F\x2C // /\n  0x3D\x2C // =\n];\n\nfunction atob(input) {\n  // The implementation here has not been performance optimized in any way and\n  // should not be.\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\n  if (arguments.length === 0) {\n    throw new ERR_MISSING_ARGS('input');\n  }\n\n  input = `${input}`;\n  let nonAsciiWhitespaceCharCount = 0;\n\n  for (let n = 0; n < input.length; n++) {\n    const index = ArrayPrototypeIndexOf(\n      kForgivingBase64AllowedChars\x2C\n      StringPrototypeCharCodeAt(input\x2C n));\n\n    if (index > 4) {\n      // The first 5 elements of `kForgivingBase64AllowedChars` are\n      // ASCII whitespace char codes.\n      nonAsciiWhitespaceCharCount++;\n    } else if (index === -1) {\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\n    }\n  }\n\n  // See #3 - https://infra.spec.whatwg.org/#forgiving-base64\n  if (nonAsciiWhitespaceCharCount % 4 === 1) {\n    throw lazyDOMException(\n      'The string to be decoded is not correctly encoded.'\x2C\n      'InvalidCharacterError');\n  }\n\n  return Buffer.from(input\x2C 'base64').toString('latin1');\n}\n\nmodule.exports = {\n  Blob\x2C\n  resolveObjectURL\x2C\n  Buffer\x2C\n  SlowBuffer\x2C\n  transcode\x2C\n  // Legacy\n  kMaxLength\x2C\n  kStringMaxLength\x2C\n  btoa\x2C\n  atob\x2C\n};\n\nObjectDefineProperties(module.exports\x2C {\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  INSPECT_MAX_BYTES: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() { return INSPECT_MAX_BYTES; }\x2C\n    set(val) { INSPECT_MAX_BYTES = val; }\n  }\n});\n
code-source-info,0xb46bbe5f158,30,8545,9496,C3O8583C9O8618C12O8625C17O8661C18O8665C28O8720C33O8724C39O8755C51O8762C56O8811C57O8839C63O8856C68O8856C73O8871C78O8910C95O9001C104O9008C109O9048C110O9070C113O9070C118O9093C120O9106C122O9115C123O9121C125O9138C127O9137C134O9199C136O9205C138O9204C145O9223C151O9241C155O9286C158O9293C163O9333C164O9355C182O9361C187O9355,,
tick,0x7ff805db1607,135397,0,0x0,3,0x102d5e910,0xb46bbe5e3c3,0xb46f7def627,0x1132442e1,0xb46bbe5a782,0xb46f7def627,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805dd2b58,135414,0,0x0,3,0x102d5e910,0xb46bbe5e3c3,0xb46f7def627,0x1132442e1,0xb46bbe5a782,0xb46f7def627,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x10258952b,135427,0,0x0,3,0x102d5e910,0xb46bbe5e3c3,0xb46f7def627,0x1132442e1,0xb46bbe5a782,0xb46f7def627,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,LazyCompile,10,135442,0xb46bbe61cf0,110,fromString node:buffer:437:20,0xb469fceeb78,~
code-source-info,0xb46bbe61cf0,30,12596,13030,C0O12623C2O12630C8O12675C14O12682C19O12706C25O12713C30O12726C35O12733C40O12750C41O12755C46O12773C51O12783C56O12820C59O12826C64O12856C66O12885C73O12891C78O12885C79O12942C85O12949C90O12962C95O12969C100O12986C101O12993C104O13000C109O13028,,
code-creation,LazyCompile,10,135513,0xb46bbe61ea8,177,fromStringFast node:buffer:418:24,0xb469fceead8,~
code-source-info,0xb46bbe61ea8,30,12052,12575,C0O12089C5O12089C11O12112C14O12134C18O12143C21O12123C26O12155C31O12191C36O12162C41O12204C42O12208C44O12222C49O12233C51O12231C54O12219C59O12250C62O12250C65O12274C72O12289C77O12300C85O12274C91O12342C110O12342C116O12373C118O12384C123O12468C130O12487C135O12498C143O12472C149O12525C156O12539C162O12536C168O12549C171O12549C174O12564C176O12573,,
tick,0x7ff805f105d0,135589,0,0x0,3,0x102d5e910,0xb46bbe61d58,0xb46bbe5f164,0xb46bbe5e3c3,0xb46f7def627,0x1132442e1,0xb46bbe5a782,0xb46f7def627,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,LazyCompile,10,135608,0xb46bbe62098,36,FastBuffer node:internal/buffer:958:14,0xb469fcfb550,~
code-source-info,0xb46bbe62098,31,26364,26453,C3O26407C7O26441C20O26407C35O26452,,
code-creation,LazyCompile,10,135642,0xb46bbe62198,23,write node:buffer:598:12,0xb469fceee98,~
code-source-info,0xb46bbe62198,30,16664,16728,C0O16698C17O16698C22O16728,,
code-creation,LazyCompile,10,135687,0xb46bbe62288,42,alignPool node:buffer:163:19,0xb469fcee588,~
code-source-info,0xb46bbe62288,30,4118,4222,C0O4152C4O4167C9O4180C19O4191C25O4203C34O4213C41O4221,,
code-creation,LazyCompile,10,135787,0xb46bbe62668,251,promisify node:internal/util:324:19,0xb4665177a40,~
code-source-info,0xb46bbe62668,21,8873,10421,C0O8873C17O8935C25O8975C33O8999C38O8978C55O9035C68O9035C73O9078C80O9091C82O9090C87O9135C94O9144C96O9143C100O9176C110O9176C115O9228C126O9260C136O9324C143O9235C148O9390C149O9553C156O9562C158O9561C161O9553C163O10117C174O10142C180O10142C185O10117C190O10178C201O10203C211O10263C218O10178C223O10330C234O10373C240O10373C245O10337C250O10419,,
code-creation,LazyCompile,10,135934,0xb46bbe62c48,65,EventEmitterMixin node:internal/event_target:1015:27,0xb46d2ca8700,~
script-source,46,node:internal/event_target,'use strict';\n\nconst {\n  ArrayFrom\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ReflectApply\x2C\n  SafeArrayIterator\x2C\n  SafeFinalizationRegistry\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  SafeWeakRef\x2C\n  SafeWeakSet\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SymbolToStringTag\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_EVENT_RECURSION\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\nconst { validateObject\x2C validateString } = require('internal/validators');\n\nconst {\n  customInspectSymbol\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\nconst { inspect } = require('util');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\n\nconst EventEmitter = require('events');\nconst {\n  kMaxEventTargetListeners\x2C\n  kMaxEventTargetListenersWarned\x2C\n} = EventEmitter;\n\nconst kEvents = Symbol('kEvents');\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\nconst kStop = Symbol('kStop');\nconst kTarget = Symbol('kTarget');\nconst kHandlers = Symbol('khandlers');\nconst kWeakHandler = Symbol('kWeak');\n\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\nconst kCreateEvent = Symbol('kCreateEvent');\nconst kNewListener = Symbol('kNewListener');\nconst kRemoveListener = Symbol('kRemoveListener');\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\nconst kTrustEvent = Symbol('kTrustEvent');\n\nconst { now } = require('internal/perf/utils');\n\nconst kType = Symbol('type');\nconst kDetail = Symbol('detail');\n\nconst isTrustedSet = new SafeWeakSet();\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\n  get isTrusted() {\n    return isTrustedSet.has(this);\n  }\n}\x2C 'isTrusted').get;\n\nfunction isEvent(value) {\n  return typeof value?.[kType] === 'string';\n}\n\nclass Event {\n  #cancelable = false;\n  #bubbles = false;\n  #composed = false;\n  #defaultPrevented = false;\n  #timestamp = now();\n  #propagationStopped = false;\n\n  /**\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    validateObject(options\x2C 'options');\n    const { bubbles\x2C cancelable\x2C composed } = options;\n    this.#cancelable = !!cancelable;\n    this.#bubbles = !!bubbles;\n    this.#composed = !!composed;\n\n    this[kType] = `${type}`;\n    if (options?.[kTrustEvent]) {\n      isTrustedSet.add(this);\n    }\n\n    // isTrusted is special (LegacyUnforgeable)\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\n      __proto__: null\x2C\n      get: isTrusted\x2C\n      enumerable: true\x2C\n      configurable: false\n    });\n    this[kTarget] = null;\n    this[kIsBeingDispatched] = false;\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({\n      type: this[kType]\x2C\n      defaultPrevented: this.#defaultPrevented\x2C\n      cancelable: this.#cancelable\x2C\n      timeStamp: this.#timestamp\x2C\n    }\x2C opts)}`;\n  }\n\n  stopImmediatePropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this[kStop] = true;\n  }\n\n  preventDefault() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#defaultPrevented = true;\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get target() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get currentTarget() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {EventTarget}\n   */\n  get srcElement() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kTarget];\n  }\n\n  /**\n   * @type {string}\n   */\n  get type() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kType];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelable() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get defaultPrevented() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#cancelable && this.#defaultPrevented;\n  }\n\n  /**\n   * @type {number}\n   */\n  get timeStamp() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#timestamp;\n  }\n\n\n  // The following are non-op and unused properties/methods from Web API Event.\n  // These are not supported in Node.js and are provided purely for\n  // API completeness.\n  /**\n   * @returns {EventTarget[]}\n   */\n  composedPath() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get returnValue() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return !this.defaultPrevented;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get bubbles() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#bubbles;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get composed() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#composed;\n  }\n\n  /**\n   * @type {number}\n   */\n  get eventPhase() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get cancelBubble() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    return this.#propagationStopped;\n  }\n\n  /**\n   * @type {boolean}\n   */\n  set cancelBubble(value) {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    if (value) {\n      this.stopPropagation();\n    }\n  }\n\n  stopPropagation() {\n    if (!isEvent(this))\n      throw new ERR_INVALID_THIS('Event');\n    this.#propagationStopped = true;\n  }\n\n  static NONE = 0;\n  static CAPTURING_PHASE = 1;\n  static AT_TARGET = 2;\n  static BUBBLING_PHASE = 3;\n}\n\nObjectDefineProperties(\n  Event.prototype\x2C {\n    [SymbolToStringTag]: {\n      __proto__: null\x2C\n      writable: false\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: 'Event'\x2C\n    }\x2C\n    stopImmediatePropagation: kEnumerableProperty\x2C\n    preventDefault: kEnumerableProperty\x2C\n    target: kEnumerableProperty\x2C\n    currentTarget: kEnumerableProperty\x2C\n    srcElement: kEnumerableProperty\x2C\n    type: kEnumerableProperty\x2C\n    cancelable: kEnumerableProperty\x2C\n    defaultPrevented: kEnumerableProperty\x2C\n    timeStamp: kEnumerableProperty\x2C\n    composedPath: kEnumerableProperty\x2C\n    returnValue: kEnumerableProperty\x2C\n    bubbles: kEnumerableProperty\x2C\n    composed: kEnumerableProperty\x2C\n    eventPhase: kEnumerableProperty\x2C\n    cancelBubble: kEnumerableProperty\x2C\n    stopPropagation: kEnumerableProperty\x2C\n  });\n\nfunction isCustomEvent(value) {\n  return isEvent(value) && (value?.[kDetail] !== undefined);\n}\n\nclass CustomEvent extends Event {\n  /**\n   * @constructor\n   * @param {string} type\n   * @param {{\n   *   bubbles?: boolean\x2C\n   *   cancelable?: boolean\x2C\n   *   composed?: boolean\x2C\n   *   detail?: any\x2C\n   * }} [options]\n   */\n  constructor(type\x2C options = kEmptyObject) {\n    if (arguments.length === 0)\n      throw new ERR_MISSING_ARGS('type');\n    super(type\x2C options);\n    this[kDetail] = options?.detail ?? null;\n  }\n\n  /**\n   * @type {any}\n   */\n  get detail() {\n    if (!isCustomEvent(this))\n      throw new ERR_INVALID_THIS('CustomEvent');\n    return this[kDetail];\n  }\n}\n\nObjectDefineProperties(CustomEvent.prototype\x2C {\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'CustomEvent'\x2C\n  }\x2C\n  detail: kEnumerableProperty\x2C\n});\n\nclass NodeCustomEvent extends Event {\n  constructor(type\x2C options) {\n    super(type\x2C options);\n    if (options?.detail) {\n      this.detail = options.detail;\n    }\n  }\n}\n\n// Weak listener cleanup\n// This has to be lazy for snapshots to work\nlet weakListenersState = null;\n// The resource needs to retain the callback so that it doesn't\n// get garbage collected now that it's weak.\nlet objectToWeakListenerMap = null;\nfunction weakListeners() {\n  weakListenersState ??= new SafeFinalizationRegistry(\n    (listener) => listener.remove()\n  );\n  objectToWeakListenerMap ??= new SafeWeakMap();\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\n}\n\n// The listeners for an EventTarget are maintained as a linked list.\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\n// use of capture or bubbling\x2C in order to be spec compliant we have to\n// take on the additional complexity of supporting it. Fortunately\x2C using\n// the linked list makes dispatching faster\x2C even if adding/removing is\n// slower.\nclass Listener {\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n              isNodeStyleListener\x2C weak) {\n    this.next = undefined;\n    if (previous !== undefined)\n      previous.next = this;\n    this.previous = previous;\n    this.listener = listener;\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\n    this.once = once;\n    this.capture = capture;\n    this.passive = passive;\n    this.isNodeStyleListener = isNodeStyleListener;\n    this.removed = false;\n    this.weak = Boolean(weak); // Don't retain the object\n\n    if (this.weak) {\n      this.callback = new SafeWeakRef(listener);\n      weakListeners().registry.register(listener\x2C this\x2C this);\n      // Make the retainer retain the listener in a WeakMap\n      weakListeners().map.set(weak\x2C listener);\n      this.listener = this.callback;\n    } else if (typeof listener === 'function') {\n      this.callback = listener;\n      this.listener = listener;\n    } else {\n      this.callback = async (...args) => {\n        if (listener.handleEvent)\n          await ReflectApply(listener.handleEvent\x2C listener\x2C args);\n      };\n      this.listener = listener;\n    }\n  }\n\n  same(listener\x2C capture) {\n    const myListener = this.weak ? this.listener.deref() : this.listener;\n    return myListener === listener && this.capture === capture;\n  }\n\n  remove() {\n    if (this.previous !== undefined)\n      this.previous.next = this.next;\n    if (this.next !== undefined)\n      this.next.previous = this.previous;\n    this.removed = true;\n    if (this.weak)\n      weakListeners().registry.unregister(this);\n  }\n}\n\nfunction initEventTarget(self) {\n  self[kEvents] = new SafeMap();\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\n  self[kMaxEventTargetListenersWarned] = false;\n}\n\nclass EventTarget {\n  // Used in checking whether an object is an EventTarget. This is a well-known\n  // symbol as EventTarget may be used cross-realm.\n  // Ref: https://github.com/nodejs/node/pull/33661\n  static [kIsEventTarget] = true;\n\n  constructor() {\n    initEventTarget(this);\n  }\n\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\n    if (this[kMaxEventTargetListeners] > 0 &&\n        size > this[kMaxEventTargetListeners] &&\n        !this[kMaxEventTargetListenersWarned]) {\n      this[kMaxEventTargetListenersWarned] = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventTarget memory leak detected. ' +\n                          `${size} ${type} listeners ` +\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\n                          'events.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.target = this;\n      w.type = type;\n      w.count = size;\n      process.emitWarning(w);\n    }\n  }\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\n\n  /**\n   * @callback EventTargetCallback\n   * @param {Event} event\n   */\n\n  /**\n   * @typedef {{ handleEvent: EventTargetCallback }} EventListener\n   */\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   *   once?: boolean\x2C\n   *   passive?: boolean\x2C\n   *   signal?: AbortSignal\n   * }} [options]\n   */\n  addEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (arguments.length < 2)\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\n\n    // We validateOptions before the validateListener check because the spec\n    // requires us to hit getters.\n    const {\n      once\x2C\n      capture\x2C\n      passive\x2C\n      signal\x2C\n      isNodeStyleListener\x2C\n      weak\x2C\n    } = validateEventListenerOptions(options);\n\n    if (!validateEventListener(listener)) {\n      // The DOM silently allows passing undefined as a second argument\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error(`addEventListener called with ${listener}` +\n                          ' which has no effect.');\n      w.name = 'AddEventListenerArgumentTypeWarning';\n      w.target = this;\n      w.type = type;\n      process.emitWarning(w);\n      return;\n    }\n    type = String(type);\n\n    if (signal) {\n      if (signal.aborted) {\n        return;\n      }\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\n      // not prevent the event target from GC.\n      signal.addEventListener('abort'\x2C () => {\n        this.removeEventListener(type\x2C listener\x2C options);\n      }\x2C { once: true\x2C [kWeakHandler]: this });\n    }\n\n    let root = this[kEvents].get(type);\n\n    if (root === undefined) {\n      root = { size: 1\x2C next: undefined };\n      // This is the first handler in our linked list.\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                   isNodeStyleListener\x2C weak);\n      this[kNewListener](\n        root.size\x2C\n        type\x2C\n        listener\x2C\n        once\x2C\n        capture\x2C\n        passive\x2C\n        weak);\n      this[kEvents].set(type\x2C root);\n      return;\n    }\n\n    let handler = root.next;\n    let previous = root;\n\n    // We have to walk the linked list to see if we have a match\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\n      previous = handler;\n      handler = handler.next;\n    }\n\n    if (handler !== undefined) { // Duplicate! Ignore\n      return;\n    }\n\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\n                 isNodeStyleListener\x2C weak);\n    root.size++;\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   */\n  removeEventListener(type\x2C listener\x2C options = kEmptyObject) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    if (!validateEventListener(listener))\n      return;\n\n    type = String(type);\n    const capture = options?.capture === true;\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined)\n      return;\n\n    let handler = root.next;\n    while (handler !== undefined) {\n      if (handler.same(listener\x2C capture)) {\n        handler.remove();\n        root.size--;\n        if (root.size === 0)\n          this[kEvents].delete(type);\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n        break;\n      }\n      handler = handler.next;\n    }\n  }\n\n  /**\n   * @param {Event} event\n   */\n  dispatchEvent(event) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n\n    if (!(event instanceof Event))\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\n\n    if (event[kIsBeingDispatched])\n      throw new ERR_EVENT_RECURSION(event.type);\n\n    this[kHybridDispatch](event\x2C event.type\x2C event);\n\n    return event.defaultPrevented !== true;\n  }\n\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\n    const createEvent = () => {\n      if (event === undefined) {\n        event = this[kCreateEvent](nodeValue\x2C type);\n        event[kTarget] = this;\n        event[kIsBeingDispatched] = true;\n      }\n      return event;\n    };\n    if (event !== undefined) {\n      event[kTarget] = this;\n      event[kIsBeingDispatched] = true;\n    }\n\n    const root = this[kEvents].get(type);\n    if (root === undefined || root.next === undefined) {\n      if (event !== undefined)\n        event[kIsBeingDispatched] = false;\n      return true;\n    }\n\n    let handler = root.next;\n    let next;\n\n    while (handler !== undefined &&\n           (handler.passive || event?.[kStop] !== true)) {\n      // Cache the next item in case this iteration removes the current one\n      next = handler.next;\n\n      if (handler.removed) {\n        // Deal with the case an event is removed while event handlers are\n        // Being processed (removeEventListener called from a listener)\n        handler = next;\n        continue;\n      }\n      if (handler.once) {\n        handler.remove();\n        root.size--;\n        const { listener\x2C capture } = handler;\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\n      }\n\n      try {\n        let arg;\n        if (handler.isNodeStyleListener) {\n          arg = nodeValue;\n        } else {\n          arg = createEvent();\n        }\n        const callback = handler.weak ?\n          handler.callback.deref() : handler.callback;\n        let result;\n        if (callback) {\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\n          if (!handler.isNodeStyleListener) {\n            arg[kIsBeingDispatched] = false;\n          }\n        }\n        if (result !== undefined && result !== null)\n          addCatch(result);\n      } catch (err) {\n        emitUncaughtException(err);\n      }\n\n      handler = next;\n    }\n\n    if (event !== undefined)\n      event[kIsBeingDispatched] = false;\n  }\n\n  [kCreateEvent](nodeValue\x2C type) {\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\n  }\n  [customInspectSymbol](depth\x2C options) {\n    if (!isEventTarget(this))\n      throw new ERR_INVALID_THIS('EventTarget');\n    const name = this.constructor.name;\n    if (depth < 0)\n      return name;\n\n    const opts = ObjectAssign({}\x2C options\x2C {\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\n    });\n\n    return `${name} ${inspect({}\x2C opts)}`;\n  }\n}\n\nObjectDefineProperties(EventTarget.prototype\x2C {\n  addEventListener: kEnumerableProperty\x2C\n  removeEventListener: kEnumerableProperty\x2C\n  dispatchEvent: kEnumerableProperty\x2C\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: 'EventTarget'\x2C\n  }\n});\n\nfunction initNodeEventTarget(self) {\n  initEventTarget(self);\n}\n\nclass NodeEventTarget extends EventTarget {\n  static [kIsNodeEventTarget] = true;\n  static defaultMaxListeners = 10;\n\n  constructor() {\n    super();\n    initNodeEventTarget(this);\n  }\n\n  /**\n   * @param {number} n\n   */\n  setMaxListeners(n) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    EventEmitter.setMaxListeners(n\x2C this);\n  }\n\n  /**\n   * @returns {number}\n   */\n  getMaxListeners() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return this[kMaxEventTargetListeners];\n  }\n\n  /**\n   * @returns {string[]}\n   */\n  eventNames() {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    return ArrayFrom(this[kEvents].keys());\n  }\n\n  /**\n   * @param {string} [type]\n   * @returns {number}\n   */\n  listenerCount(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    const root = this[kEvents].get(String(type));\n    return root !== undefined ? root.size : 0;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  off(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @param {{\n   *   capture?: boolean\x2C\n   * }} [options]\n   * @returns {NodeEventTarget}\n   */\n  removeListener(type\x2C listener\x2C options) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.removeEventListener(type\x2C listener\x2C options);\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  on(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  addListener(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @param {any} arg\n   * @returns {boolean}\n   */\n  emit(type\x2C arg) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    validateString(type\x2C 'type');\n    const hadListeners = this.listenerCount(type) > 0;\n    this[kHybridDispatch](arg\x2C type);\n    return hadListeners;\n  }\n\n  /**\n   * @param {string} type\n   * @param {EventTargetCallback|EventListener} listener\n   * @returns {NodeEventTarget}\n   */\n  once(type\x2C listener) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    this.addEventListener(type\x2C listener\x2C\n                          { once: true\x2C [kIsNodeStyleListener]: true });\n    return this;\n  }\n\n  /**\n   * @param {string} type\n   * @returns {NodeEventTarget}\n   */\n  removeAllListeners(type) {\n    if (!isNodeEventTarget(this))\n      throw new ERR_INVALID_THIS('NodeEventTarget');\n    if (type !== undefined) {\n      this[kEvents].delete(String(type));\n    } else {\n      this[kEvents].clear();\n    }\n\n    return this;\n  }\n}\n\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\n  setMaxListeners: kEnumerableProperty\x2C\n  getMaxListeners: kEnumerableProperty\x2C\n  eventNames: kEnumerableProperty\x2C\n  listenerCount: kEnumerableProperty\x2C\n  off: kEnumerableProperty\x2C\n  removeListener: kEnumerableProperty\x2C\n  on: kEnumerableProperty\x2C\n  addListener: kEnumerableProperty\x2C\n  once: kEnumerableProperty\x2C\n  emit: kEnumerableProperty\x2C\n  removeAllListeners: kEnumerableProperty\x2C\n});\n\n// EventTarget API\n\nfunction validateEventListener(listener) {\n  if (typeof listener === 'function' ||\n      typeof listener?.handleEvent === 'function') {\n    return true;\n  }\n\n  if (listener == null)\n    return false;\n\n  if (typeof listener === 'object') {\n    // Require `handleEvent` lazily.\n    return true;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\n}\n\nfunction validateEventListenerOptions(options) {\n  if (typeof options === 'boolean')\n    return { capture: options };\n\n  if (options === null)\n    return kEmptyObject;\n  validateObject(options\x2C 'options'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  return {\n    once: Boolean(options.once)\x2C\n    capture: Boolean(options.capture)\x2C\n    passive: Boolean(options.passive)\x2C\n    signal: options.signal\x2C\n    weak: options[kWeakHandler]\x2C\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\n  };\n}\n\n// Test whether the argument is an event object. This is far from a fool-proof\n// test\x2C for example this input will result in a false positive:\n// > isEventTarget({ constructor: EventTarget })\n// It stands in its current implementation as a compromise.\n// Ref: https://github.com/nodejs/node/pull/33661\nfunction isEventTarget(obj) {\n  return obj?.constructor?.[kIsEventTarget];\n}\n\nfunction isNodeEventTarget(obj) {\n  return obj?.constructor?.[kIsNodeEventTarget];\n}\n\nfunction addCatch(promise) {\n  const then = promise.then;\n  if (typeof then === 'function') {\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\n      // The callback is called with nextTick to avoid a follow-up\n      // rejection from this promise.\n      emitUncaughtException(err);\n    });\n  }\n}\n\nfunction emitUncaughtException(err) {\n  process.nextTick(() => { throw err; });\n}\n\nfunction makeEventHandler(handler) {\n  // Event handlers are dispatched in the order they were first set\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\n  function eventHandler(...args) {\n    if (typeof eventHandler.handler !== 'function') {\n      return;\n    }\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\n  }\n  eventHandler.handler = handler;\n  return eventHandler;\n}\n\nfunction defineEventHandler(emitter\x2C name) {\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\n    __proto__: null\x2C\n    get() {\n      return this[kHandlers]?.get(name)?.handler ?? null;\n    }\x2C\n    set(value) {\n      if (!this[kHandlers]) {\n        this[kHandlers] = new SafeMap();\n      }\n      let wrappedHandler = this[kHandlers]?.get(name);\n      if (wrappedHandler) {\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size--;\n          const size = this[kEvents].get(name).size;\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\n        }\n        wrappedHandler.handler = value;\n        if (typeof wrappedHandler.handler === 'function') {\n          this[kEvents].get(name).size++;\n          const size = this[kEvents].get(name).size;\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false\x2C false);\n        }\n      } else {\n        wrappedHandler = makeEventHandler(value);\n        this.addEventListener(name\x2C wrappedHandler);\n      }\n      this[kHandlers].set(name\x2C wrappedHandler);\n    }\x2C\n    configurable: true\x2C\n    enumerable: true\n  });\n}\n\nconst EventEmitterMixin = (Superclass) => {\n  class MixedEventEmitter extends Superclass {\n    constructor(...args) {\n      args = new SafeArrayIterator(args);\n      super(...args);\n      FunctionPrototypeCall(EventEmitter\x2C this);\n    }\n  }\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\n  delete protoProps.constructor;\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\n  return MixedEventEmitter;\n};\n\nmodule.exports = {\n  Event\x2C\n  CustomEvent\x2C\n  EventEmitterMixin\x2C\n  EventTarget\x2C\n  NodeEventTarget\x2C\n  defineEventHandler\x2C\n  initEventTarget\x2C\n  initNodeEventTarget\x2C\n  kCreateEvent\x2C\n  kNewListener\x2C\n  kTrustEvent\x2C\n  kRemoveListener\x2C\n  kEvents\x2C\n  kWeakHandler\x2C\n  isEventTarget\x2C\n};\n
code-source-info,0xb46bbe62c48,46,26495,26917,C0O26547C23O26731C30O26763C33O26776C38O26731C43O26790C47O26823C52O26864C57O26823C62O26890C64O26915,,
tick,0x7ff805dbdf68,139041,0,0x0,3,0x102d5e910,0xb46bbe5a9b6,0xb46f7def627,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805e4dde4,139058,0,0x0,3,0x102d5e910,0xb46bbe5a9b6,0xb46f7def627,0x1132442e1,0xb46bbe5585f,0xb46f7def627,0x1132442e1,0xb469fbe232f,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x102c711b0,139374,1,0x10266e4e0,2,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe2340,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,139538,0xb46bbe65810,5, node:internal/modules/esm/translators:1:1,0xb46bbe653a8,~
script-source,416,node:internal/modules/esm/translators,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  Boolean\x2C\n  JSONParse\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectKeys\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeStartsWith\x2C\n  SyntaxErrorPrototype\x2C\n  globalThis: { WebAssembly }\x2C\n} = primordials;\n\nlet _TYPES = null;\nfunction lazyTypes() {\n  if (_TYPES !== null) return _TYPES;\n  return _TYPES = require('internal/util/types');\n}\n\nconst { readFileSync } = require('fs');\nconst { extname\x2C isAbsolute } = require('path');\nconst {\n  hasEsmSyntax\x2C\n  loadNativeModule\x2C\n  stripBOM\x2C\n} = require('internal/modules/cjs/helpers');\nconst {\n  Module: CJSModule\x2C\n  cjsParseCache\n} = require('internal/modules/cjs/loader');\nconst internalURLModule = require('internal/url');\nconst createDynamicModule = require(\n  'internal/modules/esm/create_dynamic_module');\nconst { fileURLToPath\x2C URL } = require('url');\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\nconst { emitExperimentalWarning } = require('internal/util');\nconst {\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\n  ERR_INVALID_RETURN_PROPERTY_VALUE\n} = require('internal/errors').codes;\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\nconst moduleWrap = internalBinding('module_wrap');\nconst { ModuleWrap } = moduleWrap;\nconst asyncESM = require('internal/process/esm_loader');\nconst { emitWarningSync } = require('internal/process/warning');\nconst { TextDecoder } = require('internal/encoding');\n\nlet cjsParse;\nasync function initCJSParse() {\n  if (typeof WebAssembly === 'undefined') {\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n  } else {\n    const { parse\x2C init } =\n        require('internal/deps/cjs-module-lexer/dist/lexer');\n    try {\n      await init();\n      cjsParse = parse;\n    } catch {\n      cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\n    }\n  }\n}\n\nconst translators = new SafeMap();\nexports.translators = translators;\nexports.enrichCJSError = enrichCJSError;\n\nlet DECODER = null;\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\n  if (allowString && typeof body === 'string') {\n    return;\n  }\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\n    return;\n  }\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\n    hookName\x2C\n    'source'\x2C\n    body\n  );\n}\n\nfunction stringify(body) {\n  if (typeof body === 'string') return body;\n  assertBufferSource(body\x2C false\x2C 'transformSource');\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\n  return DECODER.decode(body);\n}\n\nfunction errPath(url) {\n  const parsed = new URL(url);\n  if (parsed.protocol === 'file:') {\n    return fileURLToPath(parsed);\n  }\n  return url;\n}\n\nasync function importModuleDynamically(specifier\x2C { url }\x2C assertions) {\n  return asyncESM.esmLoader.import(specifier\x2C url\x2C assertions);\n}\n\n// Strategy for loading a standard JavaScript module.\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\n  assertBufferSource(source\x2C true\x2C 'load');\n  source = stringify(source);\n  maybeCacheSourceMap(url\x2C source);\n  debug(`Translating StandardModule ${url}`);\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\n  moduleWrap.callbackMap.set(module\x2C {\n    initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C { url })\x2C\n    importModuleDynamically\x2C\n  });\n  return module;\n});\n\n/**\n * @param {Error | any} err\n * @param {string} [content] Content of the file\x2C if known.\n * @param {string} [filename] Useful only if `content` is unknown.\n */\nfunction enrichCJSError(err\x2C content\x2C filename) {\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\n    // Emit the warning synchronously because we are in the middle of handling\n    // a SyntaxError that will throw and likely terminate the process before an\n    // asynchronous warning would be emitted.\n    emitWarningSync(\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\n      'the .mjs extension.'\n    );\n  }\n}\n\n// Strategy for loading a node-style CommonJS module\nconst isWindows = process.platform === 'win32';\nconst winSepRegEx = /\\//g;\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\n                                                            isMain) {\n  debug(`Translating CJSModule ${url}`);\n\n  let filename = internalURLModule.fileURLToPath(new URL(url));\n  if (isWindows)\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\n\n  if (!cjsParse) await initCJSParse();\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\n  const namesWithDefault = exportNames.has('default') ?\n    [...exportNames] : ['default'\x2C ...exportNames];\n\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\n    debug(`Loading CJSModule ${url}`);\n\n    let exports;\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\n      exports = asyncESM.esmLoader.cjsCache.get(module);\n      asyncESM.esmLoader.cjsCache.delete(module);\n    } else {\n      try {\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\n      } catch (err) {\n        enrichCJSError(err\x2C undefined\x2C filename);\n        throw err;\n      }\n    }\n\n    for (const exportName of exportNames) {\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\n          exportName === 'default')\n        continue;\n      // We might trigger a getter -> dont fail.\n      let value;\n      try {\n        value = exports[exportName];\n      } catch {\n        // Continue regardless of error.\n      }\n      this.setExport(exportName\x2C value);\n    }\n    this.setExport('default'\x2C exports);\n  });\n});\n\nfunction cjsPreparseModuleExports(filename) {\n  let module = CJSModule._cache[filename];\n  if (module) {\n    const cached = cjsParseCache.get(module);\n    if (cached)\n      return { module\x2C exportNames: cached.exportNames };\n  }\n  const loaded = Boolean(module);\n  if (!loaded) {\n    module = new CJSModule(filename);\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n    CJSModule._cache[filename] = module;\n  }\n\n  let source;\n  try {\n    source = readFileSync(filename\x2C 'utf8');\n  } catch {\n    // Continue regardless of error.\n  }\n\n  let exports\x2C reexports;\n  try {\n    ({ exports\x2C reexports } = cjsParse(source || ''));\n  } catch {\n    exports = [];\n    reexports = [];\n  }\n\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\n\n  // Set first for cycles.\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\n\n  if (reexports.length) {\n    module.filename = filename;\n    module.paths = CJSModule._nodeModulePaths(module.path);\n  }\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\n    let resolved;\n    try {\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\n    } catch {\n      return;\n    }\n    const ext = extname(resolved);\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\n        isAbsolute(resolved)) {\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\n      for (const name of reexportNames)\n        exportNames.add(name);\n    }\n  });\n\n  return { module\x2C exportNames };\n}\n\n// Strategy for loading a node builtin CommonJS module that isn't\n// through normal resolution\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\n  debug(`Translating BuiltinModule ${url}`);\n  // Slice 'node:' scheme\n  const id = StringPrototypeSlice(url\x2C 5);\n  const module = loadNativeModule(id\x2C url);\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\n  }\n  debug(`Loading BuiltinModule ${url}`);\n  return module.getESMFacade();\n});\n\n// Strategy for loading a JSON file\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\n  emitExperimentalWarning('Importing JSON modules');\n  assertBufferSource(source\x2C true\x2C 'load');\n  debug(`Loading JSONModule ${url}`);\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\n    fileURLToPath(url) : null;\n  let modulePath;\n  let module;\n  if (pathname) {\n    modulePath = isWindows ?\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  source = stringify(source);\n  if (pathname) {\n    // A require call could have been called on the same file during loading and\n    // that resolves synchronously. To make sure we always return the identical\n    // export\x2C we have to check again if the module already exists or not.\n    module = CJSModule._cache[modulePath];\n    if (module && module.loaded) {\n      const exports = module.exports;\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n        this.setExport('default'\x2C exports);\n      });\n    }\n  }\n  try {\n    const exports = JSONParse(stripBOM(source));\n    module = {\n      exports\x2C\n      loaded: true\n    };\n  } catch (err) {\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\n    // parse error instead of just manipulating the original error message.\n    // That would allow to add further properties and maybe additional\n    // debugging information.\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n  if (pathname) {\n    CJSModule._cache[modulePath] = module;\n  }\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\n    debug(`Parsing JSONModule ${url}`);\n    this.setExport('default'\x2C module.exports);\n  });\n});\n\n// Strategy for loading a wasm module\ntranslators.set('wasm'\x2C async function(url\x2C source) {\n  emitExperimentalWarning('Importing WebAssembly modules');\n\n  assertBufferSource(source\x2C false\x2C 'load');\n\n  debug(`Translating WASMModule ${url}`);\n\n  let compiled;\n  try {\n    compiled = await WebAssembly.compile(source);\n  } catch (err) {\n    err.message = errPath(url) + ': ' + err.message;\n    throw err;\n  }\n\n  const imports =\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\n                        ({ module }) => module);\n  const exports =\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\n                      ({ name }) => name);\n\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\n    for (const expt of ObjectKeys(exports))\n      reflect.exports[expt].set(exports[expt]);\n  }).module;\n});\n
code-source-info,0xb46bbe65810,416,0,10763,C0O0C4O10763,,
tick,0x7ff805e4dd52,140788,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe2340,0xb46f7def627,0x1132442e1,0xb469fbe01e1,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Function,10,140802,0xb46bbe65fb8,715, node:internal/modules/esm/translators:1:1,0xb46bbe65788,~
code-source-info,0xb46bbe65fb8,416,0,10763,C0O0C180O25C186O50C192O71C198O82C204O95C210O119C216O152C222O166C228O187C233O198C239O209C245O235C251O259C257O288C268O326C274O372C275O372C277O517C283O517C288O500C294O564C300O564C305O540C311O549C317O641C323O641C328O591C334O607C340O627C346O731C352O731C357O700C363O713C369O797C375O797C379O797C381O850C387O850C391O850C393O939C399O939C404O916C410O931C416O967C422O967C427O1000C440O1001C446O967C448O1081C454O1081C459O1053C465O1185C471O1185C476O1211C481O1117C487O1147C493O1251C499O1251C504O1227C510O1319C513O1319C517O1319C519O1374C522O1359C528O1403C534O1403C538O1403C540O1471C546O1471C551O1451C557O1532C563O1532C568O1516C574O1567C575O1567C577O1997C579O1997C585O2012C587O2032C591O2047C593O2070C597O2103C598O2103C600O3104C613O3104C619O4352C626O4361C629O4344C631O4394C635O4394C637O4413C650O4413C656O7505C669O7505C675O7954C688O7954C694O9902C707O9902C714O10762,,
code-creation,Eval,10,141033,0xb46bbe674c8,5, node:internal/modules/esm/create_dynamic_module:1:1,0xb46bbe672f0,~
script-source,417,node:internal/modules/esm/create_dynamic_module,'use strict';\n\nconst {\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  JSONStringify\x2C\n  ObjectCreate\x2C\n  SafeSet\x2C\n} = primordials;\n\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\n  debug = fn;\n});\n\nfunction createImport(impt\x2C index) {\n  const imptPath = JSONStringify(impt);\n  return `import * as $import_${index} from ${imptPath};\nimport.meta.imports[${imptPath}] = $import_${index};`;\n}\n\nfunction createExport(expt) {\n  const name = `${expt}`;\n  return `let $${name};\nexport { $${name} as ${name} };\nimport.meta.exports.${name} = {\n  get: () => $${name}\x2C\n  set: (v) => $${name} = v\x2C\n};`;\n}\n\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\n  const source = `\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\nimport.meta.done();\n`;\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\n\n  const readyfns = new SafeSet();\n  const reflect = {\n    exports: ObjectCreate(null)\x2C\n    onReady: (cb) => { readyfns.add(cb); }\x2C\n  };\n\n  if (imports.length)\n    reflect.imports = ObjectCreate(null);\n\n  callbackMap.set(m\x2C {\n    initializeImportMeta: (meta\x2C wrap) => {\n      meta.exports = reflect.exports;\n      if (reflect.imports)\n        meta.imports = reflect.imports;\n      meta.done = () => {\n        evaluate(reflect);\n        reflect.onReady = (cb) => cb(reflect);\n        for (const fn of readyfns) {\n          readyfns.delete(fn);\n          fn(reflect);\n        }\n      };\n    }\x2C\n  });\n\n  return {\n    module: m\x2C\n    reflect\x2C\n  };\n};\n\nmodule.exports = createDynamicModule;\n
code-source-info,0xb46bbe674c8,417,0,1756,C0O0C4O1756,,
code-creation,Function,10,141271,0xb46bbe676f0,111, node:internal/modules/esm/create_dynamic_module:1:1,0xb46bbe67440,~
code-source-info,0xb46bbe676f0,417,0,1756,C0O0C39O25C45O47C51O68C57O85C63O101C69O140C72O140C77O173C90O174C96O140C98O642C103O1718C105O1733C110O1755,,
code-creation,Eval,10,141762,0xb46bbe68628,5, node:internal/vm/module:1:1,0xb46bbe680b0,~
script-source,418,node:internal/vm/module,'use strict';\n\nconst assert = require('internal/assert');\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeSome\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  SafePromiseAll\x2C\n  SafeWeakMap\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  TypeError\x2C\n} = primordials;\n\nconst { isContext } = internalBinding('contextify');\nconst {\n  isModuleNamespaceObject\x2C\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  customInspectSymbol\x2C\n  emitExperimentalWarning\x2C\n  getConstructorOf\x2C\n  kEmptyObject\x2C\n} = require('internal/util');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\n  ERR_VM_MODULE_LINK_FAILURE\x2C\n  ERR_VM_MODULE_NOT_MODULE\x2C\n  ERR_VM_MODULE_STATUS\x2C\n} = require('internal/errors').codes;\nconst {\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateUint32\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst binding = internalBinding('module_wrap');\nconst {\n  ModuleWrap\x2C\n  kUninstantiated\x2C\n  kInstantiating\x2C\n  kInstantiated\x2C\n  kEvaluating\x2C\n  kEvaluated\x2C\n  kErrored\x2C\n} = binding;\n\nconst STATUS_MAP = {\n  [kUninstantiated]: 'unlinked'\x2C\n  [kInstantiating]: 'linking'\x2C\n  [kInstantiated]: 'linked'\x2C\n  [kEvaluating]: 'evaluating'\x2C\n  [kEvaluated]: 'evaluated'\x2C\n  [kErrored]: 'errored'\x2C\n};\n\nlet globalModuleId = 0;\nconst defaultModuleName = 'vm:module';\nconst wrapToModuleMap = new SafeWeakMap();\n\nconst kWrap = Symbol('kWrap');\nconst kContext = Symbol('kContext');\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\nconst kLink = Symbol('kLink');\n\nclass Module {\n  constructor(options) {\n    emitExperimentalWarning('VM Modules');\n\n    if (new.target === Module) {\n      // eslint-disable-next-line no-restricted-syntax\n      throw new TypeError('Module is not a constructor');\n    }\n\n    const {\n      context\x2C\n      sourceText\x2C\n      syntheticExportNames\x2C\n      syntheticEvaluationSteps\x2C\n    } = options;\n\n    if (context !== undefined) {\n      validateObject(context\x2C 'context');\n      if (!isContext(context)) {\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\n                                       context);\n      }\n    }\n\n    let { identifier } = options;\n    if (identifier !== undefined) {\n      validateString(identifier\x2C 'options.identifier');\n    } else if (context === undefined) {\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\n    } else if (context[kPerContextModuleId] !== undefined) {\n      const curId = context[kPerContextModuleId];\n      identifier = `${defaultModuleName}(${curId})`;\n      context[kPerContextModuleId] += 1;\n    } else {\n      identifier = `${defaultModuleName}(0)`;\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\n        __proto__: null\x2C\n        value: 1\x2C\n        writable: true\x2C\n        enumerable: false\x2C\n        configurable: true\x2C\n      });\n    }\n\n    if (sourceText !== undefined) {\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\n                                   options.lineOffset\x2C options.columnOffset\x2C\n                                   options.cachedData);\n\n      binding.callbackMap.set(this[kWrap]\x2C {\n        initializeImportMeta: options.initializeImportMeta\x2C\n        importModuleDynamically: options.importModuleDynamically ?\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\n          undefined\x2C\n      });\n    } else {\n      assert(syntheticEvaluationSteps);\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\n                                   syntheticExportNames\x2C\n                                   syntheticEvaluationSteps);\n    }\n\n    wrapToModuleMap.set(this[kWrap]\x2C this);\n\n    this[kContext] = context;\n  }\n\n  get identifier() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kWrap].url;\n  }\n\n  get context() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return this[kContext];\n  }\n\n  get namespace() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\n    }\n    return this[kWrap].getNamespace();\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    return STATUS_MAP[this[kWrap].getStatus()];\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kWrap].getStatus() !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS('must be errored');\n    }\n    return this[kWrap].getError();\n  }\n\n  async link(linker) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateFunction(linker\x2C 'linker');\n    if (this.status === 'linked') {\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\n    }\n    if (this.status !== 'unlinked') {\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\n    }\n    await this[kLink](linker);\n    this[kWrap].instantiate();\n  }\n\n  async evaluate(options = kEmptyObject) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n\n    validateObject(options\x2C 'options');\n\n    let timeout = options.timeout;\n    if (timeout === undefined) {\n      timeout = -1;\n    } else {\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\n    }\n    const { breakOnSigint = false } = options;\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n    const status = this[kWrap].getStatus();\n    if (status !== kInstantiated &&\n        status !== kEvaluated &&\n        status !== kErrored) {\n      throw new ERR_VM_MODULE_STATUS(\n        'must be one of linked\x2C evaluated\x2C or errored'\n      );\n    }\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\n  }\n\n  [customInspectSymbol](depth\x2C options) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || Module;\n    const o = ObjectCreate({ constructor });\n    o.status = this.status;\n    o.identifier = this.identifier;\n    o.context = this.context;\n\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\n      __proto__: null\x2C\n      value: constructor.name\x2C\n      configurable: true\n    });\n\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return inspect(o\x2C { ...options\x2C customInspect: false });\n  }\n}\n\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\nconst kNoError = Symbol('kNoError');\n\nclass SourceTextModule extends Module {\n  #error = kNoError;\n  #statusOverride;\n\n  constructor(sourceText\x2C options = kEmptyObject) {\n    validateString(sourceText\x2C 'sourceText');\n    validateObject(options\x2C 'options');\n\n    const {\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n      context\x2C\n      identifier\x2C\n      cachedData\x2C\n    } = options;\n\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n\n    if (initializeImportMeta !== undefined &&\n        typeof initializeImportMeta !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\n    }\n\n    if (importModuleDynamically !== undefined &&\n        typeof importModuleDynamically !== 'function') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.importModuleDynamically'\x2C 'function'\x2C\n        importModuleDynamically);\n    }\n\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n\n    super({\n      sourceText\x2C\n      context\x2C\n      identifier\x2C\n      lineOffset\x2C\n      columnOffset\x2C\n      cachedData\x2C\n      initializeImportMeta\x2C\n      importModuleDynamically\x2C\n    });\n\n    this[kLink] = async (linker) => {\n      this.#statusOverride = 'linking';\n\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\n        const module = await linker(identifier\x2C this\x2C { assert });\n        if (module[kWrap] === undefined) {\n          throw new ERR_VM_MODULE_NOT_MODULE();\n        }\n        if (module.context !== this.context) {\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\n        }\n        if (module.status === 'errored') {\n          throw new ERR_VM_MODULE_LINK_FAILURE(`request for '${identifier}' resolved to an errored module`\x2C module.error);\n        }\n        if (module.status === 'unlinked') {\n          await module[kLink](linker);\n        }\n        return module[kWrap];\n      });\n\n      try {\n        if (promises !== undefined) {\n          await SafePromiseAll(promises);\n        }\n      } catch (e) {\n        this.#error = e;\n        throw e;\n      } finally {\n        this.#statusOverride = undefined;\n      }\n    };\n\n    this[kDependencySpecifiers] = undefined;\n  }\n\n  get dependencySpecifiers() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this[kDependencySpecifiers] === undefined) {\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\n    }\n    return this[kDependencySpecifiers];\n  }\n\n  get status() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return 'errored';\n    }\n    if (this.#statusOverride) {\n      return this.#statusOverride;\n    }\n    return super.status;\n  }\n\n  get error() {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (this.#error !== kNoError) {\n      return this.#error;\n    }\n    return super.error;\n  }\n\n  createCachedData() {\n    const { status } = this;\n    if (status === 'evaluating' ||\n        status === 'evaluated' ||\n        status === 'errored') {\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\n    }\n    return this[kWrap].createCachedData();\n  }\n}\n\nclass SyntheticModule extends Module {\n  constructor(exportNames\x2C evaluateCallback\x2C options = kEmptyObject) {\n    if (!ArrayIsArray(exportNames) ||\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\n                                     'Array of unique strings'\x2C\n                                     exportNames);\n    } else {\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\n                                          name\x2C\n                                          'is duplicated');\n        }\n      });\n    }\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\n\n    validateObject(options\x2C 'options');\n\n    const { context\x2C identifier } = options;\n\n    super({\n      syntheticExportNames: exportNames\x2C\n      syntheticEvaluationSteps: evaluateCallback\x2C\n      context\x2C\n      identifier\x2C\n    });\n\n    this[kLink] = () => this[kWrap].link(() => {\n      assert.fail('link callback should not be called');\n    });\n  }\n\n  setExport(name\x2C value) {\n    if (this[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    validateString(name\x2C 'name');\n    if (this[kWrap].getStatus() < kInstantiated) {\n      throw new ERR_VM_MODULE_STATUS('must be linked');\n    }\n    this[kWrap].setExport(name\x2C value);\n  }\n}\n\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\n  const importModuleDynamicallyWrapper = async (...args) => {\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\n    if (isModuleNamespaceObject(m)) {\n      return m;\n    }\n    if (!m || m[kWrap] === undefined) {\n      throw new ERR_VM_MODULE_NOT_MODULE();\n    }\n    if (m.status === 'errored') {\n      throw m.error;\n    }\n    return m.namespace;\n  };\n  return importModuleDynamicallyWrapper;\n}\n\nmodule.exports = {\n  Module\x2C\n  SourceTextModule\x2C\n  SyntheticModule\x2C\n  importModuleDynamicallyWrap\x2C\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\n};\n
code-source-info,0xb46bbe68628,418,0,12372,C0O0C4O12372,,
code-creation,Function,10,143233,0xb46bbe69890,881, node:internal/vm/module:1:1,0xb46bbe685a0,~
code-source-info,0xb46bbe69890,418,0,12372,C0O0C159O30C165O30C169O30C171O68C177O84C183O109C189O134C195O156C201O172C207O196C213O220C219O244C225O260C231O278C236O293C241O303C247O324C253O375C256O375C261O361C267O466C273O466C278O416C284O443C290O596C296O596C301O508C306O531C312O558C318O578C324O875C330O875C335O901C340O632C346O656C352O681C358O713C364O748C370O791C376O821C382O849C388O1031C394O1031C399O919C405O938C411O958C417O975C423O993C429O1011C435O1080C438O1080C442O1080C444O1233C447O1122C453O1136C458O1155C463O1173C469O1190C474O1205C480O1219C486O1262C493O1267C497O1285C504O1300C508O1317C515O1331C519O1347C526O1360C530O1374C537O1391C541O1404C548O1420C552O1431C559O1262C561O1467C562O1467C564O1496C566O1496C568O1533C570O1533C575O1533C577O1567C580O1567C584O1567C586O1601C589O1601C593O1601C595O1649C598O1649C602O1649C604O1694C607O1694C611O1694C669O5975C697O6758C700O6758C704O6758C706O6808C709O6808C713O6808C745O6860C808O10317C836O12212C843O12233C849O12243C855O12263C861O12282C865O12332C875O12227C880O12371,,
code-creation,Function,10,143328,0xb46bbe69de0,23,<instance_members_initializer> node:internal/vm/module:258:1,0xb46bbe68c10,~
code-source-info,0xb46bbe69de0,418,6829,10285,C3O6880C17O6892C22O10285,,
tick,0x7ff805dd2b58,143352,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe0214,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
tick,0x7ff805e2d43e,143364,1,0x10266e4e0,3,0x1027fed10,0xb46f7def606,0x1132442e1,0xb469fbe0214,0xb46f7def627,0x1132442e1,0xb469fbdb847,0xb46f7def627,0x1132442e1,0xb469fbd67d6,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,LazyCompile,10,143575,0xb46bbe6b448,161,ESMLoader node:internal/modules/esm/loader:248:14,0xb469fbe1918,~
code-source-info,0xb46bbe6b448,399,7158,7764,C5O7158C23O7167C33O7171C38O7210C44O7218C49O7231C59O7231C63O7288C73O7292C79O7350C89O7350C93O7404C105O7459C111O7459C118O7513C123O7538C128O7546C139O7546C145O7713C151O7747C160O7763,,
code-creation,LazyCompile,10,143642,0xb46bbe6d4f0,27,ModuleMap node:internal/modules/esm/module_map:17:14,0xb469fbe4a20,~
code-source-info,0xb46bbe6d4f0,400,518,535,C3O524C7O530C11O524C26O534,,
code-creation,LazyCompile,10,143701,0xb46bbe6d790,13,desc.value node:internal/per_context/primordials:340:32,0xb4665145f20,~
code-source-info,0xb46bbe6d790,12,9873,9932,C0O9890C7O9897C12O9920,,
code-creation,LazyCompile,10,143733,0xb46bbe6d890,13,SafeIterator node:internal/per_context/primordials:285:16,0xb4665145a38,~
code-source-info,0xb46bbe6d890,12,8138,8198,C0O8157C3O8174C7O8172C12O8197,,
code-creation,LazyCompile,10,143768,0xb46bbe6d9c0,13,next node:internal/per_context/primordials:288:9,0xb4665145ad8,~
code-source-info,0xb46bbe6d9c0,12,8207,8252,C0O8218C3O8235C8O8225C12O8246,,
code-creation,LazyCompile,10,143802,0xb46bbe6dab0,19,canBeRequiredWithoutScheme node:internal/bootstrap/loaders:254:36,0xb466514b680,~
code-source-info,0xb46bbe6dab0,15,7775,7826,C0O7786C7O7814C12O7814C18O7822,,
code-creation,LazyCompile,10,143959,0xb46bbe6dce8,32, node:internal/modules/cjs/loader:192:41,0xb469fbd9c88,~
code-source-info,0xb46bbe6dce8,396,5814,5840,C0O5822C9O5823C21O5835C31O5840,,
code-creation,LazyCompile,10,144063,0xb46bbe707b8,19,getSchemeOnlyModuleNames node:internal/bootstrap/loaders:258:34,0xb466514b6d0,~
code-source-info,0xb46bbe707b8,15,7861,7912,C0O7870C11O7887C14O7877C18O7908,,
code-creation,LazyCompile,10,144114,0xb46bbe70900,26, node:internal/modules/cjs/loader:194:49,0xb469fbd9cd8,~
code-source-info,0xb46bbe70900,396,5893,5940,C0O5918C5O5918C15O5930C20O5918C25O5940,,
code-creation,LazyCompile,10,144199,0xb46bbe70c80,152,deprecate node:internal/util:96:19,0xb46651773e0,~
code-source-info,0xb46bbe70c80,21,2401,3577,C0O2401C26O2421C31O2433C37O2447C42O2463C44O2473C45O2528C53O2566C61O2588C66O2569C83O2624C87O2652C100O2652C105O2698C106O2698C108O3273C121O3273C126O3313C129O3320C135O3513C141O3539C145O3534C149O3557C151O3575,,
code-creation,LazyCompile,10,144269,0xb46bbe71220,28,getEmbedderOptions node:internal/options:32:28,0xb46806bdbd8,~
code-source-info,0xb46bbe71220,88,760,877,C0O767C6O795C11O813C17O811C23O852C27O875,,
code-creation,LazyCompile,10,144333,0xb46bbe714c8,315,Module._initPaths node:internal/modules/cjs/loader:1248:29,0xb469fbda7e8,~
code-source-info,0xb46bbe714c8,396,39022,39978,C0O39045C9O39065C14O39069C22O39083C28O39083C33O39122C42O39142C47O39146C55O39158C61O39158C66O39353C74O39369C77O39374C85O39390C93O39374C103O39412C106O39417C114O39433C125O39417C131O39473C140O39474C143O39479C157O39479C169O39518C173O39537C180O39566C183O39571C191O39571C198O39537C203O39613C210O39642C213O39647C221O39647C228O39613C233O39690C237O39710C244O39744C249O39772C254O39803C257O39808C262O39772C270O39826C273O39744C279O39710C284O39849C286O39861C292O39922C297O39943C302O39963C305O39943C309O39941C314O39977,,
tick,0x113243440,144579,0,0x0,0,0xb46bbe71545,0xb469fbd67f4,0xb46f7df2ee0,0xb46f7dee5f7
code-creation,Eval,10,144723,0xb46bbe71c50,5, node:internal/modules/run_main:1:1,0xb46bbe71a28,~
script-source,419,node:internal/modules/run_main,'use strict';\n\nconst {\n  ObjectCreate\x2C\n  StringPrototypeEndsWith\x2C\n} = primordials;\nconst CJSLoader = require('internal/modules/cjs/loader');\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\nconst { getOptionValue } = require('internal/options');\nconst path = require('path');\nconst {\n  handleProcessExit\x2C\n} = require('internal/modules/esm/handle_process_exit');\n\nfunction resolveMainPath(main) {\n  // Note extension resolution for the main entry point can be deprecated in a\n  // future major.\n  // Module._findPath is monkey-patchable here.\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\n  if (!mainPath)\n    return;\n\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\n  if (!preserveSymlinksMain)\n    mainPath = toRealPath(mainPath);\n\n  return mainPath;\n}\n\nfunction shouldUseESMLoader(mainPath) {\n  /**\n   * @type {string[]} userLoaders A list of custom loaders registered by the user\n   * (or an empty list when none have been registered).\n   */\n  const userLoaders = getOptionValue('--experimental-loader');\n  if (userLoaders.length > 0)\n    return true;\n  const esModuleSpecifierResolution =\n    getOptionValue('--experimental-specifier-resolution');\n  if (esModuleSpecifierResolution === 'node')\n    return true;\n  // Determine the module format of the main\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\n    return true;\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\n    return false;\n  const pkg = readPackageScope(mainPath);\n  return pkg && pkg.data.type === 'module';\n}\n\nfunction runMainESM(mainPath) {\n  const { loadESM } = require('internal/process/esm_loader');\n  const { pathToFileURL } = require('internal/url');\n\n  handleMainPromise(loadESM((esmLoader) => {\n    const main = path.isAbsolute(mainPath) ?\n      pathToFileURL(mainPath).href : mainPath;\n    return esmLoader.import(main\x2C undefined\x2C ObjectCreate(null));\n  }));\n}\n\nasync function handleMainPromise(promise) {\n  process.on('exit'\x2C handleProcessExit);\n  try {\n    return await promise;\n  } finally {\n    process.off('exit'\x2C handleProcessExit);\n  }\n}\n\n// For backwards compatibility\x2C we have to run a bunch of\n// monkey-patchable code that belongs to the CJS loader (exposed by\n// `require('module')`) even when the entry point is ESM.\nfunction executeUserEntryPoint(main = process.argv[1]) {\n  const resolvedMain = resolveMainPath(main);\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\n  if (useESMLoader) {\n    runMainESM(resolvedMain || main);\n  } else {\n    // Module._load is the monkey-patchable CJS module loader.\n    Module._load(main\x2C null\x2C true);\n  }\n}\n\nmodule.exports = {\n  executeUserEntryPoint\x2C\n  handleMainPromise\x2C\n};\n
code-source-info,0xb46bbe71c50,419,0,2700,C0O0C4O2700,,
code-creation,Function,10,145035,0xb46bbe71f38,178, node:internal/modules/run_main:1:1,0xb46bbe71bc8,~
code-source-info,0xb46bbe71f38,419,0,2700,C0O0C66O25C72O41C78O101C84O101C89O149C95O157C101O169C107O228C113O228C118O209C124O270C130O270C134O270C136O320C142O320C147O297C153O2632C160O2653C166O2678C172O2647C177O2699,,
code-creation,LazyCompile,10,145126,0xb46bbe72550,163,initializeESMLoader node:internal/bootstrap/pre_execution:519:29,0xb46f7df0e20,~
code-source-info,0xb46bbe72550,389,16433,17521,C0O16515C6O16515C13O16564C16O16560C21O16558C25O16582C30O16586C34O16606C40O16635C41O16642C42O16742C48O16742C53O16658C58O16698C63O16788C69O16788C74O16989C79O16947C83O17059C88O17020C92O17225C100O17229C106O17345C112O17345C117O17294C122O17302C127O17320C132O17391C138O17391C143O17410C145O17420C149O17434C151O17454C155O17478C157O17497C162O17520,,
code-creation,LazyCompile,10,145186,0xb46bbe72768,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0xb469fbd9c38,~
code-source-info,0xb46bbe72768,396,2295,2335,C0O2300C4O2333,,
code-creation,LazyCompile,10,145225,0xb46bbe72810,21,assert node:internal/assert:11:16,0xb469fcd8b20,~
script-source,27,node:internal/assert,'use strict';\n\nlet error;\nfunction lazyError() {\n  if (!error) {\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\n  }\n  return error;\n}\n\nfunction assert(value\x2C message) {\n  if (!value) {\n    const ERR_INTERNAL_ASSERTION = lazyError();\n    throw new ERR_INTERNAL_ASSERTION(message);\n  }\n}\n\nfunction fail(message) {\n  const ERR_INTERNAL_ASSERTION = lazyError();\n  throw new ERR_INTERNAL_ASSERTION(message);\n}\n\nassert.fail = fail;\n\nmodule.exports = assert;\n
code-source-info,0xb46bbe72810,27,172,307,C0O193C4O242C7O242C11O259C13O265C18O259C20O306,,
code-creation,LazyCompile,10,145317,0xb46bbe72a10,53,loadPreloadModules node:internal/bootstrap/pre_execution:562:28,0xb46f7df0f10,~
code-source-info,0xb46bbe72a10,389,17997,18317,C0O18084C8O18084C13O18115C15O18152C21O18159C26O18235C32O18235C37O18235C42O18202C47O18279C52O18316,,
code-creation,LazyCompile,10,145376,0xb46bbe72c00,166,Module._preloadModules node:internal/modules/cjs/loader:1278:34,0xb469fbda878,~
code-source-info,0xb46bbe72c00,396,40014,40588,C0O40029C5O40034C11O40062C12O40069C13O40073C17O40086C23O40281C33O40281C42O40331C45O40353C53O40378C58O40378C63O40353C68O40344C85O40406C88O40412C95O40417C100O40439C106O40452C114O40467C116O40467C119O40501C121O40517C125O40506C130O40541C137O40557C141O40541C146O40526C151O40488C154O40565C158O40578C165O40587,,
code-creation,LazyCompile,10,145434,0xb46bbe72e18,94,Module node:internal/modules/cjs/loader:172:16,0xb469fbd9598,~
code-source-info,0xb46bbe72e18,396,5287,5524,C14O5309C16O5317C20O5325C22O5337C25O5342C30O5342C35O5335C39O5357C40O5370C44O5378C49O5396C54O5396C60O5417C71O5417C76O5456C77O5470C81O5480C82O5492C86O5503C88O5517C93O5523,,
code-creation,LazyCompile,10,145504,0xb46bbe73050,162,dirname node:path:1275:10,0xb46806acf78,~
code-source-info,0xb46bbe73050,71,38741,39410,C0O38754C8O38754C13O38797C19O38804C24O38817C26O38828C27O38849C34O38849C42O38888C44O38884C48O38922C51O38949C53O38977C57O38984C61O38991C63O38991C68O39010C73O39014C81O39053C83O39049C88O39083C92O39114C97O39133C101O39220C103O38999C108O38959C111O39261C113O39269C118O39283C128O39310C129O39315C135O39334C140O39347C142O39359C143O39364C156O39371C161O39406,,
code-creation,LazyCompile,10,145568,0xb46bbe73230,45,updateChildren node:internal/modules/cjs/loader:165:24,0xb469fbd9548,~
code-source-info,0xb46bbe73230,396,5052,5225,C0O5095C7O5101C15O5115C19O5133C23O5141C26O5141C33O5187C38O5187C44O5224,,
code-creation,LazyCompile,10,145628,0xb46bbe733f0,183,Module._nodeModulePaths node:internal/modules/cjs/loader:640:37,0xb469fbda118,~
code-source-info,0xb46bbe733f0,396,19125,20256,C0O19180C5O19192C10O19192C17O19371C19O19380C24O19395C28O19420C29O19635C32O19661C36O19668C40O19677C42O19692C47O19702C48O19702C53O19734C58O19734C64O19776C66O19789C68O19785C73O19819C75O19829C77O19825C82O19846C89O19897C100O19897C108O19933C112O19846C117O19972C120O19990C124O20010C126O20016C131O20034C138O20045C144O20049C149O20071C156O20103C159O19710C164O19643C167O20190C175O20190C180O20239C182O20252,,
tick,0x102fdab0e,145898,0,0x0,0,0x102d66130,0xb46bbe73494,0xb46bbe72c3f,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Function,11,146412,0x113244380,1428,Module._nodeModulePaths node:internal/modules/cjs/loader:640:37,0xb469fbda118,^
code-source-info,0x113244380,396,19125,20256,,,
code-creation,Function,11,146466,0x1132449c0,412,getCLIOptionsFromBinding node:internal/options:18:34,0xb46806bda60,^
code-source-info,0x1132449c0,88,497,598,,,
code-creation,Function,11,146497,0x113244c00,1228,compileForInternalLoader node:internal/bootstrap/loaders:316:27,0xb466514b810,^
code-source-info,0x113244c00,15,9991,10552,,,
code-creation,Function,11,146524,0x113245180,536,internalBinding node:internal/bootstrap/loaders:171:45,0xb466514b380,^
code-source-info,0x113245180,15,5263,5501,,,
code-creation,Function,11,146554,0x113245440,240,SafeMap node:internal/per_context/primordials:366:16,0xb4665145fc8,^
code-source-info,0x113245440,12,10601,10618,,,
code-creation,Function,11,146573,0x1132455c0,100,next node:internal/per_context/primordials:288:9,0xb4665145ad8,^
code-source-info,0x1132455c0,12,8207,8252,,,
code-creation,Function,11,146593,0x1132456c0,180,canBeRequiredWithoutScheme node:internal/bootstrap/loaders:254:36,0xb466514b680,^
code-source-info,0x1132456c0,15,7775,7826,,,
code-creation,Function,11,146613,0x113245800,184, node:internal/modules/cjs/loader:192:41,0xb469fbd9c88,^
code-source-info,0x113245800,396,5814,5840,,,
code-creation,Function,11,146640,0x113245940,1272,resolve node:path:1091:10,0xb46806acd98,^
code-source-info,0x113245940,71,33781,34691,,,
code-creation,LazyCompile,10,146889,0xb46bbe73a80,127,Module.require node:internal/modules/cjs/loader:1014:36,0xb469fbda478,~
code-source-info,0xb46bbe73a80,396,31666,31957,C0O31675C8O31675C13O31703C15O31710C20O31724C36O31730C41O31724C42O31839C51O31851C60O31867C63O31881C76O31881C93O31936C102O31948C126O31956,,
code-creation,LazyCompile,10,147007,0xb46bbe73d78,636,Module._load node:internal/modules/cjs/loader:771:24,0xb469fbda2d8,~
code-source-info,0xb46bbe73d78,396,23620,26604,C0O23654C2O23683C6O23701C14O23761C23O23701C28O23991C42O24002C47O24034C54O24054C58O24087C60O24144C63O24151C70O24157C74O24175C76O24217C88O24217C93O24287C99O24305C102O24312C106O24355C107O24384C111O24392C112O24407C119O24435C121O24476C129O24480C136O24570C144O24570C150O24624C155O24624C161O24659C166O24670C175O24702C182O24708C187O24702C188O24774C192O24782C193O24807C196O24814C210O24814C216O24880C219O24887C226O24893C230O24907C232O24945C244O24945C249O25011C255O25053C260O25067C265O25067C271O25092C273O25136C279O25152C282O25159C286O25202C287O25209C288O25234C294O25281C298O25289C299O25315C304O25315C310O25354C315O25361C326O25393C329O25406C334O25406C341O25461C345O25469C346O25559C361O25575C367O25608C371O25626C376O25645C380O25659C382O25669C386O25683C389O25690C396O25707C400O25719C404O25751C411O25799C415O25830C420O25855C426O25855C431O25875C443O25881C444O25908C449O25927C453O25941C461O25948C463O25965C467O26001C475O26029C477O26082C484O26088C492O26108C498O26112C504O26162C510O26162C516O26213C518O26223C523O26245C539O26245C546O26339C554O26366C558O26381C564O26366C572O26408C576O26436C582O26408C590O26466C592O26445C597O26512C603O26540C611O26549C615O26512C631O26594C635O26602,,
tick,0x7ff805e4dd52,147140,0,0x0,3,0x102d5e910,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,147156,0xb46bbe74228,89,logger node:internal/util/debuglog:95:18,0xb469fcd9f58,~
code-source-info,0xb46bbe74228,28,2869,3064,C0O2869C3O2901C24O2925C30O2942C34O2932C38O2947C39O2962C45O2979C51O2988C55O2969C60O2993C61O3009C65O3016C72O3029C77O3025C83O3016C88O3054,,
code-creation,LazyCompile,10,147202,0xb46bbe74368,3, node:internal/per_context/primordials:291:21,0xb4665145b78,~
code-source-info,0xb46bbe74368,12,8273,8302,C0O8284C2O8296,,
code-creation,LazyCompile,10,147257,0xb46bbe74440,140,debug node:internal/util/debuglog:76:15,0xb469fcd9eb8,~
code-source-info,0xb46bbe74440,28,2357,2751,C0O2357C3O2376C6O2376C9O2484C16O2505C22O2492C30O2490C36O2524C42O2560C47O2563C50O2560C54O2588C75O2612C81O2629C85O2619C89O2634C90O2649C96O2666C102O2675C106O2656C111O2680C112O2696C116O2703C123O2716C128O2712C134O2703C139O2741,,
code-creation,LazyCompile,10,147302,0xb46bbe745f0,41,init node:internal/util/debuglog:72:16,0xb469fcd9e68,~
code-source-info,0xb46bbe745f0,28,2259,2342,C0O2268C10O2274C14O2272C16O2311C26O2321C33O2319C40O2341,,
code-creation,LazyCompile,10,147342,0xb46bbe746e8,2,testEnabled node:internal/util/debuglog:32:19,0xb469fbcb8f8,~
code-source-info,0xb46bbe746e8,28,973,984,C0O979C1O984,,
code-creation,LazyCompile,10,147388,0xb46bbe74888,116,debuglogImpl node:internal/util/debuglog:49:22,0xb469fcd9d18,~
code-source-info,0xb46bbe74888,28,1451,1995,C0O1451C9O1470C18O1484C23O1511C34O1544C39O1552C43O1544C45O1563C55O1563C59O1595C71O1606C75O1611C83O1934C97O1952C99O1950C103O1970C112O1987C115O1993,,
code-creation,LazyCompile,10,147429,0xb46bbe74a40,10, node:internal/modules/cjs/loader:283:66,0xb469fbd9fa8,~
code-source-info,0xb46bbe74a40,396,8043,8068,C0O8055C2O8061C9O8067,,
code-creation,LazyCompile,10,147463,0xb46bbe74af8,2,noop node:internal/util/debuglog:47:14,0xb469fcd9cc8,~
code-source-info,0xb46bbe74af8,28,1419,1427,C1O1426,,
code-creation,LazyCompile,10,147592,0xb46bbe74f80,922,Module._resolveFilename node:internal/modules/cjs/loader:865:35,0xb469fbda360,~
code-source-info,0xb46bbe74f80,396,26641,29837,C0O26680C10O26697C19O26750C23O26763C31O26784C39O26784C46O26763C55O26835C59O26848C65O26848C74O26887C78O26900C84O26900C91O26952C93O26967C94O26979C96O26989C106O27048C112O27073C118O27052C124O27108C134O27108C143O27162C151O27162C160O27219C166O27232C174O27232C183O27288C191O27288C197O27340C199O27382C206O27431C219O27431C225O27462C228O27496C230O27511C236O27517C240O27501C245O27563C253O27568C257O27583C261O27609C267O27609C272O27600C276O27663C280O27670C286O27670C293O27736C296O27755C300O27741C305O27782C313O27828C318O27787C325O27848C333O27885C338O27848C343O27764C349O27723C352O27526C357O27483C362O27944C368O27973C372O27988C378O27988C387O28045C397O28102C405O28051C410O28045C413O28131C417O28146C423O28146C430O28191C431O28202C438O28206C450O28224C466O28244C477O28249C482O28289C489O28295C504O28317C510O28317C518O28325C522O28330C526O28323C530O28351C534O28351C542O28399C550O28403C563O28444C569O28484C575O28515C579O28515C587O28574C594O28484C601O28616C610O28451C615O28622C629O28651C633O28657C641O28662C646O28700C652O28706C656O28700C657O28745C659O28745C660O28832C664O28832C669O28882C673O28882C679O28914C681O28955C683O28963C688O28990C696O28997C702O29010C709O29016C717O29016C722O28972C726O29056C730O29063C738O29084C742O29104C744O29124C745O29210C749O29217C767O29217C773O29261C775O29275C777O29291C778O29315C781O29339C786O29351C790O29409C796O29449C805O29468C811O29409C816O29370C822O29390C828O29390C834O29321C837O29493C843O29516C855O29547C862O29554C867O29565C869O29583C876O29624C884O29624C889O29608C893O29735C901O29735C907O29757C909O29766C913O29790C915O29807C919O29825C921O29825,,
code-creation,LazyCompile,10,147731,0xb46bbe755d8,28,canBeRequiredByUsers node:internal/bootstrap/loaders:247:30,0xb466514b630,~
code-source-info,0xb46bbe755d8,15,7502,7598,C0O7525C5O7538C10O7542C15O7542C21O7555C23O7573C27O7594,,
code-creation,LazyCompile,10,147793,0xb46bbe75898,344,Module._resolveLookupPaths node:internal/modules/cjs/loader:678:38,0xb469fbda1a8,~
code-source-info,0xb46bbe75898,396,20298,21533,C0O20320C5O20337C10O20337C19O20376C22O20389C27O20389C34O20432C42O20432C47O20476C48O20488C49O20531C56O20535C64O20569C69O20595C76O20602C83O20615C89O20615C97O20649C104O20666C110O20666C118O20700C125O20719C131O20732C137O20732C145O20766C150O20797C155O20814C162O20824C169O20831C178O20849C183O20885C188O20857C194O20911C208O20911C213O20975C219O20982C229O21001C230O21048C234O21071C240O21085C246O21256C251O21268C265O21268C270O21323C272O21340C273O21348C281O21415C289O21348C294O21441C303O21442C306O21447C311O21462C316O21447C328O21476C336O21476C341O21514C343O21531,,
code-creation,LazyCompile,10,147869,0xb46bbe75bb0,76,trySelfParentPath node:internal/modules/cjs/loader:438:27,0xb469fbd98b8,~
code-source-info,0xb46bbe75bb0,396,12604,12867,C0O12617C4O12630C5O12643C6O12658C12O12688C16O12697C17O12718C24O12721C29O12744C36O12747C44O12789C47O12804C52O12804C59O12812C62O12817C66O12810C69O12821C72O12842C73O12855C75O12866,,
code-creation,LazyCompile,10,147933,0xb46bbe75df0,232,trySelf node:internal/modules/cjs/loader:452:17,0xb469fbd9908,~
code-source-info,0xb46bbe75df0,396,12885,13709,C0O12911C4O12928C5O12941C6O12982C9O12982C17O12959C22O12970C27O13020C31O13036C37O13059C38O13072C39O13090C47O13109C48O13122C49O13130C51O13163C55O13155C60O13175C65O13201C70O13247C82O13205C89O13263C94O13281C97O13315C102O13320C107O13281C112O13279C118O13344C119O13357C123O13375C128O13404C133O13433C138O13455C142O13433C149O13497C152O13497C159O13524C168O13404C180O13382C185O13561C197O13582C200O13588C207O13593C212O13627C219O13671C223O13633C228O13627C229O13695C231O13695,,
code-creation,LazyCompile,10,148005,0xb46bbe760c0,129,readPackageScope node:internal/modules/cjs/loader:332:26,0xb469fbd96d8,~
code-source-info,0xb46bbe760c0,396,9253,9771,C0O9296C7O9330C10O9296C16O9342C18O9369C25O9424C28O9386C34O9434C47O9446C54O9502C61O9541C66O9545C70O9506C77O9570C78O9583C79O9602C84O9626C86O9624C90O9602C95O9636C97O9647C104O9668C110O9687C116O9704C117O9731C119O9731C124O9360C127O9756C128O9769,,
code-creation,LazyCompile,10,148087,0xb46bbe76428,234,readPackage node:internal/modules/cjs/loader:301:21,0xb469fbd9688,~
code-source-info,0xb46bbe76428,396,8436,9226,C0O8471C5O8476C13O8476C20O8534C25O8551C30O8551C36O8568C38O8596C40O8612C41O8631C46O8649C51O8649C57O8687C63O8700C72O8726C77O8736C79O8766C84O8783C91O8783C97O8809C98O8822C102O8855C107O8855C112O8893C117O8914C125O8939C133O8967C141O8998C149O9026C160O9042C165O9059C170O9059C176O9088C178O9104C190O9125C195O9132C199O9148C207O9177C213O9188C220O9199C224O9195C227O9158C231O9212C233O9212,,
tick,0x113243440,148382,0,0x0,0,0xb46bbe76435,0xb46bbe7611a,0xb46bbe75df9,0xb46bbe75221,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,148438,0xb46bbe76738,199,read node:internal/modules/package_json_reader:16:14,0xb469fbdf608,~
code-source-info,0xb46bbe76738,397,292,954,C0O307C5O317C10O317C17O338C22O351C27O351C32O365C33O412C40O440C43O440C48O412C53O384C59O395C66O489C73O491C79O499C86O544C92O544C97O525C102O575C106O607C112O643C115O654C127O704C132O738C142O652C148O774C154O821C159O821C164O852C169O861C174O861C180O907C185O913C190O913C196O938C198O952,,
code-creation,LazyCompile,10,148492,0xb46bbe76a88,3,toNamespacedPath node:path:1266:19,0xb46806acf28,~
code-source-info,0xb46bbe76a88,71,38608,38668,C0O38652C2O38664,,
code-creation,LazyCompile,10,148815,0xb46bbe77020,438,Module._findPath node:internal/modules/cjs/loader:505:28,0xb469fbd9ff8,~
code-source-info,0xb46bbe77020,396,14652,17265,C0O14705C5O14710C10O14710C16O14733C18O14760C26O14783C30O14803C36O14810C41O14823C42O14836C43O14861C45O14869C51O14880C57O14880C62O14878C66O14931C69O14938C76O14948C80O14962C82O14977C84O14990C85O14998C87O15034C93O15041C100O15052C103O15095C107O15102C111O15052C119O15115C121O15107C125O15137C127O15163C134O15199C137O15179C143O15228C145O15277C147O15290C151O15282C156O15375C158O15380C162O15389C167O15404C174O15418C179O15423C181O15438C185O15492C188O15492C194O15532C196O15561C198O15584C199O15613C204O15618C209O15618C216O15653C218O15679C221O15679C226O15699C230O15727C231O15734C236O15761C240O15786C246O15822C251O15838C256O15838C264O15888C267O15899C274O15948C280O16562C285O16578C290O16578C298O16624C301O16635C306O16682C310O16753C314O16787C322O16812C327O16794C332O16834C344O16845C350O16903C356O16923C361O17008C365O17040C373O17065C378O17047C383O17085C398O17096C404O17152C408O17174C411O17181C418O17202C422O17220C424O17236C425O15299C430O15264C436O17250C437O17263,,
code-creation,LazyCompile,10,148907,0xb46bbe773d0,45,isAbsolute node:path:1156:13,0xb46806ace38,~
code-source-info,0xb46bbe773d0,71,35447,35593,C0O35460C8O35460C13O35506C19O35513C26O35531C31O35531C39O35570C41O35566C44O35589,,
code-creation,LazyCompile,10,149080,0xb46bbe77638,85,stat node:internal/modules/cjs/loader:151:14,0xb469fbd94f8,~
code-source-info,0xb46bbe77638,396,4630,5027,C0O4645C5O4661C10O4661C17O4691C23O4736C28O4746C33O4746C39O4765C41O4791C43O4805C44O4827C49O4827C54O4859C61O4892C66O4972C71O4982C76O4982C82O5011C84O5025,,
code-creation,LazyCompile,10,149153,0xb46bbe77790,44,tryExtensions node:internal/modules/cjs/loader:411:23,0xb469fbd9818,~
code-source-info,0xb46bbe77790,396,11835,12019,C0O11870C2O11882C6O11875C11O11918C16O11934C19O11928C23O11918C29O11953C31O11975C33O11991C34O11891C39O11857C42O12004C43O12017,,
code-creation,LazyCompile,10,149195,0xb46bbe778c0,50,tryFile node:internal/modules/cjs/loader:395:17,0xb469fbd9778,~
code-source-info,0xb46bbe778c0,396,11411,11605,C0O11448C3O11448C8O11469C9O11476C14O11483C15O11490C16O11493C24O11518C26O11532C31O11544C36O11544C41O11565C42O11572C45O11579C49O11603,,
code-creation,LazyCompile,10,149246,0xb46bbe77a10,42,toRealPath node:internal/modules/cjs/loader:404:20,0xb469fbd97c8,~
code-source-info,0xb46bbe77a10,396,11626,11738,C0O11644C5O11654C10O11667C17O11687C20O11698C28O11717C35O11654C41O11736,,
code-creation,LazyCompile,10,149485,0xb46bbe77e40,1079,realpathSync node:fs:2474:22,0xb46d1098a30,~
script-source,73,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\n\n'use strict';\n\n// When using FSReqCallback\x2C make sure to create the object only *after* all\n// parameter validation has happened\x2C so that the objects are not kept in memory\n// in case they are created but never used due to an exception.\n\nconst {\n  ArrayPrototypePush\x2C\n  BigIntPrototypeToString\x2C\n  MathMax\x2C\n  Number\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  Promise\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSlice\x2C\n} = primordials;\n\nconst { fs: constants } = internalBinding('constants');\nconst {\n  S_IFIFO\x2C\n  S_IFLNK\x2C\n  S_IFMT\x2C\n  S_IFREG\x2C\n  S_IFSOCK\x2C\n  F_OK\x2C\n  R_OK\x2C\n  W_OK\x2C\n  X_OK\x2C\n  O_WRONLY\x2C\n  O_SYMLINK\n} = constants;\n\nconst pathModule = require('path');\nconst { isArrayBufferView } = require('internal/util/types');\n\n// We need to get the statValues from the binding at the callsite since\n// it's re-initialized after deserialization.\n\nconst binding = internalBinding('fs');\nconst { Buffer } = require('buffer');\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_FS_FILE_TOO_LARGE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\n  }\x2C\n  AbortError\x2C\n  uvErrmapGet\x2C\n  uvException\n} = require('internal/errors');\n\nconst { FSReqCallback } = binding;\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\n  deprecate\x2C\n  kEmptyObject\x2C\n  promisify: {\n    custom: kCustomPromisifiedSymbol\x2C\n  }\x2C\n} = require('internal/util');\nconst {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n  }\x2C\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  Stats\x2C\n  getStatsFromBinding\x2C\n  realpathCacheKey\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n} = require('internal/fs/utils');\nconst {\n  Dir\x2C\n  opendir\x2C\n  opendirSync\n} = require('internal/fs/dir');\nconst {\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_BACKWARD_SLASH\x2C\n} = require('internal/constants');\nconst {\n  isUint32\x2C\n  parseFileMode\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateEncoding\x2C\n  validateFunction\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst watchers = require('internal/fs/watchers');\nconst ReadFileContext = require('internal/fs/read_file_context');\n\nlet truncateWarn = true;\nlet fs;\n\n// Lazy loaded\nlet cpFn;\nlet cpSyncFn;\nlet promises = null;\nlet ReadStream;\nlet WriteStream;\nlet rimraf;\nlet rimrafSync;\n\n// These have to be separate because of how graceful-fs happens to do it's\n// monkeypatching.\nlet FileReadStream;\nlet FileWriteStream;\n\nconst isWindows = process.platform === 'win32';\nconst isOSX = process.platform === 'darwin';\n\n\nconst showStringCoercionDeprecation = deprecate(\n  () => {}\x2C\n  'Implicit coercion of objects with own toString property is deprecated.'\x2C\n  'DEP0162'\n);\nfunction showTruncateDeprecation() {\n  if (truncateWarn) {\n    process.emitWarning(\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\n      'fs.ftruncate with a file descriptor instead.'\x2C\n      'DeprecationWarning'\x2C 'DEP0081');\n    truncateWarn = false;\n  }\n}\n\nfunction maybeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return cb;\n}\n\n// Ensure that callbacks run in the global context. Only use this function\n// for callbacks that are passed to the binding layer\x2C callbacks that are\n// invoked from JS already run in the proper scope.\nfunction makeCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\n}\n\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\n// an optimization\x2C since the data passed back to the callback needs to be\n// transformed anyway.\nfunction makeStatsCallback(cb) {\n  validateFunction(cb\x2C 'cb');\n\n  return (err\x2C stats) => {\n    if (err) return cb(err);\n    cb(err\x2C getStatsFromBinding(stats));\n  };\n}\n\nconst isFd = isUint32;\n\nfunction isFileType(stats\x2C fileType) {\n  // Use stats array directly to avoid creating an fs.Stats instance just for\n  // our internal use.\n  let mode = stats[1];\n  if (typeof mode === 'bigint')\n    mode = Number(mode);\n  return (mode & S_IFMT) === fileType;\n}\n\n/**\n * Tests a user's permissions for the file or directory\n * specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction access(path\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = F_OK;\n  }\n\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously tests a user's permissions for the file or\n * directory specified by `path`.\n * @param {string | Buffer | URL} path\n * @param {number} [mode]\n * @returns {void}\n */\nfunction accessSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = getValidMode(mode\x2C 'access');\n\n  const ctx = { path };\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @param {(exists?: boolean) => any} callback\n * @returns {void}\n */\nfunction exists(path\x2C callback) {\n  maybeCallback(callback);\n\n  function suppressedCallback(err) {\n    callback(err ? false : true);\n  }\n\n  try {\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\n  } catch {\n    return callback(false);\n  }\n}\n\nObjectDefineProperty(exists\x2C kCustomPromisifiedSymbol\x2C {\n  __proto__: null\x2C\n  value: function exists(path) { // eslint-disable-line func-name-matching\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\n  }\x2C\n});\n\n// fs.existsSync never throws\x2C it only returns true or false.\n// Since fs.existsSync never throws\x2C users have established\n// the expectation that passing invalid arguments to it\x2C even like\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\n// validation errors to users properly out of compatibility concerns.\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\n/**\n * Synchronously tests whether or not the given path exists.\n * @param {string | Buffer | URL} path\n * @returns {boolean}\n */\nfunction existsSync(path) {\n  try {\n    path = getValidatedPath(path);\n  } catch {\n    return false;\n  }\n  const ctx = { path };\n  const nPath = pathModule.toNamespacedPath(path);\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\n\n  // In case of an invalid symlink\x2C `binding.access()` on win32\n  // will **not** return an error and is therefore not enough.\n  // Double check with `binding.stat()`.\n  if (isWindows && ctx.errno === undefined) {\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\n  }\n\n  return ctx.errno === undefined;\n}\n\nfunction readFileAfterOpen(err\x2C fd) {\n  const context = this.context;\n\n  if (err) {\n    context.callback(err);\n    return;\n  }\n\n  context.fd = fd;\n\n  const req = new FSReqCallback();\n  req.oncomplete = readFileAfterStat;\n  req.context = context;\n  binding.fstat(fd\x2C false\x2C req);\n}\n\nfunction readFileAfterStat(err\x2C stats) {\n  const context = this.context;\n\n  if (err)\n    return context.close(err);\n\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n\n  if (size > kIoMaxLength) {\n    err = new ERR_FS_FILE_TOO_LARGE(size);\n    return context.close(err);\n  }\n\n  try {\n    if (size === 0) {\n      context.buffers = [];\n    } else {\n      context.buffer = Buffer.allocUnsafeSlow(size);\n    }\n  } catch (err) {\n    return context.close(err);\n  }\n  context.read();\n}\n\nfunction checkAborted(signal\x2C callback) {\n  if (signal?.aborted) {\n    callback(new AbortError(undefined\x2C { cause: signal?.reason }));\n    return true;\n  }\n  return false;\n}\n\n/**\n * Asynchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   data?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readFile(path\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { flag: 'r' });\n  const context = new ReadFileContext(callback\x2C options.encoding);\n  context.isUserFd = isFd(path); // File descriptor ownership\n\n  if (options.signal) {\n    context.signal = options.signal;\n  }\n  if (context.isUserFd) {\n    process.nextTick(function tick(context) {\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\n    }\x2C context);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.context = context;\n  req.oncomplete = readFileAfterOpen;\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               0o666\x2C\n               req);\n}\n\nfunction tryStatSync(fd\x2C isUserFd) {\n  const ctx = {};\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\n  if (ctx.errno !== undefined && !isUserFd) {\n    fs.closeSync(fd);\n    throw uvException(ctx);\n  }\n  return stats;\n}\n\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\n  let threw = true;\n  let buffer;\n  try {\n    if (size > kIoMaxLength) {\n      throw new ERR_FS_FILE_TOO_LARGE(size);\n    }\n    buffer = Buffer.allocUnsafe(size);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return buffer;\n}\n\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\n  let threw = true;\n  let bytesRead;\n  try {\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\n    threw = false;\n  } finally {\n    if (threw && !isUserFd) fs.closeSync(fd);\n  }\n  return bytesRead;\n}\n\n/**\n * Synchronously reads the entire contents of a file.\n * @param {string | Buffer | URL | number} path\n * @param {{\n *   encoding?: string | null;\n *   flag?: string;\n *   }} [options]\n * @returns {string | Buffer}\n */\nfunction readFileSync(path\x2C options) {\n  options = getOptions(options\x2C { flag: 'r' });\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\n\n  const stats = tryStatSync(fd\x2C isUserFd);\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\n  let pos = 0;\n  let buffer; // Single buffer with file data\n  let buffers; // List for when size is unknown\n\n  if (size === 0) {\n    buffers = [];\n  } else {\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\n  }\n\n  let bytesRead;\n\n  if (size !== 0) {\n    do {\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\n      pos += bytesRead;\n    } while (bytesRead !== 0 && pos < size);\n  } else {\n    do {\n      // The kernel lies about many files.\n      // Go ahead and try to read some bytes.\n      buffer = Buffer.allocUnsafe(8192);\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\n      if (bytesRead !== 0) {\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\n      }\n      pos += bytesRead;\n    } while (bytesRead !== 0);\n  }\n\n  if (!isUserFd)\n    fs.closeSync(fd);\n\n  if (size === 0) {\n    // Data was collected into the buffers list.\n    buffer = Buffer.concat(buffers\x2C pos);\n  } else if (pos < size) {\n    buffer = buffer.slice(0\x2C pos);\n  }\n\n  if (options.encoding) buffer = buffer.toString(options.encoding);\n  return buffer;\n}\n\nfunction defaultCloseCallback(err) {\n  if (err != null) throw err;\n}\n\n/**\n * Closes the file descriptor.\n * @param {number} fd\n * @param {(err?: Error) => any} [callback]\n * @returns {void}\n */\nfunction close(fd\x2C callback = defaultCloseCallback) {\n  fd = getValidatedFd(fd);\n  if (callback !== defaultCloseCallback)\n    callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.close(fd\x2C req);\n}\n\n/**\n * Synchronously closes the file descriptor.\n * @param {number} fd\n * @returns {void}\n */\nfunction closeSync(fd) {\n  fd = getValidatedFd(fd);\n\n  const ctx = {};\n  binding.close(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @param {(\n *   err?: Error\x2C\n *   fd?: number\n *   ) => any} callback\n * @returns {void}\n */\nfunction open(path\x2C flags\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  if (arguments.length < 3) {\n    callback = flags;\n    flags = 'r';\n    mode = 0o666;\n  } else if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0o666;\n  } else {\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n  }\n  const flagsNumber = stringToFlags(flags);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.open(pathModule.toNamespacedPath(path)\x2C\n               flagsNumber\x2C\n               mode\x2C\n               req);\n}\n\n/**\n * Synchronously opens a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} [flags]\n * @param {string | number} [mode]\n * @returns {number}\n */\nfunction openSync(path\x2C flags\x2C mode) {\n  path = getValidatedPath(path);\n  const flagsNumber = stringToFlags(flags);\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\n\n  const ctx = { path };\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\n                              flagsNumber\x2C mode\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {number} offsetOrOptions\n * @param {number} length\n * @param {number | bigint | null} position\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffer?: Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction read(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  let params = null;\n  if (arguments.length <= 4) {\n    if (arguments.length === 4) {\n      // This is fs.read(fd\x2C buffer\x2C options\x2C callback)\n      validateObject(offsetOrOptions\x2C 'options'\x2C { nullable: true });\n      callback = length;\n      params = offsetOrOptions;\n    } else if (arguments.length === 3) {\n      // This is fs.read(fd\x2C bufferOrParams\x2C callback)\n      if (!isArrayBufferView(buffer)) {\n        // This is fs.read(fd\x2C params\x2C callback)\n        params = buffer;\n        ({ buffer = Buffer.alloc(16384) } = params ?? kEmptyObject);\n      }\n      callback = offsetOrOptions;\n    } else {\n      // This is fs.read(fd\x2C callback)\n      callback = buffer;\n      buffer = Buffer.alloc(16384);\n    }\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = params ?? kEmptyObject);\n  }\n\n  validateBuffer(buffer);\n  callback = maybeCallback(callback);\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return process.nextTick(function tick() {\n      callback(null\x2C 0\x2C buffer);\n    });\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  function wrapper(err\x2C bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C bytesRead || 0\x2C buffer);\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n}\n\nObjectDefineProperty(read\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously reads the file from the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | bigint | null;\n *   }} [offset]\n * @returns {number}\n */\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n\n  validateBuffer(buffer);\n\n  if (arguments.length <= 3) {\n    // Assume fs.readSync(fd\x2C buffer\x2C options)\n    const options = offset || kEmptyObject;\n\n    ({\n      offset = 0\x2C\n      length = buffer.byteLength - offset\x2C\n      position = null\x2C\n    } = options);\n  }\n\n  if (offset == null) {\n    offset = 0;\n  } else {\n    validateInteger(offset\x2C 'offset'\x2C 0);\n  }\n\n  length |= 0;\n\n  if (length === 0) {\n    return 0;\n  }\n\n  if (buffer.byteLength === 0) {\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\n                                    'is empty and cannot be written');\n  }\n\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\n\n  if (position == null)\n    position = -1;\n\n  validatePosition(position\x2C 'position');\n\n  const ctx = {};\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Reads file from the specified `fd` (file descriptor)\n * and writes to an array of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesRead?: number\x2C\n *   buffers?: ArrayBufferView[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C read) {\n    callback(err\x2C read || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(readv\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\n\n/**\n * Synchronously reads file from the\n * specified `fd` (file descriptor) and writes to an array\n * of `ArrayBufferView`s.\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction readvSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes `buffer` to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string | object} buffer\n * @param {number | object} [offsetOrOptions]\n * @param {number} [length]\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number;\n *   buffer?: Buffer | TypedArray | DataView\n *   ) => any} callback\n * @returns {void}\n */\nfunction write(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err\x2C written || 0\x2C buffer);\n  }\n\n  fd = getValidatedFd(fd);\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    callback = maybeCallback(callback || position || length || offset);\n\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n\n    if (offset == null || typeof offset === 'function') {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    if (typeof position !== 'number')\n      position = null;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n\n    const req = new FSReqCallback();\n    req.oncomplete = wrapper;\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\n  }\n\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\n  if (typeof buffer !== 'string') {\n    showStringCoercionDeprecation();\n  }\n\n  if (typeof position !== 'function') {\n    if (typeof offset === 'function') {\n      position = offset;\n      offset = null;\n    } else {\n      position = length;\n    }\n    length = 'utf8';\n  }\n\n  const str = String(buffer);\n  validateEncoding(str\x2C length);\n  callback = maybeCallback(position);\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\n}\n\nObjectDefineProperty(write\x2C kCustomPromisifyArgsSymbol\x2C\n                     { __proto__: null\x2C value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\n\n/**\n * Synchronously writes `buffer` to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {Buffer | TypedArray | DataView | string} buffer\n * @param {{\n *   offset?: number;\n *   length?: number;\n *   position?: number | null;\n *   }} [offsetOrOptions]\n * @returns {number}\n */\nfunction writeSync(fd\x2C buffer\x2C offsetOrOptions\x2C length\x2C position) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  let result;\n\n  let offset = offsetOrOptions;\n  if (isArrayBufferView(buffer)) {\n    if (typeof offset === 'object') {\n      ({\n        offset = 0\x2C\n        length = buffer.byteLength - offset\x2C\n        position = null\x2C\n      } = offsetOrOptions ?? kEmptyObject);\n    }\n    if (position === undefined)\n      position = null;\n    if (offset == null) {\n      offset = 0;\n    } else {\n      validateInteger(offset\x2C 'offset'\x2C 0);\n    }\n    if (typeof length !== 'number')\n      length = buffer.byteLength - offset;\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\n                                 undefined\x2C ctx);\n  } else {\n    validatePrimitiveStringAfterArrayBufferView(buffer\x2C 'buffer');\n    validateEncoding(buffer\x2C length);\n\n    if (offset === undefined)\n      offset = null;\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\n                                 undefined\x2C ctx);\n  }\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Writes an array of `ArrayBufferView`s to the\n * specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @param {(\n *   err?: Error\x2C\n *   bytesWritten?: number\x2C\n *   buffers?: ArrayBufferView[]\n *   ) => any} callback\n * @returns {void}\n */\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\n  function wrapper(err\x2C written) {\n    callback(err\x2C written || 0\x2C buffers);\n  }\n\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n  callback = maybeCallback(callback || position);\n\n  if (buffers.length === 0) {\n    process.nextTick(callback\x2C null\x2C 0\x2C buffers);\n    return;\n  }\n\n  const req = new FSReqCallback();\n  req.oncomplete = wrapper;\n\n  if (typeof position !== 'number')\n    position = null;\n\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\n}\n\nObjectDefineProperty(writev\x2C kCustomPromisifyArgsSymbol\x2C {\n  __proto__: null\x2C\n  value: ['bytesWritten'\x2C 'buffer']\x2C\n  enumerable: false\n});\n\n/**\n * Synchronously writes an array of `ArrayBufferView`s\n * to the specified `fd` (file descriptor).\n * @param {number} fd\n * @param {ArrayBufferView[]} buffers\n * @param {number | null} [position]\n * @returns {number}\n */\nfunction writevSync(fd\x2C buffers\x2C position) {\n  fd = getValidatedFd(fd);\n  validateBufferArray(buffers);\n\n  if (buffers.length === 0) {\n    return 0;\n  }\n\n  const ctx = {};\n\n  if (typeof position !== 'number')\n    position = null;\n\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rename(oldPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C\n                 req);\n}\n\n\n/**\n * Synchronously renames file at `oldPath` to\n * the pathname provided as `newPath`.\n * @param {string | Buffer | URL} oldPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction renameSync(oldPath\x2C newPath) {\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n  const ctx = { path: oldPath\x2C dest: newPath };\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction truncate(path\x2C len\x2C callback) {\n  if (typeof path === 'number') {\n    showTruncateDeprecation();\n    return fs.ftruncate(path\x2C len\x2C callback);\n  }\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  } else if (len === undefined) {\n    len = 0;\n  }\n\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = maybeCallback(callback);\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\n    if (er) return callback(er);\n    const req = new FSReqCallback();\n    req.oncomplete = function oncomplete(er) {\n      fs.close(fd\x2C (er2) => {\n        callback(aggregateTwoErrors(er2\x2C er));\n      });\n    };\n    binding.ftruncate(fd\x2C len\x2C req);\n  });\n}\n\n/**\n * Synchronously truncates the file.\n * @param {string | Buffer | URL} path\n * @param {number} [len]\n * @returns {void}\n */\nfunction truncateSync(path\x2C len) {\n  if (typeof path === 'number') {\n    // legacy\n    showTruncateDeprecation();\n    return fs.ftruncateSync(path\x2C len);\n  }\n  if (len === undefined) {\n    len = 0;\n  }\n  // Allow error to be thrown\x2C but still close fd.\n  const fd = fs.openSync(path\x2C 'r+');\n  let ret;\n\n  try {\n    ret = fs.ftruncateSync(fd\x2C len);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\n  if (typeof len === 'function') {\n    callback = len;\n    len = 0;\n  }\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.ftruncate(fd\x2C len\x2C req);\n}\n\n/**\n * Synchronously truncates the file descriptor.\n * @param {number} fd\n * @param {number} [len]\n * @returns {void}\n */\nfunction ftruncateSync(fd\x2C len = 0) {\n  fd = getValidatedFd(fd);\n  validateInteger(len\x2C 'len');\n  len = MathMax(0\x2C len);\n  const ctx = {};\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction lazyLoadCp() {\n  if (cpFn === undefined) {\n    ({ cpFn } = require('internal/fs/cp/cp'));\n    cpFn = require('util').callbackify(cpFn);\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\n  }\n}\n\nfunction lazyLoadRimraf() {\n  if (rimraf === undefined)\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\n}\n\n/**\n * Asynchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rmdir(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  callback = makeCallback(callback);\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    validateRmOptions(\n      path\x2C\n      { ...options\x2C force: false }\x2C\n      true\x2C\n      (err\x2C options) => {\n        if (err === false) {\n          const req = new FSReqCallback();\n          req.oncomplete = callback;\n          return binding.rmdir(path\x2C req);\n        }\n        if (err) {\n          return callback(err);\n        }\n\n        lazyLoadRimraf();\n        rimraf(path\x2C options\x2C callback);\n      });\n  } else {\n    validateRmdirOptions(options);\n    const req = new FSReqCallback();\n    req.oncomplete = callback;\n    return binding.rmdir(path\x2C req);\n  }\n}\n\n/**\n * Synchronously removes a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmdirSync(path\x2C options) {\n  path = getValidatedPath(path);\n\n  if (options?.recursive) {\n    emitRecursiveRmdirWarning();\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\n    if (options !== false) {\n      lazyLoadRimraf();\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n    }\n  } else {\n    validateRmdirOptions(options);\n  }\n\n  const ctx = { path };\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  return handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction rm(path\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  path = getValidatedPath(path);\n\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\n    if (err) {\n      return callback(err);\n    }\n    lazyLoadRimraf();\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\n  });\n}\n\n/**\n * Synchronously removes files and\n * directories (modeled on the standard POSIX `rm` utility).\n * @param {string | Buffer | URL} path\n * @param {{\n *   force?: boolean;\n *   maxRetries?: number;\n *   recursive?: boolean;\n *   retryDelay?: number;\n *   }} [options]\n * @returns {void}\n */\nfunction rmSync(path\x2C options) {\n  path = getValidatedPath(path);\n  options = validateRmOptionsSync(path\x2C options\x2C false);\n\n  lazyLoadRimraf();\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\n}\n\n/**\n * Forces all currently queued I/O operations associated\n * with the file to the operating system's synchronized\n * I/O completion state.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fdatasync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fdatasync(fd\x2C req);\n}\n\n/**\n * Synchronously forces all currently queued I/O operations\n * associated with the file to the operating\n * system's synchronized I/O completion state.\n * @param {number} fd\n * @returns {void}\n */\nfunction fdatasyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Requests for all data for the open file descriptor\n * to be flushed to the storage device.\n * @param {number} fd\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fsync(fd\x2C callback) {\n  fd = getValidatedFd(fd);\n  const req = new FSReqCallback();\n  req.oncomplete = makeCallback(callback);\n  binding.fsync(fd\x2C req);\n}\n\n/**\n * Synchronously requests for all data for the open\n * file descriptor to be flushed to the storage device.\n * @param {number} fd\n * @returns {void}\n */\nfunction fsyncSync(fd) {\n  fd = getValidatedFd(fd);\n  const ctx = {};\n  binding.fsync(fd\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction mkdir(path\x2C options\x2C callback) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\n}\n\n/**\n * Synchronously creates a directory.\n * @param {string | Buffer | URL} path\n * @param {{\n *   recursive?: boolean;\n *   mode?: string | number;\n *   } | number} [options]\n * @returns {string | void}\n */\nfunction mkdirSync(path\x2C options) {\n  let mode = 0o777;\n  let recursive = false;\n  if (typeof options === 'number' || typeof options === 'string') {\n    mode = options;\n  } else if (options) {\n    if (options.recursive !== undefined)\n      recursive = options.recursive;\n    if (options.mode !== undefined)\n      mode = options.mode;\n  }\n  path = getValidatedPath(path);\n  validateBoolean(recursive\x2C 'options.recursive');\n\n  const ctx = { path };\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\n                               undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  if (recursive) {\n    return result;\n  }\n}\n\n/**\n * Reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @param {(\n *   err?: Error\x2C\n *   files?: string[] | Buffer[] | Direct[];\n *   ) => any} callback\n * @returns {void}\n */\nfunction readdir(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  if (!options.withFileTypes) {\n    req.oncomplete = callback;\n  } else {\n    req.oncomplete = (err\x2C result) => {\n      if (err) {\n        callback(err);\n        return;\n      }\n      getDirents(path\x2C result\x2C callback);\n    };\n  }\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\n                  !!options.withFileTypes\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a directory.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   encoding?: string;\n *   withFileTypes?: boolean;\n *   }} [options]\n * @returns {string | Buffer[] | Dirent[]}\n */\nfunction readdirSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\n                                 options.encoding\x2C !!options.withFileTypes\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\n}\n\n/**\n * Invokes the callback with the `fs.Stats`\n * for the file descriptor.\n * @param {number} fd\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  fd = getValidatedFd(fd);\n  callback = makeStatsCallback(callback);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.fstat(fd\x2C options.bigint\x2C req);\n}\n\n/**\n * Retrieves the `fs.Stats` for the symbolic link\n * referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\n/**\n * Asynchronously gets the stats of a file.\n * @param {string | Buffer | URL} path\n * @param {{ bigint?: boolean; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   stats?: Stats\n *   ) => any} callback\n * @returns {void}\n */\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = kEmptyObject;\n  }\n  callback = makeStatsCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback(options.bigint);\n  req.oncomplete = callback;\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\n}\n\nfunction hasNoEntryError(ctx) {\n  if (ctx.errno) {\n    const uvErr = uvErrmapGet(ctx.errno);\n    return uvErr?.[0] === 'ENOENT';\n  }\n\n  if (ctx.error) {\n    return ctx.error.code === 'ENOENT';\n  }\n\n  return false;\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the file descriptor.\n * @param {number} fd\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction fstatSync(fd\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  fd = getValidatedFd(fd);\n  const ctx = { fd };\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats` for\n * the symbolic link referred to by the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\n                              options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Synchronously retrieves the `fs.Stats`\n * for the `path`.\n * @param {string | Buffer | URL} path\n * @param {{\n *   bigint?: boolean;\n *   throwIfNoEntry?: boolean;\n *   }} [options]\n * @returns {Stats}\n */\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\n                             options.bigint\x2C undefined\x2C ctx);\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\n    return undefined;\n  }\n  handleErrorFromBinding(ctx);\n  return getStatsFromBinding(stats);\n}\n\n/**\n * Reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @param {(\n *   err?: Error\x2C\n *   linkString?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction readlink(path\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously reads the contents of a symbolic link\n * referred to by `path`.\n * @param {string | Buffer | URL} path\n * @param {{ encoding?: string; } | string} [options]\n * @returns {string | Buffer}\n */\nfunction readlinkSync(path\x2C options) {\n  options = getOptions(options);\n  path = getValidatedPath(path\x2C 'oldPath');\n  const ctx = { path };\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\n                                  options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Creates the link called `path` pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type_]\n * @param {(err?: Error) => any} callback_\n * @returns {void}\n */\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\n  const type = (typeof type_ === 'string' ? type_ : null);\n  const callback = makeCallback(arguments[arguments.length - 1]);\n\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n\n  if (isWindows && type === null) {\n    let absoluteTarget;\n    try {\n      // Symlinks targets can be relative to the newly created path.\n      // Calculate absolute file name of the symlink target\x2C and check\n      // if it is a directory. Ignore resolve error to keep symlink\n      // errors consistent between platforms if invalid path is\n      // provided.\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\n    } catch {\n      // Continue regardless of error.\n    }\n    if (absoluteTarget !== undefined) {\n      stat(absoluteTarget\x2C (err\x2C stat) => {\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\n        const resolvedFlags = stringToSymlinkType(resolvedType);\n        const destination = preprocessSymlinkDestination(target\x2C\n                                                         resolvedType\x2C\n                                                         path);\n\n        const req = new FSReqCallback();\n        req.oncomplete = callback;\n        binding.symlink(destination\x2C\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\n      });\n      return;\n    }\n  }\n\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\n\n  const flags = stringToSymlinkType(type);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\n}\n\n/**\n * Synchronously creates the link called `path`\n * pointing to `target`.\n * @param {string | Buffer | URL} target\n * @param {string | Buffer | URL} path\n * @param {string | null} [type]\n * @returns {void}\n */\nfunction symlinkSync(target\x2C path\x2C type) {\n  type = (typeof type === 'string' ? type : null);\n  if (isWindows && type === null) {\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\n      type = 'dir';\n    }\n  }\n  target = getValidatedPath(target\x2C 'target');\n  path = getValidatedPath(path);\n  const flags = stringToSymlinkType(type);\n\n  const ctx = { path: target\x2C dest: path };\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\n\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction link(existingPath\x2C newPath\x2C callback) {\n  callback = makeCallback(callback);\n\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n               pathModule.toNamespacedPath(newPath)\x2C\n               req);\n}\n\n/**\n * Synchronously creates a new link from the `existingPath`\n * to the `newPath`.\n * @param {string | Buffer | URL} existingPath\n * @param {string | Buffer | URL} newPath\n * @returns {void}\n */\nfunction linkSync(existingPath\x2C newPath) {\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\n  newPath = getValidatedPath(newPath\x2C 'newPath');\n\n  const ctx = { path: existingPath\x2C dest: newPath };\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\n                              pathModule.toNamespacedPath(newPath)\x2C\n                              undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction unlink(path\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\n}\n\n/**\n * Synchronously removes a file or symbolic link.\n * @param {string | Buffer | URL} path\n * @returns {void}\n */\nfunction unlinkSync(path) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchmod(fd\x2C mode\x2C callback) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchmod(fd\x2C mode\x2C req);\n}\n\n/**\n * Synchronously sets the permissions on the file.\n * @param {number} fd\n * @param {string | number} mode\n * @returns {void}\n */\nfunction fchmodSync(fd\x2C mode) {\n  fd = getValidatedFd(fd);\n  mode = parseFileMode(mode\x2C 'mode');\n  const ctx = {};\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchmod(path\x2C mode\x2C callback) {\n  callback = maybeCallback(callback);\n  mode = parseFileMode(mode\x2C 'mode');\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\n    if (err) {\n      callback(err);\n      return;\n    }\n    // Prefer to return the chmod error\x2C if one occurs\x2C\n    // but still try to close\x2C and report closing errors if they occur.\n    fs.fchmod(fd\x2C mode\x2C (err) => {\n      fs.close(fd\x2C (err2) => {\n        callback(aggregateTwoErrors(err2\x2C err));\n      });\n    });\n  });\n}\n\n/**\n * Synchronously changes the permissions on a symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} mode\n * @returns {void}\n */\nfunction lchmodSync(path\x2C mode) {\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\n\n  // Prefer to return the chmod error\x2C if one occurs\x2C\n  // but still try to close\x2C and report closing errors if they occur.\n  let ret;\n  try {\n    ret = fs.fchmodSync(fd\x2C mode);\n  } finally {\n    fs.closeSync(fd);\n  }\n  return ret;\n}\n\n/**\n * Asynchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chmod(path\x2C mode\x2C callback) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\n}\n\n/**\n * Synchronously changes the permissions of a file.\n * @param {string | Buffer | URL} path\n * @param {string | number} mode\n * @returns {void}\n */\nfunction chmodSync(path\x2C mode) {\n  path = getValidatedPath(path);\n  mode = parseFileMode(mode\x2C 'mode');\n\n  const ctx = { path };\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the symbolic link.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction lchownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously sets the owner of the file.\n * @param {number} fd\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction fchownSync(fd\x2C uid\x2C gid) {\n  fd = getValidatedFd(fd);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const ctx = {};\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\n}\n\n/**\n * Synchronously changes the owner and group\n * of a file.\n * @param {string | Buffer | URL} path\n * @param {number} uid\n * @param {number} gid\n * @returns {void}\n */\nfunction chownSync(path\x2C uid\x2C gid) {\n  path = getValidatedPath(path);\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\n  const ctx = { path };\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C\n                 toUnixTimestamp(mtime)\x2C\n                 req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by `path`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction utimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\n                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the file system timestamps of the object\n * referenced by the supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\n}\n\n/**\n * Synchronously changes the file system timestamps\n * of the object referenced by the\n * supplied `fd` (file descriptor).\n * @param {number} fd\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction futimesSync(fd\x2C atime\x2C mtime) {\n  fd = getValidatedFd(fd);\n  atime = toUnixTimestamp(atime\x2C 'atime');\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\n  const ctx = {};\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Changes the access and modification times of\n * a file in the same way as `fs.utimes()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\n  callback = makeCallback(callback);\n  path = getValidatedPath(path);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  req);\n}\n\n/**\n * Synchronously changes the access and modification\n * times of a file in the same way as `fs.utimesSync()`.\n * @param {string | Buffer | URL} path\n * @param {number | string | Date} atime\n * @param {number | string | Date} mtime\n * @returns {void}\n */\nfunction lutimesSync(path\x2C atime\x2C mtime) {\n  path = getValidatedPath(path);\n  const ctx = { path };\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\n                  toUnixTimestamp(atime)\x2C\n                  toUnixTimestamp(mtime)\x2C\n                  undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\n  if (signal?.aborted) {\n    const abortError = new AbortError(undefined\x2C { cause: signal?.reason });\n    if (isUserFd) {\n      callback(abortError);\n    } else {\n      fs.close(fd\x2C (err) => {\n        callback(aggregateTwoErrors(err\x2C abortError));\n      });\n    }\n    return;\n  }\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\n    if (writeErr) {\n      if (isUserFd) {\n        callback(writeErr);\n      } else {\n        fs.close(fd\x2C (err) => {\n          callback(aggregateTwoErrors(err\x2C writeErr));\n        });\n      }\n    } else if (written === length) {\n      if (isUserFd) {\n        callback(null);\n      } else {\n        fs.close(fd\x2C callback);\n      }\n    } else {\n      offset += written;\n      length -= written;\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Asynchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   signal?: AbortSignal;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n  const flag = options.flag || 'w';\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    if (typeof data !== 'string') {\n      showStringCoercionDeprecation();\n    }\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  if (isFd(path)) {\n    const isUserFd = true;\n    const signal = options.signal;\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    return;\n  }\n\n  if (checkAborted(options.signal\x2C callback))\n    return;\n\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\n    if (openErr) {\n      callback(openErr);\n    } else {\n      const isUserFd = false;\n      const signal = options.signal;\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\n    }\n  });\n}\n\n/**\n * Synchronously writes data to the file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer | TypedArray | DataView | object} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction writeFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\n\n  if (!isArrayBufferView(data)) {\n    validateStringAfterArrayBufferView(data\x2C 'data');\n    if (typeof data !== 'string') {\n      showStringCoercionDeprecation();\n    }\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\n  }\n\n  const flag = options.flag || 'w';\n\n  const isUserFd = isFd(path); // File descriptor ownership\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\n\n  let offset = 0;\n  let length = data.byteLength;\n  try {\n    while (length > 0) {\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\n      offset += written;\n      length -= written;\n    }\n  } finally {\n    if (!isUserFd) fs.closeSync(fd);\n  }\n}\n\n/**\n * Asynchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @param {(err?: Error) => any} callback\n * @returns {void}\n */\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\n  callback = maybeCallback(callback || options);\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\n}\n\n/**\n * Synchronously appends data to a file.\n * @param {string | Buffer | URL | number} path\n * @param {string | Buffer} data\n * @param {{\n *   encoding?: string | null;\n *   mode?: number;\n *   flag?: string;\n *   } | string} [options]\n * @returns {void}\n */\nfunction appendFileSync(path\x2C data\x2C options) {\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  // Force append behavior when using a supplied file descriptor\n  if (!options.flag || isFd(path))\n    options.flag = 'a';\n\n  fs.writeFileSync(path\x2C data\x2C options);\n}\n\n/**\n * Watches for the changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {string | {\n *   persistent?: boolean;\n *   recursive?: boolean;\n *   encoding?: string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   eventType?: string\x2C\n *   filename?: string | Buffer\n *   ) => any} [listener]\n * @returns {watchers.FSWatcher}\n */\nfunction watch(filename\x2C options\x2C listener) {\n  if (typeof options === 'function') {\n    listener = options;\n  }\n  options = getOptions(options);\n\n  // Don't make changes directly on options object\n  options = copyObject(options);\n\n  if (options.persistent === undefined) options.persistent = true;\n  if (options.recursive === undefined) options.recursive = false;\n  if (options.recursive && !(isOSX || isWindows))\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\n  const watcher = new watchers.FSWatcher();\n  watcher[watchers.kFSWatchStart](filename\x2C\n                                  options.persistent\x2C\n                                  options.recursive\x2C\n                                  options.encoding);\n\n  if (listener) {\n    watcher.addListener('change'\x2C listener);\n  }\n  if (options.signal) {\n    if (options.signal.aborted) {\n      process.nextTick(() => watcher.close());\n    } else {\n      const listener = () => watcher.close();\n      options.signal.addEventListener('abort'\x2C listener);\n      watcher.once('close'\x2C () => {\n        options.signal.removeEventListener('abort'\x2C listener);\n      });\n    }\n  }\n\n  return watcher;\n}\n\n\nconst statWatchers = new SafeMap();\n\n/**\n * Watches for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {{\n *   bigint?: boolean;\n *   persistent?: boolean;\n *   interval?: number;\n *   }} [options]\n * @param {(\n *   current?: Stats\x2C\n *   previous?: Stats\n *   ) => any} listener\n * @returns {watchers.StatWatcher}\n */\nfunction watchFile(filename\x2C options\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  let stat;\n\n  if (options === null || typeof options !== 'object') {\n    listener = options;\n    options = null;\n  }\n\n  options = {\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\n    // a little on the slow side but let's stick with it for now to keep\n    // behavioral changes to a minimum.\n    interval: 5007\x2C\n    persistent: true\x2C\n    ...options\n  };\n\n  validateFunction(listener\x2C 'listener');\n\n  stat = statWatchers.get(filename);\n\n  if (stat === undefined) {\n    stat = new watchers.StatWatcher(options.bigint);\n    stat[watchers.kFSStatWatcherStart](filename\x2C\n                                       options.persistent\x2C options.interval);\n    statWatchers.set(filename\x2C stat);\n  } else {\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\n  }\n\n  stat.addListener('change'\x2C listener);\n  return stat;\n}\n\n/**\n * Stops watching for changes on `filename`.\n * @param {string | Buffer | URL} filename\n * @param {() => any} [listener]\n * @returns {void}\n */\nfunction unwatchFile(filename\x2C listener) {\n  filename = getValidatedPath(filename);\n  filename = pathModule.resolve(filename);\n  const stat = statWatchers.get(filename);\n\n  if (stat === undefined) return;\n\n  if (typeof listener === 'function') {\n    const beforeListenerCount = stat.listenerCount('change');\n    stat.removeListener('change'\x2C listener);\n    if (stat.listenerCount('change') < beforeListenerCount)\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\n  } else {\n    stat.removeAllListeners('change');\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\n  }\n\n  if (stat.listenerCount('change') === 0) {\n    stat.stop();\n    statWatchers.delete(filename);\n  }\n}\n\n\nlet splitRoot;\nif (isWindows) {\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\n  // slash.\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\n  splitRoot = function splitRoot(str) {\n    return RegExpPrototypeExec(splitRootRe\x2C str)[0];\n  };\n} else {\n  splitRoot = function splitRoot(str) {\n    for (let i = 0; i < str.length; ++i) {\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\n        return StringPrototypeSlice(str\x2C 0\x2C i);\n    }\n    return str;\n  };\n}\n\nfunction encodeRealpathResult(result\x2C options) {\n  if (!options || !options.encoding || options.encoding === 'utf8')\n    return result;\n  const asBuffer = Buffer.from(result);\n  if (options.encoding === 'buffer') {\n    return asBuffer;\n  }\n  return asBuffer.toString(options.encoding);\n}\n\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\nlet nextPart;\nif (isWindows) {\n  nextPart = function nextPart(p\x2C i) {\n    for (; i < p.length; ++i) {\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\n\n      // Check for a separator character\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\n        return i;\n    }\n    return -1;\n  };\n} else {\n  nextPart = function nextPart(p\x2C i) {\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\n  };\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string | null; }} [options]\n * @returns {string | Buffer}\n */\nfunction realpathSync(p\x2C options) {\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const cache = options[realpathCacheKey];\n  const maybeCachedResult = cache?.get(p);\n  if (maybeCachedResult) {\n    return maybeCachedResult;\n  }\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n  const original = p;\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  // Skip over roots\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows) {\n    const ctx = { path: base };\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n    handleErrorFromBinding(ctx);\n    knownHard.add(base);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  // NB: p.length changes.\n  while (pos < p.length) {\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base) || cache?.get(base) === base) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        break;\n      }\n      continue;\n    }\n\n    let resolvedLink;\n    const maybeCachedResolved = cache?.get(base);\n    if (maybeCachedResolved) {\n      resolvedLink = maybeCachedResolved;\n    } else {\n      // Use stats array directly to avoid creating an fs.Stats instance just\n      // for our internal use.\n\n      const baseLong = pathModule.toNamespacedPath(base);\n      const ctx = { path: base };\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n\n      if (!isFileType(stats\x2C S_IFLNK)) {\n        knownHard.add(base);\n        cache?.set(base\x2C base);\n        continue;\n      }\n\n      // Read the link if it wasn't read before\n      // dev/ino always return 0 on windows\x2C so skip the check.\n      let linkTarget = null;\n      let id;\n      if (!isWindows) {\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\n        id = `${dev}:${ino}`;\n        if (seenLinks.has(id)) {\n          linkTarget = seenLinks.get(id);\n        }\n      }\n      if (linkTarget === null) {\n        const ctx = { path: base };\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\n        handleErrorFromBinding(ctx);\n      }\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\n\n      cache?.set(base\x2C resolvedLink);\n      if (!isWindows) seenLinks.set(id\x2C linkTarget);\n    }\n\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n\n    // Skip over roots\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      const ctx = { path: base };\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\n      handleErrorFromBinding(ctx);\n      knownHard.add(base);\n    }\n  }\n\n  cache?.set(original\x2C p);\n  return encodeRealpathResult(p\x2C options);\n}\n\n/**\n * Returns the resolved pathname.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @returns {string | Buffer}\n */\nrealpathSync.native = (path\x2C options) => {\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const ctx = { path };\n  const result = binding.realpath(path\x2C options.encoding\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n};\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} p\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nfunction realpath(p\x2C options\x2C callback) {\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\n  options = getOptions(options);\n  p = toPathIfFileURL(p);\n\n  if (typeof p !== 'string') {\n    p += '';\n  }\n  validatePath(p);\n  p = pathModule.resolve(p);\n\n  const seenLinks = new SafeMap();\n  const knownHard = new SafeSet();\n\n  // Current character position in p\n  let pos;\n  // The partial path so far\x2C including a trailing slash if any\n  let current;\n  // The partial path without a trailing slash (except when pointing at a root)\n  let base;\n  // The partial path scanned in the previous round\x2C with slash\n  let previous;\n\n  current = base = splitRoot(p);\n  pos = current.length;\n\n  // On windows\x2C check that the root exists. On unix there is no need.\n  if (isWindows && !knownHard.has(base)) {\n    fs.lstat(base\x2C (err\x2C stats) => {\n      if (err) return callback(err);\n      knownHard.add(base);\n      LOOP();\n    });\n  } else {\n    process.nextTick(LOOP);\n  }\n\n  // Walk down the path\x2C swapping out linked path parts for their real\n  // values\n  function LOOP() {\n    // Stop if scanned past end of path\n    if (pos >= p.length) {\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\n    }\n\n    // find the next part\n    const result = nextPart(p\x2C pos);\n    previous = current;\n    if (result === -1) {\n      const last = StringPrototypeSlice(p\x2C pos);\n      current += last;\n      base = previous + last;\n      pos = p.length;\n    } else {\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\n      pos = result + 1;\n    }\n\n    // Continue if not a symlink\x2C break if a pipe/socket\n    if (knownHard.has(base)) {\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\n      }\n      return process.nextTick(LOOP);\n    }\n\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\n  }\n\n  function gotStat(err\x2C stats) {\n    if (err) return callback(err);\n\n    // If not a symlink\x2C skip to the next path part\n    if (!stats.isSymbolicLink()) {\n      knownHard.add(base);\n      return process.nextTick(LOOP);\n    }\n\n    // Stat & read the link if not read before.\n    // Call `gotTarget()` as soon as the link target is known.\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\n    let id;\n    if (!isWindows) {\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\n      id = `${dev}:${ino}`;\n      if (seenLinks.has(id)) {\n        return gotTarget(null\x2C seenLinks.get(id));\n      }\n    }\n    fs.stat(base\x2C (err) => {\n      if (err) return callback(err);\n\n      fs.readlink(base\x2C (err\x2C target) => {\n        if (!isWindows) seenLinks.set(id\x2C target);\n        gotTarget(err\x2C target);\n      });\n    });\n  }\n\n  function gotTarget(err\x2C target) {\n    if (err) return callback(err);\n\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\n  }\n\n  function gotResolvedLink(resolvedLink) {\n    // Resolve the link\x2C then start over\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\n    current = base = splitRoot(p);\n    pos = current.length;\n\n    // On windows\x2C check that the root exists. On unix there is no need.\n    if (isWindows && !knownHard.has(base)) {\n      fs.lstat(base\x2C (err) => {\n        if (err) return callback(err);\n        knownHard.add(base);\n        LOOP();\n      });\n    } else {\n      process.nextTick(LOOP);\n    }\n  }\n}\n\n/**\n * Asynchronously computes the canonical pathname by\n * resolving `.`\x2C `..` and symbolic links.\n * @param {string | Buffer | URL} path\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   resolvedPath?: string | Buffer\n *   ) => any} callback\n * @returns {void}\n */\nrealpath.native = (path\x2C options\x2C callback) => {\n  callback = makeCallback(callback || options);\n  options = getOptions(options);\n  path = getValidatedPath(path);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  return binding.realpath(path\x2C options.encoding\x2C req);\n};\n\n/**\n * Creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @param {(\n *   err?: Error\x2C\n *   directory?: string\n *   ) => any} callback\n * @returns {void}\n */\nfunction mkdtemp(prefix\x2C options\x2C callback) {\n  callback = makeCallback(typeof options === 'function' ? options : callback);\n  options = getOptions(options);\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\n}\n\n/**\n * Synchronously creates a unique temporary directory.\n * @param {string} prefix\n * @param {string | { encoding?: string; }} [options]\n * @returns {string}\n */\nfunction mkdtempSync(prefix\x2C options) {\n  options = getOptions(options);\n\n  validateString(prefix\x2C 'prefix');\n  nullCheck(prefix\x2C 'prefix');\n  warnOnNonPortableTemplate(prefix);\n  const path = `${prefix}XXXXXX`;\n  const ctx = { path };\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\n                                 undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n  return result;\n}\n\n/**\n * Asynchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\n  if (typeof mode === 'function') {\n    callback = mode;\n    mode = 0;\n  }\n\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  callback = makeCallback(callback);\n\n  const req = new FSReqCallback();\n  req.oncomplete = callback;\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\n}\n\n/**\n * Synchronously copies `src` to `dest`. By\n * default\x2C `dest` is overwritten if it already exists.\n * @param {string | Buffer | URL} src\n * @param {string | Buffer | URL} dest\n * @param {number} [mode]\n * @returns {void}\n */\nfunction copyFileSync(src\x2C dest\x2C mode) {\n  src = getValidatedPath(src\x2C 'src');\n  dest = getValidatedPath(dest\x2C 'dest');\n\n  const ctx = { path: src\x2C dest };  // non-prefixed\n\n  src = pathModule._makeLong(src);\n  dest = pathModule._makeLong(dest);\n  mode = getValidMode(mode\x2C 'copyFile');\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\n  handleErrorFromBinding(ctx);\n}\n\n/**\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @param {() => any} callback\n * @returns {void}\n */\nfunction cp(src\x2C dest\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n  callback = makeCallback(callback);\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpFn(src\x2C dest\x2C options\x2C callback);\n}\n\n/**\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\n * symlink. The contents of directories will be copied recursively.\n * @param {string | URL} src\n * @param {string | URL} dest\n * @param {object} [options]\n * @returns {void}\n */\nfunction cpSync(src\x2C dest\x2C options) {\n  options = validateCpOptions(options);\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\n  lazyLoadCp();\n  cpSyncFn(src\x2C dest\x2C options);\n}\n\nfunction lazyLoadStreams() {\n  if (!ReadStream) {\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\n    FileReadStream = ReadStream;\n    FileWriteStream = WriteStream;\n  }\n}\n\n/**\n * Creates a readable stream with a default `highWaterMark`\n * of 64 KiB.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   end?: number;\n *   highWaterMark?: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {ReadStream}\n */\nfunction createReadStream(path\x2C options) {\n  lazyLoadStreams();\n  return new ReadStream(path\x2C options);\n}\n\n/**\n * Creates a write stream.\n * @param {string | Buffer | URL} path\n * @param {string | {\n *   flags?: string;\n *   encoding?: string;\n *   fd?: number | FileHandle;\n *   mode?: number;\n *   autoClose?: boolean;\n *   emitClose?: boolean;\n *   start: number;\n *   fs?: object | null;\n *   }} [options]\n * @returns {WriteStream}\n */\nfunction createWriteStream(path\x2C options) {\n  lazyLoadStreams();\n  return new WriteStream(path\x2C options);\n}\n\nmodule.exports = fs = {\n  appendFile\x2C\n  appendFileSync\x2C\n  access\x2C\n  accessSync\x2C\n  chown\x2C\n  chownSync\x2C\n  chmod\x2C\n  chmodSync\x2C\n  close\x2C\n  closeSync\x2C\n  copyFile\x2C\n  copyFileSync\x2C\n  cp\x2C\n  cpSync\x2C\n  createReadStream\x2C\n  createWriteStream\x2C\n  exists\x2C\n  existsSync\x2C\n  fchown\x2C\n  fchownSync\x2C\n  fchmod\x2C\n  fchmodSync\x2C\n  fdatasync\x2C\n  fdatasyncSync\x2C\n  fstat\x2C\n  fstatSync\x2C\n  fsync\x2C\n  fsyncSync\x2C\n  ftruncate\x2C\n  ftruncateSync\x2C\n  futimes\x2C\n  futimesSync\x2C\n  lchown\x2C\n  lchownSync\x2C\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\n  link\x2C\n  linkSync\x2C\n  lstat\x2C\n  lstatSync\x2C\n  lutimes\x2C\n  lutimesSync\x2C\n  mkdir\x2C\n  mkdirSync\x2C\n  mkdtemp\x2C\n  mkdtempSync\x2C\n  open\x2C\n  openSync\x2C\n  opendir\x2C\n  opendirSync\x2C\n  readdir\x2C\n  readdirSync\x2C\n  read\x2C\n  readSync\x2C\n  readv\x2C\n  readvSync\x2C\n  readFile\x2C\n  readFileSync\x2C\n  readlink\x2C\n  readlinkSync\x2C\n  realpath\x2C\n  realpathSync\x2C\n  rename\x2C\n  renameSync\x2C\n  rm\x2C\n  rmSync\x2C\n  rmdir\x2C\n  rmdirSync\x2C\n  stat\x2C\n  statSync\x2C\n  symlink\x2C\n  symlinkSync\x2C\n  truncate\x2C\n  truncateSync\x2C\n  unwatchFile\x2C\n  unlink\x2C\n  unlinkSync\x2C\n  utimes\x2C\n  utimesSync\x2C\n  watch\x2C\n  watchFile\x2C\n  writeFile\x2C\n  writeFileSync\x2C\n  write\x2C\n  writeSync\x2C\n  writev\x2C\n  writevSync\x2C\n  Dir\x2C\n  Dirent\x2C\n  Stats\x2C\n\n  get ReadStream() {\n    lazyLoadStreams();\n    return ReadStream;\n  }\x2C\n\n  set ReadStream(val) {\n    ReadStream = val;\n  }\x2C\n\n  get WriteStream() {\n    lazyLoadStreams();\n    return WriteStream;\n  }\x2C\n\n  set WriteStream(val) {\n    WriteStream = val;\n  }\x2C\n\n  // Legacy names... these have to be separate because of how graceful-fs\n  // (and possibly other) modules monkey patch the values.\n  get FileReadStream() {\n    lazyLoadStreams();\n    return FileReadStream;\n  }\x2C\n\n  set FileReadStream(val) {\n    FileReadStream = val;\n  }\x2C\n\n  get FileWriteStream() {\n    lazyLoadStreams();\n    return FileWriteStream;\n  }\x2C\n\n  set FileWriteStream(val) {\n    FileWriteStream = val;\n  }\x2C\n\n  // For tests\n  _toUnixTimestamp: toUnixTimestamp\n};\n\nObjectDefineProperties(fs\x2C {\n  F_OK: { __proto__: null\x2C enumerable: true\x2C value: F_OK || 0 }\x2C\n  R_OK: { __proto__: null\x2C enumerable: true\x2C value: R_OK || 0 }\x2C\n  W_OK: { __proto__: null\x2C enumerable: true\x2C value: W_OK || 0 }\x2C\n  X_OK: { __proto__: null\x2C enumerable: true\x2C value: X_OK || 0 }\x2C\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n  promises: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    enumerable: true\x2C\n    get() {\n      promises ??= require('internal/fs/promises').exports;\n      return promises;\n    }\n  }\n});\n
code-source-info,0xb46bbe77e40,73,65937,69828,C0O65954C6O65964C12O65987C18O65991C24O66013C28O66046C38O66061C44O66061C48O66080C54O66095C60O66095C67O66124C69O66132C71O66131C75O66179C79O66184C85O66186C94O66196C96O66225C98O66250C99O66276C105O66276C111O66311C117O66311C123O66345C126O66392C128O66467C130O66562C132O66638C134O66672C140O66689C146O66719C151O66801C157O66834C165O66842C172O66854C178O66862C186O66868C190O66879C196O66879C212O66862C217O66931C223O66931C227O66974C233O66974C238O67117C242O67113C247O67172C253O67172C259O67194C262O67218C264O67229C269O67258C275O67258C282O67294C284O67305C291O67317C293O67333C297O67355C304O67382C306O67393C312O67429C323O67393C335O67441C337O67459C350O67459C355O67457C359O67503C361O67516C365O67603C371O67603C385O67621C391O67623C403O67633C408O67651C414O67666C418O67674C426O67686C430O67655C443O67719C447O67727C455O67739C459O67708C466O67760C468O67781C470O67806C472O67852C479O67857C485O67859C494O67874C496O67907C503O68089C509O68100C515O68100C521O68142C529O68150C536O68178C542O68186C560O68186C566O68231C572O68231C576O68267C582O68290C586O68272C593O68320C599O68320C604O68339C611O68344C617O68346C626O68371C628O68525C631O68541C634O68551C640O68589C647O68618C656O68589C663O68648C671O68677C680O68648C687O68695C701O68710C707O68739C713O68739C720O68783C726O68783C733O68816C737O68863C745O68871C752O68887C758O68895C776O68895C781O68942C787O68942C791O68979C797O69000C815O69000C822O69055C828O69055C832O69098C838O69124C844O69124C851O69162C858O69167C864O69169C873O69200C879O69226C885O69226C891O69299C897O69314C905O69336C909O69336C916O69314C924O69395C930O69412C936O69444C941O69530C947O69558C953O69558C960O69589C968O69597C975O69611C981O69619C989O69625C993O69636C999O69636C1015O69619C1020O69690C1026O69690C1030O69735C1036O69735C1041O67102C1047O69759C1054O69764C1060O69766C1069O69786C1073O69793C1078O69826,,
tick,0x7ff805e2d810,159161,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805edebe6,159177,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805e4dde4,159187,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x10280e190,159197,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805f107dd,159206,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805ea4dea,159215,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805db1607,159224,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805edec0d,159234,0,0x0,3,0x102d5e910,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
new,MemoryChunk,0xb46b9680000,262144
code-creation,LazyCompile,10,159285,0xb46bbe7e730,135,getOptions node:internal/fs/utils:319:20,0xb46d10b4a00,~
script-source,77,node:internal/fs/utils,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  BigInt\x2C\n  Date\x2C\n  DateNow\x2C\n  DatePrototypeGetTime\x2C\n  ErrorCaptureStackTrace\x2C\n  FunctionPrototypeCall\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsInteger\x2C\n  MathMin\x2C\n  MathRound\x2C\n  ObjectIs\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  ReflectOwnKeys\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  Symbol\x2C\n  TypedArrayPrototypeIncludes\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst {\n  codes: {\n    ERR_FS_EISDIR\x2C\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\n    ERR_INCOMPATIBLE_OPTION_PAIR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_OUT_OF_RANGE\n  }\x2C\n  hideStackFrames\x2C\n  uvException\n} = require('internal/errors');\nconst {\n  isArrayBufferView\x2C\n  isBigInt64Array\x2C\n  isDate\x2C\n  isUint8Array\x2C\n} = require('internal/util/types');\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst { toPathIfFileURL } = require('internal/url');\nconst {\n  validateAbortSignal\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateInteger\x2C\n  validateObject\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst pathModule = require('path');\nconst kType = Symbol('type');\nconst kStats = Symbol('stats');\nconst assert = require('internal/assert');\n\nconst {\n  fs: {\n    F_OK = 0\x2C\n    W_OK = 0\x2C\n    R_OK = 0\x2C\n    X_OK = 0\x2C\n    COPYFILE_EXCL\x2C\n    COPYFILE_FICLONE\x2C\n    COPYFILE_FICLONE_FORCE\x2C\n    O_APPEND\x2C\n    O_CREAT\x2C\n    O_EXCL\x2C\n    O_RDONLY\x2C\n    O_RDWR\x2C\n    O_SYNC\x2C\n    O_TRUNC\x2C\n    O_WRONLY\x2C\n    S_IFBLK\x2C\n    S_IFCHR\x2C\n    S_IFDIR\x2C\n    S_IFIFO\x2C\n    S_IFLNK\x2C\n    S_IFMT\x2C\n    S_IFREG\x2C\n    S_IFSOCK\x2C\n    UV_FS_SYMLINK_DIR\x2C\n    UV_FS_SYMLINK_JUNCTION\x2C\n    UV_DIRENT_UNKNOWN\x2C\n    UV_DIRENT_FILE\x2C\n    UV_DIRENT_DIR\x2C\n    UV_DIRENT_LINK\x2C\n    UV_DIRENT_FIFO\x2C\n    UV_DIRENT_SOCKET\x2C\n    UV_DIRENT_CHAR\x2C\n    UV_DIRENT_BLOCK\n  }\x2C\n  os: {\n    errno: {\n      EISDIR\n    }\n  }\n} = internalBinding('constants');\n\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\n// available on specific systems. They can be used in combination as well\n// (F_OK | R_OK | W_OK | X_OK).\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\n\nconst kDefaultCopyMode = 0;\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\nconst kMinimumCopyMode = MathMin(\n  kDefaultCopyMode\x2C\n  COPYFILE_EXCL\x2C\n  COPYFILE_FICLONE\x2C\n  COPYFILE_FICLONE_FORCE\n);\nconst kMaximumCopyMode = COPYFILE_EXCL |\n                         COPYFILE_FICLONE |\n                         COPYFILE_FICLONE_FORCE;\n\n// Most platforms don't allow reads or writes >= 2 GiB.\n// See https://github.com/libuv/libuv/pull/1501.\nconst kIoMaxLength = 2 ** 31 - 1;\n\n// Use 64kb in case the file type is not a regular file and thus do not know the\n// actual file size. Increasing the value further results in more frequent over\n// allocation for small files and consumes CPU time and memory that should be\n// used else wise.\n// Use up to 512kb per read otherwise to partition reading big files to prevent\n// blocking other threads in case the available threads are all in use.\nconst kReadFileUnknownBufferLength = 64 * 1024;\nconst kReadFileBufferLength = 512 * 1024;\n\nconst kWriteFileMaxChunkSize = 512 * 1024;\n\nconst kMaxUserId = 2 ** 32 - 1;\n\nconst isWindows = process.platform === 'win32';\n\nlet fs;\nfunction lazyLoadFs() {\n  if (!fs) {\n    fs = require('fs');\n  }\n  return fs;\n}\n\nfunction assertEncoding(encoding) {\n  if (encoding && !Buffer.isEncoding(encoding)) {\n    const reason = 'is invalid encoding';\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\n  }\n}\n\nclass Dirent {\n  constructor(name\x2C type) {\n    this.name = name;\n    this[kType] = type;\n  }\n\n  isDirectory() {\n    return this[kType] === UV_DIRENT_DIR;\n  }\n\n  isFile() {\n    return this[kType] === UV_DIRENT_FILE;\n  }\n\n  isBlockDevice() {\n    return this[kType] === UV_DIRENT_BLOCK;\n  }\n\n  isCharacterDevice() {\n    return this[kType] === UV_DIRENT_CHAR;\n  }\n\n  isSymbolicLink() {\n    return this[kType] === UV_DIRENT_LINK;\n  }\n\n  isFIFO() {\n    return this[kType] === UV_DIRENT_FIFO;\n  }\n\n  isSocket() {\n    return this[kType] === UV_DIRENT_SOCKET;\n  }\n}\n\nclass DirentFromStats extends Dirent {\n  constructor(name\x2C stats) {\n    super(name\x2C null);\n    this[kStats] = stats;\n  }\n}\n\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\n  if (name === 'constructor') {\n    continue;\n  }\n  DirentFromStats.prototype[name] = function() {\n    return this[kStats][name]();\n  };\n}\n\nfunction copyObject(source) {\n  const target = {};\n  for (const key in source)\n    target[key] = source[key];\n  return target;\n}\n\nconst bufferSep = Buffer.from(pathModule.sep);\n\nfunction join(path\x2C name) {\n  if ((typeof path === 'string' || isUint8Array(path)) &&\n      name === undefined) {\n    return path;\n  }\n\n  if (typeof path === 'string' && isUint8Array(name)) {\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\n    return Buffer.concat([pathBuffer\x2C name]);\n  }\n\n  if (typeof path === 'string' && typeof name === 'string') {\n    return pathModule.join(path\x2C name);\n  }\n\n  if (isUint8Array(path) && isUint8Array(name)) {\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\n}\n\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\n  let i;\n  if (typeof callback === 'function') {\n    const len = names.length;\n    let toFinish = 0;\n    callback = once(callback);\n    for (i = 0; i < len; i++) {\n      const type = types[i];\n      if (type === UV_DIRENT_UNKNOWN) {\n        const name = names[i];\n        const idx = i;\n        toFinish++;\n        let filepath;\n        try {\n          filepath = join(path\x2C name);\n        } catch (err) {\n          callback(err);\n          return;\n        }\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n          if (err) {\n            callback(err);\n            return;\n          }\n          names[idx] = new DirentFromStats(name\x2C stats);\n          if (--toFinish === 0) {\n            callback(null\x2C names);\n          }\n        });\n      } else {\n        names[i] = new Dirent(names[i]\x2C types[i]);\n      }\n    }\n    if (toFinish === 0) {\n      callback(null\x2C names);\n    }\n  } else {\n    const len = names.length;\n    for (i = 0; i < len; i++) {\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\n    }\n    return names;\n  }\n}\n\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\n  if (typeof callback === 'function') {\n    if (type === UV_DIRENT_UNKNOWN) {\n      let filepath;\n      try {\n        filepath = join(path\x2C name);\n      } catch (err) {\n        callback(err);\n        return;\n      }\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\n        if (err) {\n          callback(err);\n          return;\n        }\n        callback(null\x2C new DirentFromStats(name\x2C stats));\n      });\n    } else {\n      callback(null\x2C new Dirent(name\x2C type));\n    }\n  } else if (type === UV_DIRENT_UNKNOWN) {\n    const stats = lazyLoadFs().lstatSync(join(path\x2C name));\n    return new DirentFromStats(name\x2C stats);\n  } else {\n    return new Dirent(name\x2C type);\n  }\n}\n\nfunction getOptions(options\x2C defaultOptions = kEmptyObject) {\n  if (options == null || typeof options === 'function') {\n    return defaultOptions;\n  }\n\n  if (typeof options === 'string') {\n    defaultOptions = { ...defaultOptions };\n    defaultOptions.encoding = options;\n    options = defaultOptions;\n  } else if (typeof options !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\n  }\n\n  if (options.encoding !== 'buffer')\n    assertEncoding(options.encoding);\n\n  if (options.signal !== undefined) {\n    validateAbortSignal(options.signal\x2C 'options.signal');\n  }\n  return options;\n}\n\n/**\n * @param {InternalFSBinding.FSSyncContext} ctx\n */\nfunction handleErrorFromBinding(ctx) {\n  if (ctx.errno !== undefined) {  // libuv error numbers\n    const err = uvException(ctx);\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\n    throw err;\n  }\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\n    // usually caused by memory problems. We need to figure out proper error\n    // code(s) for this.\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\n    throw ctx.error;\n  }\n}\n\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\n// otherwise return silently.\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\n  const pathIsString = typeof path === 'string';\n  const pathIsUint8Array = isUint8Array(path);\n\n  // We can only perform meaningful checks on strings and Uint8Arrays.\n  if ((!pathIsString && !pathIsUint8Array) ||\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\n    return;\n  }\n\n  const err = new ERR_INVALID_ARG_VALUE(\n    propName\x2C\n    path\x2C\n    'must be a string or Uint8Array without null bytes'\n  );\n  if (throwError) {\n    throw err;\n  }\n  return err;\n});\n\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\n  if (!isWindows) {\n    // No preprocessing is needed on Unix.\n    return path;\n  }\n  path = '' + path;\n  if (type === 'junction') {\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\n    // A relative target is relative to the link's parent directory.\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\n    return pathModule.toNamespacedPath(path);\n  }\n  if (pathModule.isAbsolute(path)) {\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\n    return pathModule.toNamespacedPath(path);\n  }\n  // Windows symlinks don't tolerate forward slashes.\n  return RegExpPrototypeSymbolReplace(/\\//g\x2C path\x2C '\\\\');\n}\n\n// Constructor for file stats.\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                   ino\x2C size\x2C blocks) {\n  this.dev = dev;\n  this.mode = mode;\n  this.nlink = nlink;\n  this.uid = uid;\n  this.gid = gid;\n  this.rdev = rdev;\n  this.blksize = blksize;\n  this.ino = ino;\n  this.size = size;\n  this.blocks = blocks;\n}\n\nStatsBase.prototype.isDirectory = function() {\n  return this._checkModeProperty(S_IFDIR);\n};\n\nStatsBase.prototype.isFile = function() {\n  return this._checkModeProperty(S_IFREG);\n};\n\nStatsBase.prototype.isBlockDevice = function() {\n  return this._checkModeProperty(S_IFBLK);\n};\n\nStatsBase.prototype.isCharacterDevice = function() {\n  return this._checkModeProperty(S_IFCHR);\n};\n\nStatsBase.prototype.isSymbolicLink = function() {\n  return this._checkModeProperty(S_IFLNK);\n};\n\nStatsBase.prototype.isFIFO = function() {\n  return this._checkModeProperty(S_IFIFO);\n};\n\nStatsBase.prototype.isSocket = function() {\n  return this._checkModeProperty(S_IFSOCK);\n};\n\nconst kNsPerMsBigInt = 10n ** 6n;\nconst kNsPerSecBigInt = 10n ** 9n;\nconst kMsPerSec = 10 ** 3;\nconst kNsPerMs = 10 ** 6;\nfunction msFromTimeSpec(sec\x2C nsec) {\n  return sec * kMsPerSec + nsec / kNsPerMs;\n}\n\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\n  return sec * kNsPerSecBigInt + nsec;\n}\n\n// The Date constructor performs Math.floor() on the absolute value\n// of the timestamp: https://tc39.es/ecma262/#sec-timeclip\n// Since there may be a precision loss when the timestamp is\n// converted to a floating point number\x2C we manually round\n// the timestamp here before passing it to Date().\n// Refs: https://github.com/nodejs/node/pull/12607\n// Refs: https://github.com/nodejs/node/pull/43714\nfunction dateFromMs(ms) {\n  // Coercing to number\x2C ms can be bigint\n  return new Date(MathRound(Number(ms)));\n}\n\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                     ino\x2C size\x2C blocks\x2C\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n                                 ino\x2C size\x2C blocks]);\n\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\n  this.atimeNs = atimeNs;\n  this.mtimeNs = mtimeNs;\n  this.ctimeNs = ctimeNs;\n  this.birthtimeNs = birthtimeNs;\n  this.atime = dateFromMs(this.atimeMs);\n  this.mtime = dateFromMs(this.mtimeMs);\n  this.ctime = dateFromMs(this.ctimeMs);\n  this.birthtime = dateFromMs(this.birthtimeMs);\n}\n\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\n\nBigIntStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\n};\n\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\n               ino\x2C size\x2C blocks\x2C\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\n                        blksize\x2C ino\x2C size\x2C blocks);\n  this.atimeMs = atimeMs;\n  this.mtimeMs = mtimeMs;\n  this.ctimeMs = ctimeMs;\n  this.birthtimeMs = birthtimeMs;\n  this.atime = dateFromMs(atimeMs);\n  this.mtime = dateFromMs(mtimeMs);\n  this.ctime = dateFromMs(ctimeMs);\n  this.birthtime = dateFromMs(birthtimeMs);\n}\n\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\nObjectSetPrototypeOf(Stats\x2C StatsBase);\n\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\nStats.prototype.isFile = StatsBase.prototype.isFile;\n\nStats.prototype._checkModeProperty = function(property) {\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\n    property === S_IFSOCK)) {\n    return false;  // Some types are not available on Windows\n  }\n  return (this.mode & S_IFMT) === property;\n};\n\n/**\n * @param {Float64Array | BigInt64Array} stats\n * @param {number} offset\n * @returns {BigIntStats | Stats}\n */\nfunction getStatsFromBinding(stats\x2C offset = 0) {\n  if (isBigInt64Array(stats)) {\n    return new BigIntStats(\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n      stats[9 + offset]\x2C\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\n    );\n  }\n  return new Stats(\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\n    stats[9 + offset]\x2C\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\n  );\n}\n\nfunction stringToFlags(flags\x2C name = 'flags') {\n  if (typeof flags === 'number') {\n    validateInt32(flags\x2C name);\n    return flags;\n  }\n\n  if (flags == null) {\n    return O_RDONLY;\n  }\n\n  switch (flags) {\n    case 'r' : return O_RDONLY;\n    case 'rs' : // Fall through.\n    case 'sr' : return O_RDONLY | O_SYNC;\n    case 'r+' : return O_RDWR;\n    case 'rs+' : // Fall through.\n    case 'sr+' : return O_RDWR | O_SYNC;\n\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\n    case 'wx' : // Fall through.\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\n\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\n    case 'wx+': // Fall through.\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\n\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\n    case 'ax' : // Fall through.\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\n    case 'as' : // Fall through.\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\n\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\n    case 'ax+': // Fall through.\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\n    case 'as+': // Fall through.\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\n  }\n\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\n}\n\nconst stringToSymlinkType = hideStackFrames((type) => {\n  let flags = 0;\n  if (typeof type === 'string') {\n    switch (type) {\n      case 'dir':\n        flags |= UV_FS_SYMLINK_DIR;\n        break;\n      case 'junction':\n        flags |= UV_FS_SYMLINK_JUNCTION;\n        break;\n      case 'file':\n        break;\n      default:\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\n    }\n  }\n  return flags;\n});\n\n// converts Date or number to a fractional UNIX timestamp\nfunction toUnixTimestamp(time\x2C name = 'time') {\n  // eslint-disable-next-line eqeqeq\n  if (typeof time === 'string' && +time == time) {\n    return +time;\n  }\n  if (NumberIsFinite(time)) {\n    if (time < 0) {\n      return DateNow() / 1000;\n    }\n    return time;\n  }\n  if (isDate(time)) {\n    // Convert to 123.456 UNIX timestamp\n    return DatePrototypeGetTime(time) / 1000;\n  }\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\n}\n\nconst validateOffsetLengthRead = hideStackFrames(\n  (offset\x2C length\x2C bufferLength) => {\n    if (offset < 0) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\n    }\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n    if (offset + length > bufferLength) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C\n                                 `<= ${bufferLength - offset}`\x2C length);\n    }\n  }\n);\n\nconst validateOffsetLengthWrite = hideStackFrames(\n  (offset\x2C length\x2C byteLength) => {\n    if (offset > byteLength) {\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\n    }\n\n    if (length > byteLength - offset) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\n    }\n\n    if (length < 0) {\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\n    }\n\n    validateInt32(length\x2C 'length'\x2C 0);\n  }\n);\n\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\n  if (typeof path !== 'string' && !isUint8Array(path)) {\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\n  }\n\n  const err = nullCheck(path\x2C propName\x2C false);\n\n  if (err !== undefined) {\n    throw err;\n  }\n});\n\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\n  const path = toPathIfFileURL(fileURLOrPath);\n  validatePath(path\x2C propName);\n  return path;\n});\n\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\n  if (ObjectIs(fd\x2C -0)) {\n    return 0;\n  }\n\n  validateInt32(fd\x2C propName\x2C 0);\n\n  return fd;\n});\n\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\n  if (!ArrayIsArray(buffers))\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n\n  for (let i = 0; i < buffers.length; i++) {\n    if (!isArrayBufferView(buffers[i]))\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\n  }\n\n  return buffers;\n});\n\nlet nonPortableTemplateWarn = true;\n\nfunction warnOnNonPortableTemplate(template) {\n  // Template strings passed to the mkdtemp() family of functions should not\n  // end with 'X' because they are handled inconsistently across platforms.\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\n                        'For details see: https://nodejs.org/api/fs.html');\n    nonPortableTemplateWarn = false;\n  }\n}\n\nconst defaultCpOptions = {\n  dereference: false\x2C\n  errorOnExist: false\x2C\n  filter: undefined\x2C\n  force: true\x2C\n  preserveTimestamps: false\x2C\n  recursive: false\x2C\n  verbatimSymlinks: false\x2C\n};\n\nconst defaultRmOptions = {\n  recursive: false\x2C\n  force: false\x2C\n  retryDelay: 100\x2C\n  maxRetries: 0\n};\n\nconst defaultRmdirOptions = {\n  retryDelay: 100\x2C\n  maxRetries: 0\x2C\n  recursive: false\x2C\n};\n\nconst validateCpOptions = hideStackFrames((options) => {\n  if (options === undefined)\n    return { ...defaultCpOptions };\n  validateObject(options\x2C 'options');\n  options = { ...defaultCpOptions\x2C ...options };\n  validateBoolean(options.dereference\x2C 'options.dereference');\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\n  validateBoolean(options.force\x2C 'options.force');\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\n  validateBoolean(options.recursive\x2C 'options.recursive');\n  validateBoolean(options.verbatimSymlinks\x2C 'options.verbatimSymlinks');\n  if (options.dereference === true && options.verbatimSymlinks === true) {\n    throw new ERR_INCOMPATIBLE_OPTION_PAIR('dereference'\x2C 'verbatimSymlinks');\n  }\n  if (options.filter !== undefined) {\n    validateFunction(options.filter\x2C 'options.filter');\n  }\n  return options;\n});\n\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  lazyLoadFs().stat(path\x2C (err\x2C stats) => {\n    if (err) {\n      if (options.force && err.code === 'ENOENT') {\n        return cb(null\x2C options);\n      }\n      return cb(err\x2C options);\n    }\n\n    if (expectDir && !stats.isDirectory()) {\n      return cb(false);\n    }\n\n    if (stats.isDirectory() && !options.recursive) {\n      return cb(new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      }));\n    }\n    return cb(null\x2C options);\n  });\n});\n\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\n  validateBoolean(options.force\x2C 'options.force');\n\n  if (!options.force || expectDir || !options.recursive) {\n    const isDirectory = lazyLoadFs()\n      .statSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\n\n    if (expectDir && !isDirectory) {\n      return false;\n    }\n\n    if (isDirectory && !options.recursive) {\n      throw new ERR_FS_EISDIR({\n        code: 'EISDIR'\x2C\n        message: 'is a directory'\x2C\n        path\x2C\n        syscall: 'rm'\x2C\n        errno: EISDIR\n      });\n    }\n  }\n\n  return options;\n});\n\nlet recursiveRmdirWarned = process.noDeprecation;\nfunction emitRecursiveRmdirWarning() {\n  if (!recursiveRmdirWarned) {\n    process.emitWarning(\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\n      'DeprecationWarning'\x2C\n      'DEP0147'\n    );\n    recursiveRmdirWarned = true;\n  }\n}\n\nconst validateRmdirOptions = hideStackFrames(\n  (options\x2C defaults = defaultRmdirOptions) => {\n    if (options === undefined)\n      return defaults;\n    validateObject(options\x2C 'options');\n\n    options = { ...defaults\x2C ...options };\n\n    validateBoolean(options.recursive\x2C 'options.recursive');\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\n\n    return options;\n  });\n\nconst getValidMode = hideStackFrames((mode\x2C type) => {\n  let min = kMinimumAccessMode;\n  let max = kMaximumAccessMode;\n  let def = F_OK;\n  if (type === 'copyFile') {\n    min = kMinimumCopyMode;\n    max = kMaximumCopyMode;\n    def = mode || kDefaultCopyMode;\n  } else {\n    assert(type === 'access');\n  }\n  if (mode == null) {\n    return def;\n  }\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\n    return mode;\n  }\n  if (typeof mode !== 'number') {\n    throw new ERR_INVALID_ARG_TYPE('mode'\x2C 'integer'\x2C mode);\n  }\n  throw new ERR_OUT_OF_RANGE(\n    'mode'\x2C `an integer >= ${min} && <= ${max}`\x2C mode);\n});\n\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer === 'string') {\n    return;\n  }\n\n  if (\n    typeof buffer === 'object' &&\n    buffer !== null &&\n    typeof buffer.toString === 'function' &&\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\n  ) {\n    return;\n  }\n\n  throw new ERR_INVALID_ARG_TYPE(\n    name\x2C\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n    buffer\n  );\n});\n\nconst validatePrimitiveStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\n  if (typeof buffer !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(\n      name\x2C\n      ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n      buffer\n    );\n  }\n});\n\nconst validatePosition = hideStackFrames((position\x2C name) => {\n  if (typeof position === 'number') {\n    validateInteger(position\x2C 'position');\n  } else if (typeof position === 'bigint') {\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\n      throw new ERR_OUT_OF_RANGE('position'\x2C\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\n                                 position);\n    }\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('position'\x2C\n                                   ['integer'\x2C 'bigint']\x2C\n                                   position);\n  }\n});\n\nmodule.exports = {\n  constants: {\n    kIoMaxLength\x2C\n    kMaxUserId\x2C\n    kReadFileBufferLength\x2C\n    kReadFileUnknownBufferLength\x2C\n    kWriteFileMaxChunkSize\x2C\n  }\x2C\n  assertEncoding\x2C\n  BigIntStats\x2C  // for testing\n  copyObject\x2C\n  Dirent\x2C\n  emitRecursiveRmdirWarning\x2C\n  getDirent\x2C\n  getDirents\x2C\n  getOptions\x2C\n  getValidatedFd\x2C\n  getValidatedPath\x2C\n  getValidMode\x2C\n  handleErrorFromBinding\x2C\n  nullCheck\x2C\n  preprocessSymlinkDestination\x2C\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\n  getStatsFromBinding\x2C\n  stringToFlags\x2C\n  stringToSymlinkType\x2C\n  Stats\x2C\n  toUnixTimestamp\x2C\n  validateBufferArray\x2C\n  validateCpOptions\x2C\n  validateOffsetLengthRead\x2C\n  validateOffsetLengthWrite\x2C\n  validatePath\x2C\n  validatePosition\x2C\n  validateRmOptions\x2C\n  validateRmOptionsSync\x2C\n  validateRmdirOptions\x2C\n  validateStringAfterArrayBufferView\x2C\n  validatePrimitiveStringAfterArrayBufferView\x2C\n  warnOnNonPortableTemplate\n};\n
code-source-info,0xb46bbe7e730,77,7291,7897,C9O7318C16O7336C27O7396C29O7418C30O7426C36O7465C41O7509C43O7533C47O7548C54O7583C60O7622C78O7628C83O7622C84O7715C91O7724C96O7742C99O7765C104O7742C108O7791C114O7819C119O7847C127O7819C132O7880C134O7895,,
tick,0x7ff805e4dd52,162292,0,0x0,3,0x102d5e910,0xb46bbe77e46,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805f105d0,162304,0,0x0,3,0x102d5e910,0xb46bbe77e46,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805ede983,162314,0,0x0,3,0x102d5e910,0xb46bbe77e46,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,162325,0xb46b9683048,48,assertEncoding node:internal/fs/utils:156:24,0xb46d10b44d8,~
code-source-info,0xb46b9683048,77,3600,3777,C0O3615C6O3632C9O3639C14O3639C21O3682C24O3709C40O3715C45O3709C47O3776,,
code-creation,LazyCompile,10,162412,0xb46b9683160,20,toPathIfFileURL node:internal/url:1565:25,0xb46d10a7670,~
script-source,74,node:internal/url,'use strict';\n\nconst {\n  Array\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototypeBind\x2C\n  Int8Array\x2C\n  Number\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ReflectApply\x2C\n  ReflectGetOwnPropertyDescriptor\x2C\n  ReflectOwnKeys\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeReplace\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  Symbol\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  decodeURIComponent\x2C\n} = primordials;\n\nconst { inspect } = require('internal/util/inspect');\nconst {\n  encodeStr\x2C\n  hexTable\x2C\n  isHexTable\n} = require('internal/querystring');\n\nconst {\n  getConstructorOf\x2C\n  removeColors\x2C\n  toUSVString\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  codes: {\n    ERR_ARG_NOT_ITERABLE\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_FILE_URL_HOST\x2C\n    ERR_INVALID_FILE_URL_PATH\x2C\n    ERR_INVALID_THIS\x2C\n    ERR_INVALID_TUPLE\x2C\n    ERR_INVALID_URL\x2C\n    ERR_INVALID_URL_SCHEME\x2C\n    ERR_MISSING_ARGS\x2C\n    ERR_NO_CRYPTO\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  CHAR_AMPERSAND\x2C\n  CHAR_BACKWARD_SLASH\x2C\n  CHAR_EQUAL\x2C\n  CHAR_FORWARD_SLASH\x2C\n  CHAR_LOWERCASE_A\x2C\n  CHAR_LOWERCASE_Z\x2C\n  CHAR_PERCENT\x2C\n  CHAR_PLUS\n} = require('internal/constants');\nconst path = require('path');\n\nconst {\n  validateFunction\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst querystring = require('querystring');\n\nconst { platform } = process;\nconst isWindows = platform === 'win32';\n\nconst {\n  domainToASCII: _domainToASCII\x2C\n  domainToUnicode: _domainToUnicode\x2C\n  encodeAuth\x2C\n  parse\x2C\n  setURLConstructor\x2C\n  URL_FLAGS_CANNOT_BE_BASE\x2C\n  URL_FLAGS_HAS_FRAGMENT\x2C\n  URL_FLAGS_HAS_HOST\x2C\n  URL_FLAGS_HAS_PASSWORD\x2C\n  URL_FLAGS_HAS_PATH\x2C\n  URL_FLAGS_HAS_QUERY\x2C\n  URL_FLAGS_HAS_USERNAME\x2C\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT\x2C\n  URL_FLAGS_SPECIAL\x2C\n  kFragment\x2C\n  kHost\x2C\n  kHostname\x2C\n  kPathStart\x2C\n  kPort\x2C\n  kQuery\x2C\n  kSchemeStart\n} = internalBinding('url');\n\nconst {\n  storeDataObject\x2C\n  revokeDataObject\x2C\n} = internalBinding('blob');\n\nconst context = Symbol('context');\nconst cannotBeBase = Symbol('cannot-be-base');\nconst cannotHaveUsernamePasswordPort =\n    Symbol('cannot-have-username-password-port');\nconst special = Symbol('special');\nconst searchParams = Symbol('query');\nconst kFormat = Symbol('format');\n\nlet blob;\nlet cryptoRandom;\n\nfunction lazyBlob() {\n  blob ??= require('internal/blob');\n  return blob;\n}\n\nfunction lazyCryptoRandom() {\n  try {\n    cryptoRandom ??= require('internal/crypto/random');\n  } catch {\n    // If Node.js built without crypto support\x2C we'll fall\n    // through here and handle it later.\n  }\n  return cryptoRandom;\n}\n\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\nconst IteratorPrototype = ObjectGetPrototypeOf(\n  ObjectGetPrototypeOf([][SymbolIterator]())\n);\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\nconst kOpaqueOrigin = 'null';\n\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\nfunction serializeTupleOrigin(scheme\x2C host\x2C port) {\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\n}\n\n// This class provides the internal state of a URL object. An instance of this\n// class is stored in every URL object and is accessed internally by setters\n// and getters. It roughly corresponds to the concept of a URL record in the\n// URL Standard\x2C with a few differences. It is also the object transported to\n// the C++ binding.\n// Refs: https://url.spec.whatwg.org/#concept-url\nclass URLContext {\n  constructor() {\n    this.flags = 0;\n    this.scheme = ':';\n    this.username = '';\n    this.password = '';\n    this.host = null;\n    this.port = null;\n    this.path = [];\n    this.query = null;\n    this.fragment = null;\n  }\n}\n\nfunction isURLSearchParams(self) {\n  return self && self[searchParams] && !self[searchParams][searchParams];\n}\n\nclass URLSearchParams {\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\n  // accordance with Web IDL spec.\n  constructor(init = undefined) {\n    if (init === null || init === undefined) {\n      this[searchParams] = [];\n    } else if (typeof init === 'object' || typeof init === 'function') {\n      const method = init[SymbolIterator];\n      if (method === this[SymbolIterator]) {\n        // While the spec does not have this branch\x2C we can use it as a\n        // shortcut to avoid having to go through the costly generic iterator.\n        const childParams = init[searchParams];\n        this[searchParams] = childParams.slice();\n      } else if (method !== null && method !== undefined) {\n        if (typeof method !== 'function') {\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\n        }\n\n        // Sequence<sequence<USVString>>\n        // Note: per spec we have to first exhaust the lists then process them\n        const pairs = [];\n        for (const pair of init) {\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\n              pair === null ||\n              typeof pair[SymbolIterator] !== 'function') {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          const convertedPair = [];\n          for (const element of pair)\n            ArrayPrototypePush(convertedPair\x2C toUSVString(element));\n          ArrayPrototypePush(pairs\x2C convertedPair);\n        }\n\n        this[searchParams] = [];\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\n          }\n          ArrayPrototypePush(this[searchParams]\x2C pair[0]\x2C pair[1]);\n        }\n      } else {\n        // Record<USVString\x2C USVString>\n        // Need to use reflection APIs for full spec compliance.\n        const visited = {};\n        this[searchParams] = [];\n        const keys = ReflectOwnKeys(init);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\n          if (desc !== undefined && desc.enumerable) {\n            const typedKey = toUSVString(key);\n            const typedValue = toUSVString(init[key]);\n\n            // Two different key may result same after `toUSVString()`\x2C we only\n            // leave the later one. Refers to WPT.\n            if (visited[typedKey] !== undefined) {\n              this[searchParams][visited[typedKey]] = typedValue;\n            } else {\n              visited[typedKey] = ArrayPrototypePush(this[searchParams]\x2C\n                                                     typedKey\x2C\n                                                     typedValue) - 1;\n            }\n          }\n        }\n      }\n    } else {\n      // USVString\n      init = toUSVString(init);\n      if (init[0] === '?') init = init.slice(1);\n      initSearchParams(this\x2C init);\n    }\n\n    // "associated url object"\n    this[context] = null;\n  }\n\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const separator = '\x2C ';\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\n\n    const list = this[searchParams];\n    const output = [];\n    for (let i = 0; i < list.length; i += 2)\n      ArrayPrototypePush(\n        output\x2C\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\n\n    const length = ArrayPrototypeReduce(\n      output\x2C\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\n      -separator.length\n    );\n    if (length > ctx.breakLength) {\n      return `${this.constructor.name} {\\n` +\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\n    } else if (output.length) {\n      return `${this.constructor.name} { ` +\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\n    }\n    return `${this.constructor.name} {}`;\n  }\n\n  append(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    name = toUSVString(name);\n    value = toUSVString(value);\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\n    update(this[context]\x2C this);\n  }\n\n  delete(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        list.splice(i\x2C 2);\n      } else {\n        i += 2;\n      }\n    }\n    update(this[context]\x2C this);\n  }\n\n  get(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return list[i + 1];\n      }\n    }\n    return null;\n  }\n\n  getAll(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    const values = [];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        values.push(list[i + 1]);\n      }\n    }\n    return values;\n  }\n\n  has(name) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 1) {\n      throw new ERR_MISSING_ARGS('name');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    for (let i = 0; i < list.length; i += 2) {\n      if (list[i] === name) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  set(name\x2C value) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    if (arguments.length < 2) {\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\n    }\n\n    const list = this[searchParams];\n    name = toUSVString(name);\n    value = toUSVString(value);\n\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\n    // the value of the first such name-value pair to `value` and remove the\n    // others.\n    let found = false;\n    for (let i = 0; i < list.length;) {\n      const cur = list[i];\n      if (cur === name) {\n        if (!found) {\n          list[i + 1] = value;\n          found = true;\n          i += 2;\n        } else {\n          list.splice(i\x2C 2);\n        }\n      } else {\n        i += 2;\n      }\n    }\n\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\n    // is `value`\x2C to `list`.\n    if (!found) {\n      ArrayPrototypePush(list\x2C name\x2C value);\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  sort() {\n    const a = this[searchParams];\n    const len = a.length;\n\n    if (len <= 2) {\n      // Nothing needs to be done.\n    } else if (len < 100) {\n      // 100 is found through testing.\n      // Simple stable in-place insertion sort\n      // Derived from v8/src/js/array.js\n      for (let i = 2; i < len; i += 2) {\n        const curKey = a[i];\n        const curVal = a[i + 1];\n        let j;\n        for (j = i - 2; j >= 0; j -= 2) {\n          if (a[j] > curKey) {\n            a[j + 2] = a[j];\n            a[j + 3] = a[j + 1];\n          } else {\n            break;\n          }\n        }\n        a[j + 2] = curKey;\n        a[j + 3] = curVal;\n      }\n    } else {\n      // Bottom-up iterative stable merge sort\n      const lBuffer = new Array(len);\n      const rBuffer = new Array(len);\n      for (let step = 2; step < len; step *= 2) {\n        for (let start = 0; start < len - 2; start += 2 * step) {\n          const mid = start + step;\n          let end = mid + step;\n          end = end < len ? end : len;\n          if (mid > end)\n            continue;\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\n        }\n      }\n    }\n\n    update(this[context]\x2C this);\n  }\n\n  // https://heycam.github.io/webidl/#es-iterators\n  // Define entries here rather than [Symbol.iterator] as the function name\n  // must be set to `entries`.\n  entries() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key+value');\n  }\n\n  forEach(callback\x2C thisArg = undefined) {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    validateFunction(callback\x2C 'callback');\n\n    let list = this[searchParams];\n\n    let i = 0;\n    while (i < list.length) {\n      const key = list[i];\n      const value = list[i + 1];\n      callback.call(thisArg\x2C value\x2C key\x2C this);\n      // In case the URL object's `search` is updated\n      list = this[searchParams];\n      i += 2;\n    }\n  }\n\n  // https://heycam.github.io/webidl/#es-iterable\n  keys() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'key');\n  }\n\n  values() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return createSearchParamsIterator(this\x2C 'value');\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\n  toString() {\n    if (!isURLSearchParams(this))\n      throw new ERR_INVALID_THIS('URLSearchParams');\n\n    return serializeParams(this[searchParams]);\n  }\n}\n\nObjectDefineProperties(URLSearchParams.prototype\x2C {\n  append: kEnumerableProperty\x2C\n  delete: kEnumerableProperty\x2C\n  get: kEnumerableProperty\x2C\n  getAll: kEnumerableProperty\x2C\n  has: kEnumerableProperty\x2C\n  set: kEnumerableProperty\x2C\n  sort: kEnumerableProperty\x2C\n  entries: kEnumerableProperty\x2C\n  forEach: kEnumerableProperty\x2C\n  keys: kEnumerableProperty\x2C\n  values: kEnumerableProperty\x2C\n  toString: kEnumerableProperty\x2C\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URLSearchParams' }\x2C\n\n  // https://heycam.github.io/webidl/#es-iterable-entries\n  [SymbolIterator]: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    writable: true\x2C\n    value: URLSearchParams.prototype.entries\x2C\n  }\x2C\n});\n\nfunction onParseComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                         host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n  if (!this[searchParams]) { // Invoked from URL constructor\n    this[searchParams] = new URLSearchParams();\n    this[searchParams][context] = this;\n  }\n  initSearchParams(this[searchParams]\x2C query);\n}\n\nfunction onParseError(input\x2C flags) {\n  throw new ERR_INVALID_URL(input);\n}\n\nfunction onParseProtocolComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\n    ctx.flags |= URL_FLAGS_SPECIAL;\n  } else {\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\n  }\n  ctx.scheme = protocol;\n  ctx.port = port;\n}\n\nfunction onParseHostnameComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  } else {\n    ctx.host = null;\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParsePortComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].port = port;\n}\n\nfunction onParseHostComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  ReflectApply(onParseHostnameComplete\x2C this\x2C arguments);\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\n    ReflectApply(onParsePortComplete\x2C this\x2C arguments);\n}\n\nfunction onParsePathComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = this[context];\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\n    ctx.path = path;\n    ctx.flags |= URL_FLAGS_HAS_PATH;\n  } else {\n    ctx.path = [];\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\n  }\n\n  // The C++ binding may set host to empty string.\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\n    ctx.host = host;\n    ctx.flags |= URL_FLAGS_HAS_HOST;\n  }\n}\n\nfunction onParseSearchComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                               host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].query = query;\n}\n\nfunction onParseHashComplete(flags\x2C protocol\x2C username\x2C password\x2C\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\n  this[context].fragment = fragment;\n}\n\nfunction isURLThis(self) {\n  return (self !== undefined && self !== null && self[context] !== undefined);\n}\n\nclass URL {\n  constructor(input\x2C base = undefined) {\n    // toUSVString is not needed.\n    input = `${input}`;\n    let base_context;\n    if (base !== undefined) {\n      base_context = new URL(base)[context];\n    }\n    this[context] = new URLContext();\n    parse(input\x2C -1\x2C base_context\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C\n          FunctionPrototypeBind(onParseError\x2C this\x2C input));\n  }\n\n  get [special]() {\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\n  }\n\n  get [cannotBeBase]() {\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\n  }\n\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\n  get [cannotHaveUsernamePasswordPort]() {\n    const { host\x2C scheme } = this[context];\n    return ((host == null || host === '') ||\n            this[cannotBeBase] ||\n            scheme === 'file:');\n  }\n\n  [inspect.custom](depth\x2C opts) {\n    if (this == null ||\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\n      throw new ERR_INVALID_THIS('URL');\n    }\n\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n\n    const constructor = getConstructorOf(this) || URL;\n    const obj = ObjectCreate({ constructor });\n\n    obj.href = this.href;\n    obj.origin = this.origin;\n    obj.protocol = this.protocol;\n    obj.username = this.username;\n    obj.password = this.password;\n    obj.host = this.host;\n    obj.hostname = this.hostname;\n    obj.port = this.port;\n    obj.pathname = this.pathname;\n    obj.search = this.search;\n    obj.searchParams = this.searchParams;\n    obj.hash = this.hash;\n\n    if (opts.showHidden) {\n      obj.cannotBeBase = this[cannotBeBase];\n      obj.special = this[special];\n      obj[context] = this[context];\n    }\n\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\n  }\n\n  [kFormat](options) {\n    if (options)\n      validateObject(options\x2C 'options');\n\n    options = {\n      fragment: true\x2C\n      unicode: false\x2C\n      search: true\x2C\n      auth: true\x2C\n      ...options\n    };\n    const ctx = this[context];\n    // https://url.spec.whatwg.org/#url-serializing\n    let ret = ctx.scheme;\n    if (ctx.host !== null) {\n      ret += '//';\n      const has_username = ctx.username !== '';\n      const has_password = ctx.password !== '';\n      if (options.auth && (has_username || has_password)) {\n        if (has_username)\n          ret += ctx.username;\n        if (has_password)\n          ret += `:${ctx.password}`;\n        ret += '@';\n      }\n      ret += options.unicode ?\n        domainToUnicode(ctx.host) : ctx.host;\n      if (ctx.port !== null)\n        ret += `:${ctx.port}`;\n    }\n    if (this[cannotBeBase]) {\n      ret += ctx.path[0];\n    } else {\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === '') {\n        ret += '/.';\n      }\n      if (ctx.path.length) {\n        ret += '/' + ArrayPrototypeJoin(ctx.path\x2C '/');\n      }\n    }\n    if (options.search && ctx.query !== null)\n      ret += `?${ctx.query}`;\n    if (options.fragment && ctx.fragment !== null)\n      ret += `#${ctx.fragment}`;\n    return ret;\n  }\n\n  // https://heycam.github.io/webidl/#es-stringifier\n  toString() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  get href() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  set href(input) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    input = `${input}`;\n    parse(input\x2C -1\x2C undefined\x2C undefined\x2C\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C\n          FunctionPrototypeBind(onParseError\x2C this\x2C input));\n  }\n\n  // readonly\n  get origin() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // Refs: https://url.spec.whatwg.org/#concept-url-origin\n    const ctx = this[context];\n    switch (ctx.scheme) {\n      case 'blob:':\n        if (ctx.path.length > 0) {\n          try {\n            return (new URL(ctx.path[0])).origin;\n          } catch {\n            // Fall through... do nothing\n          }\n        }\n        return kOpaqueOrigin;\n      case 'ftp:':\n      case 'http:':\n      case 'https:':\n      case 'ws:':\n      case 'wss:':\n        return serializeTupleOrigin(ctx.scheme\x2C ctx.host\x2C ctx.port);\n    }\n    return kOpaqueOrigin;\n  }\n\n  get protocol() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].scheme;\n  }\n\n  set protocol(scheme) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    scheme = `${scheme}`;\n    if (scheme.length === 0)\n      return;\n    const ctx = this[context];\n    parse(scheme\x2C kSchemeStart\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseProtocolComplete\x2C this));\n  }\n\n  get username() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].username;\n  }\n\n  set username(username) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    username = `${username}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (username === '') {\n      ctx.username = '';\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\n      return;\n    }\n    ctx.username = encodeAuth(username);\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\n  }\n\n  get password() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].password;\n  }\n\n  set password(password) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    password = `${password}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (password === '') {\n      ctx.password = '';\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\n      return;\n    }\n    ctx.password = encodeAuth(password);\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\n  }\n\n  get host() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    let ret = ctx.host || '';\n    if (ctx.port !== null)\n      ret += `:${ctx.port}`;\n    return ret;\n  }\n\n  set host(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHost\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHostComplete\x2C this));\n  }\n\n  get hostname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[context].host || '';\n  }\n\n  set hostname(host) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    host = `${host}`;\n    if (this[cannotBeBase]) {\n      // Cannot set the host if cannot-be-base is set\n      return;\n    }\n    parse(host\x2C kHostname\x2C null\x2C ctx\x2C onParseHostnameComplete.bind(this));\n  }\n\n  get port() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const port = this[context].port;\n    return port === null ? '' : String(port);\n  }\n\n  set port(port) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    port = `${port}`;\n    if (this[cannotHaveUsernamePasswordPort])\n      return;\n    const ctx = this[context];\n    if (port === '') {\n      ctx.port = null;\n      return;\n    }\n    parse(port\x2C kPort\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParsePortComplete\x2C this));\n  }\n\n  get pathname() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    if (this[cannotBeBase])\n      return ctx.path[0];\n    if (ctx.path.length === 0)\n      return '';\n    return `/${ArrayPrototypeJoin(ctx.path\x2C '/')}`;\n  }\n\n  set pathname(path) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    // toUSVString is not needed.\n    path = `${path}`;\n    if (this[cannotBeBase])\n      return;\n    parse(path\x2C kPathStart\x2C null\x2C this[context]\x2C\n          onParsePathComplete.bind(this));\n  }\n\n  get search() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const { query } = this[context];\n    if (query === null || query === '')\n      return '';\n    return `?${query}`;\n  }\n\n  set search(search) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    search = toUSVString(search);\n    if (search === '') {\n      ctx.query = null;\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n    } else {\n      if (search[0] === '?') search = StringPrototypeSlice(search\x2C 1);\n      ctx.query = '';\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\n      if (search) {\n        parse(search\x2C kQuery\x2C null\x2C ctx\x2C\n              FunctionPrototypeBind(onParseSearchComplete\x2C this));\n      }\n    }\n    initSearchParams(this[searchParams]\x2C search);\n  }\n\n  // readonly\n  get searchParams() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[searchParams];\n  }\n\n  get hash() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const { fragment } = this[context];\n    if (fragment === null || fragment === '')\n      return '';\n    return `#${fragment}`;\n  }\n\n  set hash(hash) {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    const ctx = this[context];\n    // toUSVString is not needed.\n    hash = `${hash}`;\n    if (!hash) {\n      ctx.fragment = null;\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\n      return;\n    }\n    if (hash[0] === '#') hash = StringPrototypeSlice(hash\x2C 1);\n    ctx.fragment = '';\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\n    parse(hash\x2C kFragment\x2C null\x2C ctx\x2C\n          FunctionPrototypeBind(onParseHashComplete\x2C this));\n  }\n\n  toJSON() {\n    if (!isURLThis(this))\n      throw new ERR_INVALID_THIS('URL');\n    return this[kFormat]({});\n  }\n\n  static createObjectURL(obj) {\n    const cryptoRandom = lazyCryptoRandom();\n    if (cryptoRandom === undefined)\n      throw new ERR_NO_CRYPTO();\n\n    // Yes\x2C lazy loading is annoying but because of circular\n    // references between the url\x2C internal/blob\x2C and buffer\n    // modules\x2C lazy loading here makes sure that things work.\n    const blob = lazyBlob();\n    if (!blob.isBlob(obj))\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\n\n    const id = cryptoRandom.randomUUID();\n\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\n\n    return `blob:nodedata:${id}`;\n  }\n\n  static revokeObjectURL(url) {\n    url = `${url}`;\n    try {\n      const parsed = new URL(url);\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\n      if (split.length === 2)\n        revokeDataObject(split[1]);\n    } catch {\n      // If there's an error\x2C it's ignored.\n    }\n  }\n}\n\nObjectDefineProperties(URL.prototype\x2C {\n  [kFormat]: { __proto__: null\x2C configurable: false\x2C writable: false }\x2C\n  [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'URL' }\x2C\n  toString: kEnumerableProperty\x2C\n  href: kEnumerableProperty\x2C\n  origin: kEnumerableProperty\x2C\n  protocol: kEnumerableProperty\x2C\n  username: kEnumerableProperty\x2C\n  password: kEnumerableProperty\x2C\n  host: kEnumerableProperty\x2C\n  hostname: kEnumerableProperty\x2C\n  port: kEnumerableProperty\x2C\n  pathname: kEnumerableProperty\x2C\n  search: kEnumerableProperty\x2C\n  searchParams: kEnumerableProperty\x2C\n  hash: kEnumerableProperty\x2C\n  toJSON: kEnumerableProperty\x2C\n});\n\nfunction update(url\x2C params) {\n  if (!url)\n    return;\n\n  const ctx = url[context];\n  const serializedParams = params.toString();\n  if (serializedParams) {\n    ctx.query = serializedParams;\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\n  } else {\n    ctx.query = null;\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\n  }\n}\n\nfunction initSearchParams(url\x2C init) {\n  if (!init) {\n    url[searchParams] = [];\n    return;\n  }\n  url[searchParams] = parseParams(init);\n}\n\n// application/x-www-form-urlencoded parser\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\nfunction parseParams(qs) {\n  const out = [];\n  let pairStart = 0;\n  let lastPos = 0;\n  let seenSep = false;\n  let buf = '';\n  let encoded = false;\n  let encodeCheck = 0;\n  let i;\n  for (i = 0; i < qs.length; ++i) {\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\n\n    // Try matching key/value pair separator\n    if (code === CHAR_AMPERSAND) {\n      if (pairStart === i) {\n        // We saw an empty substring between pair separators\n        lastPos = pairStart = i + 1;\n        continue;\n      }\n\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      // If `buf` is the key\x2C add an empty value.\n      if (!seenSep)\n        out.push('');\n\n      seenSep = false;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = pairStart = i + 1;\n      continue;\n    }\n\n    // Try matching key/value separator (e.g. '=') if we haven't already\n    if (!seenSep && code === CHAR_EQUAL) {\n      // Key/value separator match!\n      if (lastPos < i)\n        buf += qs.slice(lastPos\x2C i);\n      if (encoded)\n        buf = querystring.unescape(buf);\n      out.push(buf);\n\n      seenSep = true;\n      buf = '';\n      encoded = false;\n      encodeCheck = 0;\n      lastPos = i + 1;\n      continue;\n    }\n\n    // Handle + and percent decoding.\n    if (code === CHAR_PLUS) {\n      if (lastPos < i)\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n      buf += ' ';\n      lastPos = i + 1;\n    } else if (!encoded) {\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\n      // calls to string decoding functions\n      if (code === CHAR_PERCENT) {\n        encodeCheck = 1;\n      } else if (encodeCheck > 0) {\n        if (isHexTable[code] === 1) {\n          if (++encodeCheck === 3) {\n            encoded = true;\n          }\n        } else {\n          encodeCheck = 0;\n        }\n      }\n    }\n  }\n\n  // Deal with any leftover key or value data\n\n  // There is a trailing &. No more processing is needed.\n  if (pairStart === i)\n    return out;\n\n  if (lastPos < i)\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\n  if (encoded)\n    buf = querystring.unescape(buf);\n  ArrayPrototypePush(out\x2C buf);\n\n  // If `buf` is the key\x2C add an empty value.\n  if (!seenSep)\n    ArrayPrototypePush(out\x2C '');\n\n  return out;\n}\n\n// Adapted from querystring's implementation.\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\nconst noEscape = new Int8Array([\n/*\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\n*/\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\n]);\n\n// Special version of hexTable that uses `+` for U+0020 SPACE.\nconst paramHexTable = hexTable.slice();\nparamHexTable[0x20] = '+';\n\n// application/x-www-form-urlencoded serializer\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\nfunction serializeParams(array) {\n  const len = array.length;\n  if (len === 0)\n    return '';\n\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\n\n  for (let i = 2; i < len; i += 2) {\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\n    output += `&${encodedParam}=${encodedValue}`;\n  }\n\n  return output;\n}\n\n// Mainly to mitigate func-name-matching ESLint rule\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\n  // https://heycam.github.io/webidl/#dfn-class-string\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\n    __proto__: null\x2C\n    writable: false\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    value: classStr\n  });\n\n  // https://heycam.github.io/webidl/#es-operations\n  for (const key of ObjectKeys(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\n    ObjectDefineProperty(proto\x2C key\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      value: obj[key]\n    });\n  }\n}\n\n// for merge sort\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\n  const sizeLeft = mid - start;\n  const sizeRight = end - mid;\n  let l\x2C r\x2C o;\n\n  for (l = 0; l < sizeLeft; l++)\n    lBuffer[l] = out[start + l];\n  for (r = 0; r < sizeRight; r++)\n    rBuffer[r] = out[mid + r];\n\n  l = 0;\n  r = 0;\n  o = start;\n  while (l < sizeLeft && r < sizeRight) {\n    if (lBuffer[l] <= rBuffer[r]) {\n      out[o++] = lBuffer[l++];\n      out[o++] = lBuffer[l++];\n    } else {\n      out[o++] = rBuffer[r++];\n      out[o++] = rBuffer[r++];\n    }\n  }\n  while (l < sizeLeft)\n    out[o++] = lBuffer[l++];\n  while (r < sizeRight)\n    out[o++] = rBuffer[r++];\n}\n\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\nfunction createSearchParamsIterator(target\x2C kind) {\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\n  iterator[context] = {\n    target\x2C\n    kind\x2C\n    index: 0\n  };\n  return iterator;\n}\n\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\n\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\n  next() {\n    if (!this ||\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n    }\n\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const values = target[searchParams];\n    const len = values.length;\n    if (index >= len) {\n      return {\n        value: undefined\x2C\n        done: true\n      };\n    }\n\n    const name = values[index];\n    const value = values[index + 1];\n    this[context].index = index + 2;\n\n    let result;\n    if (kind === 'key') {\n      result = name;\n    } else if (kind === 'value') {\n      result = value;\n    } else {\n      result = [name\x2C value];\n    }\n\n    return {\n      value: result\x2C\n      done: false\n    };\n  }\x2C\n  [inspect.custom](recurseTimes\x2C ctx) {\n    if (this == null || this[context] == null || this[context].target == null)\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\n\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\n      return ctx.stylize('[Object]'\x2C 'special');\n\n    const innerOpts = { ...ctx };\n    if (recurseTimes !== null) {\n      innerOpts.depth = recurseTimes - 1;\n    }\n    const {\n      target\x2C\n      kind\x2C\n      index\n    } = this[context];\n    const output = ArrayPrototypeReduce(\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\n      (prev\x2C cur\x2C i) => {\n        const key = i % 2 === 0;\n        if (kind === 'key' && key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'value' && !key) {\n          ArrayPrototypePush(prev\x2C cur);\n        } else if (kind === 'key+value' && !key) {\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\n        }\n        return prev;\n      }\x2C\n      []\n    );\n    const breakLn = inspect(output\x2C innerOpts).includes('\\n');\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\n    let outputStr;\n    if (breakLn) {\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\n    } else {\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\n    }\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\n  }\n});\n\nfunction domainToASCII(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToASCII(`${domain}`);\n}\n\nfunction domainToUnicode(domain) {\n  if (arguments.length < 1)\n    throw new ERR_MISSING_ARGS('domain');\n\n  // toUSVString is not needed.\n  return _domainToUnicode(`${domain}`);\n}\n\n// Utility function that converts a URL object into an ordinary\n// options object as expected by the http.request and https.request\n// APIs.\nfunction urlToHttpOptions(url) {\n  const options = {\n    protocol: url.protocol\x2C\n    hostname: typeof url.hostname === 'string' &&\n              StringPrototypeStartsWith(url.hostname\x2C '[') ?\n      StringPrototypeSlice(url.hostname\x2C 1\x2C -1) :\n      url.hostname\x2C\n    hash: url.hash\x2C\n    search: url.search\x2C\n    pathname: url.pathname\x2C\n    path: `${url.pathname || ''}${url.search || ''}`\x2C\n    href: url.href\n  };\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\n  }\n  return options;\n}\n\nconst forwardSlashRegEx = /\\//g;\n\nfunction getPathFromURLWin32(url) {\n  const hostname = url.hostname;\n  let pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded \\\\ or / characters'\n        );\n      }\n    }\n  }\n  pathname = pathname.replace(forwardSlashRegEx\x2C '\\\\');\n  pathname = decodeURIComponent(pathname);\n  if (hostname !== '') {\n    // If hostname is set\x2C then we have a UNC path\n    // Pass the hostname through domainToUnicode just in case\n    // it is an IDN using punycode encoding. We do not need to worry\n    // about percent encoding because the URL parser will have\n    // already taken care of that for us. Note that this only\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\n  }\n  // Otherwise\x2C it's a local path that requires a drive letter\n  const letter = pathname.codePointAt(1) | 0x20;\n  const sep = pathname[2];\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\n      (sep !== ':')) {\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\n  }\n  return pathname.slice(1);\n}\n\nfunction getPathFromURLPosix(url) {\n  if (url.hostname !== '') {\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\n  }\n  const pathname = url.pathname;\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === '%') {\n      const third = pathname.codePointAt(n + 2) | 0x20;\n      if (pathname[n + 1] === '2' && third === 102) {\n        throw new ERR_INVALID_FILE_URL_PATH(\n          'must not include encoded / characters'\n        );\n      }\n    }\n  }\n  return decodeURIComponent(pathname);\n}\n\nfunction fileURLToPath(path) {\n  if (typeof path === 'string')\n    path = new URL(path);\n  else if (!isURLInstance(path))\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\n  if (path.protocol !== 'file:')\n    throw new ERR_INVALID_URL_SCHEME('file');\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\n}\n\n// The following characters are percent-encoded when converting from file path\n// to URL:\n// - %: The percent character is the only character not encoded by the\n//        `pathname` setter.\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\n//      character but the `pathname` setters replaces it by a forward slash.\n// - LF: The newline character is stripped out by the `pathname` setter.\n//       (See whatwg/url#419)\n// - CR: The carriage return character is also stripped out by the `pathname`\n//       setter.\n// - TAB: The tab character is also stripped out by the `pathname` setter.\nconst percentRegEx = /%/g;\nconst backslashRegEx = /\\\\/g;\nconst newlineRegEx = /\\n/g;\nconst carriageReturnRegEx = /\\r/g;\nconst tabRegEx = /\\t/g;\n\nfunction encodePathChars(filepath) {\n  if (StringPrototypeIncludes(filepath\x2C '%'))\n    filepath = StringPrototypeReplace(filepath\x2C percentRegEx\x2C '%25');\n  // In posix\x2C backslash is a valid character in paths:\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\n    filepath = StringPrototypeReplace(filepath\x2C backslashRegEx\x2C '%5C');\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\n    filepath = StringPrototypeReplace(filepath\x2C newlineRegEx\x2C '%0A');\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\n    filepath = StringPrototypeReplace(filepath\x2C carriageReturnRegEx\x2C '%0D');\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\n    filepath = StringPrototypeReplace(filepath\x2C tabRegEx\x2C '%09');\n  return filepath;\n}\n\nfunction pathToFileURL(filepath) {\n  const outURL = new URL('file://');\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\n    // UNC path format: \\\\server\\share\\resource\n    const paths = StringPrototypeSplit(filepath\x2C '\\\\');\n    if (paths.length <= 3) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Missing UNC resource path'\n      );\n    }\n    const hostname = paths[2];\n    if (hostname.length === 0) {\n      throw new ERR_INVALID_ARG_VALUE(\n        'filepath'\x2C\n        filepath\x2C\n        'Empty UNC servername'\n      );\n    }\n    outURL.hostname = domainToASCII(hostname);\n    outURL.pathname = encodePathChars(\n      ArrayPrototypeJoin(ArrayPrototypeSlice(paths\x2C 3)\x2C '/'));\n  } else {\n    let resolved = path.resolve(filepath);\n    // path.resolve strips trailing slashes so we must add them back\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\n                                                   filepath.length - 1);\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\n        resolved[resolved.length - 1] !== path.sep)\n      resolved += '/';\n    outURL.pathname = encodePathChars(resolved);\n  }\n  return outURL;\n}\n\nfunction isURLInstance(fileURLOrPath) {\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\n}\n\nfunction toPathIfFileURL(fileURLOrPath) {\n  if (!isURLInstance(fileURLOrPath))\n    return fileURLOrPath;\n  return fileURLToPath(fileURLOrPath);\n}\n\nfunction constructUrl(flags\x2C protocol\x2C username\x2C password\x2C\n                      host\x2C port\x2C path\x2C query\x2C fragment) {\n  const ctx = new URLContext();\n  ctx.flags = flags;\n  ctx.scheme = protocol;\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\n  ctx.port = port;\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\n  ctx.query = query;\n  ctx.fragment = fragment;\n  ctx.host = host;\n\n  const url = ObjectCreate(URL.prototype);\n  url[context] = ctx;\n  const params = new URLSearchParams();\n  url[searchParams] = params;\n  params[context] = url;\n  initSearchParams(params\x2C query);\n  return url;\n}\nsetURLConstructor(constructUrl);\n\nmodule.exports = {\n  toUSVString\x2C\n  fileURLToPath\x2C\n  pathToFileURL\x2C\n  toPathIfFileURL\x2C\n  isURLInstance\x2C\n  URL\x2C\n  URLSearchParams\x2C\n  domainToASCII\x2C\n  domainToUnicode\x2C\n  urlToHttpOptions\x2C\n  formatSymbol: kFormat\x2C\n  searchParamsSymbol: searchParams\x2C\n  encodeStr\n};\n
code-source-info,0xb46b9683160,74,43877,43998,C0O43897C3O43902C9O43936C11O43957C12O43960C15O43967C19O43996,,
tick,0x10280e197,167566,0,0x0,3,0x102d5e910,0xb46bbe77e52,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805e4dde4,167578,0,0x0,3,0x102d5e910,0xb46bbe77e52,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805ede589,167589,0,0x0,3,0x102d5e910,0xb46bbe77e52,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805f105d0,167601,0,0x0,3,0x102d5e910,0xb46bbe77e52,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,167613,0xb46b96864b8,17,isURLInstance node:internal/url:1561:23,0xb46d10a7620,~
code-source-info,0xb46b96864b8,74,43754,43851,C0O43774C3O43795C6O43820C12O43842C16O43849,,
code-creation,LazyCompile,10,167678,0xb46b9686620,81, node:internal/fs/utils:674:38,0xb46d10b5400,~
code-source-info,0xb46b9686620,77,18323,18593,C14O18356C22O18389C25O18389C31O18415C36O18446C49O18421C54O18415C55O18511C68O18511C74O18548C76O18577C78O18577C80O18592,,
code-creation,LazyCompile,10,167735,0xb46b9686838,110, node:internal/fs/utils:361:35,0xb46d10b4aa0,~
code-source-info,0xb46b9686838,77,8625,9214,C16O8689C21O8742C26O8742C31O8836C37O8859C41O8887C45O8904C51O8904C60O8955C64O8976C69O8976C76O9021C77O9028C78O9048C94O9048C100O9162C104O9184C106O9184C107O9201C109O9212,,
code-creation,LazyCompile,10,167786,0xb46b96869b0,16,isUint8Array node:internal/util/types:13:22,0xb466517b820,~
script-source,23,node:internal/util/types,'use strict';\n\nconst {\n  ArrayBufferIsView\x2C\n  ObjectDefineProperties\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n} = primordials;\n\nfunction isTypedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\n}\n\nfunction isUint8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\n}\n\nfunction isUint8ClampedArray(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\n}\n\nfunction isUint16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\n}\n\nfunction isUint32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\n}\n\nfunction isInt8Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\n}\n\nfunction isInt16Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\n}\n\nfunction isInt32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\n}\n\nfunction isFloat32Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\n}\n\nfunction isFloat64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\n}\n\nfunction isBigInt64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\n}\n\nfunction isBigUint64Array(value) {\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\n}\n\nmodule.exports = {\n  ...internalBinding('types')\x2C\n  isArrayBufferView: ArrayBufferIsView\x2C\n  isTypedArray\x2C\n  isUint8Array\x2C\n  isUint8ClampedArray\x2C\n  isUint16Array\x2C\n  isUint32Array\x2C\n  isInt8Array\x2C\n  isInt16Array\x2C\n  isInt32Array\x2C\n  isFloat32Array\x2C\n  isFloat64Array\x2C\n  isBigInt64Array\x2C\n  isBigUint64Array\x2C\n};\n\nlet isCryptoKey;\nlet isKeyObject;\n\nObjectDefineProperties(module.exports\x2C {\n  isKeyObject: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isKeyObject) {\n        ({ isKeyObject } = require('internal/crypto/keys'));\n      }\n\n      return isKeyObject(obj);\n    }\n  }\x2C\n  isCryptoKey: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value(obj) {\n      if (!process.versions.openssl) {\n        return false;\n      }\n\n      if (!isCryptoKey) {\n        ({ isCryptoKey } = require('internal/crypto/keys'));\n      }\n\n      return isCryptoKey(obj);\n    }\n  }\n});\n
code-source-info,0xb46b96869b0,23,257,342,C0O269C5O276C12O323C15O340,,
code-creation,LazyCompile,10,168162,0xb46b9686e38,61,splitRoot node:fs:2430:33,0xb46d1098940,~
code-source-info,0xb46b9686e38,73,64777,64969,C0O64802C2O64813C6O64807C11O64834C16O64838C24O64876C26O64872C31O64904C44O64911C49O64943C50O64823C55O64789C58O64954C60O64965,,
code-creation,LazyCompile,10,168203,0xb46b9686f70,20,nextPart node:fs:2463:31,0xb46d10989e0,~
code-source-info,0xb46b9686f70,73,65684,65742,C0O65697C14O65704C19O65738,,
code-creation,LazyCompile,10,168275,0xb46b9687078,63,handleErrorFromBinding node:internal/fs/utils:344:32,0xb46d10b4a50,~
code-source-info,0xb46b9687078,77,7986,8484,C0O8004C6O8067C11O8067C16O8089C24O8089C29O8146C31O8146C32O8171C38O8399C43O8426C51O8399C56O8472C60O8462C62O8483,,
code-creation,LazyCompile,10,168320,0xb46b96871c8,34,isFileType node:fs:218:20,0xb46d1096dc0,~
code-source-info,0xb46b96871c8,73,5624,5865,C0O5758C2O5763C6O5770C10O5804C15O5811C20O5827C22O5842C24O5840C30O5850C33O5863,,
tick,0x103b6a494,168768,1,0x10262cb50,6,0x1027fed10,0xb46bbe78070,0xb46bbe77a33,0xb46bbe778ed,0xb46bbe777a7,0xb46bbe77178,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,169266,0xb46b96873e8,72,encodeRealpathResult node:fs:2439:30,0xb46d1098990,~
code-source-info,0xb46b96873e8,73,65003,65261,C0O65025C4O65050C10O65070C17O65079C22O65095C24O65109C25O65129C30O65136C35O65136C41O65164C48O65173C53O65193C55O65209C56O65232C61O65249C66O65232C71O65259,,
code-creation,LazyCompile,10,169325,0xb46b9687618,62,loadNativeModule node:internal/modules/cjs/helpers:44:26,0xb469fbd3e38,~
code-source-info,0xb46b9687618,395,1151,1431,C0O1187C5O1200C10O1204C15O1204C21O1221C26O1228C35O1258C43O1258C48O1384C53O1384C57O1414C59O1425C61O1430,,
code-creation,LazyCompile,10,169404,0xb46b9687fd8,246,Module.load node:internal/modules/cjs/loader:986:33,0xb469fbda3f0,~
code-source-info,0xb46b9687fd8,396,30727,31540,C0O30742C8O30788C16O30742C21O30796C26O30809C32O30796C36O30820C38O30834C42O30848C45O30868C52O30885C55O30890C60O30890C66O30868C71O30859C75O30931C78O30931C83O31008C91O31012C101O31065C106O31076C112O31090C124O31096C129O31090C130O31136C133O31143C140O31154C144O31165C150O31185C151O31197C155O31226C160O31235C165O31337C170O31372C175O31383C187O31423C192O31430C197O31430C204O31444C206O31442C211O31476C216O31485C221O31485C228O31510C233O31519C238O31519C245O31539,,
code-creation,LazyCompile,10,169585,0xb46b9688348,98,findLongestRegisteredExtension node:internal/modules/cjs/loader:424:40,0xb469fbd9868,~
code-source-info,0xb46b9688348,396,12147,12576,C0O12175C5O12180C10O12180C16O12206C18O12230C20O12256C22O12324C36O12277C44O12324C49O12338C51O12357C55O12366C56O12376C61O12383C63O12430C68O12449C74O12488C77O12499C84O12510C89O12530C91O12554C92O12261C95O12561C97O12574,,
code-creation,LazyCompile,10,169679,0xb46b9688530,353,basename node:path:1306:11,0xb46806acfc8,~
code-source-info,0xb46b9688530,71,39511,41903,C0O39529C4O39558C12O39558C17O39590C25O39590C30O39637C32O39654C35O39681C37O39692C41O39721C47O39728C52O39739C57O39754C61O39746C66O39770C68O39778C73O39796C75O39806C76O39830C80O39837C84O39871C87O39899C91O39906C95O39913C96O39913C101O39947C106O39947C112O39991C114O40004C116O40000C121O40174C125O40207C127O40217C131O40234C135O40280C137O40301C142O40467C144O40501C146O40522C150O40549C151O40560C156O40631C158O40644C161O40644C166O40640C171O40700C178O40713C183O40849C190O41012C193O41039C198O39921C203O39881C206O41114C208O41124C213O41141C220O41176C222O41184C227O41211C232O41225C246O41232C251O41271C252O41300C256O41307C260O41314C261O41314C266O41333C271O41337C279O41376C281O41372C286O41540C290O41571C292O41581C296O41596C300O41626C302O41634C307O41754C309O41784C311O41792C315O41322C320O41282C323O41816C325O41824C330O41838C332O41848C333O41853C347O41860C352O41899,,
tick,0x7ff805db1414,169843,0,0x0,3,0x102d5e910,0xb46b9688352,0xb46b9688026,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,169925,0xb46b96889d8,485,Module._extensions..js node:internal/modules/cjs/loader:1129:37,0xb469fbda590,~
code-source-info,0xb46b96889d8,396,35266,37018,C0O35365C5O35379C10O35379C16O35398C18O35409C25O35419C34O35452C39O35464C40O35478C46O35506C51O35519C60O35519C67O35557C76O35561C83O35621C86O35621C91O35710C96O35717C103O35723C113O35730C118O35767C123O35785C128O35785C134O35823C139O35829C147O35871C152O35876C157O35888C167O35876C174O35933C179O35933C184O35974C203O35974C209O36145C212O36156C219O36162C224O36190C229O36228C235O36246C244O36246C254O36241C257O36359C261O36405C268O36439C271O36464C279O36471C283O36513C293O36471C300O36439C314O36405C321O36541C325O36598C335O36598C345O36567C352O36576C359O36661C365O36673C367O36708C376O36708C384O36754C387O36748C391O36786C403O36803C416O36812C429O36839C438O36870C443O36839C459O36893C464O36893C469O36958C471O36958C472O36988C477O36988C484O37017,,
code-creation,LazyCompile,10,170051,0xb46b9688e20,376,readFileSync node:fs:464:22,0xb46d10971d0,~
code-source-info,0xb46b9688e20,73,11791,13168,C0O11811C5O11832C10O11821C17O11876C22O11876C27O11930C35O11948C38O11951C43O11974C56O11951C62O12005C65O12005C71O12047C76O12065C79O12047C88O12081C95O12102C97O12111C99O12157C101O12202C102O12211C107O12224C112O12253C124O12262C130O12310C132O12324C133O12333C138O12357C143O12413C159O12369C165O12427C167O12434C174O12474C175O12468C182O12481C187O12346C192O12605C197O12621C207O12621C213O12646C232O12658C238O12708C239O12722C244O12739C249O12774C256O12774C263O12739C268O12810C270O12817C277O12851C278O12851C283O12505C286O12866C290O12885C295O12888C300O12888C305O12906C306O12915C311O12977C316O12993C321O12993C330O13024C332O13032C337O13062C344O13062C351O13096C357O13122C362O13139C367O13122C373O13152C375O13166,,
code-creation,LazyCompile,10,170143,0xb46b9689140,30,isEncoding node:buffer:535:40,0xb469fceeda8,~
code-source-info,0xb46b9689140,30,14913,15045,C0O14928C6O14976C12O14983C20O15001C23O15001C28O15029C29O15043,,
code-creation,LazyCompile,10,170177,0xb46b9689248,30,normalizeEncoding node:internal/util:160:27,0xb4665177610,~
code-source-info,0xb46b9689248,21,4199,4304,C0O4209C7O4232C14O4250C19O4263C21O4277C22O4280C25O4287C29O4302,,
code-creation,LazyCompile,10,170209,0xb46b9689330,9,isUint32 node:internal/validators:41:18,0xb466517a430,~
code-source-info,0xb46b9689330,22,818,863,C0O830C2O854C5O843C8O861,,
code-creation,LazyCompile,10,170255,0xb46b9689490,113,openSync node:fs:590:18,0xb46d1097360,~
code-source-info,0xb46b9689490,73,14862,15241,C0O14886C5O14893C11O14939C16O14939C21O14963C37O14970C44O15021C51O15023C58O15048C63O15056C70O15061C73O15072C78O15072C95O15056C101O15194C106O15194C110O15225C112O15239,,
code-creation,LazyCompile,10,170294,0xb46b9689618,37, node:internal/fs/utils:686:42,0xb46d10b5450,~
code-source-info,0xb46b9689618,77,18638,18773,C14O18693C19O18693C24O18727C29O18727C34O18759C36O18771,,
code-creation,LazyCompile,10,170360,0xb46b96899f0,515,stringToFlags node:internal/fs/utils:561:23,0xb46d10b5270,~
code-source-info,0xb46b96899f0,77,15229,16463,C14O15257C20O15294C25O15294C30O15326C32O15339C33O15347C38O15372C42O15388C43O15396C202O15428C206O15444C207O15494C214O15512C216O15510C219O15519C220O15536C224O15550C225O15602C232O15618C234O15616C237O15625C238O15642C245O15659C247O15657C253O15669C255O15667C258O15678C259O15728C266O15745C268O15743C274O15755C276O15753C282O15766C284O15764C287O15773C288O15791C295O15808C297O15806C303O15818C305O15816C308O15825C309O15875C316O15892C318O15890C324O15902C326O15900C332O15911C334O15909C337O15918C338O15935C345O15953C347O15951C353O15963C355O15961C358O15972C359O16022C366O16040C368O16038C374O16050C376O16048C382O16061C384O16059C387O16068C388O16118C395O16136C397O16134C403O16146C405O16144C411O16157C413O16155C416O16164C417O16182C424O16200C426O16198C432O16210C434O16208C437O16217C438O16267C445O16285C447O16283C453O16295C455O16293C461O16304C463O16302C466O16311C467O16361C474O16379C476O16377C482O16389C484O16387C490O16398C492O16396C495O16405C496O16413C509O16419C514O16413,,
code-creation,LazyCompile,10,170454,0xb46b9689dc8,86,parseFileMode node:internal/validators:60:23,0xb466517a480,~
code-source-info,0xb46b9689dc8,22,1509,1798,C0O1532C11O1549C17O1586C24O1610C27O1590C34O1645C41O1690C52O1651C57O1645C58O1711C66O1719C73O1752C78O1752C83O1783C85O1796,,
code-creation,LazyCompile,10,170524,0xb46b9689f38,66,tryStatSync node:fs:418:21,0xb46d10970e0,~
code-source-info,0xb46b9689f38,73,10766,10976,C0O10797C2O10817C7O10825C22O10825C28O10869C36O10893C38O10909C43O10912C48O10912C53O10931C58O10937C62O10931C63O10961C65O10974,,
code-creation,LazyCompile,10,170580,0xb46b968a0b8,96,tryCreateBuffer node:fs:428:25,0xb46d1097130,~
code-source-info,0xb46b968a0b8,73,11002,11289,C0O11039C2O11051C7O11071C9O11082C11O11080C16O11104C23O11110C28O11104C29O11153C34O11169C39O11169C45O11192C57O11198C58O11225C65O11239C67O11249C72O11252C77O11252C93O11273C95O11287,,
code-creation,LazyCompile,10,170617,0xb46b968a210,17,allocUnsafe node:buffer:378:42,0xb469fcee998,~
code-source-info,0xb46b968a210,30,11010,11065,C0O11021C5O11021C9O11041C12O11048C16O11063,,
code-creation,LazyCompile,10,170648,0xb46b968a320,54, node:buffer:354:36,0xb469fcee8f8,~
code-source-info,0xb46b968a320,30,10308,10463,C0O10322C8O10322C13O10354C14O10365C21O10381C23O10378C28O10400C33O10432C46O10406C51O10400C53O10462,,
code-creation,LazyCompile,10,170699,0xb46b968a4a8,177,validateNumber node:internal/validators:119:24,0xb466517a660,~
code-source-info,0xb46b968a4a8,22,3362,3807,C19O3402C25O3437C41O3443C46O3437C47O3495C54O3521C66O3553C83O3602C86O3602C92O3629C110O3698C136O3730C151O3774C169O3635C174O3629C176O3806,,
code-creation,LazyCompile,10,170746,0xb46b968a678,119,allocate node:buffer:403:18,0xb469fceea88,~
code-source-info,0xb46b968a678,30,11712,12027,C0O11723C1O11732C6O11744C11O11751C16O11768C17O11775C20O11794C24O11803C27O11784C32O11817C34O11829C39O11840C41O11838C44O11826C49O11859C52O11859C55O11887C62O11902C67O11913C75O11887C81O11936C88O11950C94O11947C100O11960C103O11960C106O11977C108O11986C109O11993C114O12000C118O12025,,
code-creation,LazyCompile,10,170803,0xb46b968a838,86,tryReadSync node:fs:443:21,0xb46d1097180,~
code-source-info,0xb46b968a838,73,11311,11546,C0O11360C2O11372C7O11395C12O11410C29O11410C35O11446C47O11452C48O11479C55O11493C57O11503C62O11506C67O11506C83O11527C85O11544,,
code-creation,LazyCompile,10,170862,0xb46b968aa28,251,readSync node:fs:704:18,0xb46d1097400,~
code-source-info,0xb46b968aa28,73,17927,18911,C0O17927C2O17970C7O17975C13O17998C18O17998C22O18039C29O18046C34O18121C40O18131C43O18159C55O18177C61O18193C68O18204C73O18220C82O18262C87O18288C92O18315C105O18315C110O18360C117O18376C118O18387C123O18400C124O18409C125O18428C131O18439C136O18452C152O18458C157O18452C158O18580C163O18628C174O18580C179O18644C184O18670C188O18688C196O18688C201O18743C203O18764C208O18772C233O18772C239O18864C244O18864C248O18895C250O18909,,
code-creation,LazyCompile,10,170918,0xb46b968ac90,52, node:internal/fs/utils:692:40,0xb46d10b54a0,~
code-source-info,0xb46b968ac90,77,18816,18937,C14O18845C22O18849C29O18873C30O18882C31O18890C44O18890C49O18925C51O18935,,
code-creation,LazyCompile,10,170961,0xb46b968add8,155, node:internal/validators:85:3,0xb466517a520,~
code-source-info,0xb46b968add8,22,2270,2733,C36O2411C42O2450C58O2456C63O2450C64O2515C69O2520C75O2552C91O2558C96O2552C97O2617C99O2627C106O2642C111O2657C121O2696C134O2709C147O2663C152O2657C154O2732,,
tick,0x7ff805e2d43e,171024,0,0x0,3,0x102d5e910,0xb46b968acbc,0xb46b968aa2f,0xb46b968a855,0xb46b9688ebf,0xb46b9688a14,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,171038,0xb46b968afc8,51, node:internal/validators:200:40,0xb466517a890,~
code-source-info,0xb46b968afc8,22,6000,6230,C14O6033C19O6038C25O6071C30O6102C43O6077C48O6071C50O6229,,
code-creation,LazyCompile,10,171079,0xb46b968b120,151, node:internal/validators:74:3,0xb466517a4d0,~
code-source-info,0xb46b968b120,22,1843,2224,C12O1863C25O1893C32O1926C38O1963C54O1969C59O1963C60O2022C65O2027C71O2057C87O2063C92O2057C93O2116C95O2126C102O2141C107O2154C117O2193C130O2206C143O2160C148O2154C150O2223,,
code-creation,LazyCompile,10,171131,0xb46b968b310,103, node:internal/fs/utils:642:3,0xb46d10b5360,~
code-source-info,0xb46b968b310,77,17440,17819,C0O17480C1O17491C6O17504C22O17510C27O17504C28O17568C29O17579C34O17592C50O17598C55O17592C56O17656C58O17667C64O17676C69O17700C82O17789C95O17706C100O17700C102O17818,,
code-creation,LazyCompile,10,171193,0xb46b968b618,151, node:internal/fs/utils:907:42,0xb46d10b5810,~
code-source-info,0xb46b968b618,77,24660,25218,C0O24684C6O24724C14O24724C21O24772C27O24812C32O24835C35O24830C37O24827C47O24861C53O24868C56O24855C61O24883C77O24966C80O24961C98O24986C104O24993C117O24889C122O24883C125O25066C143O25072C148O25066C150O25217,,
code-creation,LazyCompile,10,171360,0xb46b968b7d0,47,closeSync node:fs:540:19,0xb46d10972c0,~
code-source-info,0xb46b968b7d0,73,13731,13853,C0O13740C5O13745C11O13780C13O13786C18O13794C31O13794C36O13823C41O13823C46O13852,,
code-creation,LazyCompile,10,171417,0xb46b968b900,162,toString node:buffer:789:46,0xb469fcf0660,~
code-source-info,0xb46b968b900,30,23289,23851,C0O23289C2O23330C8O23337C13O23362C20O23380C25O23362C31O23388C32O23413C37O23424C38O23434C43O23444C48O23462C50O23472C55O23484C57O23494C58O23506C65O23521C71O23550C76O23561C83O23583C90O23596C92O23604C97O23618C99O23628C100O23632C104O23676C109O23676C115O23698C116O23714C119O23714C124O23742C126O23769C133O23775C138O23769C139O23825C156O23825C161O23849,,
code-creation,LazyCompile,10,171513,0xb46b968bbc8,499,getEncodingOps node:buffer:684:24,0xb469fcf04d0,~
code-source-info,0xb46b968bbc8,30,20070,21871,C0O20085C10O20120C62O20148C64O20161C69O20173C74O20192C78O20197C79O20204C81O20217C86O20229C91O20248C95O20253C96O20260C101O20271C107O20315C109O20328C114O20340C119O20359C123O20364C124O20371C126O20384C131O20396C136O20415C140O20420C141O20427C143O20452C145O20465C150O20478C155O20497C159O20502C160O20509C162O20522C167O20535C172O20554C176O20560C177O20567C179O20580C184O20593C189O20612C193O20617C194O20624C199O20635C205O20679C207O20692C212O20705C217O20724C221O20729C222O20736C224O20749C229O20762C234O20781C238O20787C239O20794C241O20807C246O20820C251O20839C255O20844C256O20851C258O20876C260O20889C267O20916C270O20916C277O20953C282O20976C287O20995C291O21003C292O21010C294O21035C296O21048C303O21076C306O21076C313O21113C318O21137C323O21156C327O21164C328O21171C330O21196C332O21209C339O21234C344O21256C349O21275C353O21282C354O21289C356O21302C361O21316C366O21335C370O21342C371O21349C376O21360C382O21404C384O21417C391O21442C396O21464C401O21483C405O21490C406O21497C408O21510C413O21524C418O21543C422O21550C423O21557C425O21582C427O21595C434O21608C437O21608C444O21645C449O21664C454O21683C458O21687C459O21694C461O21719C463O21732C470O21761C473O21761C480O21798C485O21823C490O21842C494O21852C495O21859C498O21870,,
code-creation,LazyCompile,10,171618,0xb46b968bfb0,12,slice node:buffer:599:12,0xb469fceef78,~
code-source-info,0xb46b968bfb0,30,16741,16787,C0O16766C5O16766C11O16787,,
new,MemoryChunk,0xb46fb180000,262144
code-creation,LazyCompile,10,171906,0xb46b968d7a8,499,Module._compile node:internal/modules/cjs/loader:1074:37,0xb469fbda500,~
code-source-info,0xb46b968d7a8,396,33358,35199,C0O33386C2O33403C4O33416C11O33426C20O33444C25O33456C30O33485C35O33504C40O33513C45O33513C51O33549C56O33556C61O33565C66O33565C72O33609C86O33609C91O33681C103O33681C109O33742C111O33750C119O33754C128O33797C135O33818C141O33912C144O33924C151O33928C159O33959C162O33981C170O34006C177O34010C185O33981C193O33972C203O34203C210O34210C215O34223C221O34223C226O34210C231O34203C237O34287C242O34300C248O34367C256O34388C262O34419C264O34415C269O34441C273O34456C279O34470C285O34489C290O34517C295O34567C300O34572C305O34572C311O34609C316O34609C322O34653C324O34684C329O34713C330O34739C333O34747C339O34764C344O34771C349O34783C357O34781C363O34800C367O34828C388O34837C396O34973C401O35012C410O35050C419O35059C428O35068C437O35076C446O35086C459O34982C465O35103C469O35129C475O35139C481O35156C486O35163C490O35173C496O35183C498O35197,,
code-creation,LazyCompile,10,172030,0xb46b968dd20,274,maybeCacheSourceMap node:internal/source_map/source_map_cache:80:29,0xb469fbd0e28,~
code-source-info,0xb46b968dd20,393,2489,3717,C0O2577C3O2577C7O2603C10O2617C15O2621C23O2641C25O2661C26O2668C30O2681C35O2692C44O2690C54O2825C64O2825C68O2841C69O2848C70O2869C80O2869C86O2972C88O3002C91O3030C96O3037C101O3002C107O3072C112O3092C117O3099C122O3121C126O3152C131O3170C136O3174C143O3203C150O3234C160O3264C166O3278C170O3170C178O3303C182O3334C187O3358C192O3362C200O3395C210O3425C216O3439C220O3358C228O3593C233O3611C238O3615C246O3648C256O3678C262O3692C266O3611C273O3716,,
code-creation,LazyCompile,10,172090,0xb46b968e910,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:49:30,0xb469fbd0d88,~
code-source-info,0xb46b968e910,393,1668,1813,C0O1675C6O1718C11O1739C17O1739C22O1718C26O1786C30O1811,,
code-creation,LazyCompile,10,172135,0xb46b968ea88,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:56:30,0xb469fbd0dd8,~
code-source-info,0xb46b968ea88,393,1844,2459,C0O1854C8O1854C13O1959C19O1959C24O1898C29O1924C34O1988C38O2017C42O2072C48O2072C53O2046C58O2128C64O2186C70O2345C76O2345C81O2318C86O2377C90O2433C92O2451C99O2458,,
code-creation,LazyCompile,10,172175,0xb46b968ec00,30,validateBoolean node:internal/validators:143:25,0xb466517a700,~
code-source-info,0xb46b968ec00,22,4208,4319,C0O4226C6O4262C22O4268C27O4262C29O4318,,
tick,0x7ff805eea9f1,172258,1,0x10261b400,6,0x102a1f600,0xb46b968dd2f,0xb46b968d7fe,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,172818,0xb46b968eff8,165,wrapSafe node:internal/modules/cjs/loader:1034:18,0xb469fbd9ae8,~
code-source-info,0xb46b968eff8,396,32154,33150,C0O32154C9O32197C17O32232C22O32239C27O32239C33O32258C40O32268C45O32285C52O32302C56O32391C64O32268C70O32614C74O32631C81O32641C86O32657C98O32772C102O32788C113O32641C118O33025C130O33048C135O33060C142O33071C147O33100C157O33100C162O33134C164O33134,,
code-creation,LazyCompile,10,172948,0xb46b968f7d8,475,compileFunction node:vm:316:25,0xb46806b4a70,~
script-source,85,node:vm,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  Symbol\x2C\n  PromiseReject\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst {\n  ContextifyScript\x2C\n  MicrotaskQueue\x2C\n  makeContext\x2C\n  isContext: _isContext\x2C\n  constants\x2C\n  compileFunction: _compileFunction\x2C\n  measureMemory: _measureMemory\x2C\n} = internalBinding('contextify');\nconst {\n  ERR_CONTEXT_NOT_INITIALIZED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n} = require('internal/errors').codes;\nconst {\n  isArrayBufferView\x2C\n} = require('internal/util/types');\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateBuffer\x2C\n  validateFunction\x2C\n  validateInt32\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n  validateUint32\x2C\n} = require('internal/validators');\nconst {\n  emitExperimentalWarning\x2C\n  kEmptyObject\x2C\n  kVmBreakFirstLineSymbol\x2C\n} = require('internal/util');\nconst kParsingContext = Symbol('script parsing context');\n\nclass Script extends ContextifyScript {\n  constructor(code\x2C options = kEmptyObject) {\n    code = `${code}`;\n    if (typeof options === 'string') {\n      options = { filename: options };\n    } else {\n      validateObject(options\x2C 'options');\n    }\n\n    const {\n      filename = 'evalmachine.<anonymous>'\x2C\n      lineOffset = 0\x2C\n      columnOffset = 0\x2C\n      cachedData\x2C\n      produceCachedData = false\x2C\n      importModuleDynamically\x2C\n      [kParsingContext]: parsingContext\x2C\n    } = options;\n\n    validateString(filename\x2C 'options.filename');\n    validateInt32(lineOffset\x2C 'options.lineOffset');\n    validateInt32(columnOffset\x2C 'options.columnOffset');\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.cachedData'\x2C\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\n        cachedData\n      );\n    }\n    validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n\n    // Calling `ReThrow()` on a native TryCatch does not generate a new\n    // abort-on-uncaught-exception check. A dummy try/catch in JS land\n    // protects against that.\n    try { // eslint-disable-line no-useless-catch\n      super(code\x2C\n            filename\x2C\n            lineOffset\x2C\n            columnOffset\x2C\n            cachedData\x2C\n            produceCachedData\x2C\n            parsingContext);\n    } catch (e) {\n      throw e; /* node-do-not-add-exception-line */\n    }\n\n    if (importModuleDynamically !== undefined) {\n      validateFunction(importModuleDynamically\x2C\n                       'options.importModuleDynamically');\n      const { importModuleDynamicallyWrap } =\n        require('internal/vm/module');\n      const { callbackMap } = internalBinding('module_wrap');\n      callbackMap.set(this\x2C {\n        importModuleDynamically:\n          importModuleDynamicallyWrap(importModuleDynamically)\x2C\n      });\n    }\n  }\n\n  runInThisContext(options) {\n    const { breakOnSigint\x2C args } = getRunInContextArgs(null\x2C options);\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInContext\x2C this\x2C args);\n  }\n\n  runInContext(contextifiedObject\x2C options) {\n    validateContext(contextifiedObject);\n    const { breakOnSigint\x2C args } = getRunInContextArgs(\n      contextifiedObject\x2C\n      options\x2C\n    );\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\n      return sigintHandlersWrap(super.runInContext\x2C this\x2C args);\n    }\n    return ReflectApply(super.runInContext\x2C this\x2C args);\n  }\n\n  runInNewContext(contextObject\x2C options) {\n    const context = createContext(contextObject\x2C getContextOptions(options));\n    return this.runInContext(context\x2C options);\n  }\n}\n\nfunction validateContext(contextifiedObject) {\n  if (!isContext(contextifiedObject)) {\n    throw new ERR_INVALID_ARG_TYPE('contextifiedObject'\x2C 'vm.Context'\x2C\n                                   contextifiedObject);\n  }\n}\n\nfunction getRunInContextArgs(contextifiedObject\x2C options = kEmptyObject) {\n  validateObject(options\x2C 'options');\n\n  let timeout = options.timeout;\n  if (timeout === undefined) {\n    timeout = -1;\n  } else {\n    validateUint32(timeout\x2C 'options.timeout'\x2C true);\n  }\n\n  const {\n    displayErrors = true\x2C\n    breakOnSigint = false\x2C\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false\x2C\n  } = options;\n\n  validateBoolean(displayErrors\x2C 'options.displayErrors');\n  validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\n\n  return {\n    breakOnSigint\x2C\n    args: [\n      contextifiedObject\x2C\n      timeout\x2C\n      displayErrors\x2C\n      breakOnSigint\x2C\n      breakFirstLine\x2C\n    ]\x2C\n  };\n}\n\nfunction getContextOptions(options) {\n  if (!options)\n    return {};\n  const contextOptions = {\n    name: options.contextName\x2C\n    origin: options.contextOrigin\x2C\n    codeGeneration: undefined\x2C\n    microtaskMode: options.microtaskMode\x2C\n  };\n  if (contextOptions.name !== undefined)\n    validateString(contextOptions.name\x2C 'options.contextName');\n  if (contextOptions.origin !== undefined)\n    validateString(contextOptions.origin\x2C 'options.contextOrigin');\n  if (options.contextCodeGeneration !== undefined) {\n    validateObject(options.contextCodeGeneration\x2C\n                   'options.contextCodeGeneration');\n    const { strings\x2C wasm } = options.contextCodeGeneration;\n    if (strings !== undefined)\n      validateBoolean(strings\x2C 'options.contextCodeGeneration.strings');\n    if (wasm !== undefined)\n      validateBoolean(wasm\x2C 'options.contextCodeGeneration.wasm');\n    contextOptions.codeGeneration = { strings\x2C wasm };\n  }\n  if (options.microtaskMode !== undefined)\n    validateString(options.microtaskMode\x2C 'options.microtaskMode');\n  return contextOptions;\n}\n\nfunction isContext(object) {\n  validateObject(object\x2C 'object'\x2C { allowArray: true });\n\n  return _isContext(object);\n}\n\nlet defaultContextNameIndex = 1;\nfunction createContext(contextObject = {}\x2C options = kEmptyObject) {\n  if (isContext(contextObject)) {\n    return contextObject;\n  }\n\n  validateObject(options\x2C 'options');\n\n  const {\n    name = `VM Context ${defaultContextNameIndex++}`\x2C\n    origin\x2C\n    codeGeneration\x2C\n    microtaskMode\n  } = options;\n\n  validateString(name\x2C 'options.name');\n  if (origin !== undefined)\n    validateString(origin\x2C 'options.origin');\n  if (codeGeneration !== undefined)\n    validateObject(codeGeneration\x2C 'options.codeGeneration');\n\n  let strings = true;\n  let wasm = true;\n  if (codeGeneration !== undefined) {\n    ({ strings = true\x2C wasm = true } = codeGeneration);\n    validateBoolean(strings\x2C 'options.codeGeneration.strings');\n    validateBoolean(wasm\x2C 'options.codeGeneration.wasm');\n  }\n\n  let microtaskQueue = null;\n  if (microtaskMode !== undefined) {\n    validateOneOf(microtaskMode\x2C 'options.microtaskMode'\x2C\n                  ['afterEvaluate'\x2C undefined]);\n\n    if (microtaskMode === 'afterEvaluate')\n      microtaskQueue = new MicrotaskQueue();\n  }\n\n  makeContext(contextObject\x2C name\x2C origin\x2C strings\x2C wasm\x2C microtaskQueue);\n  return contextObject;\n}\n\nfunction createScript(code\x2C options) {\n  return new Script(code\x2C options);\n}\n\n// Remove all SIGINT listeners and re-attach them after the wrapped function\n// has executed\x2C so that caught SIGINT are handled by the listeners again.\nfunction sigintHandlersWrap(fn\x2C thisArg\x2C argsArray) {\n  const sigintListeners = process.rawListeners('SIGINT');\n\n  process.removeAllListeners('SIGINT');\n\n  try {\n    return ReflectApply(fn\x2C thisArg\x2C argsArray);\n  } finally {\n    // Add using the public methods so that the `newListener` handler of\n    // process can re-attach the listeners.\n    ArrayPrototypeForEach(sigintListeners\x2C (listener) => {\n      process.addListener('SIGINT'\x2C listener);\n    });\n  }\n}\n\nfunction runInContext(code\x2C contextifiedObject\x2C options) {\n  validateContext(contextifiedObject);\n  if (typeof options === 'string') {\n    options = {\n      filename: options\x2C\n      [kParsingContext]: contextifiedObject\n    };\n  } else {\n    options = { ...options\x2C [kParsingContext]: contextifiedObject };\n  }\n  return createScript(code\x2C options)\n    .runInContext(contextifiedObject\x2C options);\n}\n\nfunction runInNewContext(code\x2C contextObject\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  contextObject = createContext(contextObject\x2C getContextOptions(options));\n  options = { ...options\x2C [kParsingContext]: contextObject };\n  return createScript(code\x2C options).runInNewContext(contextObject\x2C options);\n}\n\nfunction runInThisContext(code\x2C options) {\n  if (typeof options === 'string') {\n    options = { filename: options };\n  }\n  return createScript(code\x2C options).runInThisContext(options);\n}\n\nfunction compileFunction(code\x2C params\x2C options = kEmptyObject) {\n  validateString(code\x2C 'code');\n  if (params !== undefined) {\n    validateArray(params\x2C 'params');\n    ArrayPrototypeForEach(params\x2C\n                          (param\x2C i) => validateString(param\x2C `params[${i}]`));\n  }\n\n  const {\n    filename = ''\x2C\n    columnOffset = 0\x2C\n    lineOffset = 0\x2C\n    cachedData = undefined\x2C\n    produceCachedData = false\x2C\n    parsingContext = undefined\x2C\n    contextExtensions = []\x2C\n    importModuleDynamically\x2C\n  } = options;\n\n  validateString(filename\x2C 'options.filename');\n  validateUint32(columnOffset\x2C 'options.columnOffset');\n  validateUint32(lineOffset\x2C 'options.lineOffset');\n  if (cachedData !== undefined)\n    validateBuffer(cachedData\x2C 'options.cachedData');\n  validateBoolean(produceCachedData\x2C 'options.produceCachedData');\n  if (parsingContext !== undefined) {\n    if (\n      typeof parsingContext !== 'object' ||\n      parsingContext === null ||\n      !isContext(parsingContext)\n    ) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.parsingContext'\x2C\n        'Context'\x2C\n        parsingContext\n      );\n    }\n  }\n  validateArray(contextExtensions\x2C 'options.contextExtensions');\n  ArrayPrototypeForEach(contextExtensions\x2C (extension\x2C i) => {\n    const name = `options.contextExtensions[${i}]`;\n    validateObject(extension\x2C name\x2C { nullable: true });\n  });\n\n  const result = _compileFunction(\n    code\x2C\n    filename\x2C\n    lineOffset\x2C\n    columnOffset\x2C\n    cachedData\x2C\n    produceCachedData\x2C\n    parsingContext\x2C\n    contextExtensions\x2C\n    params\n  );\n\n  if (produceCachedData) {\n    result.function.cachedDataProduced = result.cachedDataProduced;\n  }\n\n  if (result.cachedData) {\n    result.function.cachedData = result.cachedData;\n  }\n\n  if (importModuleDynamically !== undefined) {\n    validateFunction(importModuleDynamically\x2C\n                     'options.importModuleDynamically');\n    const { importModuleDynamicallyWrap } =\n      require('internal/vm/module');\n    const { callbackMap } = internalBinding('module_wrap');\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\n    const func = result.function;\n    callbackMap.set(result.cacheKey\x2C {\n      importModuleDynamically: (s\x2C _k\x2C i) => wrapped(s\x2C func\x2C i)\x2C\n    });\n  }\n\n  return result.function;\n}\n\nconst measureMemoryModes = {\n  summary: constants.measureMemory.mode.SUMMARY\x2C\n  detailed: constants.measureMemory.mode.DETAILED\x2C\n};\n\nconst measureMemoryExecutions = {\n  default: constants.measureMemory.execution.DEFAULT\x2C\n  eager: constants.measureMemory.execution.EAGER\x2C\n};\n\nfunction measureMemory(options = kEmptyObject) {\n  emitExperimentalWarning('vm.measureMemory');\n  validateObject(options\x2C 'options');\n  const { mode = 'summary'\x2C execution = 'default' } = options;\n  validateOneOf(mode\x2C 'options.mode'\x2C ['summary'\x2C 'detailed']);\n  validateOneOf(execution\x2C 'options.execution'\x2C ['default'\x2C 'eager']);\n  const result = _measureMemory(measureMemoryModes[mode]\x2C\n                                measureMemoryExecutions[execution]);\n  if (result === undefined) {\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\n  }\n  return result;\n}\n\nmodule.exports = {\n  Script\x2C\n  createContext\x2C\n  createScript\x2C\n  runInContext\x2C\n  runInNewContext\x2C\n  runInThisContext\x2C\n  isContext\x2C\n  compileFunction\x2C\n  measureMemory\x2C\n};\n\n// The vm module is patched to include vm.Module\x2C vm.SourceTextModule\n// and vm.SyntheticModule in the pre-execution phase when\n// --experimental-vm-modules is on.\n
code-source-info,0xb46b968f7d8,85,9645,11910,C12O9670C19O9688C28O9688C33O9720C37O9752C46O9752C51O9789C56O9811C62O9789C67O9918C79O9937C87O9959C95O9979C103O10007C111O10038C119O10070C128O10098C133O10141C142O10141C147O10189C156O10189C161O10245C170O10245C175O10297C179O10331C188O10331C193O10383C202O10383C207O10450C211O10490C224O10579C230O10619C247O10625C252O10619C253O10748C262O10748C267O10813C272O10835C278O10813C283O11007C315O11007C321O11184C325O11220C330O11257C334O11248C338O11295C344O11320C349O11349C353O11340C357O11368C361O11396C371O11417C382O11417C387O11566C396O11566C401O11528C406O11625C415O11625C420O11609C425O11677C429O11677C431O11755C435O11748C437O11781C442O11792C454O11835C462O11781C470O11899C474O11908,,
tick,0x7ff805edeb48,174507,0,0x0,3,0x102d5e910,0xb46b968f069,0xb46b968d80f,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,174523,0xb46b96909e8,95, node:internal/validators:177:39,0xb466517a7f0,~
code-source-info,0xb46b96909e8,22,5304,5582,C16O5340C21O5345C27O5372C43O5378C48O5372C49O5442C56O5449C61O5483C66O5506C71O5523C87O5529C92O5523C94O5581,,
code-creation,LazyCompile,10,174560,0xb46b9690b48,27, node:vm:321:27,0xb46b968f4a0,~
code-source-info,0xb46b9690b48,85,9845,9896,C0O9859C10O9891C21O9859C26O9896,,
code-creation,Eval,10,174608,0xb46b9690de0,5, /Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/no-cluster.js:1:1,0xb46b9690c98,~
script-source,420,/Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/no-cluster.js,const cluster = require('cluster')\n\ncluster.on('fork'\x2C () => {\n  throw new Error('0x does not support clustering.')\n})\n
code-source-info,0xb46b9690de0,420,0,119,C0O0C4O119,,
code-creation,Function,10,174677,0xb46b9690ec8,29, /Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/no-cluster.js:1:1,0xb46b9690d58,~
code-source-info,0xb46b9690ec8,420,0,119,C0O16C3O16C8O44C21O44C28O118,,
tick,0x102c74e77,174774,0,0x0,3,0x102d5e910,0xb46b968f981,0xb46b968f069,0xb46b968d80f,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,175210,0xb46b9691138,19,importModuleDynamicallyWrap node:internal/vm/module:436:37,0xb46bbe68658,~
code-source-info,0xb46b9691138,418,11767,12210,C0O11767C13O11836C18O12208,,
code-creation,LazyCompile,10,175297,0xb46b9692318,159,makeRequireFunction node:internal/modules/cjs/helpers:58:29,0xb469fbd3e88,~
code-source-info,0xb46b9692318,395,1708,3678,C0O1708C22O1744C25O1748C29O1744C31O1768C33O1779C53O1811C58O1815C69O1831C73O1811C75O1858C81O1858C83O1885C89O1894C95O1922C104O3082C109O3313C111O3329C115O3469C117O3483C121O3495C126O3518C130O3508C134O3583C137O3611C141O3602C145O3627C148O3650C152O3641C156O3661C158O3676,,
code-creation,LazyCompile,10,175360,0xb46b9692568,14,require node:internal/modules/cjs/helpers:101:31,0xb46b96921e8,~
code-source-info,0xb46b9692568,395,3108,3154,C0O3123C3O3134C8O3134C13O3148,,
code-creation,LazyCompile,10,175423,0xb46b96926e8,10, node:internal/modules/cjs/helpers:29:66,0xb469fbd4058,~
code-source-info,0xb46b96926e8,395,810,835,C0O822C2O828C9O834,,
code-creation,LazyCompile,10,175472,0xb46b9692860,129,compileForPublicLoader node:internal/bootstrap/loaders:263:25,0xb466514b720,~
code-source-info,0xb46b9692860,15,8006,8678,C0O8025C6O8169C16O8212C33O8175C38O8169C39O8249C44O8249C48O8291C54O8480C61O8511C69O8480C75O8535C80O8553C90O8569C93O8585C98O8569C102O8551C106O8610C111O8610C115O8635C120O8635C124O8666C128O8674,,
code-creation,Eval,10,175697,0xb46b9692bd0,5, node:cluster:1:1,0xb46b9692a88,~
script-source,421,node:cluster,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst childOrPrimary = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'primary';\nmodule.exports = require(`internal/cluster/${childOrPrimary}`);\n
code-source-info,0xb46b9692bd0,421,0,1291,C0O0C4O1291,,
code-creation,Function,10,175862,0xb46b9692c78,39, node:cluster:1:1,0xb46b9692b48,~
code-source-info,0xb46b9692c78,421,0,1291,C0O1172C3O1200C7O1189C19O1227C24O1272C29O1244C33O1242C38O1290,,
tick,0x102cc6e1a,176024,1,0x10266e4e0,2,0x1027fed10,0x113244e26,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,176244,0xb46b96938a8,5, node:internal/cluster/primary:1:1,0xb46b9693520,~
script-source,422,node:internal/cluster/primary,'use strict';\n\nconst {\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSome\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  RegExpPrototypeExec\x2C\n  SafeMap\x2C\n  StringPrototypeStartsWith\x2C\n} = primordials;\n\nconst assert = require('internal/assert');\nconst { fork } = require('child_process');\nconst path = require('path');\nconst EventEmitter = require('events');\nconst RoundRobinHandle = require('internal/cluster/round_robin_handle');\nconst SharedHandle = require('internal/cluster/shared_handle');\nconst Worker = require('internal/cluster/worker');\nconst { internal\x2C sendHelper } = require('internal/cluster/utils');\nconst cluster = new EventEmitter();\nconst intercom = new EventEmitter();\nconst SCHED_NONE = 1;\nconst SCHED_RR = 2;\nconst minPort = 1024;\nconst maxPort = 65535;\nconst { validatePort } = require('internal/validators');\n\nmodule.exports = cluster;\n\nconst handles = new SafeMap();\ncluster.isWorker = false;\ncluster.isMaster = true; // Deprecated alias. Must be same as isPrimary.\ncluster.isPrimary = true;\ncluster.Worker = Worker;\ncluster.workers = {};\ncluster.settings = {};\ncluster.SCHED_NONE = SCHED_NONE;  // Leave it to the operating system.\ncluster.SCHED_RR = SCHED_RR;      // Primary distributes connections.\n\nlet ids = 0;\nlet debugPortOffset = 1;\nlet initialized = false;\n\n// XXX(bnoordhuis) Fold cluster.schedulingPolicy into cluster.settings?\nlet schedulingPolicy = process.env.NODE_CLUSTER_SCHED_POLICY;\nif (schedulingPolicy === 'rr')\n  schedulingPolicy = SCHED_RR;\nelse if (schedulingPolicy === 'none')\n  schedulingPolicy = SCHED_NONE;\nelse if (process.platform === 'win32') {\n  // Round-robin doesn't perform well on\n  // Windows due to the way IOCP is wired up.\n  schedulingPolicy = SCHED_NONE;\n} else\n  schedulingPolicy = SCHED_RR;\n\ncluster.schedulingPolicy = schedulingPolicy;\n\ncluster.setupPrimary = function(options) {\n  const settings = {\n    args: ArrayPrototypeSlice(process.argv\x2C 2)\x2C\n    exec: process.argv[1]\x2C\n    execArgv: process.execArgv\x2C\n    silent: false\x2C\n    ...cluster.settings\x2C\n    ...options\n  };\n\n  // Tell V8 to write profile data for each process to a separate file.\n  // Without --logfile=v8-%p.log\x2C everything ends up in a single\x2C unusable\n  // file. (Unusable because what V8 logs are memory addresses and each\n  // process has its own memory mappings.)\n  if (ArrayPrototypeSome(settings.execArgv\x2C\n                         (s) => StringPrototypeStartsWith(s\x2C '--prof')) &&\n      !ArrayPrototypeSome(settings.execArgv\x2C\n                          (s) => StringPrototypeStartsWith(s\x2C '--logfile='))) {\n    settings.execArgv = [...settings.execArgv\x2C '--logfile=v8-%p.log'];\n  }\n\n  cluster.settings = settings;\n\n  if (initialized === true)\n    return process.nextTick(setupSettingsNT\x2C settings);\n\n  initialized = true;\n  schedulingPolicy = cluster.schedulingPolicy;  // Freeze policy.\n  assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR\x2C\n         `Bad cluster.schedulingPolicy: ${schedulingPolicy}`);\n\n  process.nextTick(setupSettingsNT\x2C settings);\n\n  process.on('internalMessage'\x2C (message) => {\n    if (message.cmd !== 'NODE_DEBUG_ENABLED')\n      return;\n\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.state === 'online' || worker.state === 'listening') {\n        process._debugProcess(worker.process.pid);\n      } else {\n        worker.once('online'\x2C function() {\n          process._debugProcess(this.process.pid);\n        });\n      }\n    }\n  });\n};\n\n// Deprecated alias must be same as setupPrimary\ncluster.setupMaster = cluster.setupPrimary;\n\nfunction setupSettingsNT(settings) {\n  cluster.emit('setup'\x2C settings);\n}\n\nfunction createWorkerProcess(id\x2C env) {\n  const workerEnv = { ...process.env\x2C ...env\x2C NODE_UNIQUE_ID: `${id}` };\n  const execArgv = [...cluster.settings.execArgv];\n  const debugArgRegex = /--inspect(?:-brk|-port)?|--debug-port/;\n  const nodeOptions = process.env.NODE_OPTIONS || '';\n\n  if (ArrayPrototypeSome(execArgv\x2C\n                         (arg) => RegExpPrototypeExec(debugArgRegex\x2C arg) !== null) ||\n      RegExpPrototypeExec(debugArgRegex\x2C nodeOptions) !== null) {\n    let inspectPort;\n    if ('inspectPort' in cluster.settings) {\n      if (typeof cluster.settings.inspectPort === 'function')\n        inspectPort = cluster.settings.inspectPort();\n      else\n        inspectPort = cluster.settings.inspectPort;\n\n      validatePort(inspectPort);\n    } else {\n      inspectPort = process.debugPort + debugPortOffset;\n      if (inspectPort > maxPort)\n        inspectPort = inspectPort - maxPort + minPort - 1;\n      debugPortOffset++;\n    }\n\n    ArrayPrototypePush(execArgv\x2C `--inspect-port=${inspectPort}`);\n  }\n\n  return fork(cluster.settings.exec\x2C cluster.settings.args\x2C {\n    cwd: cluster.settings.cwd\x2C\n    env: workerEnv\x2C\n    serialization: cluster.settings.serialization\x2C\n    silent: cluster.settings.silent\x2C\n    windowsHide: cluster.settings.windowsHide\x2C\n    execArgv: execArgv\x2C\n    stdio: cluster.settings.stdio\x2C\n    gid: cluster.settings.gid\x2C\n    uid: cluster.settings.uid\n  });\n}\n\nfunction removeWorker(worker) {\n  assert(worker);\n  delete cluster.workers[worker.id];\n\n  if (ObjectKeys(cluster.workers).length === 0) {\n    assert(handles.size === 0\x2C 'Resource leak detected.');\n    intercom.emit('disconnect');\n  }\n}\n\nfunction removeHandlesForWorker(worker) {\n  assert(worker);\n\n  handles.forEach((handle\x2C key) => {\n    if (handle.remove(worker))\n      handles.delete(key);\n  });\n}\n\ncluster.fork = function(env) {\n  cluster.setupPrimary();\n  const id = ++ids;\n  const workerProcess = createWorkerProcess(id\x2C env);\n  const worker = new Worker({\n    id: id\x2C\n    process: workerProcess\n  });\n\n  worker.on('message'\x2C function(message\x2C handle) {\n    cluster.emit('message'\x2C this\x2C message\x2C handle);\n  });\n\n  worker.process.once('exit'\x2C (exitCode\x2C signalCode) => {\n    /*\n     * Remove the worker from the workers list only\n     * if it has disconnected\x2C otherwise we might\n     * still want to access it.\n     */\n    if (!worker.isConnected()) {\n      removeHandlesForWorker(worker);\n      removeWorker(worker);\n    }\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'dead';\n    worker.emit('exit'\x2C exitCode\x2C signalCode);\n    cluster.emit('exit'\x2C worker\x2C exitCode\x2C signalCode);\n  });\n\n  worker.process.once('disconnect'\x2C () => {\n    /*\n     * Now is a good time to remove the handles\n     * associated with this worker because it is\n     * not connected to the primary anymore.\n     */\n    removeHandlesForWorker(worker);\n\n    /*\n     * Remove the worker from the workers list only\n     * if its process has exited. Otherwise\x2C we might\n     * still want to access it.\n     */\n    if (worker.isDead())\n      removeWorker(worker);\n\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\n    worker.state = 'disconnected';\n    worker.emit('disconnect');\n    cluster.emit('disconnect'\x2C worker);\n  });\n\n  worker.process.on('internalMessage'\x2C internal(worker\x2C onmessage));\n  process.nextTick(emitForkNT\x2C worker);\n  cluster.workers[worker.id] = worker;\n  return worker;\n};\n\nfunction emitForkNT(worker) {\n  cluster.emit('fork'\x2C worker);\n}\n\ncluster.disconnect = function(cb) {\n  const workers = ObjectKeys(cluster.workers);\n\n  if (workers.length === 0) {\n    process.nextTick(() => intercom.emit('disconnect'));\n  } else {\n    for (const worker of ObjectValues(cluster.workers)) {\n      if (worker.isConnected()) {\n        worker.disconnect();\n      }\n    }\n  }\n\n  if (typeof cb === 'function')\n    intercom.once('disconnect'\x2C cb);\n};\n\nconst methodMessageMapping = {\n  close\x2C\n  exitedAfterDisconnect\x2C\n  listening\x2C\n  online\x2C\n  queryServer\x2C\n};\n\nfunction onmessage(message\x2C handle) {\n  const worker = this;\n\n  const fn = methodMessageMapping[message.act];\n\n  if (typeof fn === 'function')\n    fn(worker\x2C message);\n}\n\nfunction online(worker) {\n  worker.state = 'online';\n  worker.emit('online');\n  cluster.emit('online'\x2C worker);\n}\n\nfunction exitedAfterDisconnect(worker\x2C message) {\n  worker.exitedAfterDisconnect = true;\n  send(worker\x2C { ack: message.seq });\n}\n\nfunction queryServer(worker\x2C message) {\n  // Stop processing if worker already disconnecting\n  if (worker.exitedAfterDisconnect)\n    return;\n\n  const key = `${message.address}:${message.port}:${message.addressType}:` +\n              `${message.fd}:${message.index}`;\n  let handle = handles.get(key);\n\n  if (handle === undefined) {\n    let address = message.address;\n\n    // Find shortest path for unix sockets because of the ~100 byte limit\n    if (message.port < 0 && typeof address === 'string' &&\n        process.platform !== 'win32') {\n\n      address = path.relative(process.cwd()\x2C address);\n\n      if (message.address.length < address.length)\n        address = message.address;\n    }\n\n    // UDP is exempt from round-robin connection balancing for what should\n    // be obvious reasons: it's connectionless. There is nothing to send to\n    // the workers except raw datagrams and that's pointless.\n    if (schedulingPolicy !== SCHED_RR ||\n        message.addressType === 'udp4' ||\n        message.addressType === 'udp6') {\n      handle = new SharedHandle(key\x2C address\x2C message);\n    } else {\n      handle = new RoundRobinHandle(key\x2C address\x2C message);\n    }\n\n    handles.set(key\x2C handle);\n  }\n\n  if (!handle.data)\n    handle.data = message.data;\n\n  // Set custom server data\n  handle.add(worker\x2C (errno\x2C reply\x2C handle) => {\n    const { data } = handles.get(key);\n\n    if (errno)\n      handles.delete(key);  // Gives other workers a chance to retry.\n\n    send(worker\x2C {\n      errno\x2C\n      key\x2C\n      ack: message.seq\x2C\n      data\x2C\n      ...reply\n    }\x2C handle);\n  });\n}\n\nfunction listening(worker\x2C message) {\n  const info = {\n    addressType: message.addressType\x2C\n    address: message.address\x2C\n    port: message.port\x2C\n    fd: message.fd\n  };\n\n  worker.state = 'listening';\n  worker.emit('listening'\x2C info);\n  cluster.emit('listening'\x2C worker\x2C info);\n}\n\n// Server in worker is closing\x2C remove from list. The handle may have been\n// removed by a prior call to removeHandlesForWorker() so guard against that.\nfunction close(worker\x2C message) {\n  const key = message.key;\n  const handle = handles.get(key);\n\n  if (handle && handle.remove(worker))\n    handles.delete(key);\n}\n\nfunction send(worker\x2C message\x2C handle\x2C cb) {\n  return sendHelper(worker.process\x2C message\x2C handle\x2C cb);\n}\n\n// Extend generic Worker with methods specific to the primary process.\nWorker.prototype.disconnect = function() {\n  this.exitedAfterDisconnect = true;\n  send(this\x2C { act: 'disconnect' });\n  removeHandlesForWorker(this);\n  removeWorker(this);\n  return this;\n};\n\nWorker.prototype.destroy = function(signo) {\n  const proc = this.process;\n  const signal = signo || 'SIGTERM';\n\n  proc.kill(signal);\n};\n
code-source-info,0xb46b96938a8,422,0,10698,C0O0C4O10698,,
tick,0x103b69f66,177473,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Function,10,177490,0xb46b9694270,640, node:internal/cluster/primary:1:1,0xb46b9693820,~
code-source-info,0xb46b9694270,422,0,10698,C0O0C160O25C166O47C172O70C178O92C184O106C190O122C196O145C201O156C207O216C210O216C214O216C216O261C219O261C224O252C230O300C233O300C237O300C239O338C242O338C247O382C250O382C254O382C256O451C259O451C263O451C265O509C268O509C272O509C274O578C277O578C282O553C288O563C294O629C296O629C301O629C303O666C305O666C310O666C312O705C314O705C316O725C318O725C320O744C324O744C326O766C332O766C334O798C337O798C342O781C348O831C350O846C354O874C356O874C361O874C363O889C367O906C371O915C375O932C379O988C383O1006C387O1014C392O1029C396O1039C400O1055C404O1061C408O1078C412O1084C417O1103C421O1155C426O1172C430O1236C431O1236C433O1261C435O1261C437O1282C438O1282C440O1385C443O1393C448O1397C452O1385C454O1424C459O1445C464O1457C466O1474C470O1491C475O1512C480O1526C482O1543C486O1562C489O1574C496O1583C501O1687C503O1704C507O1727C509O1744C511O1757C516O1782C520O1803C527O1824C531O3495C537O3525C541O3515C545O5411C552O5424C556O7104C563O7123C567O7528C574O7532C580O7541C586O7566C592O7579C598O7589C604O7528C606O10372C609O10379C618O10400C622O10562C625O10569C634O10587C639O10697,,
code-creation,Eval,10,178030,0xb46b9696148,5, node:child_process:1:1,0xb46b9695c20,~
script-source,423,node:child_process,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeLastIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  ArrayPrototypePushApply\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RegExpPrototypeExec\x2C\n  SafeSet\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToUpperCase\x2C\n} = primordials;\n\nconst {\n  convertToValidSignal\x2C\n  createDeferredPromise\x2C\n  getSystemErrorName\x2C\n  kEmptyObject\x2C\n  promisify\x2C\n} = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nlet debug = require('internal/util/debuglog').debuglog(\n  'child_process'\x2C\n  (fn) => {\n    debug = fn;\n  }\n);\nconst { Buffer } = require('buffer');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\n\nconst {\n  AbortError\x2C\n  codes: errorCodes\x2C\n  genericNodeError\x2C\n} = require('internal/errors');\nconst {\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_CHILD_PROCESS_IPC_REQUIRED\x2C\n  ERR_CHILD_PROCESS_STDIO_MAXBUFFER\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_OUT_OF_RANGE\x2C\n} = errorCodes;\nconst { clearTimeout\x2C setTimeout } = require('timers');\nconst { getValidatedPath } = require('internal/fs/utils');\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateArray\x2C\n  validateBoolean\x2C\n  validateFunction\x2C\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst child_process = require('internal/child_process');\nconst {\n  getValidStdio\x2C\n  setupChannel\x2C\n  ChildProcess\x2C\n  stdioStringToArray\n} = child_process;\n\nconst MAX_BUFFER = 1024 * 1024;\n\n/**\n * Spawns a new Node.js process + fork.\n * @param {string|URL} modulePath\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   detached?: boolean;\n *   env?: Record<string\x2C string>;\n *   execPath?: string;\n *   execArgv?: string[];\n *   gid?: number;\n *   serialization?: string;\n *   signal?: AbortSignal;\n *   killSignal?: string | number;\n *   silent?: boolean;\n *   stdio?: Array | string;\n *   uid?: number;\n *   windowsVerbatimArguments?: boolean;\n *   timeout?: number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction fork(modulePath\x2C args = []\x2C options) {\n  modulePath = getValidatedPath(modulePath\x2C 'modulePath');\n\n  // Get options and args arguments.\n  let execArgv;\n\n  if (args == null) {\n    args = [];\n  } else if (typeof args === 'object' && !ArrayIsArray(args)) {\n    options = args;\n    args = [];\n  } else {\n    validateArray(args\x2C 'args');\n  }\n\n  if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n  options = { ...options\x2C shell: false };\n  options.execPath = options.execPath || process.execPath;\n\n  // Prepare arguments for fork:\n  execArgv = options.execArgv || process.execArgv;\n\n  if (execArgv === process.execArgv && process._eval != null) {\n    const index = ArrayPrototypeLastIndexOf(execArgv\x2C process._eval);\n    if (index > 0) {\n      // Remove the -e switch to avoid fork bombing ourselves.\n      execArgv = ArrayPrototypeSlice(execArgv);\n      ArrayPrototypeSplice(execArgv\x2C index - 1\x2C 2);\n    }\n  }\n\n  args = [...execArgv\x2C modulePath\x2C ...args];\n\n  if (typeof options.stdio === 'string') {\n    options.stdio = stdioStringToArray(options.stdio\x2C 'ipc');\n  } else if (!ArrayIsArray(options.stdio)) {\n    // Use a separate fd=3 for the IPC channel. Inherit stdin\x2C stdout\x2C\n    // and stderr from the parent if silent isn't set.\n    options.stdio = stdioStringToArray(\n      options.silent ? 'pipe' : 'inherit'\x2C\n      'ipc');\n  } else if (!ArrayPrototypeIncludes(options.stdio\x2C 'ipc')) {\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio');\n  }\n\n  return spawn(options.execPath\x2C args\x2C options);\n}\n\nfunction _forkChild(fd\x2C serializationMode) {\n  // set process.send()\n  const p = new Pipe(PipeConstants.IPC);\n  p.open(fd);\n  p.unref();\n  const control = setupChannel(process\x2C p\x2C serializationMode);\n  process.on('newListener'\x2C function onNewListener(name) {\n    if (name === 'message' || name === 'disconnect') control.refCounted();\n  });\n  process.on('removeListener'\x2C function onRemoveListener(name) {\n    if (name === 'message' || name === 'disconnect') control.unrefCounted();\n  });\n}\n\nfunction normalizeExecArgs(command\x2C options\x2C callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = undefined;\n  }\n\n  // Make a shallow copy so we don't clobber the user's options object.\n  options = { ...options };\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\n\n  return {\n    file: command\x2C\n    options: options\x2C\n    callback: callback\n  };\n}\n\n/**\n * Spawns a shell executing the given command.\n * @param {string} command\n * @param {{\n *   cmd?: string;\n *   env?: Record<string\x2C string>;\n *   encoding?: string;\n *   shell?: string;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction exec(command\x2C options\x2C callback) {\n  const opts = normalizeExecArgs(command\x2C options\x2C callback);\n  return module.exports.execFile(opts.file\x2C\n                                 opts.options\x2C\n                                 opts.callback);\n}\n\nconst customPromiseExecFunction = (orig) => {\n  return (...args) => {\n    const { promise\x2C resolve\x2C reject } = createDeferredPromise();\n\n    promise.child = orig(...args\x2C (err\x2C stdout\x2C stderr) => {\n      if (err !== null) {\n        err.stdout = stdout;\n        err.stderr = stderr;\n        reject(err);\n      } else {\n        resolve({ stdout\x2C stderr });\n      }\n    });\n\n    return promise;\n  };\n};\n\nObjectDefineProperty(exec\x2C promisify.custom\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  value: customPromiseExecFunction(exec)\n});\n\nfunction normalizeExecFileArgs(file\x2C args\x2C options\x2C callback) {\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args != null && typeof args === 'object') {\n    callback = options;\n    options = args;\n    args = null;\n  } else if (typeof args === 'function') {\n    callback = args;\n    options = null;\n    args = null;\n  }\n\n  if (args == null) {\n    args = [];\n  }\n\n  if (typeof options === 'function') {\n    callback = options;\n  } else if (options != null) {\n    validateObject(options\x2C 'options');\n  }\n\n  if (options == null) {\n    options = kEmptyObject;\n  }\n\n  if (callback != null) {\n    validateFunction(callback\x2C 'callback');\n  }\n\n  // Validate argv0\x2C if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0\x2C 'options.argv0');\n  }\n\n  return { file\x2C args\x2C options\x2C callback };\n}\n\n/**\n * Spawns the specified file as a shell.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string\x2C string>;\n *   encoding?: string;\n *   timeout?: number;\n *   maxBuffer?: number;\n *   killSignal?: string | number;\n *   uid?: number;\n *   gid?: number;\n *   windowsHide?: boolean;\n *   windowsVerbatimArguments?: boolean;\n *   shell?: boolean | string;\n *   signal?: AbortSignal;\n *   }} [options]\n * @param {(\n *   error?: Error\x2C\n *   stdout?: string | Buffer\x2C\n *   stderr?: string | Buffer\n *   ) => any} [callback]\n * @returns {ChildProcess}\n */\nfunction execFile(file\x2C args\x2C options\x2C callback) {\n  ({ file\x2C args\x2C options\x2C callback } = normalizeExecFileArgs(file\x2C args\x2C options\x2C callback));\n\n  options = {\n    encoding: 'utf8'\x2C\n    timeout: 0\x2C\n    maxBuffer: MAX_BUFFER\x2C\n    killSignal: 'SIGTERM'\x2C\n    cwd: null\x2C\n    env: null\x2C\n    shell: false\x2C\n    ...options\n  };\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  const child = spawn(file\x2C args\x2C {\n    cwd: options.cwd\x2C\n    env: options.env\x2C\n    gid: options.gid\x2C\n    shell: options.shell\x2C\n    signal: options.signal\x2C\n    uid: options.uid\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\n  });\n\n  let encoding;\n  const _stdout = [];\n  const _stderr = [];\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\n    encoding = options.encoding;\n  } else {\n    encoding = null;\n  }\n  let stdoutLen = 0;\n  let stderrLen = 0;\n  let killed = false;\n  let exited = false;\n  let timeoutId;\n\n  let ex = null;\n\n  let cmd = file;\n\n  function exithandler(code\x2C signal) {\n    if (exited) return;\n    exited = true;\n\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n\n    if (!callback) return;\n\n    // merge chunks\n    let stdout;\n    let stderr;\n    if (encoding ||\n      (\n        child.stdout &&\n        child.stdout.readableEncoding\n      )) {\n      stdout = ArrayPrototypeJoin(_stdout\x2C '');\n    } else {\n      stdout = Buffer.concat(_stdout);\n    }\n    if (encoding ||\n      (\n        child.stderr &&\n        child.stderr.readableEncoding\n      )) {\n      stderr = ArrayPrototypeJoin(_stderr\x2C '');\n    } else {\n      stderr = Buffer.concat(_stderr);\n    }\n\n    if (!ex && code === 0 && signal === null) {\n      callback(null\x2C stdout\x2C stderr);\n      return;\n    }\n\n    if (args?.length)\n      cmd += ` ${ArrayPrototypeJoin(args\x2C ' ')}`;\n\n    if (!ex) {\n      ex = genericNodeError(`Command failed: ${cmd}\\n${stderr}`\x2C {\n        code: code < 0 ? getSystemErrorName(code) : code\x2C\n        killed: child.killed || killed\x2C\n        signal: signal\n      });\n    }\n\n    ex.cmd = cmd;\n    callback(ex\x2C stdout\x2C stderr);\n  }\n\n  function errorhandler(e) {\n    ex = e;\n\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    exithandler();\n  }\n\n  function kill() {\n    if (child.stdout)\n      child.stdout.destroy();\n\n    if (child.stderr)\n      child.stderr.destroy();\n\n    killed = true;\n    try {\n      child.kill(options.killSignal);\n    } catch (e) {\n      ex = e;\n      exithandler();\n    }\n  }\n\n  if (options.timeout > 0) {\n    timeoutId = setTimeout(function delayedKill() {\n      kill();\n      timeoutId = null;\n    }\x2C options.timeout);\n  }\n\n  if (child.stdout) {\n    if (encoding)\n      child.stdout.setEncoding(encoding);\n\n    child.stdout.on('data'\x2C function onChildStdout(chunk) {\n      // Do not need to count the length\n      if (options.maxBuffer === Infinity) {\n        ArrayPrototypePush(_stdout\x2C chunk);\n        return;\n      }\n      const encoding = child.stdout.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      const slice = encoding ? StringPrototypeSlice :\n        (buf\x2C ...args) => buf.slice(...args);\n      stdoutLen += length;\n\n      if (stdoutLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\n        ArrayPrototypePush(_stdout\x2C slice(chunk\x2C 0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout');\n        kill();\n      } else {\n        ArrayPrototypePush(_stdout\x2C chunk);\n      }\n    });\n  }\n\n  if (child.stderr) {\n    if (encoding)\n      child.stderr.setEncoding(encoding);\n\n    child.stderr.on('data'\x2C function onChildStderr(chunk) {\n      // Do not need to count the length\n      if (options.maxBuffer === Infinity) {\n        ArrayPrototypePush(_stderr\x2C chunk);\n        return;\n      }\n      const encoding = child.stderr.readableEncoding;\n      const length = encoding ?\n        Buffer.byteLength(chunk\x2C encoding) :\n        chunk.length;\n      stderrLen += length;\n\n      if (stderrLen > options.maxBuffer) {\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\n        ArrayPrototypePush(_stderr\x2C\n                           chunk.slice(0\x2C truncatedLen));\n\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr');\n        kill();\n      } else {\n        ArrayPrototypePush(_stderr\x2C chunk);\n      }\n    });\n  }\n\n  child.addListener('close'\x2C exithandler);\n  child.addListener('error'\x2C errorhandler);\n\n  return child;\n}\n\nObjectDefineProperty(execFile\x2C promisify.custom\x2C {\n  __proto__: null\x2C\n  enumerable: false\x2C\n  value: customPromiseExecFunction(execFile)\n});\n\nfunction normalizeSpawnArguments(file\x2C args\x2C options) {\n  validateString(file\x2C 'file');\n\n  if (file.length === 0)\n    throw new ERR_INVALID_ARG_VALUE('file'\x2C file\x2C 'cannot be empty');\n\n  if (ArrayIsArray(args)) {\n    args = ArrayPrototypeSlice(args);\n  } else if (args == null) {\n    args = [];\n  } else if (typeof args !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('args'\x2C 'object'\x2C args);\n  } else {\n    options = args;\n    args = [];\n  }\n\n  if (options === undefined)\n    options = kEmptyObject;\n  else\n    validateObject(options\x2C 'options');\n\n  let cwd = options.cwd;\n\n  // Validate the cwd\x2C if present.\n  if (cwd != null) {\n    cwd = getValidatedPath(cwd\x2C 'options.cwd');\n  }\n\n  // Validate detached\x2C if present.\n  if (options.detached != null) {\n    validateBoolean(options.detached\x2C 'options.detached');\n  }\n\n  // Validate the uid\x2C if present.\n  if (options.uid != null && !isInt32(options.uid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.uid'\x2C 'int32'\x2C options.uid);\n  }\n\n  // Validate the gid\x2C if present.\n  if (options.gid != null && !isInt32(options.gid)) {\n    throw new ERR_INVALID_ARG_TYPE('options.gid'\x2C 'int32'\x2C options.gid);\n  }\n\n  // Validate the shell\x2C if present.\n  if (options.shell != null &&\n      typeof options.shell !== 'boolean' &&\n      typeof options.shell !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE('options.shell'\x2C\n                                   ['boolean'\x2C 'string']\x2C options.shell);\n  }\n\n  // Validate argv0\x2C if present.\n  if (options.argv0 != null) {\n    validateString(options.argv0\x2C 'options.argv0');\n  }\n\n  // Validate windowsHide\x2C if present.\n  if (options.windowsHide != null) {\n    validateBoolean(options.windowsHide\x2C 'options.windowsHide');\n  }\n\n  // Validate windowsVerbatimArguments\x2C if present.\n  let { windowsVerbatimArguments } = options;\n  if (windowsVerbatimArguments != null) {\n    validateBoolean(windowsVerbatimArguments\x2C\n                    'options.windowsVerbatimArguments');\n  }\n\n  if (options.shell) {\n    const command = ArrayPrototypeJoin([file\x2C ...args]\x2C ' ');\n    // Set the shell\x2C switches\x2C and commands.\n    if (process.platform === 'win32') {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else\n        file = process.env.comspec || 'cmd.exe';\n      // '/d /s /c' is used only for cmd.exe.\n      if (RegExpPrototypeExec(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i\x2C file) !== null) {\n        args = ['/d'\x2C '/s'\x2C '/c'\x2C `"${command}"`];\n        windowsVerbatimArguments = true;\n      } else {\n        args = ['-c'\x2C command];\n      }\n    } else {\n      if (typeof options.shell === 'string')\n        file = options.shell;\n      else if (process.platform === 'android')\n        file = '/system/bin/sh';\n      else\n        file = '/bin/sh';\n      args = ['-c'\x2C command];\n    }\n  }\n\n  if (typeof options.argv0 === 'string') {\n    ArrayPrototypeUnshift(args\x2C options.argv0);\n  } else {\n    ArrayPrototypeUnshift(args\x2C file);\n  }\n\n  const env = options.env || process.env;\n  const envPairs = [];\n\n  // process.env.NODE_V8_COVERAGE always propagates\x2C making it possible to\n  // collect coverage for programs that spawn with white-listed environment.\n  if (process.env.NODE_V8_COVERAGE &&\n      !ObjectPrototypeHasOwnProperty(options.env || {}\x2C 'NODE_V8_COVERAGE')) {\n    env.NODE_V8_COVERAGE = process.env.NODE_V8_COVERAGE;\n  }\n\n  let envKeys = [];\n  // Prototype values are intentionally included.\n  for (const key in env) {\n    ArrayPrototypePush(envKeys\x2C key);\n  }\n\n  if (process.platform === 'win32') {\n    // On Windows env keys are case insensitive. Filter out duplicates\x2C\n    // keeping only the first one (in lexicographic order)\n    const sawKey = new SafeSet();\n    envKeys = ArrayPrototypeFilter(\n      ArrayPrototypeSort(envKeys)\x2C\n      (key) => {\n        const uppercaseKey = StringPrototypeToUpperCase(key);\n        if (sawKey.has(uppercaseKey)) {\n          return false;\n        }\n        sawKey.add(uppercaseKey);\n        return true;\n      }\n    );\n  }\n\n  for (const key of envKeys) {\n    const value = env[key];\n    if (value !== undefined) {\n      ArrayPrototypePush(envPairs\x2C `${key}=${value}`);\n    }\n  }\n\n  return {\n    // Make a shallow copy so we don't clobber the user's options object.\n    ...options\x2C\n    args\x2C\n    cwd\x2C\n    detached: !!options.detached\x2C\n    envPairs\x2C\n    file\x2C\n    windowsHide: !!options.windowsHide\x2C\n    windowsVerbatimArguments: !!windowsVerbatimArguments\x2C\n  };\n}\n\nfunction abortChildProcess(child\x2C killSignal) {\n  if (!child)\n    return;\n  try {\n    if (child.kill(killSignal)) {\n      child.emit('error'\x2C new AbortError());\n    }\n  } catch (err) {\n    child.emit('error'\x2C err);\n  }\n}\n\n/**\n * Spawns a new process using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   env?: Record<string\x2C string>;\n *   argv0?: string;\n *   stdio?: Array | string;\n *   detached?: boolean;\n *   uid?: number;\n *   gid?: number;\n *   serialization?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   signal?: AbortSignal;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   }} [options]\n * @returns {ChildProcess}\n */\nfunction spawn(file\x2C args\x2C options) {\n  options = normalizeSpawnArguments(file\x2C args\x2C options);\n  validateTimeout(options.timeout);\n  validateAbortSignal(options.signal\x2C 'options.signal');\n  const killSignal = sanitizeKillSignal(options.killSignal);\n  const child = new ChildProcess();\n\n  debug('spawn'\x2C options);\n  child.spawn(options);\n\n  if (options.timeout > 0) {\n    let timeoutId = setTimeout(() => {\n      if (timeoutId) {\n        try {\n          child.kill(killSignal);\n        } catch (err) {\n          child.emit('error'\x2C err);\n        }\n        timeoutId = null;\n      }\n    }\x2C options.timeout);\n\n    child.once('exit'\x2C () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n    });\n  }\n\n  if (options.signal) {\n    const signal = options.signal;\n    if (signal.aborted) {\n      process.nextTick(onAbortListener);\n    } else {\n      signal.addEventListener('abort'\x2C onAbortListener\x2C { once: true });\n      child.once('exit'\x2C\n                 () => signal.removeEventListener('abort'\x2C onAbortListener));\n    }\n\n    function onAbortListener() {\n      abortChildProcess(child\x2C killSignal);\n    }\n  }\n\n  return child;\n}\n\n/**\n * Spawns a new process synchronously using the given `file`.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   argv0?: string;\n *   stdio?: string | Array;\n *   env?: Record<string\x2C string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   shell?: boolean | string;\n *   windowsVerbatimArguments?: boolean;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {{\n *   pid: number;\n *   output: Array;\n *   stdout: Buffer | string;\n *   stderr: Buffer | string;\n *   status: number | null;\n *   signal: string | null;\n *   error: Error;\n *   }}\n */\nfunction spawnSync(file\x2C args\x2C options) {\n  options = {\n    maxBuffer: MAX_BUFFER\x2C\n    ...normalizeSpawnArguments(file\x2C args\x2C options)\n  };\n\n  debug('spawnSync'\x2C options);\n\n  // Validate the timeout\x2C if present.\n  validateTimeout(options.timeout);\n\n  // Validate maxBuffer\x2C if present.\n  validateMaxBuffer(options.maxBuffer);\n\n  // Validate and translate the kill signal\x2C if present.\n  options.killSignal = sanitizeKillSignal(options.killSignal);\n\n  options.stdio = getValidStdio(options.stdio || 'pipe'\x2C true).stdio;\n\n  if (options.input) {\n    const stdin = options.stdio[0] = { ...options.stdio[0] };\n    stdin.input = options.input;\n  }\n\n  // We may want to pass data in on any given fd\x2C ensure it is a valid buffer\n  for (let i = 0; i < options.stdio.length; i++) {\n    const input = options.stdio[i] && options.stdio[i].input;\n    if (input != null) {\n      const pipe = options.stdio[i] = { ...options.stdio[i] };\n      if (isArrayBufferView(input)) {\n        pipe.input = input;\n      } else if (typeof input === 'string') {\n        pipe.input = Buffer.from(input\x2C options.encoding);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`\x2C\n                                       ['Buffer'\x2C\n                                        'TypedArray'\x2C\n                                        'DataView'\x2C\n                                        'string']\x2C\n                                       input);\n      }\n    }\n  }\n\n  return child_process.spawnSync(options);\n}\n\n\nfunction checkExecSyncError(ret\x2C args\x2C cmd) {\n  let err;\n  if (ret.error) {\n    err = ret.error;\n    ObjectAssign(err\x2C ret);\n  } else if (ret.status !== 0) {\n    let msg = 'Command failed: ';\n    msg += cmd || ArrayPrototypeJoin(args\x2C ' ');\n    if (ret.stderr && ret.stderr.length > 0)\n      msg += `\\n${ret.stderr.toString()}`;\n    err = genericNodeError(msg\x2C ret);\n  }\n  return err;\n}\n\n/**\n * Spawns a file as a shell synchronously.\n * @param {string} file\n * @param {string[]} [args]\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string\x2C string>;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   shell?: boolean | string;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execFileSync(file\x2C args\x2C options) {\n  ({ file\x2C args\x2C options } = normalizeExecFileArgs(file\x2C args\x2C options));\n\n  const inheritStderr = !options.stdio;\n  const ret = spawnSync(file\x2C args\x2C options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const errArgs = [options.argv0 || file];\n  ArrayPrototypePushApply(errArgs\x2C args);\n  const err = checkExecSyncError(ret\x2C errArgs);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n/**\n * Spawns a shell executing the given `command` synchronously.\n * @param {string} command\n * @param {{\n *   cwd?: string;\n *   input?: string | Buffer | TypedArray | DataView;\n *   stdio?: string | Array;\n *   env?: Record<string\x2C string>;\n *   shell?: string;\n *   uid?: number;\n *   gid?: number;\n *   timeout?: number;\n *   killSignal?: string | number;\n *   maxBuffer?: number;\n *   encoding?: string;\n *   windowsHide?: boolean;\n *   }} [options]\n * @returns {Buffer | string}\n */\nfunction execSync(command\x2C options) {\n  const opts = normalizeExecArgs(command\x2C options\x2C null);\n  const inheritStderr = !opts.options.stdio;\n\n  const ret = spawnSync(opts.file\x2C opts.options);\n\n  if (inheritStderr && ret.stderr)\n    process.stderr.write(ret.stderr);\n\n  const err = checkExecSyncError(ret\x2C opts.args\x2C command);\n\n  if (err)\n    throw err;\n\n  return ret.stdout;\n}\n\n\nfunction validateTimeout(timeout) {\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\n    throw new ERR_OUT_OF_RANGE('timeout'\x2C 'an unsigned integer'\x2C timeout);\n  }\n}\n\n\nfunction validateMaxBuffer(maxBuffer) {\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\n    throw new ERR_OUT_OF_RANGE('options.maxBuffer'\x2C\n                               'a positive number'\x2C\n                               maxBuffer);\n  }\n}\n\n\nfunction sanitizeKillSignal(killSignal) {\n  if (typeof killSignal === 'string' || typeof killSignal === 'number') {\n    return convertToValidSignal(killSignal);\n  } else if (killSignal != null) {\n    throw new ERR_INVALID_ARG_TYPE('options.killSignal'\x2C\n                                   ['string'\x2C 'number']\x2C\n                                   killSignal);\n  }\n}\n\nmodule.exports = {\n  _forkChild\x2C\n  ChildProcess\x2C\n  exec\x2C\n  execFile\x2C\n  execFileSync\x2C\n  execSync\x2C\n  fork\x2C\n  spawn\x2C\n  spawnSync\n};\n
code-source-info,0xb46b9696148,423,0,25161,C0O0C4O25161,,
code-creation,Function,10,180950,0xb46b9696c20,790, node:child_process:1:1,0xb46b96960c0,~
code-source-info,0xb46b9696c20,423,0,25161,C0O0C253O1159C259O1175C265O1199C271O1225C277O1247C283O1276C289O1298C295O1321C301O1343C307O1367C313O1392C319O1419C325O1438C331O1454C336O1478C342O1511C348O1534C354O1545C360O1569C366O1727C369O1727C374O1625C380O1649C386O1674C392O1696C398O1712C403O1783C406O1783C411O1761C417O1827C420O1827C425O1860C438O1861C444O1827C446O1944C449O1944C454O1933C460O2006C463O2006C468O1971C474O1988C480O2104C483O2104C488O2047C494O2068C499O2082C505O2142C511O2167C517O2201C523O2238C529O2262C535O2333C538O2333C543O2304C549O2318C555O2381C558O2381C563O2360C569O2549C572O2549C577O2421C583O2432C589O2455C595O2472C601O2491C607O2511C613O2529C619O2603C622O2603C626O2603C628O2720C631O2648C637O2665C643O2681C649O2697C655O2755C661O2755C663O6563C668O6967C678O7026C689O6930C694O13288C704O13347C715O13247C720O25032C730O25053C736O25067C742O25083C748O25091C754O25103C760O25119C766O25131C772O25139C778O25148C784O25047C789O25160,,
tick,0x7ff805edeb48,181059,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805db1607,181074,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805f105d0,181088,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,181604,0xb46b969a878,5, node:internal/child_process:1:1,0xb46b9699bc0,~
script-source,424,node:internal/child_process,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeReduce\x2C\n  ArrayPrototypeSlice\x2C\n  FunctionPrototype\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  errnoException\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_HANDLE_TYPE\x2C\n    ERR_INVALID_SYNC_FORK_INPUT\x2C\n    ERR_IPC_CHANNEL_CLOSED\x2C\n    ERR_IPC_DISCONNECTED\x2C\n    ERR_IPC_ONE_PIPE\x2C\n    ERR_IPC_SYNC_FORK\x2C\n    ERR_MISSING_ARGS\n  }\n} = require('internal/errors');\nconst {\n  validateArray\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\nconst EventEmitter = require('events');\nconst net = require('net');\nconst dgram = require('dgram');\nconst inspect = require('internal/util/inspect').inspect;\nconst assert = require('internal/assert');\n\nconst { Process } = internalBinding('process_wrap');\nconst {\n  WriteWrap\x2C\n  kReadBytesOrError\x2C\n  kArrayBufferOffset\x2C\n  kLastWriteWasAsync\x2C\n  streamBaseState\n} = internalBinding('stream_wrap');\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\nconst { TCP } = internalBinding('tcp_wrap');\nconst { TTY } = internalBinding('tty_wrap');\nconst { UDP } = internalBinding('udp_wrap');\nconst SocketList = require('internal/socket_list');\nconst { owner_symbol } = require('internal/async_hooks').symbols;\nconst { convertToValidSignal\x2C deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst spawn_sync = internalBinding('spawn_sync');\nconst { kStateSymbol } = require('internal/dgram');\n\nconst {\n  UV_EACCES\x2C\n  UV_EAGAIN\x2C\n  UV_EINVAL\x2C\n  UV_EMFILE\x2C\n  UV_ENFILE\x2C\n  UV_ENOENT\x2C\n  UV_ENOSYS\x2C\n  UV_ESRCH\n} = internalBinding('uv');\n\nconst { SocketListSend\x2C SocketListReceive } = SocketList;\n\n// Lazy loaded for startup performance and to allow monkey patching of\n// internalBinding('http_parser').HTTPParser.\nlet freeParser;\nlet HTTPParser;\n\nconst MAX_HANDLE_RETRANSMISSIONS = 3;\nconst kChannelHandle = Symbol('kChannelHandle');\nconst kIsUsedAsStdio = Symbol('kIsUsedAsStdio');\nconst kPendingMessages = Symbol('kPendingMessages');\n\n// This object contain function to convert TCP objects to native handle objects\n// and back again.\nconst handleConversion = {\n  'net.Native': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'net.Server': {\n    simultaneousAccepts: true\x2C\n\n    send(message\x2C server\x2C options) {\n      return server._handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const server = new net.Server();\n      server.listen(handle\x2C () => {\n        emit(server);\n      });\n    }\n  }\x2C\n\n  'net.Socket': {\n    send(message\x2C socket\x2C options) {\n      if (!socket._handle)\n        return;\n\n      // If the socket was created by net.Server\n      if (socket.server) {\n        // The worker should keep track of the socket\n        message.key = socket.server._connectionKey;\n\n        const firstTime = !this[kChannelHandle].sockets.send[message.key];\n        const socketList = getSocketList('send'\x2C this\x2C message.key);\n\n        // The server should no longer expose a .connection property\n        // and when asked to close it should query the socket status from\n        // the workers\n        if (firstTime) socket.server._setupWorker(socketList);\n\n        // Act like socket is detached\n        if (!options.keepOpen)\n          socket.server._connections--;\n      }\n\n      const handle = socket._handle;\n\n      // Remove handle from socket object\x2C it will be closed when the socket\n      // will be sent\n      if (!options.keepOpen) {\n        handle.onread = nop;\n        socket._handle = null;\n        socket.setTimeout(0);\n\n        if (freeParser === undefined)\n          freeParser = require('_http_common').freeParser;\n        if (HTTPParser === undefined)\n          HTTPParser = require('_http_common').HTTPParser;\n\n        // In case of an HTTP connection socket\x2C release the associated\n        // resources\n        if (socket.parser && socket.parser instanceof HTTPParser) {\n          freeParser(socket.parser\x2C null\x2C socket);\n          if (socket._httpMessage)\n            socket._httpMessage.detachSocket(socket);\n        }\n      }\n\n      return handle;\n    }\x2C\n\n    postSend(message\x2C handle\x2C options\x2C callback\x2C target) {\n      // Store the handle after successfully sending it\x2C so it can be closed\n      // when the NODE_HANDLE_ACK is received. If the handle could not be sent\x2C\n      // just close it.\n      if (handle && !options.keepOpen) {\n        if (target) {\n          // There can only be one _pendingMessage as passing handles are\n          // processed one at a time: handles are stored in _handleQueue while\n          // waiting for the NODE_HANDLE_ACK of the current passing handle.\n          assert(!target._pendingMessage);\n          target._pendingMessage =\n              { callback\x2C message\x2C handle\x2C options\x2C retransmissions: 0 };\n        } else {\n          handle.close();\n        }\n      }\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new net.Socket({\n        handle: handle\x2C\n        readable: true\x2C\n        writable: true\n      });\n\n      // If the socket was created by net.Server we will track the socket\n      if (message.key) {\n\n        // Add socket to connections list\n        const socketList = getSocketList('got'\x2C this\x2C message.key);\n        socketList.add({\n          socket: socket\n        });\n      }\n\n      emit(socket);\n    }\n  }\x2C\n\n  'dgram.Native': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C handle\x2C options) {\n      return handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      emit(handle);\n    }\n  }\x2C\n\n  'dgram.Socket': {\n    simultaneousAccepts: false\x2C\n\n    send(message\x2C socket\x2C options) {\n      message.dgramType = socket.type;\n\n      return socket[kStateSymbol].handle;\n    }\x2C\n\n    got(message\x2C handle\x2C emit) {\n      const socket = new dgram.Socket(message.dgramType);\n\n      socket.bind(handle\x2C () => {\n        emit(socket);\n      });\n    }\n  }\n};\n\nfunction stdioStringToArray(stdio\x2C channel) {\n  const options = [];\n\n  switch (stdio) {\n    case 'ignore':\n    case 'overlapped':\n    case 'pipe': ArrayPrototypePush(options\x2C stdio\x2C stdio\x2C stdio); break;\n    case 'inherit': ArrayPrototypePush(options\x2C 0\x2C 1\x2C 2); break;\n    default:\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  if (channel) ArrayPrototypePush(options\x2C channel);\n\n  return options;\n}\n\nfunction ChildProcess() {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this._closesNeeded = 1;\n  this._closesGot = 0;\n  this.connected = false;\n\n  this.signalCode = null;\n  this.exitCode = null;\n  this.killed = false;\n  this.spawnfile = null;\n\n  this._handle = new Process();\n  this._handle[owner_symbol] = this;\n\n  this._handle.onexit = (exitCode\x2C signalCode) => {\n    if (signalCode) {\n      this.signalCode = signalCode;\n    } else {\n      this.exitCode = exitCode;\n    }\n\n    if (this.stdin) {\n      this.stdin.destroy();\n    }\n\n    this._handle.close();\n    this._handle = null;\n\n    if (exitCode < 0) {\n      const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';\n      const err = errnoException(exitCode\x2C syscall);\n\n      if (this.spawnfile)\n        err.path = this.spawnfile;\n\n      err.spawnargs = ArrayPrototypeSlice(this.spawnargs\x2C 1);\n      this.emit('error'\x2C err);\n    } else {\n      this.emit('exit'\x2C this.exitCode\x2C this.signalCode);\n    }\n\n    // If any of the stdio streams have not been touched\x2C\n    // then pull all the data through so that it can get the\n    // eof and emit a 'close' event.\n    // Do it on nextTick so that the user has one last chance\n    // to consume the output\x2C if for example they only want to\n    // start reading the data once the process exits.\n    process.nextTick(flushStdio\x2C this);\n\n    maybeClose(this);\n  };\n}\nObjectSetPrototypeOf(ChildProcess.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(ChildProcess\x2C EventEmitter);\n\n\nfunction flushStdio(subprocess) {\n  const stdio = subprocess.stdio;\n\n  if (stdio == null) return;\n\n  for (let i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\n    // which data can be read from a stream\x2C e.g. being consumed on the\n    // native layer directly as a StreamBase.\n    if (!stream || !stream.readable || stream[kIsUsedAsStdio]) {\n      continue;\n    }\n    stream.resume();\n  }\n}\n\n\nfunction createSocket(pipe\x2C readable) {\n  return net.Socket({ handle: pipe\x2C readable });\n}\n\n\nfunction getHandleWrapType(stream) {\n  if (stream instanceof Pipe) return 'pipe';\n  if (stream instanceof TTY) return 'tty';\n  if (stream instanceof TCP) return 'tcp';\n  if (stream instanceof UDP) return 'udp';\n\n  return false;\n}\n\nfunction closePendingHandle(target) {\n  target._pendingMessage.handle.close();\n  target._pendingMessage = null;\n}\n\n\nChildProcess.prototype.spawn = function(options) {\n  let i = 0;\n\n  validateObject(options\x2C 'options');\n\n  // If no `stdio` option was given - use default\n  let stdio = options.stdio || 'pipe';\n\n  stdio = getValidStdio(stdio\x2C false);\n\n  const ipc = stdio.ipc;\n  const ipcFd = stdio.ipcFd;\n  stdio = options.stdio = stdio.stdio;\n\n\n  validateOneOf(options.serialization\x2C 'options.serialization'\x2C\n                [undefined\x2C 'json'\x2C 'advanced']);\n  const serialization = options.serialization || 'json';\n\n  if (ipc !== undefined) {\n    // Let child process know about opened IPC channel\n    if (options.envPairs === undefined)\n      options.envPairs = [];\n    else\n      validateArray(options.envPairs\x2C 'options.envPairs');\n\n    ArrayPrototypePush(options.envPairs\x2C `NODE_CHANNEL_FD=${ipcFd}`);\n    ArrayPrototypePush(options.envPairs\x2C\n                       `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`);\n  }\n\n  validateString(options.file\x2C 'options.file');\n  this.spawnfile = options.file;\n\n  if (options.args === undefined) {\n    this.spawnargs = [];\n  } else {\n    validateArray(options.args\x2C 'options.args');\n    this.spawnargs = options.args;\n  }\n\n  const err = this._handle.spawn(options);\n\n  // Run-time errors should emit an error\x2C not throw an exception.\n  if (err === UV_EACCES ||\n      err === UV_EAGAIN ||\n      err === UV_EMFILE ||\n      err === UV_ENFILE ||\n      err === UV_ENOENT) {\n    process.nextTick(onErrorNT\x2C this\x2C err);\n\n    // There is no point in continuing when we've hit EMFILE or ENFILE\n    // because we won't be able to set up the stdio file descriptors.\n    if (err === UV_EMFILE || err === UV_ENFILE)\n      return err;\n  } else if (err) {\n    // Close all opened fds on error\n    for (i = 0; i < stdio.length; i++) {\n      const stream = stdio[i];\n      if (stream.type === 'pipe') {\n        stream.handle.close();\n      }\n    }\n\n    this._handle.close();\n    this._handle = null;\n    throw errnoException(err\x2C 'spawn');\n  } else {\n    process.nextTick(onSpawnNT\x2C this);\n  }\n\n  this.pid = this._handle.pid;\n\n  for (i = 0; i < stdio.length; i++) {\n    const stream = stdio[i];\n    if (stream.type === 'ignore') continue;\n\n    if (stream.ipc) {\n      this._closesNeeded++;\n      continue;\n    }\n\n    // The stream is already cloned and piped\x2C thus stop its readable side\x2C\n    // otherwise we might attempt to read from the stream when at the same time\n    // the child process does.\n    if (stream.type === 'wrap') {\n      stream.handle.reading = false;\n      stream.handle.readStop();\n      stream._stdio.pause();\n      stream._stdio.readableFlowing = false;\n      stream._stdio._readableState.reading = false;\n      stream._stdio[kIsUsedAsStdio] = true;\n      continue;\n    }\n\n    if (stream.handle) {\n      stream.socket = createSocket(this.pid !== 0 ?\n        stream.handle : null\x2C i > 0);\n\n      if (i > 0 && this.pid !== 0) {\n        this._closesNeeded++;\n        stream.socket.on('close'\x2C () => {\n          maybeClose(this);\n        });\n      }\n    }\n  }\n\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\n    stdio[0].socket : null;\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\n    stdio[1].socket : null;\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\n    stdio[2].socket : null;\n\n  this.stdio = [];\n\n  for (i = 0; i < stdio.length; i++)\n    ArrayPrototypePush(this.stdio\x2C\n                       stdio[i].socket === undefined ? null : stdio[i].socket);\n\n  // Add .send() method and start listening for IPC data\n  if (ipc !== undefined) setupChannel(this\x2C ipc\x2C serialization);\n\n  return err;\n};\n\n\nfunction onErrorNT(self\x2C err) {\n  self._handle.onexit(err);\n}\n\n\nfunction onSpawnNT(self) {\n  self.emit('spawn');\n}\n\n\nChildProcess.prototype.kill = function(sig) {\n\n  const signal = sig === 0 ? sig :\n    convertToValidSignal(sig === undefined ? 'SIGTERM' : sig);\n\n  if (this._handle) {\n    const err = this._handle.kill(signal);\n    if (err === 0) {\n      /* Success. */\n      this.killed = true;\n      return true;\n    }\n    if (err === UV_ESRCH) {\n      /* Already dead. */\n    } else if (err === UV_EINVAL || err === UV_ENOSYS) {\n      /* The underlying platform doesn't support this signal. */\n      throw errnoException(err\x2C 'kill');\n    } else {\n      /* Other error\x2C almost certainly EPERM. */\n      this.emit('error'\x2C errnoException(err\x2C 'kill'));\n    }\n  }\n\n  /* Kill didn't succeed. */\n  return false;\n};\n\n\nChildProcess.prototype.ref = function() {\n  if (this._handle) this._handle.ref();\n};\n\n\nChildProcess.prototype.unref = function() {\n  if (this._handle) this._handle.unref();\n};\n\nclass Control extends EventEmitter {\n  #channel = null;\n  #refs = 0;\n  #refExplicitlySet = false;\n\n  constructor(channel) {\n    super();\n    this.#channel = channel;\n    this[kPendingMessages] = [];\n  }\n\n  // The methods keeping track of the counter are being used to track the\n  // listener count on the child process object as well as when writes are\n  // in progress. Once the user has explicitly requested a certain state\x2C these\n  // methods become no-ops in order to not interfere with the user's intentions.\n  refCounted() {\n    if (++this.#refs === 1 && !this.#refExplicitlySet) {\n      this.#channel.ref();\n    }\n  }\n\n  unrefCounted() {\n    if (--this.#refs === 0 && !this.#refExplicitlySet) {\n      this.#channel.unref();\n      this.emit('unref');\n    }\n  }\n\n  ref() {\n    this.#refExplicitlySet = true;\n    this.#channel.ref();\n  }\n\n  unref() {\n    this.#refExplicitlySet = true;\n    this.#channel.unref();\n  }\n\n  get fd() {\n    return this.#channel ? this.#channel.fd : undefined;\n  }\n}\n\nconst channelDeprecationMsg = '_channel is deprecated. ' +\n                              'Use ChildProcess.channel instead.';\n\nlet serialization;\nfunction setupChannel(target\x2C channel\x2C serializationMode) {\n  const control = new Control(channel);\n  target.channel = control;\n  target[kChannelHandle] = channel;\n\n  ObjectDefineProperty(target\x2C '_channel'\x2C {\n    __proto__: null\x2C\n    get: deprecate(() => {\n      return target.channel;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    set: deprecate((val) => {\n      target.channel = val;\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n\n  target._handleQueue = null;\n  target._pendingMessage = null;\n\n  if (serialization === undefined)\n    serialization = require('internal/child_process/serialization');\n  const {\n    initMessageChannel\x2C\n    parseChannelMessages\x2C\n    writeChannelMessage\n  } = serialization[serializationMode];\n\n  let pendingHandle = null;\n  initMessageChannel(channel);\n  channel.pendingHandle = null;\n  channel.onread = function(arrayBuffer) {\n    const recvHandle = channel.pendingHandle;\n    channel.pendingHandle = null;\n    if (arrayBuffer) {\n      const nread = streamBaseState[kReadBytesOrError];\n      const offset = streamBaseState[kArrayBufferOffset];\n      const pool = new Uint8Array(arrayBuffer\x2C offset\x2C nread);\n      if (recvHandle)\n        pendingHandle = recvHandle;\n\n      for (const message of parseChannelMessages(channel\x2C pool)) {\n        // There will be at most one NODE_HANDLE message in every chunk we\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\n        // that we deliver the handle with the right message however.\n        if (isInternal(message)) {\n          if (message.cmd === 'NODE_HANDLE') {\n            handleMessage(message\x2C pendingHandle\x2C true);\n            pendingHandle = null;\n          } else {\n            handleMessage(message\x2C undefined\x2C true);\n          }\n        } else {\n          handleMessage(message\x2C undefined\x2C false);\n        }\n      }\n    } else {\n      this.buffering = false;\n      target.disconnect();\n      channel.onread = nop;\n      channel.close();\n      target.channel = null;\n      maybeClose(target);\n    }\n  };\n\n  // Object where socket lists will live\n  channel.sockets = { got: {}\x2C send: {} };\n\n  // Handlers will go through this\n  target.on('internalMessage'\x2C function(message\x2C handle) {\n    // Once acknowledged - continue sending handles.\n    if (message.cmd === 'NODE_HANDLE_ACK' ||\n        message.cmd === 'NODE_HANDLE_NACK') {\n\n      if (target._pendingMessage) {\n        if (message.cmd === 'NODE_HANDLE_ACK') {\n          closePendingHandle(target);\n        } else if (target._pendingMessage.retransmissions++ ===\n                   MAX_HANDLE_RETRANSMISSIONS) {\n          closePendingHandle(target);\n          process.emitWarning('Handle did not reach the receiving process ' +\n                              'correctly'\x2C 'SentHandleNotReceivedWarning');\n        }\n      }\n\n      assert(ArrayIsArray(target._handleQueue));\n      const queue = target._handleQueue;\n      target._handleQueue = null;\n\n      if (target._pendingMessage) {\n        target._send(target._pendingMessage.message\x2C\n                     target._pendingMessage.handle\x2C\n                     target._pendingMessage.options\x2C\n                     target._pendingMessage.callback);\n      }\n\n      for (let i = 0; i < queue.length; i++) {\n        const args = queue[i];\n        target._send(args.message\x2C args.handle\x2C args.options\x2C args.callback);\n      }\n\n      // Process a pending disconnect (if any).\n      if (!target.connected && target.channel && !target._handleQueue)\n        target._disconnect();\n\n      return;\n    }\n\n    if (message.cmd !== 'NODE_HANDLE') return;\n\n    // It is possible that the handle is not received because of some error on\n    // ancillary data reception such as MSG_CTRUNC. In this case\x2C report the\n    // sender about it by sending a NODE_HANDLE_NACK message.\n    if (!handle)\n      return target._send({ cmd: 'NODE_HANDLE_NACK' }\x2C null\x2C true);\n\n    // Acknowledge handle receival. Don't emit error events (for example if\n    // the other side has disconnected) because this call to send() is not\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\n    // a message.\n    target._send({ cmd: 'NODE_HANDLE_ACK' }\x2C null\x2C true);\n\n    const obj = handleConversion[message.type];\n\n    // Update simultaneous accepts on Windows\n    if (process.platform === 'win32') {\n      handle.setSimultaneousAccepts(false);\n    }\n\n    // Convert handle object\n    obj.got.call(this\x2C message\x2C handle\x2C (handle) => {\n      handleMessage(message.msg\x2C handle\x2C isInternal(message.msg));\n    });\n  });\n\n  target.on('newListener'\x2C function() {\n\n    process.nextTick(() => {\n      if (!target.channel || !target.listenerCount('message'))\n        return;\n\n      const messages = target.channel[kPendingMessages];\n      const { length } = messages;\n      if (!length) return;\n\n      for (let i = 0; i < length; i++) {\n        ReflectApply(target.emit\x2C target\x2C messages[i]);\n      }\n\n      target.channel[kPendingMessages] = [];\n    });\n  });\n\n  target.send = function(message\x2C handle\x2C options\x2C callback) {\n    if (typeof handle === 'function') {\n      callback = handle;\n      handle = undefined;\n      options = undefined;\n    } else if (typeof options === 'function') {\n      callback = options;\n      options = undefined;\n    } else if (options !== undefined) {\n      validateObject(options\x2C 'options');\n    }\n\n    options = { swallowErrors: false\x2C ...options };\n\n    if (this.connected) {\n      return this._send(message\x2C handle\x2C options\x2C callback);\n    }\n    const ex = new ERR_IPC_CHANNEL_CLOSED();\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n    } else {\n      process.nextTick(() => this.emit('error'\x2C ex));\n    }\n    return false;\n  };\n\n  target._send = function(message\x2C handle\x2C options\x2C callback) {\n    assert(this.connected || this.channel);\n\n    if (message === undefined)\n      throw new ERR_MISSING_ARGS('message');\n\n    // Non-serializable messages should not reach the remote\n    // end point; as any failure in the stringification there\n    // will result in error message that is weakly consumable.\n    // So perform a final check on message prior to sending.\n    if (typeof message !== 'string' &&\n        typeof message !== 'object' &&\n        typeof message !== 'number' &&\n        typeof message !== 'boolean') {\n      throw new ERR_INVALID_ARG_TYPE(\n        'message'\x2C ['string'\x2C 'object'\x2C 'number'\x2C 'boolean']\x2C message);\n    }\n\n    // Support legacy function signature\n    if (typeof options === 'boolean') {\n      options = { swallowErrors: options };\n    }\n\n    let obj;\n\n    // Package messages with a handle object\n    if (handle) {\n      // This message will be handled by an internalMessage event handler\n      message = {\n        cmd: 'NODE_HANDLE'\x2C\n        type: null\x2C\n        msg: message\n      };\n\n      if (handle instanceof net.Socket) {\n        message.type = 'net.Socket';\n      } else if (handle instanceof net.Server) {\n        message.type = 'net.Server';\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\n        message.type = 'net.Native';\n      } else if (handle instanceof dgram.Socket) {\n        message.type = 'dgram.Socket';\n      } else if (handle instanceof UDP) {\n        message.type = 'dgram.Native';\n      } else {\n        throw new ERR_INVALID_HANDLE_TYPE();\n      }\n\n      // Queue-up message and handle if we haven't received ACK yet.\n      if (this._handleQueue) {\n        ArrayPrototypePush(this._handleQueue\x2C {\n          callback: callback\x2C\n          handle: handle\x2C\n          options: options\x2C\n          message: message.msg\x2C\n        });\n        return this._handleQueue.length === 1;\n      }\n\n      obj = handleConversion[message.type];\n\n      // convert TCP object to native handle object\n      handle = ReflectApply(handleConversion[message.type].send\x2C\n                            target\x2C [message\x2C handle\x2C options]);\n\n      // If handle was sent twice\x2C or it is impossible to get native handle\n      // out of it - just send a text without the handle.\n      if (!handle)\n        message = message.msg;\n\n      // Update simultaneous accepts on Windows\n      if (obj.simultaneousAccepts && process.platform === 'win32') {\n        handle.setSimultaneousAccepts(true);\n      }\n    } else if (this._handleQueue &&\n               !(message && (message.cmd === 'NODE_HANDLE_ACK' ||\n                             message.cmd === 'NODE_HANDLE_NACK'))) {\n      // Queue request anyway to avoid out-of-order messages.\n      ArrayPrototypePush(this._handleQueue\x2C {\n        callback: callback\x2C\n        handle: null\x2C\n        options: options\x2C\n        message: message\x2C\n      });\n      return this._handleQueue.length === 1;\n    }\n\n    const req = new WriteWrap();\n\n    const err = writeChannelMessage(channel\x2C req\x2C message\x2C handle);\n    const wasAsyncWrite = streamBaseState[kLastWriteWasAsync];\n\n    if (err === 0) {\n      if (handle) {\n        if (!this._handleQueue)\n          this._handleQueue = [];\n        if (obj && obj.postSend)\n          obj.postSend(message\x2C handle\x2C options\x2C callback\x2C target);\n      }\n\n      if (wasAsyncWrite) {\n        req.oncomplete = () => {\n          control.unrefCounted();\n          if (typeof callback === 'function')\n            callback(null);\n        };\n        control.refCounted();\n      } else if (typeof callback === 'function') {\n        process.nextTick(callback\x2C null);\n      }\n    } else {\n      // Cleanup handle on error\n      if (obj && obj.postSend)\n        obj.postSend(message\x2C handle\x2C options\x2C callback);\n\n      if (!options.swallowErrors) {\n        const ex = errnoException(err\x2C 'write');\n        if (typeof callback === 'function') {\n          process.nextTick(callback\x2C ex);\n        } else {\n          process.nextTick(() => this.emit('error'\x2C ex));\n        }\n      }\n    }\n\n    /* If the primary is > 2 read() calls behind\x2C please stop sending. */\n    return channel.writeQueueSize < (65536 * 2);\n  };\n\n  // Connected will be set to false immediately when a disconnect() is\n  // requested\x2C even though the channel might still be alive internally to\n  // process queued messages. The three states are distinguished as follows:\n  // - disconnect() never requested: channel is not null and connected\n  //   is true\n  // - disconnect() requested\x2C messages in the queue: channel is not null\n  //   and connected is false\n  // - disconnect() requested\x2C channel actually disconnected: channel is\n  //   null and connected is false\n  target.connected = true;\n\n  target.disconnect = function() {\n    if (!this.connected) {\n      this.emit('error'\x2C new ERR_IPC_DISCONNECTED());\n      return;\n    }\n\n    // Do not allow any new messages to be written.\n    this.connected = false;\n\n    // If there are no queued messages\x2C disconnect immediately. Otherwise\x2C\n    // postpone the disconnect so that it happens internally after the\n    // queue is flushed.\n    if (!this._handleQueue)\n      this._disconnect();\n  };\n\n  target._disconnect = function() {\n    assert(this.channel);\n\n    // This marks the fact that the channel is actually disconnected.\n    this.channel = null;\n    this[kChannelHandle] = null;\n\n    if (this._pendingMessage)\n      closePendingHandle(this);\n\n    let fired = false;\n    function finish() {\n      if (fired) return;\n      fired = true;\n\n      channel.close();\n      target.emit('disconnect');\n    }\n\n    // If a message is being read\x2C then wait for it to complete.\n    if (channel.buffering) {\n      this.once('message'\x2C finish);\n      this.once('internalMessage'\x2C finish);\n\n      return;\n    }\n\n    process.nextTick(finish);\n  };\n\n  function emit(event\x2C message\x2C handle) {\n    if ('internalMessage' === event || target.listenerCount('message')) {\n      target.emit(event\x2C message\x2C handle);\n      return;\n    }\n\n    ArrayPrototypePush(\n      target.channel[kPendingMessages]\x2C\n      [event\x2C message\x2C handle]\n    );\n  }\n\n  function handleMessage(message\x2C handle\x2C internal) {\n    if (!target.channel)\n      return;\n\n    const eventName = (internal ? 'internalMessage' : 'message');\n\n    process.nextTick(emit\x2C eventName\x2C message\x2C handle);\n  }\n\n  channel.readStart();\n  return control;\n}\n\nconst INTERNAL_PREFIX = 'NODE_';\nfunction isInternal(message) {\n  return (message !== null &&\n          typeof message === 'object' &&\n          typeof message.cmd === 'string' &&\n          message.cmd.length > INTERNAL_PREFIX.length &&\n          StringPrototypeSlice(message.cmd\x2C 0\x2C INTERNAL_PREFIX.length) ===\n            INTERNAL_PREFIX);\n}\n\nconst nop = FunctionPrototype;\n\nfunction getValidStdio(stdio\x2C sync) {\n  let ipc;\n  let ipcFd;\n\n  // Replace shortcut with an array\n  if (typeof stdio === 'string') {\n    stdio = stdioStringToArray(stdio);\n  } else if (!ArrayIsArray(stdio)) {\n    throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n  }\n\n  // At least 3 stdio will be created\n  // Don't concat() a new Array() because it would be sparse\x2C and\n  // stdio.reduce() would skip the sparse elements of stdio.\n  // See https://stackoverflow.com/a/5501711/3561\n  while (stdio.length < 3) ArrayPrototypePush(stdio\x2C undefined);\n\n  // Translate stdio into C++-readable form\n  // (i.e. PipeWraps or fds)\n  stdio = ArrayPrototypeReduce(stdio\x2C (acc\x2C stdio\x2C i) => {\n    function cleanup() {\n      for (let i = 0; i < acc.length; i++) {\n        if ((acc[i].type === 'pipe' || acc[i].type === 'ipc') && acc[i].handle)\n          acc[i].handle.close();\n      }\n    }\n\n    // Defaults\n    if (stdio == null) {\n      stdio = i < 3 ? 'pipe' : 'ignore';\n    }\n\n    if (stdio === 'ignore') {\n      ArrayPrototypePush(acc\x2C { type: 'ignore' });\n    } else if (stdio === 'pipe' || stdio === 'overlapped' ||\n               (typeof stdio === 'number' && stdio < 0)) {\n      const a = {\n        type: stdio === 'overlapped' ? 'overlapped' : 'pipe'\x2C\n        readable: i === 0\x2C\n        writable: i !== 0\n      };\n\n      if (!sync)\n        a.handle = new Pipe(PipeConstants.SOCKET);\n\n      ArrayPrototypePush(acc\x2C a);\n    } else if (stdio === 'ipc') {\n      if (sync || ipc !== undefined) {\n        // Cleanup previously created pipes\n        cleanup();\n        if (!sync)\n          throw new ERR_IPC_ONE_PIPE();\n        else\n          throw new ERR_IPC_SYNC_FORK();\n      }\n\n      ipc = new Pipe(PipeConstants.IPC);\n      ipcFd = i;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'pipe'\x2C\n        handle: ipc\x2C\n        ipc: true\n      });\n    } else if (stdio === 'inherit') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'inherit'\x2C\n        fd: i\n      });\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\n      ArrayPrototypePush(acc\x2C {\n        type: 'fd'\x2C\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\n      });\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\n               getHandleWrapType(stdio._handle)) {\n      const handle = getHandleWrapType(stdio) ?\n        stdio :\n        getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\n\n      ArrayPrototypePush(acc\x2C {\n        type: 'wrap'\x2C\n        wrapType: getHandleWrapType(handle)\x2C\n        handle: handle\x2C\n        _stdio: stdio\n      });\n    } else if (isArrayBufferView(stdio) || typeof stdio === 'string') {\n      if (!sync) {\n        cleanup();\n        throw new ERR_INVALID_SYNC_FORK_INPUT(inspect(stdio));\n      }\n    } else {\n      // Cleanup\n      cleanup();\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\n    }\n\n    return acc;\n  }\x2C []);\n\n  return { stdio\x2C ipc\x2C ipcFd };\n}\n\n\nfunction getSocketList(type\x2C worker\x2C key) {\n  const sockets = worker[kChannelHandle].sockets[type];\n  let socketList = sockets[key];\n  if (!socketList) {\n    const Construct = type === 'send' ? SocketListSend : SocketListReceive;\n    socketList = sockets[key] = new Construct(worker\x2C key);\n  }\n  return socketList;\n}\n\n\nfunction maybeClose(subprocess) {\n  subprocess._closesGot++;\n\n  if (subprocess._closesGot === subprocess._closesNeeded) {\n    subprocess.emit('close'\x2C subprocess.exitCode\x2C subprocess.signalCode);\n  }\n}\n\nfunction spawnSync(options) {\n  const result = spawn_sync.spawn(options);\n\n  if (result.output && options.encoding && options.encoding !== 'buffer') {\n    for (let i = 0; i < result.output.length; i++) {\n      if (!result.output[i])\n        continue;\n      result.output[i] = result.output[i].toString(options.encoding);\n    }\n  }\n\n  result.stdout = result.output && result.output[1];\n  result.stderr = result.output && result.output[2];\n\n  if (result.error) {\n    result.error = errnoException(result.error\x2C 'spawnSync ' + options.file);\n    result.error.path = options.file;\n    result.error.spawnargs = ArrayPrototypeSlice(options.args\x2C 1);\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  ChildProcess\x2C\n  kChannelHandle\x2C\n  setupChannel\x2C\n  getValidStdio\x2C\n  stdioStringToArray\x2C\n  spawnSync\n};\n
code-source-info,0xb46b969a878,424,0,31427,C0O0C4O31427,,
code-creation,Function,10,185147,0xb46b969be98,1265, node:internal/child_process:1:1,0xb46b969a7f0,~
code-source-info,0xb46b969be98,424,0,31427,C0O0C296O25C302O41C308O63C314O87C320O110C325O131C331O156C337O180C342O204C348O220C354O244C359O254C365O564C371O564C376O294C387O325C393O351C399O378C405O407C411O440C417O468C423O494C429O516C435O539C441O674C447O674C452O602C458O619C464O637C470O654C476O727C482O727C486O727C488O758C494O758C498O758C500O788C506O788C510O788C512O822C518O822C523O854C527O822C529O879C535O879C539O879C541O928C544O928C549O916C555O1069C558O1069C563O971C569O984C575O1005C581O1027C587O1049C593O1144C596O1144C601O1109C607O1126C613O1190C616O1190C621O1182C627O1235C630O1235C635O1227C641O1280C644O1280C649O1272C655O1328C661O1328C666O1386C672O1386C677O1417C682O1369C688O1471C694O1471C699O1435C705O1457C711O1527C717O1527C722O1505C728O1578C731O1578C735O1578C737O1634C743O1634C748O1617C754O1776C757O1776C762O1672C768O1685C774O1698C780O1711C786O1724C792O1737C798O1750C804O1763C810O1808C816O1824C822O1980C823O1980C825O1996C826O1996C828O2044C830O2044C832O2070C835O2070C839O2070C841O2119C844O2119C848O2119C850O2170C853O2170C857O2170C859O2323C864O2341C869O2379C877O2445C891O2522C896O2560C904O2634C918O2798C923O2804C931O4365C939O5118C953O5598C958O5637C966O5703C980O5782C985O5821C993O5948C1009O2323C1011O7946C1019O7970C1024O7912C1029O7982C1032O7982C1037O8968C1046O8984C1050O12687C1059O12702C1063O13386C1072O13400C1076O13473C1085O13489C1137O13572C1193O13550C1195O14579C1200O14606C1203O14579C1205O14680C1206O14680C1208O26837C1210O26837C1212O27170C1214O27170C1216O31304C1223O31325C1229O31341C1235O31359C1241O31375C1247O31392C1253O31414C1259O31319C1264O31426,,
code-creation,Function,10,185277,0xb46b969c618,26,<instance_members_initializer> node:internal/child_process:522:1,0xb46b969b558,~
code-source-info,0xb46b969c618,424,13550,14547,C3O13600C11O13616C19O13641C25O14547,,
tick,0x103b69f6c,185302,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b9696e8e,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x10280e281,185319,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b9696e8e,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805ede983,185334,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b9696e8e,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x102a760a8,186258,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b969c092,0x113244eeb,0x1132442e1,0xb46b9696e8e,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,186552,0xb46b96a01b0,5, node:dgram:1:1,0xb46b969fc38,~
script-source,425,node:dgram,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypePush\x2C\n  FunctionPrototypeBind\x2C\n  FunctionPrototypeCall\x2C\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst errors = require('internal/errors');\nconst {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\x2C\n} = require('internal/dgram');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_MISSING_ARGS\x2C\n  ERR_SOCKET_ALREADY_BOUND\x2C\n  ERR_SOCKET_BAD_BUFFER_SIZE\x2C\n  ERR_SOCKET_BUFFER_SIZE\x2C\n  ERR_SOCKET_DGRAM_IS_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_CONNECTED\x2C\n  ERR_SOCKET_DGRAM_NOT_RUNNING\x2C\n  ERR_INVALID_FD_TYPE\n} = errors.codes;\nconst {\n  isInt32\x2C\n  validateAbortSignal\x2C\n  validateString\x2C\n  validateNumber\x2C\n  validatePort\x2C\n} = require('internal/validators');\nconst { Buffer } = require('buffer');\nconst { deprecate } = require('internal/util');\nconst { isArrayBufferView } = require('internal/util/types');\nconst EventEmitter = require('events');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol\x2C owner_symbol }\n} = require('internal/async_hooks');\nconst { UV_UDP_REUSEADDR } = internalBinding('constants').os;\n\nconst {\n  constants: { UV_UDP_IPV6ONLY }\x2C\n  UDP\x2C\n  SendWrap\n} = internalBinding('udp_wrap');\n\nconst BIND_STATE_UNBOUND = 0;\nconst BIND_STATE_BINDING = 1;\nconst BIND_STATE_BOUND = 2;\n\nconst CONNECT_STATE_DISCONNECTED = 0;\nconst CONNECT_STATE_CONNECTING = 1;\nconst CONNECT_STATE_CONNECTED = 2;\n\nconst RECV_BUFFER = true;\nconst SEND_BUFFER = false;\n\n// Lazily loaded\nlet _cluster = null;\nfunction lazyLoadCluster() {\n  if (!_cluster) _cluster = require('cluster');\n  return _cluster;\n}\n\nconst errnoException = errors.errnoException;\nconst exceptionWithHostPort = errors.exceptionWithHostPort;\n\n\nfunction Socket(type\x2C listener) {\n  FunctionPrototypeCall(EventEmitter\x2C this);\n  let lookup;\n  let recvBufferSize;\n  let sendBufferSize;\n\n  let options;\n  if (type !== null && typeof type === 'object') {\n    options = type;\n    type = options.type;\n    lookup = options.lookup;\n    recvBufferSize = options.recvBufferSize;\n    sendBufferSize = options.sendBufferSize;\n  }\n\n  const handle = newHandle(type\x2C lookup);\n  handle[owner_symbol] = this;\n\n  this[async_id_symbol] = handle.getAsyncId();\n  this.type = type;\n\n  if (typeof listener === 'function')\n    this.on('message'\x2C listener);\n\n  this[kStateSymbol] = {\n    handle\x2C\n    receiving: false\x2C\n    bindState: BIND_STATE_UNBOUND\x2C\n    connectState: CONNECT_STATE_DISCONNECTED\x2C\n    queue: undefined\x2C\n    reuseAddr: options && options.reuseAddr\x2C // Use UV_UDP_REUSEADDR if true.\n    ipv6Only: options && options.ipv6Only\x2C\n    recvBufferSize\x2C\n    sendBufferSize\n  };\n\n  if (options?.signal !== undefined) {\n    const { signal } = options;\n    validateAbortSignal(signal\x2C 'options.signal');\n    const onAborted = () => {\n      this.close();\n    };\n    if (signal.aborted) {\n      onAborted();\n    } else {\n      signal.addEventListener('abort'\x2C onAborted);\n      this.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\n    }\n  }\n}\nObjectSetPrototypeOf(Socket.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Socket\x2C EventEmitter);\n\n\nfunction createSocket(type\x2C listener) {\n  return new Socket(type\x2C listener);\n}\n\n\nfunction startListening(socket) {\n  const state = socket[kStateSymbol];\n\n  state.handle.onmessage = onMessage;\n  state.handle.onerror = onError;\n  state.handle.recvStart();\n  state.receiving = true;\n  state.bindState = BIND_STATE_BOUND;\n\n  if (state.recvBufferSize)\n    bufferSize(socket\x2C state.recvBufferSize\x2C RECV_BUFFER);\n\n  if (state.sendBufferSize)\n    bufferSize(socket\x2C state.sendBufferSize\x2C SEND_BUFFER);\n\n  socket.emit('listening');\n}\n\nfunction replaceHandle(self\x2C newHandle) {\n  const state = self[kStateSymbol];\n  const oldHandle = state.handle;\n\n  // Set up the handle that we got from primary.\n  newHandle.lookup = oldHandle.lookup;\n  newHandle.bind = oldHandle.bind;\n  newHandle.send = oldHandle.send;\n  newHandle[owner_symbol] = self;\n\n  // Replace the existing handle by the handle we got from primary.\n  oldHandle.close();\n  state.handle = newHandle;\n}\n\nfunction bufferSize(self\x2C size\x2C buffer) {\n  if (size >>> 0 !== size)\n    throw new ERR_SOCKET_BAD_BUFFER_SIZE();\n\n  const ctx = {};\n  const ret = self[kStateSymbol].handle.bufferSize(size\x2C buffer\x2C ctx);\n  if (ret === undefined) {\n    throw new ERR_SOCKET_BUFFER_SIZE(ctx);\n  }\n  return ret;\n}\n\n// Query primary process to get the server handle and utilize it.\nfunction bindServerHandle(self\x2C options\x2C errCb) {\n  const cluster = lazyLoadCluster();\n\n  const state = self[kStateSymbol];\n  cluster._getServer(self\x2C options\x2C (err\x2C handle) => {\n    if (err) {\n      errCb(err);\n      return;\n    }\n\n    if (!state.handle) {\n      // Handle has been closed in the mean time.\n      return handle.close();\n    }\n\n    replaceHandle(self\x2C handle);\n    startListening(self);\n  });\n}\n\nSocket.prototype.bind = function(port_\x2C address_ /* \x2C callback */) {\n  let port = port_;\n\n  healthCheck(this);\n  const state = this[kStateSymbol];\n\n  if (state.bindState !== BIND_STATE_UNBOUND)\n    throw new ERR_SOCKET_ALREADY_BOUND();\n\n  state.bindState = BIND_STATE_BINDING;\n\n  const cb = arguments.length && arguments[arguments.length - 1];\n  if (typeof cb === 'function') {\n    function removeListeners() {\n      this.removeListener('error'\x2C removeListeners);\n      this.removeListener('listening'\x2C onListening);\n    }\n\n    function onListening() {\n      FunctionPrototypeCall(removeListeners\x2C this);\n      FunctionPrototypeCall(cb\x2C this);\n    }\n\n    this.on('error'\x2C removeListeners);\n    this.on('listening'\x2C onListening);\n  }\n\n  if (port !== null &&\n      typeof port === 'object' &&\n      typeof port.recvStart === 'function') {\n    replaceHandle(this\x2C port);\n    startListening(this);\n    return this;\n  }\n\n  // Open an existing fd instead of creating a new one.\n  if (port !== null && typeof port === 'object' &&\n      isInt32(port.fd) && port.fd > 0) {\n    const fd = port.fd;\n    const exclusive = !!port.exclusive;\n    const state = this[kStateSymbol];\n\n    const cluster = lazyLoadCluster();\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: null\x2C\n        port: null\x2C\n        addressType: this.type\x2C\n        fd\x2C\n        flags: null\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = errnoException(err\x2C 'open');\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n      return this;\n    }\n\n    const type = guessHandleType(fd);\n    if (type !== 'UDP')\n      throw new ERR_INVALID_FD_TYPE(type);\n    const err = state.handle.open(fd);\n\n    if (err)\n      throw errnoException(err\x2C 'open');\n\n    startListening(this);\n    return this;\n  }\n\n  let address;\n  let exclusive;\n\n  if (port !== null && typeof port === 'object') {\n    address = port.address || '';\n    exclusive = !!port.exclusive;\n    port = port.port;\n  } else {\n    address = typeof address_ === 'function' ? '' : address_;\n    exclusive = false;\n  }\n\n  // Defaulting address for bind to all interfaces\n  if (!address) {\n    if (this.type === 'udp4')\n      address = '0.0.0.0';\n    else\n      address = '::';\n  }\n\n  // Resolve address first\n  state.handle.lookup(address\x2C (err\x2C ip) => {\n    if (err) {\n      state.bindState = BIND_STATE_UNBOUND;\n      this.emit('error'\x2C err);\n      return;\n    }\n\n    const cluster = lazyLoadCluster();\n\n    let flags = 0;\n    if (state.reuseAddr)\n      flags |= UV_UDP_REUSEADDR;\n    if (state.ipv6Only)\n      flags |= UV_UDP_IPV6ONLY;\n\n    if (cluster.isWorker && !exclusive) {\n      bindServerHandle(this\x2C {\n        address: ip\x2C\n        port: port\x2C\n        addressType: this.type\x2C\n        fd: -1\x2C\n        flags: flags\n      }\x2C (err) => {\n        // Callback to handle error.\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n      });\n    } else {\n      if (!state.handle)\n        return; // Handle has been closed in the mean time\n\n      const err = state.handle.bind(ip\x2C port || 0\x2C flags);\n      if (err) {\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\n        state.bindState = BIND_STATE_UNBOUND;\n        this.emit('error'\x2C ex);\n        // Todo: close?\n        return;\n      }\n\n      startListening(this);\n    }\n  });\n\n  return this;\n};\n\nSocket.prototype.connect = function(port\x2C address\x2C callback) {\n  port = validatePort(port\x2C 'Port'\x2C false);\n  if (typeof address === 'function') {\n    callback = address;\n    address = '';\n  } else if (address === undefined) {\n    address = '';\n  }\n\n  validateString(address\x2C 'address');\n\n  const state = this[kStateSymbol];\n\n  if (state.connectState !== CONNECT_STATE_DISCONNECTED)\n    throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n\n  state.connectState = CONNECT_STATE_CONNECTING;\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(_connect\x2C this\x2C\n                                        port\x2C address\x2C callback));\n    return;\n  }\n\n  ReflectApply(_connect\x2C this\x2C [port\x2C address\x2C callback]);\n};\n\n\nfunction _connect(port\x2C address\x2C callback) {\n  const state = this[kStateSymbol];\n  if (callback)\n    this.once('connect'\x2C callback);\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doConnect\x2C\n      ex\x2C this\x2C ip\x2C address\x2C port\x2C callback\n    );\n  };\n\n  state.handle.lookup(address\x2C afterDns);\n}\n\n\nfunction doConnect(ex\x2C self\x2C ip\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n  if (!state.handle)\n    return;\n\n  if (!ex) {\n    const err = state.handle.connect(ip\x2C port);\n    if (err) {\n      ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port);\n    }\n  }\n\n  if (ex) {\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n    return process.nextTick(() => {\n      if (callback) {\n        self.removeListener('connect'\x2C callback);\n        callback(ex);\n      } else {\n        self.emit('error'\x2C ex);\n      }\n    });\n  }\n\n  state.connectState = CONNECT_STATE_CONNECTED;\n  process.nextTick(() => self.emit('connect'));\n}\n\n\nSocket.prototype.disconnect = function() {\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const err = state.handle.disconnect();\n  if (err)\n    throw errnoException(err\x2C 'connect');\n  else\n    state.connectState = CONNECT_STATE_DISCONNECTED;\n};\n\n\n// Thin wrapper around `send`\x2C here for compatibility with dgram_legacy.js\nSocket.prototype.sendto = function(buffer\x2C\n                                   offset\x2C\n                                   length\x2C\n                                   port\x2C\n                                   address\x2C\n                                   callback) {\n  validateNumber(offset\x2C 'offset');\n  validateNumber(length\x2C 'length');\n  validateNumber(port\x2C 'port');\n  validateString(address\x2C 'address');\n\n  this.send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback);\n};\n\n\nfunction sliceBuffer(buffer\x2C offset\x2C length) {\n  if (typeof buffer === 'string') {\n    buffer = Buffer.from(buffer);\n  } else if (!isArrayBufferView(buffer)) {\n    throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  offset = offset >>> 0;\n  length = length >>> 0;\n  if (offset > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\n  }\n\n  if (offset + length > buffer.byteLength) {\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\n  }\n\n  return Buffer.from(buffer.buffer\x2C buffer.byteOffset + offset\x2C length);\n}\n\n\nfunction fixBufferList(list) {\n  const newlist = new Array(list.length);\n\n  for (let i = 0\x2C l = list.length; i < l; i++) {\n    const buf = list[i];\n    if (typeof buf === 'string')\n      newlist[i] = Buffer.from(buf);\n    else if (!isArrayBufferView(buf))\n      return null;\n    else\n      newlist[i] = Buffer.from(buf.buffer\x2C buf.byteOffset\x2C buf.byteLength);\n  }\n\n  return newlist;\n}\n\n\nfunction enqueue(self\x2C toEnqueue) {\n  const state = self[kStateSymbol];\n\n  // If the send queue hasn't been initialized yet\x2C do it\x2C and install an\n  // event handler that flushes the send queue after binding is done.\n  if (state.queue === undefined) {\n    state.queue = [];\n    self.once(EventEmitter.errorMonitor\x2C onListenError);\n    self.once('listening'\x2C onListenSuccess);\n  }\n  ArrayPrototypePush(state.queue\x2C toEnqueue);\n}\n\n\nfunction onListenSuccess() {\n  this.removeListener(EventEmitter.errorMonitor\x2C onListenError);\n  FunctionPrototypeCall(clearQueue\x2C this);\n}\n\n\nfunction onListenError(err) {\n  this.removeListener('listening'\x2C onListenSuccess);\n  this[kStateSymbol].queue = undefined;\n}\n\n\nfunction clearQueue() {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n  state.queue = undefined;\n\n  // Flush the send queue.\n  for (const queueEntry of queue)\n    queueEntry();\n}\n\n// valid combinations\n// For connectionless sockets\n// send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port\x2C address)\n// send(buffer\x2C offset\x2C length\x2C port\x2C callback)\n// send(buffer\x2C offset\x2C length\x2C port)\n// send(bufferOrList\x2C port\x2C address\x2C callback)\n// send(bufferOrList\x2C port\x2C address)\n// send(bufferOrList\x2C port\x2C callback)\n// send(bufferOrList\x2C port)\n// For connected sockets\n// send(buffer\x2C offset\x2C length\x2C callback)\n// send(buffer\x2C offset\x2C length)\n// send(bufferOrList\x2C callback)\n// send(bufferOrList)\nSocket.prototype.send = function(buffer\x2C\n                                 offset\x2C\n                                 length\x2C\n                                 port\x2C\n                                 address\x2C\n                                 callback) {\n\n  let list;\n  const state = this[kStateSymbol];\n  const connected = state.connectState === CONNECT_STATE_CONNECTED;\n  if (!connected) {\n    if (address || (port && typeof port !== 'function')) {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n    } else {\n      callback = port;\n      port = offset;\n      address = length;\n    }\n  } else {\n    if (typeof length === 'number') {\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\n      if (typeof port === 'function') {\n        callback = port;\n        port = null;\n      }\n    } else {\n      callback = offset;\n    }\n\n    if (port || address)\n      throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\n  }\n\n  if (!ArrayIsArray(buffer)) {\n    if (typeof buffer === 'string') {\n      list = [ Buffer.from(buffer) ];\n    } else if (!isArrayBufferView(buffer)) {\n      throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\n                                     ['Buffer'\x2C\n                                      'TypedArray'\x2C\n                                      'DataView'\x2C\n                                      'string']\x2C\n                                     buffer);\n    } else {\n      list = [ buffer ];\n    }\n  } else if (!(list = fixBufferList(buffer))) {\n    throw new ERR_INVALID_ARG_TYPE('buffer list arguments'\x2C\n                                   ['Buffer'\x2C\n                                    'TypedArray'\x2C\n                                    'DataView'\x2C\n                                    'string']\x2C\n                                   buffer);\n  }\n\n  if (!connected)\n    port = validatePort(port\x2C 'Port'\x2C false);\n\n  // Normalize callback so it's either a function or undefined but not anything\n  // else.\n  if (typeof callback !== 'function')\n    callback = undefined;\n\n  if (typeof address === 'function') {\n    callback = address;\n    address = undefined;\n  } else if (address != null) {\n    validateString(address\x2C 'address');\n  }\n\n  healthCheck(this);\n\n  if (state.bindState === BIND_STATE_UNBOUND)\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\n\n  if (list.length === 0)\n    ArrayPrototypePush(list\x2C Buffer.alloc(0));\n\n  // If the socket hasn't been bound yet\x2C push the outbound packet onto the\n  // send queue and send after binding is complete.\n  if (state.bindState !== BIND_STATE_BOUND) {\n    enqueue(this\x2C FunctionPrototypeBind(this.send\x2C this\x2C\n                                        list\x2C port\x2C address\x2C callback));\n    return;\n  }\n\n  const afterDns = (ex\x2C ip) => {\n    defaultTriggerAsyncIdScope(\n      this[async_id_symbol]\x2C\n      doSend\x2C\n      ex\x2C this\x2C ip\x2C list\x2C address\x2C port\x2C callback\n    );\n  };\n\n  if (!connected) {\n    state.handle.lookup(address\x2C afterDns);\n  } else {\n    afterDns(null\x2C null);\n  }\n};\n\nfunction doSend(ex\x2C self\x2C ip\x2C list\x2C address\x2C port\x2C callback) {\n  const state = self[kStateSymbol];\n\n  if (ex) {\n    if (typeof callback === 'function') {\n      process.nextTick(callback\x2C ex);\n      return;\n    }\n\n    process.nextTick(() => self.emit('error'\x2C ex));\n    return;\n  } else if (!state.handle) {\n    return;\n  }\n\n  const req = new SendWrap();\n  req.list = list;  // Keep reference alive.\n  req.address = address;\n  req.port = port;\n  if (callback) {\n    req.callback = callback;\n    req.oncomplete = afterSend;\n  }\n\n  let err;\n  if (port)\n    err = state.handle.send(req\x2C list\x2C list.length\x2C port\x2C ip\x2C !!callback);\n  else\n    err = state.handle.send(req\x2C list\x2C list.length\x2C !!callback);\n\n  if (err >= 1) {\n    // Synchronous finish. The return code is msg_length + 1 so that we can\n    // distinguish between synchronous success and asynchronous success.\n    if (callback)\n      process.nextTick(callback\x2C null\x2C err - 1);\n    return;\n  }\n\n  if (err && callback) {\n    // Don't emit as error\x2C dgram_legacy.js compatibility\n    const ex = exceptionWithHostPort(err\x2C 'send'\x2C address\x2C port);\n    process.nextTick(callback\x2C ex);\n  }\n}\n\nfunction afterSend(err\x2C sent) {\n  if (err) {\n    err = exceptionWithHostPort(err\x2C 'send'\x2C this.address\x2C this.port);\n  } else {\n    err = null;\n  }\n\n  this.callback(err\x2C sent);\n}\n\nSocket.prototype.close = function(callback) {\n  const state = this[kStateSymbol];\n  const queue = state.queue;\n\n  if (typeof callback === 'function')\n    this.on('close'\x2C callback);\n\n  if (queue !== undefined) {\n    ArrayPrototypePush(queue\x2C FunctionPrototypeBind(this.close\x2C this));\n    return this;\n  }\n\n  healthCheck(this);\n  stopReceiving(this);\n  state.handle.close();\n  state.handle = null;\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\n                             process.nextTick\x2C\n                             socketCloseNT\x2C\n                             this);\n\n  return this;\n};\n\n\nfunction socketCloseNT(self) {\n  self.emit('close');\n}\n\n\nSocket.prototype.address = function() {\n  healthCheck(this);\n\n  const out = {};\n  const err = this[kStateSymbol].handle.getsockname(out);\n  if (err) {\n    throw errnoException(err\x2C 'getsockname');\n  }\n\n  return out;\n};\n\nSocket.prototype.remoteAddress = function() {\n  healthCheck(this);\n\n  const state = this[kStateSymbol];\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\n\n  const out = {};\n  const err = state.handle.getpeername(out);\n  if (err)\n    throw errnoException(err\x2C 'getpeername');\n\n  return out;\n};\n\n\nSocket.prototype.setBroadcast = function(arg) {\n  const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setBroadcast');\n  }\n};\n\n\nSocket.prototype.setTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastTTL = function(ttl) {\n  validateNumber(ttl\x2C 'ttl');\n\n  const err = this[kStateSymbol].handle.setMulticastTTL(ttl);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastTTL');\n  }\n\n  return ttl;\n};\n\n\nSocket.prototype.setMulticastLoopback = function(arg) {\n  const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastLoopback');\n  }\n\n  return arg; // 0.4 compatibility\n};\n\n\nSocket.prototype.setMulticastInterface = function(interfaceAddress) {\n  healthCheck(this);\n  validateString(interfaceAddress\x2C 'interfaceAddress');\n\n  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'setMulticastInterface');\n  }\n};\n\nSocket.prototype.addMembership = function(multicastAddress\x2C\n                                          interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.addMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addMembership');\n  }\n};\n\n\nSocket.prototype.dropMembership = function(multicastAddress\x2C\n                                           interfaceAddress) {\n  healthCheck(this);\n\n  if (!multicastAddress) {\n    throw new ERR_MISSING_ARGS('multicastAddress');\n  }\n\n  const { handle } = this[kStateSymbol];\n  const err = handle.dropMembership(multicastAddress\x2C interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropMembership');\n  }\n};\n\nSocket.prototype.addSourceSpecificMembership = function(sourceAddress\x2C\n                                                        groupAddress\x2C\n                                                        interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress\x2C\n                                                          groupAddress\x2C\n                                                          interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'addSourceSpecificMembership');\n  }\n};\n\n\nSocket.prototype.dropSourceSpecificMembership = function(sourceAddress\x2C\n                                                         groupAddress\x2C\n                                                         interfaceAddress) {\n  healthCheck(this);\n\n  validateString(sourceAddress\x2C 'sourceAddress');\n  validateString(groupAddress\x2C 'groupAddress');\n\n  const err =\n    this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress\x2C\n                                                           groupAddress\x2C\n                                                           interfaceAddress);\n  if (err) {\n    throw errnoException(err\x2C 'dropSourceSpecificMembership');\n  }\n};\n\n\nfunction healthCheck(socket) {\n  if (!socket[kStateSymbol].handle) {\n    // Error message from dgram_legacy.js.\n    throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\n  }\n}\n\n\nfunction stopReceiving(socket) {\n  const state = socket[kStateSymbol];\n\n  if (!state.receiving)\n    return;\n\n  state.handle.recvStop();\n  state.receiving = false;\n}\n\n\nfunction onMessage(nread\x2C handle\x2C buf\x2C rinfo) {\n  const self = handle[owner_symbol];\n  if (nread < 0) {\n    return self.emit('error'\x2C errnoException(nread\x2C 'recvmsg'));\n  }\n  rinfo.size = buf.length; // compatibility\n  self.emit('message'\x2C buf\x2C rinfo);\n}\n\n\nfunction onError(nread\x2C handle\x2C error) {\n  const self = handle[owner_symbol];\n  return self.emit('error'\x2C error);\n}\n\n\nSocket.prototype.ref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.ref();\n\n  return this;\n};\n\n\nSocket.prototype.unref = function() {\n  const handle = this[kStateSymbol].handle;\n\n  if (handle)\n    handle.unref();\n\n  return this;\n};\n\n\nSocket.prototype.setRecvBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.setSendBufferSize = function(size) {\n  bufferSize(this\x2C size\x2C SEND_BUFFER);\n};\n\n\nSocket.prototype.getRecvBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C RECV_BUFFER);\n};\n\n\nSocket.prototype.getSendBufferSize = function() {\n  return bufferSize(this\x2C 0\x2C SEND_BUFFER);\n};\n\n\n// Deprecated private APIs.\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].handle;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].handle = val;\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_receiving'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].receiving;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].receiving = val;\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_bindState'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].bindState;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].bindState = val;\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_queue'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].queue;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].queue = val;\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\n});\n\n\nObjectDefineProperty(Socket.prototype\x2C '_reuseAddr'\x2C {\n  __proto__: null\x2C\n  get: deprecate(function() {\n    return this[kStateSymbol].reuseAddr;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x2C\n  set: deprecate(function(val) {\n    this[kStateSymbol].reuseAddr = val;\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\n});\n\n\nSocket.prototype._healthCheck = deprecate(function() {\n  healthCheck(this);\n}\x2C 'Socket.prototype._healthCheck() is deprecated'\x2C 'DEP0112');\n\n\nSocket.prototype._stopReceiving = deprecate(function() {\n  stopReceiving(this);\n}\x2C 'Socket.prototype._stopReceiving() is deprecated'\x2C 'DEP0112');\n\n\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\nObjectDefineProperty(UDP.prototype\x2C 'owner'\x2C {\n  __proto__: null\x2C\n  get() { return this[owner_symbol]; }\x2C\n  set(v) { return this[owner_symbol] = v; }\n});\n\n\nmodule.exports = {\n  _createSocketHandle: deprecate(\n    _createSocketHandle\x2C\n    'dgram._createSocketHandle() is deprecated'\x2C\n    'DEP0112'\n  )\x2C\n  createSocket\x2C\n  Socket\n};\n
code-source-info,0xb46b96a01b0,425,0,27463,C0O0C4O27463,,
code-creation,Function,10,189655,0xb46b96a2118,1507, node:dgram:1:1,0xb46b96a0128,~
code-source-info,0xb46b96a2118,425,0,27463,C0O0C276O1159C282O1168C288O1184C294O1206C300O1231C306O1256C311O1280C316O1304C322O1351C328O1351C333O1443C339O1443C344O1389C350O1405C355O1428C361O1498C364O1498C369O1478C375O1819C380O1533C386O1561C392O1585C398O1605C404O1633C410O1663C416O1689C422O1722C428O1756C434O1788C440O1924C446O1924C451O1836C457O1847C463O1870C469O1888C475O1906C481O1975C487O1975C492O1964C498O2016C504O2016C509O2002C514O2072C520O2072C525O2050C531O2125C537O2125C541O2125C543O2231C549O2231C554O2154C565O2195C571O2212C577O2293C580O2293C585O2321C590O2272C596O2391C599O2391C604O2391C609O2350C615O2371C620O2378C626O2448C627O2448C629O2478C631O2478C633O2506C635O2506C637O2545C638O2545C640O2581C642O2581C644O2616C646O2616C648O2640C649O2640C651O2666C652O2666C654O2706C655O2706C657O2841C661O2834C663O2894C667O2887C669O4215C672O4243C680O4267C685O4215C690O4279C696O4279C701O6049C704O6056C713O6071C717O9517C720O9524C729O9542C733O11337C736O11344C745O11365C749O11753C752O11760C761O11777C765O14816C768O14823C777O14838C781O19055C784O19062C793O19078C797O19709C800O19716C809O19734C813O19929C816O19936C825O19960C829O20276C832O20283C841O20306C845O20460C848O20467C857O20484C861O20664C864O20671C873O20697C877O20895C880O20902C889O20933C893O21139C896O21146C905O21178C909O21445C912O21452C921O21476C925O21856C928O21863C937O21888C941O22270C944O22277C953O22315C957O22928C960O22935C969O22974C973O24301C976O24308C985O24322C989O24435C992O24442C1001O24458C1005O24573C1008O24580C1017O24608C1021O24671C1024O24678C1033O24706C1037O24769C1040O24776C1049O24804C1053O24867C1056O24874C1065O24902C1069O24993C1072O25021C1085O25071C1096O25071C1105O25198C1116O25198C1125O24993C1130O25325C1133O25353C1146O25406C1157O25406C1166O25539C1177O25539C1186O25325C1191O25672C1194O25700C1207O25753C1218O25753C1227O25886C1238O25886C1247O25672C1252O26019C1255O26047C1268O26096C1279O26096C1288O26221C1299O26221C1308O26019C1313O26346C1316O26374C1329O26427C1340O26427C1349O26560C1360O26560C1369O26346C1374O26693C1377O26700C1382O26725C1393O26725C1398O26723C1402O26835C1405O26842C1410O26869C1421O26869C1426O26867C1430O27158C1443O27201C1451O27241C1459O27133C1464O27289C1478O27331C1489O27437C1495O27453C1501O27304C1506O27462,,
tick,0x7ff805f12098,189819,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b969c092,0x113244eeb,0x1132442e1,0xb46b9696e8e,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805edea05,189838,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b969c092,0x113244eeb,0x1132442e1,0xb46b9696e8e,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x1027c823e,189957,1,0x10266e4e0,2,0x1027fed10,0x113244e26,0x1132442e1,0xb46b96a226b,0x113244eeb,0x1132442e1,0xb46b969c092,0x113244eeb,0x1132442e1,0xb46b9696e8e,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,190153,0xb46b96a55b0,5, node:internal/dgram:1:1,0xb46b96a53a8,~
script-source,426,node:internal/dgram,'use strict';\n\nconst {\n  FunctionPrototypeBind\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { codes } = require('internal/errors');\nconst { UDP } = internalBinding('udp_wrap');\nconst { guessHandleType } = internalBinding('util');\nconst {\n  isInt32\x2C\n  validateFunction\x2C\n} = require('internal/validators');\nconst { UV_EINVAL } = internalBinding('uv');\nconst {\n  ERR_SOCKET_BAD_TYPE\x2C\n} = codes;\nconst kStateSymbol = Symbol('state symbol');\nlet dns;  // Lazy load for startup performance.\n\n\nfunction lookup4(lookup\x2C address\x2C callback) {\n  return lookup(address || '127.0.0.1'\x2C 4\x2C callback);\n}\n\n\nfunction lookup6(lookup\x2C address\x2C callback) {\n  return lookup(address || '::1'\x2C 6\x2C callback);\n}\n\nfunction newHandle(type\x2C lookup) {\n  if (lookup === undefined) {\n    if (dns === undefined) {\n      dns = require('dns');\n    }\n\n    lookup = dns.lookup;\n  } else {\n    validateFunction(lookup\x2C 'lookup');\n  }\n\n  if (type === 'udp4') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup4\x2C handle\x2C lookup);\n    return handle;\n  }\n\n  if (type === 'udp6') {\n    const handle = new UDP();\n\n    handle.lookup = FunctionPrototypeBind(lookup6\x2C handle\x2C lookup);\n    handle.bind = handle.bind6;\n    handle.connect = handle.connect6;\n    handle.send = handle.send6;\n    return handle;\n  }\n\n  throw new ERR_SOCKET_BAD_TYPE();\n}\n\n\nfunction _createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\n  const handle = newHandle(addressType);\n  let err;\n\n  if (isInt32(fd) && fd > 0) {\n    const type = guessHandleType(fd);\n    if (type !== 'UDP') {\n      err = UV_EINVAL;\n    } else {\n      err = handle.open(fd);\n    }\n  } else if (port || address) {\n    err = handle.bind(address\x2C port || 0\x2C flags);\n  }\n\n  if (err) {\n    handle.close();\n    return err;\n  }\n\n  return handle;\n}\n\n\nmodule.exports = {\n  kStateSymbol\x2C\n  _createSocketHandle\x2C\n  newHandle\n};\n
code-source-info,0xb46b96a55b0,426,0,1849,C0O0C4O1849,,
code-creation,Function,10,190393,0xb46b96a5878,196, node:internal/dgram:1:1,0xb46b96a5528,~
code-source-info,0xb46b96a5878,426,0,1849,C0O0C56O25C62O50C67O94C73O94C78O84C83O138C86O138C91O130C97O195C100O195C105O175C111O263C117O263C122O230C128O241C134O317C137O317C142O303C148O350C154O403C157O403C162O431C163O431C165O1776C172O1797C178O1813C184O1836C190O1791C195O1848,,
code-creation,Eval,10,190701,0xb46b96a9590,5, node:internal/socket_list:1:1,0xb46b96a9438,~
script-source,427,node:internal/socket_list,'use strict';\n\nconst { ERR_CHILD_CLOSED_BEFORE_REPLY } = require('internal/errors').codes;\n\nconst EventEmitter = require('events');\n\n// This object keeps track of the sockets that are sent\nclass SocketListSend extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n    this.key = key;\n    this.child = child;\n    child.once('exit'\x2C () => this.emit('exit'\x2C this));\n  }\n\n  _request(msg\x2C cmd\x2C swallowErrors\x2C callback) {\n    const self = this;\n\n    if (!this.child.connected) return onclose();\n    this.child._send(msg\x2C undefined\x2C swallowErrors);\n\n    function onclose() {\n      self.child.removeListener('internalMessage'\x2C onreply);\n      callback(new ERR_CHILD_CLOSED_BEFORE_REPLY());\n    }\n\n    function onreply(msg) {\n      if (!(msg.cmd === cmd && msg.key === self.key)) return;\n      self.child.removeListener('disconnect'\x2C onclose);\n      self.child.removeListener('internalMessage'\x2C onreply);\n\n      callback(null\x2C msg);\n    }\n\n    this.child.once('disconnect'\x2C onclose);\n    this.child.on('internalMessage'\x2C onreply);\n  }\n\n  close(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_NOTIFY_CLOSE'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_ALL_CLOSED'\x2C true\x2C callback);\n  }\n\n  getConnections(callback) {\n    this._request({\n      cmd: 'NODE_SOCKET_GET_COUNT'\x2C\n      key: this.key\n    }\x2C 'NODE_SOCKET_COUNT'\x2C false\x2C (err\x2C msg) => {\n      if (err) return callback(err);\n      callback(null\x2C msg.count);\n    });\n  }\n}\n\n\n// This object keeps track of the sockets that are received\nclass SocketListReceive extends EventEmitter {\n  constructor(child\x2C key) {\n    super();\n\n    this.connections = 0;\n    this.key = key;\n    this.child = child;\n\n    function onempty(self) {\n      if (!self.child.connected) return;\n\n      self.child._send({\n        cmd: 'NODE_SOCKET_ALL_CLOSED'\x2C\n        key: self.key\n      }\x2C undefined\x2C true);\n    }\n\n    this.child.on('internalMessage'\x2C (msg) => {\n      if (msg.key !== this.key) return;\n\n      if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\n        // Already empty\n        if (this.connections === 0) return onempty(this);\n\n        // Wait for sockets to get closed\n        this.once('empty'\x2C onempty);\n      } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\n        if (!this.child.connected) return;\n        this.child._send({\n          cmd: 'NODE_SOCKET_COUNT'\x2C\n          key: this.key\x2C\n          count: this.connections\n        });\n      }\n    });\n  }\n\n  add(obj) {\n    this.connections++;\n\n    // Notify the previous owner of the socket about its state change\n    obj.socket.once('close'\x2C () => {\n      this.connections--;\n\n      if (this.connections === 0) this.emit('empty'\x2C this);\n    });\n  }\n}\n\nmodule.exports = { SocketListSend\x2C SocketListReceive };\n
code-source-info,0xb46b96a9590,427,0,2705,C0O0C4O2705,,
code-creation,Function,10,191031,0xb46b96a9bd0,126, node:internal/socket_list:1:1,0xb46b96a9508,~
code-source-info,0xb46b96a9bd0,427,0,2705,C0O0C8O57C11O57C16O83C21O23C27O113C30O113C35O218C73O1525C101O2649C108O2668C114O2684C120O2664C125O2704,,
code-creation,LazyCompile,10,191177,0xb46b96aa4c0,14,customPromiseExecFunction node:child_process:229:35,0xb46b9696778,~
code-source-info,0xb46b96aa4c0,423,6563,6927,C0O6563C9O6577C13O6925,,
tick,0x7ff805e41468,191260,0,0x0,3,0x102d5e910,0xb46b9696ec6,0x113244eeb,0x1132442e1,0xb46b969434b,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,191367,0xb46b96ac838,5, node:internal/cluster/round_robin_handle:1:1,0xb46b96ac620,~
script-source,428,node:internal/cluster/round_robin_handle,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Boolean\x2C\n  ObjectCreate\x2C\n  SafeMap\x2C\n} = primordials;\n\nconst assert = require('internal/assert');\nconst net = require('net');\nconst { sendHelper } = require('internal/cluster/utils');\nconst { append\x2C init\x2C isEmpty\x2C peek\x2C remove } = require('internal/linkedlist');\nconst { constants } = internalBinding('tcp_wrap');\n\nmodule.exports = RoundRobinHandle;\n\nfunction RoundRobinHandle(key\x2C address\x2C { port\x2C fd\x2C flags\x2C backlog\x2C readableAll\x2C writableAll }) {\n  this.key = key;\n  this.all = new SafeMap();\n  this.free = new SafeMap();\n  this.handles = init(ObjectCreate(null));\n  this.handle = null;\n  this.server = net.createServer(assert.fail);\n\n  if (fd >= 0)\n    this.server.listen({ fd\x2C backlog });\n  else if (port >= 0) {\n    this.server.listen({\n      port\x2C\n      host: address\x2C\n      // Currently\x2C net module only supports `ipv6Only` option in `flags`.\n      ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY)\x2C\n      backlog\x2C\n    });\n  } else\n    this.server.listen({\n      path: address\x2C\n      backlog\x2C\n      readableAll\x2C\n      writableAll\x2C\n    });  // UNIX socket path.\n  this.server.once('listening'\x2C () => {\n    this.handle = this.server._handle;\n    this.handle.onconnection = (err\x2C handle) => this.distribute(err\x2C handle);\n    this.server._handle = null;\n    this.server = null;\n  });\n}\n\nRoundRobinHandle.prototype.add = function(worker\x2C send) {\n  assert(this.all.has(worker.id) === false);\n  this.all.set(worker.id\x2C worker);\n\n  const done = () => {\n    if (this.handle.getsockname) {\n      const out = {};\n      this.handle.getsockname(out);\n      // TODO(bnoordhuis) Check err.\n      send(null\x2C { sockname: out }\x2C null);\n    } else {\n      send(null\x2C null\x2C null);  // UNIX socket.\n    }\n\n    this.handoff(worker);  // In case there are connections pending.\n  };\n\n  if (this.server === null)\n    return done();\n\n  // Still busy binding.\n  this.server.once('listening'\x2C done);\n  this.server.once('error'\x2C (err) => {\n    send(err.errno\x2C null);\n  });\n};\n\nRoundRobinHandle.prototype.remove = function(worker) {\n  const existed = this.all.delete(worker.id);\n\n  if (!existed)\n    return false;\n\n  this.free.delete(worker.id);\n\n  if (this.all.size !== 0)\n    return false;\n\n  while (!isEmpty(this.handles)) {\n    const handle = peek(this.handles);\n    handle.close();\n    remove(handle);\n  }\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n\nRoundRobinHandle.prototype.distribute = function(err\x2C handle) {\n  append(this.handles\x2C handle);\n  // eslint-disable-next-line node-core/no-array-destructuring\n  const [ workerEntry ] = this.free; // this.free is a SafeMap\n\n  if (ArrayIsArray(workerEntry)) {\n    const { 0: workerId\x2C 1: worker } = workerEntry;\n    this.free.delete(workerId);\n    this.handoff(worker);\n  }\n};\n\nRoundRobinHandle.prototype.handoff = function(worker) {\n  if (!this.all.has(worker.id)) {\n    return;  // Worker is closing (or has closed) the server.\n  }\n\n  const handle = peek(this.handles);\n\n  if (handle === null) {\n    this.free.set(worker.id\x2C worker);  // Add to ready queue again.\n    return;\n  }\n\n  remove(handle);\n\n  const message = { act: 'newconn'\x2C key: this.key };\n\n  sendHelper(worker.process\x2C message\x2C handle\x2C (reply) => {\n    if (reply.accepted)\n      handle.close();\n    else\n      this.distribute(0\x2C handle);  // Worker is shutting down. Send to another.\n\n    this.handoff(worker);\n  });\n};\n
code-source-info,0xb46b96ac838,428,0,3381,C0O0C4O3381,,
code-creation,Function,10,191781,0xb46b96acc00,217, node:internal/cluster/round_robin_handle:1:1,0xb46b96ac7b0,~
code-source-info,0xb46b96acc00,428,0,3381,C0O0C49O25C55O41C61O52C67O68C73O110C76O110C80O110C82O150C85O150C89O150C91O189C94O189C99O174C105O272C108O272C113O232C119O240C125O246C131O255C137O261C143O326C146O326C151O312C157O356C159O371C163O1351C172O1365C176O2016C185O2033C189O2414C198O2435C202O2790C211O2808C216O3380,,
code-creation,Eval,10,191890,0xb46b96ad550,5, node:internal/cluster/utils:1:1,0xb46b96ad3d8,~
script-source,429,node:internal/cluster/utils,'use strict';\n\nconst {\n  ReflectApply\x2C\n  SafeMap\x2C\n} = primordials;\n\nmodule.exports = {\n  sendHelper\x2C\n  internal\n};\n\nconst callbacks = new SafeMap();\nlet seq = 0;\n\nfunction sendHelper(proc\x2C message\x2C handle\x2C cb) {\n  if (!proc.connected)\n    return false;\n\n  // Mark message as internal. See INTERNAL_PREFIX\n  // in lib/internal/child_process.js\n  message = { cmd: 'NODE_CLUSTER'\x2C ...message\x2C seq };\n\n  if (typeof cb === 'function')\n    callbacks.set(seq\x2C cb);\n\n  seq += 1;\n  return proc.send(message\x2C handle);\n}\n\n// Returns an internalMessage listener that hands off normal messages\n// to the callback but intercepts and redirects ACK messages.\nfunction internal(worker\x2C cb) {\n  return function onInternalMessage(message\x2C handle) {\n    if (message.cmd !== 'NODE_CLUSTER')\n      return;\n\n    let fn = cb;\n\n    if (message.ack !== undefined) {\n      const callback = callbacks.get(message.ack);\n\n      if (callback !== undefined) {\n        fn = callback;\n        callbacks.delete(message.ack);\n      }\n    }\n\n    ReflectApply(fn\x2C worker\x2C arguments);\n  };\n}\n
code-source-info,0xb46b96ad550,429,0,1053,C0O0C4O1053,,
code-creation,Function,10,192033,0xb46b96ad710,72, node:internal/cluster/utils:1:1,0xb46b96ad4c8,~
code-source-info,0xb46b96ad710,429,0,1053,C0O0C24O25C30O41C35O68C42O89C48O103C54O83C58O134C60O134C65O134C67O159C68O159C71O1052,,
code-creation,Eval,10,192130,0xb46b96adfe8,5, node:internal/cluster/shared_handle:1:1,0xb46b96ade60,~
script-source,430,node:internal/cluster/shared_handle,'use strict';\nconst { SafeMap } = primordials;\nconst assert = require('internal/assert');\nconst dgram = require('internal/dgram');\nconst net = require('net');\n\nmodule.exports = SharedHandle;\n\nfunction SharedHandle(key\x2C address\x2C { port\x2C addressType\x2C fd\x2C flags }) {\n  this.key = key;\n  this.workers = new SafeMap();\n  this.handle = null;\n  this.errno = 0;\n\n  let rval;\n  if (addressType === 'udp4' || addressType === 'udp6')\n    rval = dgram._createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n  else\n    rval = net._createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\n\n  if (typeof rval === 'number')\n    this.errno = rval;\n  else\n    this.handle = rval;\n}\n\nSharedHandle.prototype.add = function(worker\x2C send) {\n  assert(!this.workers.has(worker.id));\n  this.workers.set(worker.id\x2C worker);\n  send(this.errno\x2C null\x2C this.handle);\n};\n\nSharedHandle.prototype.remove = function(worker) {\n  if (!this.workers.has(worker.id))\n    return false;\n\n  this.workers.delete(worker.id);\n\n  if (this.workers.size !== 0)\n    return false;\n\n  this.handle.close();\n  this.handle = null;\n  return true;\n};\n
code-source-info,0xb46b96adfe8,430,0,1102,C0O0C4O1102,,
code-creation,Function,10,192282,0xb46b96ae220,89, node:internal/cluster/shared_handle:1:1,0xb46b96adf60,~
code-source-info,0xb46b96ae220,430,0,1102,C0O0C22O22C28O62C31O62C35O62C37O104C40O104C44O104C46O143C49O143C53O143C55O160C57O175C61O685C70O699C74O861C83O878C88O1101,,
code-creation,Eval,10,192378,0xb46b96ae828,5, node:internal/cluster/worker:1:1,0xb46b96ae6a0,~
script-source,431,node:internal/cluster/worker,'use strict';\n\nconst {\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\n\nconst { kEmptyObject } = require('internal/util');\n\nmodule.exports = Worker;\n\n// Common Worker implementation shared between the cluster primary and workers.\nfunction Worker(options) {\n  if (!(this instanceof Worker))\n    return new Worker(options);\n\n  ReflectApply(EventEmitter\x2C this\x2C []);\n\n  if (options === null || typeof options !== 'object')\n    options = kEmptyObject;\n\n  this.exitedAfterDisconnect = undefined;\n\n  this.state = options.state || 'none';\n  this.id = options.id | 0;\n\n  if (options.process) {\n    this.process = options.process;\n    this.process.on('error'\x2C (code\x2C signal) =>\n      this.emit('error'\x2C code\x2C signal)\n    );\n    this.process.on('message'\x2C (message\x2C handle) =>\n      this.emit('message'\x2C message\x2C handle)\n    );\n  }\n}\n\nObjectSetPrototypeOf(Worker.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Worker\x2C EventEmitter);\n\nWorker.prototype.kill = function() {\n  ReflectApply(this.destroy\x2C this\x2C arguments);\n};\n\nWorker.prototype.send = function() {\n  return ReflectApply(this.process.send\x2C this.process\x2C arguments);\n};\n\nWorker.prototype.isDead = function() {\n  return this.process.exitCode != null || this.process.signalCode != null;\n};\n\nWorker.prototype.isConnected = function() {\n  return this.process.connected;\n};\n
code-source-info,0xb46b96ae828,431,0,1377,C0O0C4O1377,,
code-creation,Function,10,192582,0xb46b96aeba0,158, node:internal/cluster/worker:1:1,0xb46b96ae7a0,~
code-source-info,0xb46b96aeba0,431,0,1377,C0O0C20O25C25O49C31O102C34O102C38O102C40O147C43O147C48O130C54O174C56O189C60O874C63O902C71O926C76O874C81O938C87O938C92O983C95O990C104O1005C108O1071C111O1078C120O1093C124O1179C127O1186C136O1203C140O1297C143O1304C152O1326C157O1376,,
tick,0x7ff805f12098,192625,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b969437c,0x113244eeb,0x1132442e1,0xb46b9692c95,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b9690ecb,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,192664,0xb46b96af118,21,EventEmitter node:events:212:22,0xb469fce2708,~
code-source-info,0xb46b96af118,29,6313,6361,C0O6324C3O6337C8O6342C13O6342C20O6360,,
code-creation,LazyCompile,10,192712,0xb46b96af258,149,EventEmitter.init node:events:337:29,0xb469fce2ad8,~
code-source-info,0xb46b96af258,29,9844,10433,C0O9865C6O9901C13O9913C16O9913C21O9939C25O9909C30O9955C32O9970C37O9970C41O9968C45O9994C46O10012C50O10050C60O10043C64O10082C71O10090C80O10117C85O10138C93O10117C98O10191C100O10196C105O10208C108O10221C113O10208C117O10206C123O10377C125O10382C131O10407C138O10417C140O10416C143O10392C148O10432,,
code-creation,LazyCompile,10,192820,0xb46b96af7a8,151,getESMFacade node:internal/bootstrap/loaders:281:15,0xb466514b770,~
code-source-info,0xb46b96af7a8,15,8694,9323,C0O8694C8O8712C14O8732C18O8739C19O8767C29O8767C34O8752C39O8815C42O8828C51O8859C53O8859C55O8889C62O8914C67O8889C72O8931C82O8931C87O8979C89O9031C102O8993C107O8991C111O9237C116O9244C121O9244C125O9268C130O9275C140O9275C146O9312C150O9319,,
code-creation,LazyCompile,10,192905,0xb46b96afb88,40, node:internal/bootstrap/loaders:290:15,0xb46b96af6a0,~
code-source-info,0xb46b96afb88,15,9058,9163,C0O9071C5O9084C10O9084C14O9112C24O9133C27O9146C32O9112C39O9162,,
code-creation,LazyCompile,10,192950,0xb46b96afcd8,89,syncExports node:internal/bootstrap/loaders:304:14,0xb466514b7c0,~
code-source-info,0xb46b96afcd8,15,9630,9963,C0O9658C5O9683C11O9712C13O9725C17O9717C22O9767C24O9772C28O9785C30O9800C35O9815C37O9838C42O9845C51O9897C54O9909C59O9935C67O9897C73O9845C79O9734C84O9699C88O9962,,
code-creation,LazyCompile,10,193001,0xb46b96afe48,35,getOwn node:internal/bootstrap/loaders:187:16,0xb466514b458,~
code-source-info,0xb46b96afe48,15,5646,5800,C0O5682C5O5689C14O5743C26O5743C34O5798,,
code-creation,RegExp,3,193389,0x113245ec0,1604,(?:^|\\/)\\.?\\.$
tick,0x113245ec5,193754,0,0x0,0,0x102d751a0,0x1031b8cb8,0xb46bbe770a9,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,194791,0xb46b96b05c8,5, /Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/redir-stdout.js:1:1,0xb46b96b0420,~
script-source,432,/Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/redir-stdout.js,'use strict'\nconst net = require('net')\n\nlet isWorker = false\ntry {\n  // Skip redirecting stdout in Worker threads.\n  isWorker = !require('worker_threads').isMainThread\n} catch (e) {}\n\nif (!isWorker) {\n  const socket = new net.Socket({\n    fd: 3\x2C\n    readable: false\x2C\n    writable: true\n  })\n  Object.defineProperty(process\x2C 'stdout'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get: () => socket\n  })\n  Object.defineProperty(process.stdout\x2C 'fd'\x2C {\n    value: socket._handle.fd\n  })\n}\n
code-source-info,0xb46b96b05c8,432,0,494,C0O0C4O494,,
code-creation,Function,10,194904,0xb46b96b0870,157, /Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/redir-stdout.js:1:1,0xb46b96b0540,~
code-source-info,0xb46b96b0870,432,0,494,C0O25C3O25C8O56C13O118C16O130C21O155C30O127C42O185C53O227C65O219C70O219C72O294C76O301C81O316C93O392C101O301C106O412C110O419C115O434C119O442C135O476C140O484C148O419C156O493,,
tick,0x113244080,195007,0,0x0,0,0xb46b968f069,0xb46b968d80f,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,195207,0xb46b96b0d80,37,get SocketAddress node:net:1924:20,0xb469fbf6760,~
code-source-info,0xb46b96b0d80,406,51703,51808,C0O51712C14O51730C19O51763C26O51726C32O51783C36O51804,,
code-creation,Eval,10,195420,0xb46b96b1188,5, node:worker_threads:1:1,0xb46b96b1040,~
script-source,433,node:worker_threads,'use strict';\n\nconst {\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  threadId\x2C\n  Worker\n} = require('internal/worker');\n\nconst {\n  MessagePort\x2C\n  MessageChannel\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  BroadcastChannel\x2C\n} = require('internal/worker/io');\n\nconst {\n  markAsUntransferable\x2C\n} = require('internal/buffer');\n\nmodule.exports = {\n  isMainThread\x2C\n  MessagePort\x2C\n  MessageChannel\x2C\n  markAsUntransferable\x2C\n  moveMessagePortToContext\x2C\n  receiveMessageOnPort\x2C\n  resourceLimits\x2C\n  threadId\x2C\n  SHARE_ENV\x2C\n  Worker\x2C\n  parentPort: null\x2C\n  workerData: null\x2C\n  BroadcastChannel\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n};\n
code-source-info,0xb46b96b1188,433,0,686,C0O0C4O686,,
code-creation,Function,10,195533,0xb46b96b1398,180, node:worker_threads:1:1,0xb46b96b1100,~
code-source-info,0xb46b96b1398,433,0,686,C0O139C3O139C8O25C13O41C18O54C23O72C28O94C33O116C38O128C43O285C46O285C51O178C56O193C61O211C66O239C71O263C76O353C79O353C84O327C89O382C96O403C102O419C108O434C114O452C120O476C126O504C132O528C138O546C144O558C150O571C156O621C162O641C168O663C174O397C179O685,,
code-creation,Eval,10,195913,0xb46b96b2338,5, node:internal/worker:1:1,0xb46b96b1d48,~
script-source,434,node:internal/worker,'use strict';\n\nconst {\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePush\x2C\n  Float64Array\x2C\n  FunctionPrototypeBind\x2C\n  JSONStringify\x2C\n  MathMax\x2C\n  ObjectCreate\x2C\n  ObjectEntries\x2C\n  Promise\x2C\n  PromiseResolve\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  String\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  TypedArrayPrototypeFill\x2C\n  Uint32Array\x2C\n  globalThis: { Atomics\x2C SharedArrayBuffer }\x2C\n} = primordials;\n\nconst EventEmitter = require('events');\nconst assert = require('internal/assert');\nconst path = require('path');\nconst { now } = require('internal/perf/utils');\n\nconst errorCodes = require('internal/errors').codes;\nconst {\n  ERR_WORKER_NOT_RUNNING\x2C\n  ERR_WORKER_PATH\x2C\n  ERR_WORKER_UNSERIALIZABLE_ERROR\x2C\n  ERR_WORKER_INVALID_EXEC_ARGV\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n} = errorCodes;\nconst { getOptionValue } = require('internal/options');\n\nconst workerIo = require('internal/worker/io');\nconst {\n  drainMessagePort\x2C\n  MessageChannel\x2C\n  messageTypes\x2C\n  kPort\x2C\n  kIncrementsPortRef\x2C\n  kWaitingStreams\x2C\n  kStdioWantsMoreDataCallback\x2C\n  setupPortReferencing\x2C\n  ReadableWorkerStdio\x2C\n  WritableWorkerStdio\n} = workerIo;\nconst { deserializeError } = require('internal/error_serdes');\nconst { fileURLToPath\x2C isURLInstance\x2C pathToFileURL } = require('internal/url');\nconst { kEmptyObject } = require('internal/util');\nconst { validateArray } = require('internal/validators');\n\nconst {\n  ownsProcessState\x2C\n  isMainThread\x2C\n  resourceLimits: resourceLimitsRaw\x2C\n  threadId\x2C\n  Worker: WorkerImpl\x2C\n  kMaxYoungGenerationSizeMb\x2C\n  kMaxOldGenerationSizeMb\x2C\n  kCodeRangeSizeMb\x2C\n  kStackSizeMb\x2C\n  kTotalResourceLimitCount\n} = internalBinding('worker');\n\nconst kHandle = Symbol('kHandle');\nconst kPublicPort = Symbol('kPublicPort');\nconst kDispose = Symbol('kDispose');\nconst kOnExit = Symbol('kOnExit');\nconst kOnMessage = Symbol('kOnMessage');\nconst kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\nconst kOnErrorMessage = Symbol('kOnErrorMessage');\nconst kParentSideStdio = Symbol('kParentSideStdio');\nconst kLoopStartTime = Symbol('kLoopStartTime');\nconst kIsOnline = Symbol('kIsOnline');\n\nconst SHARE_ENV = SymbolFor('nodejs.worker_threads.SHARE_ENV');\nlet debug = require('internal/util/debuglog').debuglog('worker'\x2C (fn) => {\n  debug = fn;\n});\n\nlet cwdCounter;\n\nconst environmentData = new SafeMap();\n\nif (isMainThread) {\n  cwdCounter = new Uint32Array(new SharedArrayBuffer(4));\n  const originalChdir = process.chdir;\n  process.chdir = function(path) {\n    Atomics.add(cwdCounter\x2C 0\x2C 1);\n    originalChdir(path);\n  };\n}\n\nfunction setEnvironmentData(key\x2C value) {\n  if (value === undefined)\n    environmentData.delete(key);\n  else\n    environmentData.set(key\x2C value);\n}\n\nfunction getEnvironmentData(key) {\n  return environmentData.get(key);\n}\n\nfunction assignEnvironmentData(data) {\n  if (data === undefined) return;\n  data.forEach((value\x2C key) => {\n    environmentData.set(key\x2C value);\n  });\n}\n\nclass Worker extends EventEmitter {\n  constructor(filename\x2C options = kEmptyObject) {\n    super();\n    debug(`[${threadId}] create new worker`\x2C filename\x2C options);\n    if (options.execArgv)\n      validateArray(options.execArgv\x2C 'options.execArgv');\n\n    let argv;\n    if (options.argv) {\n      validateArray(options.argv\x2C 'options.argv');\n      argv = ArrayPrototypeMap(options.argv\x2C String);\n    }\n\n    let url\x2C doEval;\n    if (options.eval) {\n      if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_VALUE(\n          'options.eval'\x2C\n          options.eval\x2C\n          'must be false when \\'filename\\' is not a string'\n        );\n      }\n      url = null;\n      doEval = 'classic';\n    } else if (isURLInstance(filename) && filename.protocol === 'data:') {\n      url = null;\n      doEval = 'module';\n      filename = `import ${JSONStringify(`${filename}`)}`;\n    } else {\n      doEval = false;\n      if (isURLInstance(filename)) {\n        url = filename;\n        filename = fileURLToPath(filename);\n      } else if (typeof filename !== 'string') {\n        throw new ERR_INVALID_ARG_TYPE(\n          'filename'\x2C\n          ['string'\x2C 'URL']\x2C\n          filename\n        );\n      } else if (path.isAbsolute(filename) ||\n                 RegExpPrototypeExec(/^\\.\\.?[\\\\/]/\x2C filename) !== null) {\n        filename = path.resolve(filename);\n        url = pathToFileURL(filename);\n      } else {\n        throw new ERR_WORKER_PATH(filename);\n      }\n    }\n\n    let env;\n    if (typeof options.env === 'object' && options.env !== null) {\n      env = ObjectCreate(null);\n      ArrayPrototypeForEach(\n        ObjectEntries(options.env)\x2C\n        ({ 0: key\x2C 1: value }) => { env[key] = `${value}`; }\n      );\n    } else if (options.env == null) {\n      env = process.env;\n    } else if (options.env !== SHARE_ENV) {\n      throw new ERR_INVALID_ARG_TYPE(\n        'options.env'\x2C\n        ['object'\x2C 'undefined'\x2C 'null'\x2C 'worker_threads.SHARE_ENV']\x2C\n        options.env);\n    }\n\n    // Set up the C++ handle for the worker\x2C as well as some internal wiring.\n    this[kHandle] = new WorkerImpl(url\x2C\n                                   env === process.env ? null : env\x2C\n                                   options.execArgv\x2C\n                                   parseResourceLimits(options.resourceLimits)\x2C\n                                   !!(options.trackUnmanagedFds ?? true));\n    if (this[kHandle].invalidExecArgv) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(this[kHandle].invalidExecArgv);\n    }\n    if (this[kHandle].invalidNodeOptions) {\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(\n        this[kHandle].invalidNodeOptions\x2C 'invalid NODE_OPTIONS env variable');\n    }\n    this[kHandle].onexit = (code\x2C customErr\x2C customErrReason) => {\n      this[kOnExit](code\x2C customErr\x2C customErrReason);\n    };\n    this[kPort] = this[kHandle].messagePort;\n    this[kPort].on('message'\x2C (data) => this[kOnMessage](data));\n    this[kPort].start();\n    this[kPort].unref();\n    this[kPort][kWaitingStreams] = 0;\n    debug(`[${threadId}] created Worker with ID ${this.threadId}`);\n\n    let stdin = null;\n    if (options.stdin)\n      stdin = new WritableWorkerStdio(this[kPort]\x2C 'stdin');\n    const stdout = new ReadableWorkerStdio(this[kPort]\x2C 'stdout');\n    if (!options.stdout) {\n      stdout[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stdout\x2C process.stdout);\n    }\n    const stderr = new ReadableWorkerStdio(this[kPort]\x2C 'stderr');\n    if (!options.stderr) {\n      stderr[kIncrementsPortRef] = false;\n      pipeWithoutWarning(stderr\x2C process.stderr);\n    }\n\n    this[kParentSideStdio] = { stdin\x2C stdout\x2C stderr };\n\n    const { port1\x2C port2 } = new MessageChannel();\n    const transferList = [port2];\n    // If transferList is provided.\n    if (options.transferList)\n      ArrayPrototypePush(transferList\x2C\n                         ...new SafeArrayIterator(options.transferList));\n\n    this[kPublicPort] = port1;\n    ArrayPrototypeForEach(['message'\x2C 'messageerror']\x2C (event) => {\n      this[kPublicPort].on(event\x2C (message) => this.emit(event\x2C message));\n    });\n    setupPortReferencing(this[kPublicPort]\x2C this\x2C 'message');\n    this[kPort].postMessage({\n      argv\x2C\n      type: messageTypes.LOAD_SCRIPT\x2C\n      filename\x2C\n      doEval\x2C\n      cwdCounter: cwdCounter || workerIo.sharedCwdCounter\x2C\n      workerData: options.workerData\x2C\n      environmentData\x2C\n      publicPort: port2\x2C\n      manifestURL: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').url :\n        null\x2C\n      manifestSrc: getOptionValue('--experimental-policy') ?\n        require('internal/process/policy').src :\n        null\x2C\n      hasStdin: !!options.stdin\n    }\x2C transferList);\n    // Use this to cache the Worker's loopStart value once available.\n    this[kLoopStartTime] = -1;\n    this[kIsOnline] = false;\n    this.performance = {\n      eventLoopUtilization: FunctionPrototypeBind(eventLoopUtilization\x2C this)\x2C\n    };\n    // Actually start the new thread now that everything is in place.\n    this[kHandle].startThread();\n\n    process.nextTick(() => process.emit('worker'\x2C this));\n  }\n\n  [kOnExit](code\x2C customErr\x2C customErrReason) {\n    debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\n    drainMessagePort(this[kPublicPort]);\n    drainMessagePort(this[kPort]);\n    this.removeAllListeners('message');\n    this.removeAllListeners('messageerrors');\n    this[kPublicPort].unref();\n    this[kPort].unref();\n    this[kDispose]();\n    if (customErr) {\n      debug(`[${threadId}] failing with custom error ${customErr} \\\n        and with reason ${customErrReason}`);\n      this.emit('error'\x2C new errorCodes[customErr](customErrReason));\n    }\n    this.emit('exit'\x2C code);\n    this.removeAllListeners();\n  }\n\n  [kOnCouldNotSerializeErr]() {\n    this.emit('error'\x2C new ERR_WORKER_UNSERIALIZABLE_ERROR());\n  }\n\n  [kOnErrorMessage](serialized) {\n    // This is what is called for uncaught exceptions.\n    const error = deserializeError(serialized);\n    this.emit('error'\x2C error);\n  }\n\n  [kOnMessage](message) {\n    switch (message.type) {\n      case messageTypes.UP_AND_RUNNING:\n        this[kIsOnline] = true;\n        return this.emit('online');\n      case messageTypes.COULD_NOT_SERIALIZE_ERROR:\n        return this[kOnCouldNotSerializeErr]();\n      case messageTypes.ERROR_MESSAGE:\n        return this[kOnErrorMessage](message.error);\n      case messageTypes.STDIO_PAYLOAD:\n      {\n        const { stream\x2C chunks } = message;\n        const readable = this[kParentSideStdio][stream];\n        ArrayPrototypeForEach(chunks\x2C ({ chunk\x2C encoding }) => {\n          readable.push(chunk\x2C encoding);\n        });\n        return;\n      }\n      case messageTypes.STDIO_WANTS_MORE_DATA:\n      {\n        const { stream } = message;\n        return this[kParentSideStdio][stream][kStdioWantsMoreDataCallback]();\n      }\n    }\n\n    assert.fail(`Unknown worker message type ${message.type}`);\n  }\n\n  [kDispose]() {\n    this[kHandle].onexit = null;\n    this[kHandle] = null;\n    this[kPort] = null;\n    this[kPublicPort] = null;\n\n    const { stdout\x2C stderr } = this[kParentSideStdio];\n\n    if (!stdout.readableEnded) {\n      debug(`[${threadId}] explicitly closes stdout for ${this.threadId}`);\n      stdout.push(null);\n    }\n    if (!stderr.readableEnded) {\n      debug(`[${threadId}] explicitly closes stderr for ${this.threadId}`);\n      stderr.push(null);\n    }\n  }\n\n  postMessage(...args) {\n    if (this[kPublicPort] === null) return;\n\n    ReflectApply(this[kPublicPort].postMessage\x2C this[kPublicPort]\x2C args);\n  }\n\n  terminate(callback) {\n    debug(`[${threadId}] terminates Worker with ID ${this.threadId}`);\n\n    this.ref();\n\n    if (typeof callback === 'function') {\n      process.emitWarning(\n        'Passing a callback to worker.terminate() is deprecated. ' +\n        'It returns a Promise instead.'\x2C\n        'DeprecationWarning'\x2C 'DEP0132');\n      if (this[kHandle] === null) return PromiseResolve();\n      this.once('exit'\x2C (exitCode) => callback(null\x2C exitCode));\n    }\n\n    if (this[kHandle] === null) return PromiseResolve();\n\n    this[kHandle].stopThread();\n\n    // Do not use events.once() here\x2C because the 'exit' event will always be\n    // emitted regardless of any errors\x2C and the point is to only resolve\n    // once the thread has actually stopped.\n    return new Promise((resolve) => {\n      this.once('exit'\x2C resolve);\n    });\n  }\n\n  ref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].ref();\n    this[kPublicPort].ref();\n  }\n\n  unref() {\n    if (this[kHandle] === null) return;\n\n    this[kHandle].unref();\n    this[kPublicPort].unref();\n  }\n\n  get threadId() {\n    if (this[kHandle] === null) return -1;\n\n    return this[kHandle].threadId;\n  }\n\n  get stdin() {\n    return this[kParentSideStdio].stdin;\n  }\n\n  get stdout() {\n    return this[kParentSideStdio].stdout;\n  }\n\n  get stderr() {\n    return this[kParentSideStdio].stderr;\n  }\n\n  get resourceLimits() {\n    if (this[kHandle] === null) return {};\n\n    return makeResourceLimits(this[kHandle].getResourceLimits());\n  }\n\n  getHeapSnapshot() {\n    const heapSnapshotTaker = this[kHandle] && this[kHandle].takeHeapSnapshot();\n    return new Promise((resolve\x2C reject) => {\n      if (!heapSnapshotTaker) return reject(new ERR_WORKER_NOT_RUNNING());\n      heapSnapshotTaker.ondone = (handle) => {\n        const { HeapSnapshotStream } = require('internal/heap_utils');\n        resolve(new HeapSnapshotStream(handle));\n      };\n    });\n  }\n}\n\nfunction pipeWithoutWarning(source\x2C dest) {\n  const sourceMaxListeners = source._maxListeners;\n  const destMaxListeners = dest._maxListeners;\n  source.setMaxListeners(Infinity);\n  dest.setMaxListeners(Infinity);\n\n  source.pipe(dest);\n\n  source._maxListeners = sourceMaxListeners;\n  dest._maxListeners = destMaxListeners;\n}\n\nconst resourceLimitsArray = new Float64Array(kTotalResourceLimitCount);\nfunction parseResourceLimits(obj) {\n  const ret = resourceLimitsArray;\n  TypedArrayPrototypeFill(ret\x2C -1);\n  if (typeof obj !== 'object' || obj === null) return ret;\n\n  if (typeof obj.maxOldGenerationSizeMb === 'number')\n    ret[kMaxOldGenerationSizeMb] = MathMax(obj.maxOldGenerationSizeMb\x2C 2);\n  if (typeof obj.maxYoungGenerationSizeMb === 'number')\n    ret[kMaxYoungGenerationSizeMb] = obj.maxYoungGenerationSizeMb;\n  if (typeof obj.codeRangeSizeMb === 'number')\n    ret[kCodeRangeSizeMb] = obj.codeRangeSizeMb;\n  if (typeof obj.stackSizeMb === 'number')\n    ret[kStackSizeMb] = obj.stackSizeMb;\n  return ret;\n}\n\nfunction makeResourceLimits(float64arr) {\n  return {\n    maxYoungGenerationSizeMb: float64arr[kMaxYoungGenerationSizeMb]\x2C\n    maxOldGenerationSizeMb: float64arr[kMaxOldGenerationSizeMb]\x2C\n    codeRangeSizeMb: float64arr[kCodeRangeSizeMb]\x2C\n    stackSizeMb: float64arr[kStackSizeMb]\n  };\n}\n\nfunction eventLoopUtilization(util1\x2C util2) {\n  // TODO(trevnorris): Works to solve the thread-safe read/write issue of\n  // loopTime\x2C but has the drawback that it can't be set until the event loop\n  // has had a chance to turn. So it will be impossible to read the ELU of\n  // a worker thread immediately after it's been created.\n  if (!this[kIsOnline] || !this[kHandle]) {\n    return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  // Cache loopStart\x2C since it's only written to once.\n  if (this[kLoopStartTime] === -1) {\n    this[kLoopStartTime] = this[kHandle].loopStartTime();\n    if (this[kLoopStartTime] === -1)\n      return { idle: 0\x2C active: 0\x2C utilization: 0 };\n  }\n\n  if (util2) {\n    const idle = util1.idle - util2.idle;\n    const active = util1.active - util2.active;\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\n  }\n\n  const idle = this[kHandle].loopIdleTime();\n\n  // Using performance.now() here is fine since it's always the time from\n  // the beginning of the process\x2C and is why it needs to be offset by the\n  // loopStart time (which is also calculated from the beginning of the\n  // process).\n  const active = now() - this[kLoopStartTime] - idle;\n\n  if (!util1) {\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\n  }\n\n  const idle_delta = idle - util1.idle;\n  const active_delta = active - util1.active;\n  const utilization = active_delta / (idle_delta + active_delta);\n  return { idle: idle_delta\x2C active: active_delta\x2C utilization };\n}\n\nmodule.exports = {\n  ownsProcessState\x2C\n  isMainThread\x2C\n  SHARE_ENV\x2C\n  resourceLimits:\n    !isMainThread ? makeResourceLimits(resourceLimitsRaw) : {}\x2C\n  setEnvironmentData\x2C\n  getEnvironmentData\x2C\n  assignEnvironmentData\x2C\n  threadId\x2C\n  Worker\x2C\n};\n
code-source-info,0xb46b96b2338,434,0,15418,C0O0C4O15418,,
code-creation,Function,10,197707,0xb46b96b3698,1208, node:internal/worker:1:1,0xb46b96b22b0,~
code-source-info,0xb46b96b3698,434,0,15418,C0O0C247O25C253O50C259O71C265O93C270O109C276O134C282O151C288O162C294O178C300O195C306O206C312O224C318O240C324O263C330O284C335O295C341O305C346O315C351O328C357O355C368O384C374O393C379O453C387O453C392O487C400O487C404O487C406O528C414O528C418O528C420O561C428O561C434O553C440O613C448O613C454O639C458O613C460O820C464O657C470O683C476O702C482O737C488O769C494O793C500O859C508O859C514O840C520O906C528O906C532O906C534O1153C538O947C544O967C550O985C556O1001C562O1010C568O1032C574O1051C580O1082C586O1106C592O1129C598O1192C606O1192C612O1171C618O1282C626O1282C632O1234C638O1249C644O1264C650O1332C658O1332C664O1315C670O1384C678O1384C684O1366C690O1655C694O1655C700O1427C705O1447C710O1479C715O1500C721O1520C727O1534C733O1563C739O1590C745O1610C751O1626C756O1699C760O1699C764O1699C766O1738C770O1738C774O1738C776O1778C780O1778C784O1778C786O1814C790O1814C794O1814C796O1852C800O1852C804O1852C806O1906C810O1906C814O1906C816O1965C820O1965C824O1965C826O2017C830O2017C834O2017C836O2068C840O2068C844O2068C846O2112C850O2112C854O2112C856O2152C860O2152C864O2152C866O2210C874O2210C880O2243C896O2244C902O2210C904O2296C905O2296C907O2333C909O2333C914O2333C916O2349C927O2371C933O2400C942O2384C947O2382C951O2451C957O2459C961O2451C963O2468C973O2482C979O2964C989O8037C999O8673C1009O8773C1019O8946C1029O9843C1115O12725C1117O12725C1122O12725C1124O15174C1132O15195C1138O15215C1144O15231C1153O15265C1159O15280C1172O15326C1178O15348C1184O15370C1190O15395C1196O15407C1202O15189C1207O15417,,
tick,0x7ff805e2d43e,197840,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b96b139b,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b96b0880,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805edebe6,197856,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46b96b139b,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b96b0880,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,198024,0xb46b96b5610,5, node:internal/error_serdes:1:1,0xb46b96b5348,~
script-source,435,node:internal/error_serdes,'use strict';\n\nconst Buffer = require('buffer').Buffer;\nconst {\n  ArrayPrototypeForEach\x2C\n  Error\x2C\n  EvalError\x2C\n  FunctionPrototypeCall\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeToString\x2C\n  RangeError\x2C\n  ReferenceError\x2C\n  SafeSet\x2C\n  SymbolToStringTag\x2C\n  SyntaxError\x2C\n  TypeError\x2C\n  URIError\x2C\n} = primordials;\n\nconst kSerializedError = 0;\nconst kSerializedObject = 1;\nconst kInspectedError = 2;\n\nconst errors = {\n  Error\x2C TypeError\x2C RangeError\x2C URIError\x2C SyntaxError\x2C ReferenceError\x2C EvalError\n};\nconst errorConstructorNames = new SafeSet(ObjectKeys(errors));\n\nfunction TryGetAllProperties(object\x2C target = object) {\n  const all = ObjectCreate(null);\n  if (object === null)\n    return all;\n  ObjectAssign(all\x2C\n               TryGetAllProperties(ObjectGetPrototypeOf(object)\x2C target));\n  const keys = ObjectGetOwnPropertyNames(object);\n  ArrayPrototypeForEach(keys\x2C (key) => {\n    let descriptor;\n    try {\n      descriptor = ObjectGetOwnPropertyDescriptor(object\x2C key);\n    } catch { return; }\n    const getter = descriptor.get;\n    if (getter && key !== '__proto__') {\n      try {\n        descriptor.value = FunctionPrototypeCall(getter\x2C target);\n      } catch {\n        // Continue regardless of error.\n      }\n    }\n    if ('value' in descriptor && typeof descriptor.value !== 'function') {\n      delete descriptor.get;\n      delete descriptor.set;\n      all[key] = descriptor;\n    }\n  });\n  return all;\n}\n\nfunction GetConstructors(object) {\n  const constructors = [];\n\n  for (let current = object;\n    current !== null;\n    current = ObjectGetPrototypeOf(current)) {\n    const desc = ObjectGetOwnPropertyDescriptor(current\x2C 'constructor');\n    if (desc && desc.value) {\n      ObjectDefineProperty(constructors\x2C constructors.length\x2C {\n        __proto__: null\x2C\n        value: desc.value\x2C enumerable: true\n      });\n    }\n  }\n\n  return constructors;\n}\n\nfunction GetName(object) {\n  const desc = ObjectGetOwnPropertyDescriptor(object\x2C 'name');\n  return desc && desc.value;\n}\n\nlet internalUtilInspect;\nfunction inspect(...args) {\n  if (!internalUtilInspect) {\n    internalUtilInspect = require('internal/util/inspect');\n  }\n  return internalUtilInspect.inspect(...args);\n}\n\nlet serialize;\nfunction serializeError(error) {\n  if (!serialize) serialize = require('v8').serialize;\n  try {\n    if (typeof error === 'object' &&\n        ObjectPrototypeToString(error) === '[object Error]') {\n      const constructors = GetConstructors(error);\n      for (let i = 0; i < constructors.length; i++) {\n        const name = GetName(constructors[i]);\n        if (errorConstructorNames.has(name)) {\n          const serialized = serialize({\n            constructor: name\x2C\n            properties: TryGetAllProperties(error)\n          });\n          return Buffer.concat([Buffer.from([kSerializedError])\x2C serialized]);\n        }\n      }\n    }\n  } catch {\n    // Continue regardless of error.\n  }\n  try {\n    const serialized = serialize(error);\n    return Buffer.concat([Buffer.from([kSerializedObject])\x2C serialized]);\n  } catch {\n    // Continue regardless of error.\n  }\n  return Buffer.concat([Buffer.from([kInspectedError])\x2C\n                        Buffer.from(inspect(error)\x2C 'utf8')]);\n}\n\nlet deserialize;\nfunction deserializeError(error) {\n  if (!deserialize) deserialize = require('v8').deserialize;\n  switch (error[0]) {\n    case kSerializedError: {\n      const { constructor\x2C properties } = deserialize(error.subarray(1));\n      const ctor = errors[constructor];\n      ObjectDefineProperty(properties\x2C SymbolToStringTag\x2C {\n        __proto__: null\x2C\n        value: { value: 'Error'\x2C configurable: true }\x2C\n        enumerable: true\n      });\n      return ObjectCreate(ctor.prototype\x2C properties);\n    }\n    case kSerializedObject:\n      return deserialize(error.subarray(1));\n    case kInspectedError: {\n      const buf = Buffer.from(error.buffer\x2C\n                              error.byteOffset + 1\x2C\n                              error.byteLength - 1);\n      return buf.toString('utf8');\n    }\n  }\n  require('assert').fail('This should not happen');\n}\n\nmodule.exports = { serializeError\x2C deserializeError };\n
code-source-info,0xb46b96b5610,435,0,4224,C0O0C4O4224,,
code-creation,Function,10,198526,0xb46b96b5a30,335, node:internal/error_serdes:1:1,0xb46b96b5588,~
code-source-info,0xb46b96b5a30,435,0,4224,C0O0C100O30C106O30C111O47C115O30C117O66C123O91C128O100C133O113C139O138C145O154C151O170C157O194C163O228C169O257C175O281C180O295C186O322C191O336C196O354C201O365C207O386C212O401C217O414C222O467C223O467C225O496C227O496C229O523C231O523C233O542C240O546C246O553C252O564C258O576C264O586C270O599C276O615C282O542C284O658C287O670C294O658C299O658C301O2111C302O2111C304O2308C305O2308C307O3309C308O3309C310O4169C317O4188C323O4204C329O4184C334O4223,,
code-creation,Function,11,198708,0x1132465c0,960,debuglog node:internal/util/debuglog:71:18,0xb469fcd9d68,^
code-source-info,0x1132465c0,28,2232,3240,,,
tick,0x103b6a0bc,198774,0,0x0,0,0x102d66340,0xb469fbd23d1,0xb46b96b3a18,0x113244eeb,0x1132442e1,0xb46b96b139b,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb46bbe73ea8,0xb46bbe73acc,0xb46b9692570,0xb46b96b0880,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Function,11,198791,0x113246a00,40,toNamespacedPath node:path:1266:19,0xb46806acf28,^
code-source-info,0x113246a00,71,38608,38668,,,
code-creation,Function,11,198822,0x113246ac0,168,nextPart node:fs:2463:31,0xb46d10989e0,^
code-source-info,0x113246ac0,73,65684,65742,,,
code-creation,Function,11,198844,0x113246c00,308,isFileType node:fs:218:20,0xb46d1096dc0,^
code-source-info,0x113246c00,73,5624,5865,,,
code-creation,Function,11,198867,0x113246dc0,272,validateString node:internal/validators:114:24,0xb466517a5c0,^
code-source-info,0x113246dc0,22,3228,3337,,,
code-creation,Function,11,198900,0x113246f80,1296,dirname node:path:1275:10,0xb46806acf78,^
code-source-info,0x113246f80,71,38741,39410,,,
code-creation,Function,11,198925,0x113247540,1292,deprecate node:internal/util:96:19,0xb46651773e0,^
code-source-info,0x113247540,21,2401,3577,,,
code-creation,Function,11,198945,0x113247b00,296,getOwn node:internal/bootstrap/loaders:187:16,0xb466514b458,^
code-source-info,0x113247b00,15,5646,5800,,,
code-creation,Function,11,198968,0x113247cc0,668,syncExports node:internal/bootstrap/loaders:304:14,0xb466514b7c0,^
code-source-info,0x113247cc0,15,9630,9963,,,
code-creation,Function,11,198996,0x113248000,240,SafeSet node:internal/per_context/primordials:379:16,0xb4665146108,^
code-source-info,0x113248000,12,10928,10945,,,
code-creation,Function,11,199017,0x113248180,200, node:vm:321:27,0xb46b968f4a0,^
code-source-info,0x113248180,85,9845,9896,,,
code-creation,Function,11,199036,0x113248300,44,noop node:internal/util/debuglog:47:14,0xb469fcd9cc8,^
code-source-info,0x113248300,28,1419,1427,,,
code-creation,LazyCompile,10,199517,0xb46b96b7010,914,Socket node:net:294:16,0xb469fbf4510,~
code-source-info,0xb46b96b7010,406,7386,11869,C0O7400C2O7411C7O7431C12O7438C17O7458C18O7461C25O7472C34O7492C42O7567C52O7498C57O7492C58O7620C65O7631C81O7662C90O7690C98O7757C115O7846C121O7876C131O7696C136O7690C137O7934C144O7952C155O7999C167O8028C178O7999C183O8109C189O8131C194O8144C195O8174C199O8192C200O8208C204O8412C206O8417C211O8434C215O8442C216O8457C220O8468C222O8473C226O8482C230O8492C231O8505C235O8515C236O8526C240O8536C242O8541C246O8562C250O8569C252O8574C256O8584C260O8594C262O8599C266O8608C270O8618C272O8623C276O8634C280O8644C282O8649C286O8661C290O8672C296O8709C303O8725C314O8768C320O8847C322O8871C325O8887C330O8871C334O8869C338O8961C339O8979C343O8990C344O9010C348O9050C349O9072C353O9083C358O9090C363O9097C368O9097C374O9133C380O9170C384O9160C388O9193C390O9198C396O9236C401O9217C405O9215C411O9267C417O9299C422O9323C424O9441C429O9456C434O9454C438O9497C443O9505C448O9505C454O9762C456O9777C464O9783C469O9777C470O9817C472O9822C475O9846C480O9854C485O9854C489O9839C493O9873C495O9881C502O9893C507O9917C514O9936C516O9925C523O9945C527O10027C532O10035C539O10035C545O10060C547O10077C555O10083C560O10077C561O10126C562O10139C566O10153C568O10167C571O10167C575O10165C579O10358C584O10384C597O10358C602O10515C607O10525C617O10585C620O10605C625O10585C631O10630C639O10676C647O10725C655O10756C657O10761C661O10770C665O10784C667O10789C670O10810C674O10801C680O10837C682O10842C685O10860C689O10851C693O10878C695O10883C698O10903C702O10894C706O10920C708O10925C713O10940C716O10956C721O10940C725O10938C729O10968C731O10973C736O10990C739O11006C744O10990C748O10988C752O11020C754O11025C757O11065C761O11087C767O11055C769O11054C771O11052C775O11159C786O11159C792O11194C795O11194C799O11221C800O11239C804O11249C806O11271C810O11412C816O11431C822O11440C827O11469C833O11556C839O11572C843O11592C848O11600C853O11600C857O11618C858O11639C864O11672C870O11698C877O11698C882O11744C883O11756C887O11766C888O11779C892O11819C894O11824C898O11836C902O11843C904O11848C908O11863C913O11868,,
code-creation,LazyCompile,10,199702,0xb46b96b7760,169,Duplex node:internal/streams/duplex:54:16,0xb46d2cbf9a0,~
script-source,57,node:internal/streams/duplex,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototype inheritance\x2C this class\n// prototypically inherits from Readable\x2C and then parasitically from\n// Writable.\n\n'use strict';\n\nconst {\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nmodule.exports = Duplex;\n\nconst Readable = require('internal/streams/readable');\nconst Writable = require('internal/streams/writable');\n\nObjectSetPrototypeOf(Duplex.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(Duplex\x2C Readable);\n\n{\n  const keys = ObjectKeys(Writable.prototype);\n  // Allow the keys array to be GC'ed.\n  for (let i = 0; i < keys.length; i++) {\n    const method = keys[i];\n    if (!Duplex.prototype[method])\n      Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex))\n    return new Duplex(options);\n\n  Readable.call(this\x2C options);\n  Writable.call(this\x2C options);\n\n  if (options) {\n    this.allowHalfOpen = options.allowHalfOpen !== false;\n\n    if (options.readable === false) {\n      this._readableState.readable = false;\n      this._readableState.ended = true;\n      this._readableState.endEmitted = true;\n    }\n\n    if (options.writable === false) {\n      this._writableState.writable = false;\n      this._writableState.ending = true;\n      this._writableState.ended = true;\n      this._writableState.finished = true;\n    }\n  } else {\n    this.allowHalfOpen = true;\n  }\n}\n\nObjectDefineProperties(Duplex.prototype\x2C {\n  writable:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writable') }\x2C\n  writableHighWaterMark:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableHighWaterMark') }\x2C\n  writableObjectMode:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableObjectMode') }\x2C\n  writableBuffer:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableBuffer') }\x2C\n  writableLength:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableLength') }\x2C\n  writableFinished:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableFinished') }\x2C\n  writableCorked:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableCorked') }\x2C\n  writableEnded:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableEnded') }\x2C\n  writableNeedDrain:\n    { __proto__: null\x2C ...ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableNeedDrain') }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    get() {\n      if (this._readableState === undefined ||\n        this._writableState === undefined) {\n        return false;\n      }\n      return this._readableState.destroyed && this._writableState.destroyed;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      if (this._readableState && this._writableState) {\n        this._readableState.destroyed = value;\n        this._writableState.destroyed = value;\n      }\n    }\n  }\n});\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nDuplex.fromWeb = function(pair\x2C options) {\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(\n    pair\x2C\n    options);\n};\n\nDuplex.toWeb = function(duplex) {\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\n};\n\nlet duplexify;\n\nDuplex.from = function(body) {\n  if (!duplexify) {\n    duplexify = require('internal/streams/duplexify');\n  }\n  return duplexify(body\x2C 'body');\n};\n
code-source-info,0xb46b96b7760,57,2011,2663,C0O2025C2O2036C7O2060C12O2067C17O2087C18O2091C23O2100C28O2100C34O2123C39O2132C44O2132C50O2156C54O2204C60O2218C64O2194C68O2246C74O2255C79O2279C85O2303C89O2323C95O2344C99O2363C105O2389C109O2420C115O2429C120O2453C126O2477C130O2497C136O2519C140O2538C146O2559C150O2578C156O2602C162O2631C163O2650C168O2662,,
tick,0x10258952b,200332,0,0x0,3,0x102d6ee20,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,200670,0xb46b96b7f20,220,Readable node:internal/streams/readable:186:18,0xb468068bc40,~
script-source,58,node:internal/streams/readable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  NumberIsInteger\x2C\n  NumberIsNaN\x2C\n  NumberParseInt\x2C\n  ObjectDefineProperties\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  Promise\x2C\n  SafeSet\x2C\n  SymbolAsyncIterator\x2C\n  Symbol\n} = primordials;\n\nmodule.exports = Readable;\nReadable.ReadableState = ReadableState;\n\nconst EE = require('events');\nconst { Stream\x2C prependListener } = require('internal/streams/legacy');\nconst { Buffer } = require('buffer');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\nconst eos = require('internal/streams/end-of-stream');\n\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\n  debug = fn;\n});\nconst BufferList = require('internal/streams/buffer_list');\nconst destroyImpl = require('internal/streams/destroy');\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n    ERR_OUT_OF_RANGE\x2C\n    ERR_STREAM_PUSH_AFTER_EOF\x2C\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\x2C\n  }\n} = require('internal/errors');\nconst { validateObject } = require('internal/validators');\n\nconst kPaused = Symbol('kPaused');\n\nconst { StringDecoder } = require('string_decoder');\nconst from = require('internal/streams/from');\n\nObjectSetPrototypeOf(Readable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Readable\x2C Stream);\nconst nop = () => {};\n\nconst { errorOrDestroy } = destroyImpl;\n\nfunction ReadableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.readableObjectMode);\n\n  // The point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value\x2C means "don't call _read preemptively ever"\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift().\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = [];\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately\x2C or on a later tick.  We set this to true at first\x2C because\n  // any actions that shouldn't happen until "later" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // Whenever we return null\x2C then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n  this[kPaused] = null;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'end' (and potentially 'finish').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Has it been destroyed.\n  this.destroyed = false;\n\n  // Indicates whether the stream has errored. When true no further\n  // _read calls\x2C 'data' or 'readable' events should occur. This is needed\n  // since when autoDestroy is disabled we need a way to tell whether the\n  // stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Ref the piped dest which we need a drain event on it\n  // type: null | Writable | Set<Writable>.\n  this.awaitDrainWriters = null;\n  this.multiAwaitDrain = false;\n\n  // If true\x2C a maybeReadMore has been scheduled.\n  this.readingMore = false;\n\n  this.dataEmitted = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options && options.encoding) {\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\n\nfunction Readable(options) {\n  if (!(this instanceof Readable))\n    return new Readable(options);\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the ReadableState constructor\x2C at least with V8 6.5.\n  const isDuplex = this instanceof Stream.Duplex;\n\n  this._readableState = new ReadableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.read === 'function')\n      this._read = options.read;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal && !isDuplex)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    if (this._readableState.needReadable) {\n      maybeReadMore(this\x2C this._readableState);\n    }\n  });\n}\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet\x2C\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C false);\n};\n\n// Unshift should *always* be something directly out of read().\nReadable.prototype.unshift = function(chunk\x2C encoding) {\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C true);\n};\n\nfunction readableAddChunk(stream\x2C chunk\x2C encoding\x2C addToFront) {\n  debug('readableAddChunk'\x2C chunk);\n  const state = stream._readableState;\n\n  let err;\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (state.encoding !== encoding) {\n        if (addToFront && state.encoding) {\n          // When unshifting\x2C if state.encoding is set\x2C we have to save\n          // the string in the BufferList with the state encoding.\n          chunk = Buffer.from(chunk\x2C encoding).toString(state.encoding);\n        } else {\n          chunk = Buffer.from(chunk\x2C encoding);\n          encoding = '';\n        }\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = '';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = '';\n    } else if (chunk != null) {\n      err = new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  if (err) {\n    errorOrDestroy(stream\x2C err);\n  } else if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream\x2C state);\n  } else if (state.objectMode || (chunk && chunk.length > 0)) {\n    if (addToFront) {\n      if (state.endEmitted)\n        errorOrDestroy(stream\x2C new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\n      else if (state.destroyed || state.errored)\n        return false;\n      else\n        addChunk(stream\x2C state\x2C chunk\x2C true);\n    } else if (state.ended) {\n      errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\n    } else if (state.destroyed || state.errored) {\n      return false;\n    } else {\n      state.reading = false;\n      if (state.decoder && !encoding) {\n        chunk = state.decoder.write(chunk);\n        if (state.objectMode || chunk.length !== 0)\n          addChunk(stream\x2C state\x2C chunk\x2C false);\n        else\n          maybeReadMore(stream\x2C state);\n      } else {\n        addChunk(stream\x2C state\x2C chunk\x2C false);\n      }\n    }\n  } else if (!addToFront) {\n    state.reading = false;\n    maybeReadMore(stream\x2C state);\n  }\n\n  // We can push more data if we are below the highWaterMark.\n  // Also\x2C if we have no data yet\x2C we can stand some more bytes.\n  // This is to work around cases where hwm=0\x2C such as the repl.\n  return !state.ended &&\n    (state.length < state.highWaterMark || state.length === 0);\n}\n\nfunction addChunk(stream\x2C state\x2C chunk\x2C addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync &&\n      stream.listenerCount('data') > 0) {\n    // Use the guard to avoid creating `Set()` repeatedly\n    // when we have multiple pipes.\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n\n    state.dataEmitted = true;\n    stream.emit('data'\x2C chunk);\n  } else {\n    // Update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront)\n      state.buffer.unshift(chunk);\n    else\n      state.buffer.push(chunk);\n\n    if (state.needReadable)\n      emitReadable(stream);\n  }\n  maybeReadMore(stream\x2C state);\n}\n\nReadable.prototype.isPaused = function() {\n  const state = this._readableState;\n  return state[kPaused] === true || state.flowing === false;\n};\n\n// Backwards compatibility.\nReadable.prototype.setEncoding = function(enc) {\n  const decoder = new StringDecoder(enc);\n  this._readableState.decoder = decoder;\n  // If setEncoding(null)\x2C decoder.encoding equals utf8.\n  this._readableState.encoding = this._readableState.decoder.encoding;\n\n  const buffer = this._readableState.buffer;\n  // Iterate over current buffer to convert already stored Buffers:\n  let content = '';\n  for (const data of buffer) {\n    content += decoder.write(data);\n  }\n  buffer.clear();\n  if (content !== '')\n    buffer.push(content);\n  this._readableState.length = content.length;\n  return this;\n};\n\n// Don't raise the hwm > 1GB.\nconst MAX_HWM = 0x40000000;\nfunction computeNewHighWaterMark(n) {\n  if (n > MAX_HWM) {\n    throw new ERR_OUT_OF_RANGE('size'\x2C '<= 1GiB'\x2C n);\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts.\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n\x2C state) {\n  if (n <= 0 || (state.length === 0 && state.ended))\n    return 0;\n  if (state.objectMode)\n    return 1;\n  if (NumberIsNaN(n)) {\n    // Only flow one buffer at a time.\n    if (state.flowing && state.length)\n      return state.buffer.first().length;\n    return state.length;\n  }\n  if (n <= state.length)\n    return n;\n  return state.ended ? state.length : 0;\n}\n\n// You can override either this method\x2C or the async _read(n) below.\nReadable.prototype.read = function(n) {\n  debug('read'\x2C n);\n  // Same as parseInt(undefined\x2C 10)\x2C however V8 7.3 performance regressed\n  // in this scenario\x2C so we are doing it manually.\n  if (n === undefined) {\n    n = NaN;\n  } else if (!NumberIsInteger(n)) {\n    n = NumberParseInt(n\x2C 10);\n  }\n  const state = this._readableState;\n  const nOrig = n;\n\n  // If we're asking for more than the current hwm\x2C then raise the hwm.\n  if (n > state.highWaterMark)\n    state.highWaterMark = computeNewHighWaterMark(n);\n\n  if (n !== 0)\n    state.emittedReadable = false;\n\n  // If we're doing read(0) to trigger a readable event\x2C but we\n  // already have a bunch of data in the buffer\x2C then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 &&\n      state.needReadable &&\n      ((state.highWaterMark !== 0 ?\n        state.length >= state.highWaterMark :\n        state.length > 0) ||\n       state.ended)) {\n    debug('read: emitReadable'\x2C state.length\x2C state.ended);\n    if (state.length === 0 && state.ended)\n      endReadable(this);\n    else\n      emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n\x2C state);\n\n  // If we've ended\x2C and we're now clear\x2C then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0)\n      endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases\x2C such as passthrough streams\x2C _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer\x2C providing enough data when\n  // before there was *not* enough.\n  //\n  // So\x2C the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read\x2C then call _read.\n  // Note that this may be asynchronous\x2C or synchronous.  Yes\x2C it is\n  // deeply ugly to write APIs this way\x2C but that still doesn't mean\n  // that the Readable class should behave improperly\x2C as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie\x2C if the read call\n  // has returned yet)\x2C so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event\x2C then we need to do some reading.\n  let doRead = state.needReadable;\n  debug('need readable'\x2C doRead);\n\n  // If we currently have less than the highWaterMark\x2C then also read some.\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark'\x2C doRead);\n  }\n\n  // However\x2C if we've ended\x2C then there's no point\x2C if we're already\n  // reading\x2C then it's unnecessary\x2C if we're constructing we have to wait\x2C\n  // and if we're destroyed or errored\x2C then it's not allowed\x2C\n  if (state.ended || state.reading || state.destroyed || state.errored ||\n      !state.constructed) {\n    doRead = false;\n    debug('reading\x2C ended or constructing'\x2C doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // If the length is currently zero\x2C then we *need* a readable event.\n    if (state.length === 0)\n      state.needReadable = true;\n\n    // Call internal read method\n    try {\n      this._read(state.highWaterMark);\n    } catch (err) {\n      errorOrDestroy(this\x2C err);\n    }\n\n    state.sync = false;\n    // If _read pushed data synchronously\x2C then `reading` will be false\x2C\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading)\n      n = howMuchToRead(nOrig\x2C state);\n  }\n\n  let ret;\n  if (n > 0)\n    ret = fromList(n\x2C state);\n  else\n    ret = null;\n\n  if (ret === null) {\n    state.needReadable = state.length <= state.highWaterMark;\n    n = 0;\n  } else {\n    state.length -= n;\n    if (state.multiAwaitDrain) {\n      state.awaitDrainWriters.clear();\n    } else {\n      state.awaitDrainWriters = null;\n    }\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer\x2C then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended)\n      state.needReadable = true;\n\n    // If we tried to read() past the EOF\x2C then emit end on the next tick.\n    if (nOrig !== n && state.ended)\n      endReadable(this);\n  }\n\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\n    state.dataEmitted = true;\n    this.emit('data'\x2C ret);\n  }\n\n  return ret;\n};\n\nfunction onEofChunk(stream\x2C state) {\n  debug('onEofChunk');\n  if (state.ended) return;\n  if (state.decoder) {\n    const chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  if (state.sync) {\n    // If we are sync\x2C wait until next tick to emit the data.\n    // Otherwise we risk emitting data in the flow()\n    // the readable code triggers during a read() call.\n    emitReadable(stream);\n  } else {\n    // Emit 'readable' now to make sure it gets picked up.\n    state.needReadable = false;\n    state.emittedReadable = true;\n    // We have to emit readable now that we are EOF. Modules\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\n    emitReadable_(stream);\n  }\n}\n\n// Don't emit readable right away in sync mode\x2C because this can trigger\n// another read() call => stack overflow.  This way\x2C it might trigger\n// a nextTick recursion warning\x2C but that's not so bad.\nfunction emitReadable(stream) {\n  const state = stream._readableState;\n  debug('emitReadable'\x2C state.needReadable\x2C state.emittedReadable);\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable'\x2C state.flowing);\n    state.emittedReadable = true;\n    process.nextTick(emitReadable_\x2C stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  const state = stream._readableState;\n  debug('emitReadable_'\x2C state.destroyed\x2C state.length\x2C state.ended);\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\n    stream.emit('readable');\n    state.emittedReadable = false;\n  }\n\n  // The stream needs another readable event if:\n  // 1. It is not flowing\x2C as the flow mechanism will take\n  //    care of it.\n  // 2. It is not ended.\n  // 3. It is below the highWaterMark\x2C so we can schedule\n  //    another readable later.\n  state.needReadable =\n    !state.flowing &&\n    !state.ended &&\n    state.length <= state.highWaterMark;\n  flow(stream);\n}\n\n\n// At this point\x2C the user has presumably seen the 'readable' event\x2C\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call\x2C in which case reading = true if\n// it's in progress.\n// However\x2C if we're not ended\x2C or reading\x2C and the length < hwm\x2C\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream\x2C state) {\n  if (!state.readingMore && state.constructed) {\n    state.readingMore = true;\n    process.nextTick(maybeReadMore_\x2C stream\x2C state);\n  }\n}\n\nfunction maybeReadMore_(stream\x2C state) {\n  // Attempt to read more data if we should.\n  //\n  // The conditions for reading more data are (one of):\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\n  //   is responsible for filling the buffer with enough data if such data\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\n  //   when the stream consumer calls read() instead.\n  // - No data in the buffer\x2C and the stream is in flowing mode. In this mode\n  //   the loop below is responsible for ensuring read() is called. Failing to\n  //   call read here would abort the flow and there's no other mechanism for\n  //   continuing the flow if the stream consumer has just subscribed to the\n  //   'data' event.\n  //\n  // In addition to the above conditions to keep reading data\x2C the following\n  // conditions prevent the data from being read:\n  // - The stream has ended (state.ended).\n  // - There is already a pending 'read' operation (state.reading). This is a\n  //   case where the stream has called the implementation defined _read()\n  //   method\x2C but they are processing the call asynchronously and have _not_\n  //   called push() with new data. In this case we skip performing more\n  //   read()s. The execution ends in this method again after the _read() ends\n  //   up calling push() with more data.\n  while (!state.reading && !state.ended &&\n         (state.length < state.highWaterMark ||\n          (state.flowing && state.length === 0))) {\n    const len = state.length;\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // Didn't get any data\x2C stop spinning.\n      break;\n  }\n  state.readingMore = false;\n}\n\n// Abstract method.  to be overridden in specific implementation classes.\n// call cb(er\x2C data) where data is <= n in length.\n// for virtual (non-string\x2C non-buffer) streams\x2C "length" is somewhat\n// arbitrary\x2C and perhaps not very meaningful.\nReadable.prototype._read = function(n) {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\n};\n\nReadable.prototype.pipe = function(dest\x2C pipeOpts) {\n  const src = this;\n  const state = this._readableState;\n\n  if (state.pipes.length === 1) {\n    if (!state.multiAwaitDrain) {\n      state.multiAwaitDrain = true;\n      state.awaitDrainWriters = new SafeSet(\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : []\n      );\n    }\n  }\n\n  state.pipes.push(dest);\n  debug('pipe count=%d opts=%j'\x2C state.pipes.length\x2C pipeOpts);\n\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\n              dest !== process.stdout &&\n              dest !== process.stderr;\n\n  const endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted)\n    process.nextTick(endFn);\n  else\n    src.once('end'\x2C endFn);\n\n  dest.on('unpipe'\x2C onunpipe);\n  function onunpipe(readable\x2C unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  let ondrain;\n\n  let cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // Cleanup event handlers once the pipe is broken.\n    dest.removeListener('close'\x2C onclose);\n    dest.removeListener('finish'\x2C onfinish);\n    if (ondrain) {\n      dest.removeListener('drain'\x2C ondrain);\n    }\n    dest.removeListener('error'\x2C onerror);\n    dest.removeListener('unpipe'\x2C onunpipe);\n    src.removeListener('end'\x2C onend);\n    src.removeListener('end'\x2C unpipe);\n    src.removeListener('data'\x2C ondata);\n\n    cleanedUp = true;\n\n    // If the reader is waiting for a drain event from this\n    // specific writer\x2C then it would cause it to never start\n    // flowing again.\n    // So\x2C if this is awaiting a drain\x2C then we just call it now.\n    // If we don't know\x2C then assume that we are waiting for one.\n    if (ondrain && state.awaitDrainWriters &&\n        (!dest._writableState || dest._writableState.needDrain))\n      ondrain();\n  }\n\n  function pause() {\n    // If the user unpiped during `dest.write()`\x2C it is possible\n    // to get stuck in a permanently paused state if that write\n    // also returned false.\n    // => Check whether `dest` is still a piping destination.\n    if (!cleanedUp) {\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\n        debug('false write response\x2C pause'\x2C 0);\n        state.awaitDrainWriters = dest;\n        state.multiAwaitDrain = false;\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\n        debug('false write response\x2C pause'\x2C state.awaitDrainWriters.size);\n        state.awaitDrainWriters.add(dest);\n      }\n      src.pause();\n    }\n    if (!ondrain) {\n      // When the dest drains\x2C it reduces the awaitDrain counter\n      // on the source.  This would be more elegant with a .once()\n      // handler in flow()\x2C but adding and removing repeatedly is\n      // too slow.\n      ondrain = pipeOnDrain(src\x2C dest);\n      dest.on('drain'\x2C ondrain);\n    }\n  }\n\n  src.on('data'\x2C ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    const ret = dest.write(chunk);\n    debug('dest.write'\x2C ret);\n    if (ret === false) {\n      pause();\n    }\n  }\n\n  // If the dest has an error\x2C then stop piping into it.\n  // However\x2C don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror'\x2C er);\n    unpipe();\n    dest.removeListener('error'\x2C onerror);\n    if (dest.listenerCount('error') === 0) {\n      const s = dest._writableState || dest._readableState;\n      if (s && !s.errorEmitted) {\n        // User incorrectly emitted 'error' directly on the stream.\n        errorOrDestroy(dest\x2C er);\n      } else {\n        dest.emit('error'\x2C er);\n      }\n    }\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Both close and finish should trigger unpipe\x2C but only once.\n  function onclose() {\n    dest.removeListener('finish'\x2C onfinish);\n    unpipe();\n  }\n  dest.once('close'\x2C onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close'\x2C onclose);\n    unpipe();\n  }\n  dest.once('finish'\x2C onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // Tell the dest that it's being piped to.\n  dest.emit('pipe'\x2C src);\n\n  // Start the flow if it hasn't been started already.\n\n  if (dest.writableNeedDrain === true) {\n    if (state.flowing) {\n      pause();\n    }\n  } else if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src\x2C dest) {\n  return function pipeOnDrainFunctionResult() {\n    const state = src._readableState;\n\n    // `ondrain` will call directly\x2C\n    // `this` maybe not a reference to dest\x2C\n    // so we use the real dest here.\n    if (state.awaitDrainWriters === dest) {\n      debug('pipeOnDrain'\x2C 1);\n      state.awaitDrainWriters = null;\n    } else if (state.multiAwaitDrain) {\n      debug('pipeOnDrain'\x2C state.awaitDrainWriters.size);\n      state.awaitDrainWriters.delete(dest);\n    }\n\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\n      src.listenerCount('data')) {\n      src.resume();\n    }\n  };\n}\n\n\nReadable.prototype.unpipe = function(dest) {\n  const state = this._readableState;\n  const unpipeInfo = { hasUnpiped: false };\n\n  // If we're not piping anywhere\x2C then do nothing.\n  if (state.pipes.length === 0)\n    return this;\n\n  if (!dest) {\n    // remove all.\n    const dests = state.pipes;\n    state.pipes = [];\n    this.pause();\n\n    for (let i = 0; i < dests.length; i++)\n      dests[i].emit('unpipe'\x2C this\x2C { hasUnpiped: false });\n    return this;\n  }\n\n  // Try to find the right one.\n  const index = ArrayPrototypeIndexOf(state.pipes\x2C dest);\n  if (index === -1)\n    return this;\n\n  state.pipes.splice(index\x2C 1);\n  if (state.pipes.length === 0)\n    this.pause();\n\n  dest.emit('unpipe'\x2C this\x2C unpipeInfo);\n\n  return this;\n};\n\n// Set up data events if they are asked for\n// Ensure readable listeners eventually get something.\nReadable.prototype.on = function(ev\x2C fn) {\n  const res = Stream.prototype.on.call(this\x2C ev\x2C fn);\n  const state = this._readableState;\n\n  if (ev === 'data') {\n    // Update readableListening so that resume() may be a no-op\n    // a few lines down. This is needed to support once('readable').\n    state.readableListening = this.listenerCount('readable') > 0;\n\n    // Try start flowing on next tick if stream isn't explicitly paused.\n    if (state.flowing !== false)\n      this.resume();\n  } else if (ev === 'readable') {\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.flowing = false;\n      state.emittedReadable = false;\n      debug('on readable'\x2C state.length\x2C state.reading);\n      if (state.length) {\n        emitReadable(this);\n      } else if (!state.reading) {\n        process.nextTick(nReadingNextTick\x2C this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nReadable.prototype.removeListener = function(ev\x2C fn) {\n  const res = Stream.prototype.removeListener.call(this\x2C\n                                                   ev\x2C fn);\n\n  if (ev === 'readable') {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\nReadable.prototype.off = Readable.prototype.removeListener;\n\nReadable.prototype.removeAllListeners = function(ev) {\n  const res = Stream.prototype.removeAllListeners.apply(this\x2C\n                                                        arguments);\n\n  if (ev === 'readable' || ev === undefined) {\n    // We need to check if there is someone still listening to\n    // readable and reset the state. However this needs to happen\n    // after readable has been emitted but before I/O (nextTick) to\n    // support once('readable'\x2C fn) cycles. This means that calling\n    // resume within the same tick will have no\n    // effect.\n    process.nextTick(updateReadableListening\x2C this);\n  }\n\n  return res;\n};\n\nfunction updateReadableListening(self) {\n  const state = self._readableState;\n  state.readableListening = self.listenerCount('readable') > 0;\n\n  if (state.resumeScheduled && state[kPaused] === false) {\n    // Flowing needs to be set to true now\x2C otherwise\n    // the upcoming resume will not flow.\n    state.flowing = true;\n\n    // Crude way to check if we should resume.\n  } else if (self.listenerCount('data') > 0) {\n    self.resume();\n  } else if (!state.readableListening) {\n    state.flowing = null;\n  }\n}\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them\x2C then switch into old mode.\nReadable.prototype.resume = function() {\n  const state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    // We flow only if there is no one listening\n    // for readable\x2C but we still have to call\n    // resume().\n    state.flowing = !state.readableListening;\n    resume(this\x2C state);\n  }\n  state[kPaused] = false;\n  return this;\n};\n\nfunction resume(stream\x2C state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    process.nextTick(resume_\x2C stream\x2C state);\n  }\n}\n\nfunction resume_(stream\x2C state) {\n  debug('resume'\x2C state.reading);\n  if (!state.reading) {\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading)\n    stream.read(0);\n}\n\nReadable.prototype.pause = function() {\n  debug('call pause flowing=%j'\x2C this._readableState.flowing);\n  if (this._readableState.flowing !== false) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  this._readableState[kPaused] = true;\n  return this;\n};\n\nfunction flow(stream) {\n  const state = stream._readableState;\n  debug('flow'\x2C state.flowing);\n  while (state.flowing && stream.read() !== null);\n}\n\n// Wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function(stream) {\n  let paused = false;\n\n  // TODO (ronag): Should this.destroy(err) emit\n  // 'error' on the wrapped stream? Would require\n  // a static factory method\x2C e.g. Readable.wrap(stream).\n\n  stream.on('data'\x2C (chunk) => {\n    if (!this.push(chunk) && stream.pause) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  stream.on('end'\x2C () => {\n    this.push(null);\n  });\n\n  stream.on('error'\x2C (err) => {\n    errorOrDestroy(this\x2C err);\n  });\n\n  stream.on('close'\x2C () => {\n    this.destroy();\n  });\n\n  stream.on('destroy'\x2C () => {\n    this.destroy();\n  });\n\n  this._read = () => {\n    if (paused && stream.resume) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\n  const streamKeys = ObjectKeys(stream);\n  for (let j = 1; j < streamKeys.length; j++) {\n    const i = streamKeys[j];\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = stream[i].bind(stream);\n    }\n  }\n\n  return this;\n};\n\nReadable.prototype[SymbolAsyncIterator] = function() {\n  return streamToAsyncIterator(this);\n};\n\nReadable.prototype.iterator = function(options) {\n  if (options !== undefined) {\n    validateObject(options\x2C 'options');\n  }\n  return streamToAsyncIterator(this\x2C options);\n};\n\nfunction streamToAsyncIterator(stream\x2C options) {\n  if (typeof stream.read !== 'function') {\n    stream = Readable.wrap(stream\x2C { objectMode: true });\n  }\n\n  const iter = createAsyncIterator(stream\x2C options);\n  iter.stream = stream;\n  return iter;\n}\n\nasync function* createAsyncIterator(stream\x2C options) {\n  let callback = nop;\n\n  function next(resolve) {\n    if (this === stream) {\n      callback();\n      callback = nop;\n    } else {\n      callback = resolve;\n    }\n  }\n\n  stream.on('readable'\x2C next);\n\n  let error;\n  const cleanup = eos(stream\x2C { writable: false }\x2C (err) => {\n    error = err ? aggregateTwoErrors(error\x2C err) : null;\n    callback();\n    callback = nop;\n  });\n\n  try {\n    while (true) {\n      const chunk = stream.destroyed ? null : stream.read();\n      if (chunk !== null) {\n        yield chunk;\n      } else if (error) {\n        throw error;\n      } else if (error === null) {\n        return;\n      } else {\n        await new Promise(next);\n      }\n    }\n  } catch (err) {\n    error = aggregateTwoErrors(error\x2C err);\n    throw error;\n  } finally {\n    if (\n      (error || options?.destroyOnReturn !== false) &&\n      (error === undefined || stream._readableState.autoDestroy)\n    ) {\n      destroyImpl.destroyer(stream\x2C null);\n    } else {\n      stream.off('readable'\x2C next);\n      cleanup();\n    }\n  }\n}\n\n// Making it explicit these properties are not enumerable\n// because otherwise some prototype manipulation in\n// userland will fail.\nObjectDefineProperties(Readable.prototype\x2C {\n  readable: {\n    __proto__: null\x2C\n    get() {\n      const r = this._readableState;\n      // r.readable === false means that this is part of a Duplex stream\n      // where the readable side was disabled upon construction.\n      // Compat. The user might manually disable readable side through\n      // deprecated setter.\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\n        !r.endEmitted;\n    }\x2C\n    set(val) {\n      // Backwards compat.\n      if (this._readableState) {\n        this._readableState.readable = !!val;\n      }\n    }\n  }\x2C\n\n  readableDidRead: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.dataEmitted;\n    }\n  }\x2C\n\n  readableAborted: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return !!(\n        this._readableState.readable !== false &&\n        (this._readableState.destroyed || this._readableState.errored) &&\n        !this._readableState.endEmitted\n      );\n    }\n  }\x2C\n\n  readableHighWaterMark: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.highWaterMark;\n    }\n  }\x2C\n\n  readableBuffer: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState && this._readableState.buffer;\n    }\n  }\x2C\n\n  readableFlowing: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return this._readableState.flowing;\n    }\x2C\n    set: function(state) {\n      if (this._readableState) {\n        this._readableState.flowing = state;\n      }\n    }\n  }\x2C\n\n  readableLength: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState.length;\n    }\n  }\x2C\n\n  readableObjectMode: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.objectMode : false;\n    }\n  }\x2C\n\n  readableEncoding: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.encoding : null;\n    }\n  }\x2C\n\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.errored : null;\n    }\n  }\x2C\n\n  closed: {\n    __proto__: null\x2C\n    get() {\n      return this._readableState ? this._readableState.closed : false;\n    }\n  }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // We ignore the value if the stream\n      // has not been initialized yet.\n      if (!this._readableState) {\n        return;\n      }\n\n      // Backward compatibility\x2C the user is explicitly\n      // managing destroyed.\n      this._readableState.destroyed = value;\n    }\n  }\x2C\n\n  readableEnded: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._readableState ? this._readableState.endEmitted : false;\n    }\n  }\x2C\n\n});\n\nObjectDefineProperties(ReadableState.prototype\x2C {\n  // Legacy getter for `pipesCount`.\n  pipesCount: {\n    __proto__: null\x2C\n    get() {\n      return this.pipes.length;\n    }\n  }\x2C\n\n  // Legacy property for `paused`.\n  paused: {\n    __proto__: null\x2C\n    get() {\n      return this[kPaused] !== false;\n    }\x2C\n    set(value) {\n      this[kPaused] = !!value;\n    }\n  }\n});\n\n// Exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable\x2C so please take care when making\n// changes to the function body.\nfunction fromList(n\x2C state) {\n  // nothing buffered.\n  if (state.length === 0)\n    return null;\n\n  let ret;\n  if (state.objectMode)\n    ret = state.buffer.shift();\n  else if (!n || n >= state.length) {\n    // Read it all\x2C truncate the list.\n    if (state.decoder)\n      ret = state.buffer.join('');\n    else if (state.buffer.length === 1)\n      ret = state.buffer.first();\n    else\n      ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list.\n    ret = state.buffer.consume(n\x2C state.decoder);\n  }\n\n  return ret;\n}\n\nfunction endReadable(stream) {\n  const state = stream._readableState;\n\n  debug('endReadable'\x2C state.endEmitted);\n  if (!state.endEmitted) {\n    state.ended = true;\n    process.nextTick(endReadableNT\x2C state\x2C stream);\n  }\n}\n\nfunction endReadableNT(state\x2C stream) {\n  debug('endReadableNT'\x2C state.endEmitted\x2C state.length);\n\n  // Check that we didn't get one last unshift.\n  if (!state.errored && !state.closeEmitted &&\n      !state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.emit('end');\n\n    if (stream.writable && stream.allowHalfOpen === false) {\n      process.nextTick(endWritableNT\x2C stream);\n    } else if (state.autoDestroy) {\n      // In case of duplex streams we need a way to detect\n      // if the writable side is ready for autoDestroy as well.\n      const wState = stream._writableState;\n      const autoDestroy = !wState || (\n        wState.autoDestroy &&\n        // We don't expect the writable to ever 'finish'\n        // if writable is explicitly set to false.\n        (wState.finished || wState.writable === false)\n      );\n\n      if (autoDestroy) {\n        stream.destroy();\n      }\n    }\n  }\n}\n\nfunction endWritableNT(stream) {\n  const writable = stream.writable && !stream.writableEnded &&\n    !stream.destroyed;\n  if (writable) {\n    stream.end();\n  }\n}\n\nReadable.from = function(iterable\x2C opts) {\n  return from(Readable\x2C iterable\x2C opts);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nReadable.fromWeb = function(readableStream\x2C options) {\n  return lazyWebStreams().newStreamReadableFromReadableStream(\n    readableStream\x2C\n    options);\n};\n\nReadable.toWeb = function(streamReadable\x2C options) {\n  return lazyWebStreams().newReadableStreamFromStreamReadable(\n    streamReadable\x2C\n    options);\n};\n\nReadable.wrap = function(src\x2C options) {\n  return new Readable({\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true\x2C\n    ...options\x2C\n    destroy(err\x2C callback) {\n      destroyImpl.destroyer(src\x2C err);\n      callback(err);\n    }\n  }).wrap(src);\n};\n
code-source-info,0xb46b96b7f20,58,6353,7224,C0O6353C9O6367C16O6378C21O6404C28O6411C33O6433C34O6588C41O6604C44O6611C48O6593C52O6622C71O6644C76O6642C80O6691C84O6729C92O6756C95O6777C99O6767C103O6807C111O6837C114O6861C118O6851C122O6894C130O6926C133O6952C137O6942C141O6980C149O6991C151O7007C158O7030C166O7007C171O7052C178O7059C186O7059C192O7083C199O7095C212O7095C219O7223,,
tick,0x7ff805e4dd52,205434,0,0x0,3,0x102d6ee20,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805e4dd5c,205447,0,0x0,3,0x102d6ee20,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805ea4dea,205456,0,0x0,3,0x102d6ee20,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805ede983,205467,0,0x0,3,0x102d6ee20,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,205477,0xb46b96bae00,18,Stream node:internal/streams/legacy:10:16,0xb468068e590,~
script-source,59,node:internal/streams/legacy,'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  ObjectSetPrototypeOf\x2C\n} = primordials;\n\nconst EE = require('events');\n\nfunction Stream(opts) {\n  EE.call(this\x2C opts);\n}\nObjectSetPrototypeOf(Stream.prototype\x2C EE.prototype);\nObjectSetPrototypeOf(Stream\x2C EE);\n\nStream.prototype.pipe = function(dest\x2C options) {\n  const source = this;\n\n  function ondata(chunk) {\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\n      source.pause();\n    }\n  }\n\n  source.on('data'\x2C ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain'\x2C ondrain);\n\n  // If the 'end' option is not supplied\x2C dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end'\x2C onend);\n    source.on('close'\x2C onclose);\n  }\n\n  let didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // Don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this\x2C 'error') === 0) {\n      this.emit('error'\x2C er);\n    }\n  }\n\n  prependListener(source\x2C 'error'\x2C onerror);\n  prependListener(dest\x2C 'error'\x2C onerror);\n\n  // Remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data'\x2C ondata);\n    dest.removeListener('drain'\x2C ondrain);\n\n    source.removeListener('end'\x2C onend);\n    source.removeListener('close'\x2C onclose);\n\n    source.removeListener('error'\x2C onerror);\n    dest.removeListener('error'\x2C onerror);\n\n    source.removeListener('end'\x2C cleanup);\n    source.removeListener('close'\x2C cleanup);\n\n    dest.removeListener('close'\x2C cleanup);\n  }\n\n  source.on('end'\x2C cleanup);\n  source.on('close'\x2C cleanup);\n\n  dest.on('close'\x2C cleanup);\n  dest.emit('pipe'\x2C source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\nfunction prependListener(emitter\x2C event\x2C fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function')\n    return emitter.prependListener(event\x2C fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event])\n    emitter.on(event\x2C fn);\n  else if (ArrayIsArray(emitter._events[event]))\n    emitter._events[event].unshift(fn);\n  else\n    emitter._events[event] = [fn\x2C emitter._events[event]];\n}\n\nmodule.exports = { Stream\x2C prependListener };\n
code-source-info,0xb46b96bae00,59,127,160,C0O138C5O141C10O141C17O159,,
tick,0x1030e24b2,206442,0,0x0,0,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,206564,0xb46b96bb618,354,ReadableState node:internal/streams/readable:83:23,0xb468068bbf0,~
code-source-info,0xb46b96bb618,58,2626,6333,C0O2964C6O3003C8O3032C11O3039C15O3021C20O3172C25O3193C27O3212C33O3188C37O3228C41O3269C52O3292C54O3311C60O3262C64O3477C69O3498C73O3512C88O3512C97O3585C102O3585C106O3496C110O3788C112O3806C115O3802C120O3800C124O3822C125O3834C129O3841C131O3852C135O3860C136O3873C140O3883C141O3894C145O3905C146O3921C150O3932C151O3945C155O4139C156O4156C160O4436C161O4446C165O4567C166O4585C170O4596C171O4617C175O4628C176O4651C180O4662C181O4683C185O4694C187O4699C191O4708C195O4794C196O4812C200O4883C202O4901C208O4920C214O4930C218O4898C222O5017C224O5037C230O5056C236O5068C240O5034C244O5110C245O5125C249O5378C250O5391C254O5461C255O5473C259O5577C260O5595C264O5802C269O5826C271O5845C279O5823C283O5978C284O6001C288O6011C289O6032C293O6094C294O6111C298O6123C299O6140C303O6152C304O6165C308O6175C309O6189C313O6199C317O6222C323O6238C325O6257C328O6279C335O6253C340O6251C344O6318C348O6308C353O6332,,
code-creation,LazyCompile,10,206688,0xb46b96bba30,98,getHighWaterMark node:internal/streams/state:19:26,0xb4680690ee8,~
script-source,62,node:internal/streams/state,'use strict';\n\nconst {\n  MathFloor\x2C\n  NumberIsInteger\x2C\n} = primordials;\n\nconst { ERR_INVALID_ARG_VALUE } = require('internal/errors').codes;\n\nfunction highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey) {\n  return options.highWaterMark != null ? options.highWaterMark :\n    isDuplex ? options[duplexKey] : null;\n}\n\nfunction getDefaultHighWaterMark(objectMode) {\n  return objectMode ? 16 : 16 * 1024;\n}\n\nfunction getHighWaterMark(state\x2C options\x2C duplexKey\x2C isDuplex) {\n  const hwm = highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey);\n  if (hwm != null) {\n    if (!NumberIsInteger(hwm) || hwm < 0) {\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\n      throw new ERR_INVALID_ARG_VALUE(name\x2C hwm);\n    }\n    return MathFloor(hwm);\n  }\n\n  // Default value\n  return getDefaultHighWaterMark(state.objectMode);\n}\n\nmodule.exports = {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n};\n
code-source-info,0xb46b96bba30,62,424,832,C0O478C12O478C18O529C21O552C26O557C33O585C38O611C47O633C56O678C69O684C74O678C75O732C80O739C84O754C85O781C88O818C93O788C97O830,,
code-creation,LazyCompile,10,206836,0xb46b96bbcd0,26,highWaterMarkFrom node:internal/streams/state:10:27,0xb4680690db0,~
code-source-info,0xb46b96bbcd0,62,168,309,C0O218C7O250C15O270C19O288C25O307,,
code-creation,LazyCompile,10,206868,0xb46b96bbdb0,13,getDefaultHighWaterMark node:internal/streams/state:15:33,0xb4680690e98,~
code-source-info,0xb46b96bbdb0,62,343,397,C0O360C12O395,,
code-creation,LazyCompile,10,206907,0xb46b96bbe88,17,BufferList node:internal/streams/buffer_list:14:14,0xb46806902f8,~
script-source,61,node:internal/streams/buffer_list,'use strict';\n\nconst {\n  StringPrototypeSlice\x2C\n  SymbolIterator\x2C\n  TypedArrayPrototypeSet\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst { Buffer } = require('buffer');\nconst { inspect } = require('internal/util/inspect');\n\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  push(v) {\n    const entry = { data: v\x2C next: null };\n    if (this.length > 0)\n      this.tail.next = entry;\n    else\n      this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  }\n\n  unshift(v) {\n    const entry = { data: v\x2C next: this.head };\n    if (this.length === 0)\n      this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  }\n\n  shift() {\n    if (this.length === 0)\n      return;\n    const ret = this.head.data;\n    if (this.length === 1)\n      this.head = this.tail = null;\n    else\n      this.head = this.head.next;\n    --this.length;\n    return ret;\n  }\n\n  clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  }\n\n  join(s) {\n    if (this.length === 0)\n      return '';\n    let p = this.head;\n    let ret = '' + p.data;\n    while ((p = p.next) !== null)\n      ret += s + p.data;\n    return ret;\n  }\n\n  concat(n) {\n    if (this.length === 0)\n      return Buffer.alloc(0);\n    const ret = Buffer.allocUnsafe(n >>> 0);\n    let p = this.head;\n    let i = 0;\n    while (p) {\n      TypedArrayPrototypeSet(ret\x2C p.data\x2C i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n\x2C hasStrings) {\n    const data = this.head.data;\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0\x2C n);\n      this.head.data = data.slice(n);\n      return slice;\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift();\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\n  }\n\n  first() {\n    return this.head.data;\n  }\n\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data;\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = '';\n    let p = this.head;\n    let c = 0;\n    do {\n      const str = p.data;\n      if (n > str.length) {\n        ret += str;\n        n -= str.length;\n      } else {\n        if (n === str.length) {\n          ret += str;\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          ret += StringPrototypeSlice(str\x2C 0\x2C n);\n          this.head = p;\n          p.data = StringPrototypeSlice(str\x2C n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n);\n    const retLen = n;\n    let p = this.head;\n    let c = 0;\n    do {\n      const buf = p.data;\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n        n -= buf.length;\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\n          ++c;\n          if (p.next)\n            this.head = p.next;\n          else\n            this.head = this.tail = null;\n        } else {\n          TypedArrayPrototypeSet(ret\x2C\n                                 new Uint8Array(buf.buffer\x2C buf.byteOffset\x2C n)\x2C\n                                 retLen - n);\n          this.head = p;\n          p.data = buf.slice(n);\n        }\n        break;\n      }\n      ++c;\n    } while ((p = p.next) !== null);\n    this.length -= c;\n    return ret;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_\x2C options) {\n    return inspect(this\x2C {\n      ...options\x2C\n      // Only inspect one level.\n      depth: 0\x2C\n      // It should not recurse.\n      customInspect: false\n    });\n  }\n};\n
code-source-info,0xb46b96bbe88,61,265,338,C0O274C1O284C5O296C6O306C10O318C11O330C16O337,,
code-creation,LazyCompile,10,207456,0xb46b96bc5c0,98,construct node:internal/streams/destroy:219:19,0xb46d2cbe228,~
script-source,56,node:internal/streams/destroy,'use strict';\n\nconst {\n  aggregateTwoErrors\x2C\n  codes: {\n    ERR_MULTIPLE_CALLBACK\x2C\n  }\x2C\n  AbortError\x2C\n} = require('internal/errors');\nconst {\n  Symbol\x2C\n} = primordials;\nconst {\n  kDestroyed\x2C\n  isDestroyed\x2C\n  isFinished\x2C\n  isServerRequest\n} = require('internal/streams/utils');\n\nconst kDestroy = Symbol('kDestroy');\nconst kConstruct = Symbol('kConstruct');\n\nfunction checkError(err\x2C w\x2C r) {\n  if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n  }\n}\n\n// Backwards compat. cb() is undocumented and unused in core but\n// unfortunately might be used by modules.\nfunction destroy(err\x2C cb) {\n  const r = this._readableState;\n  const w = this._writableState;\n  // With duplex streams we use the writable side for state.\n  const s = w || r;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    if (typeof cb === 'function') {\n      cb();\n    }\n\n    return this;\n  }\n\n\n  // We set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n  checkError(err\x2C w\x2C r);\n\n  if (w) {\n    w.destroyed = true;\n  }\n  if (r) {\n    r.destroyed = true;\n  }\n\n  // If still constructing then defer calling _destroy.\n  if (!s.constructed) {\n    this.once(kDestroy\x2C function(er) {\n      _destroy(this\x2C aggregateTwoErrors(er\x2C err)\x2C cb);\n    });\n  } else {\n    _destroy(this\x2C err\x2C cb);\n  }\n\n  return this;\n}\n\nfunction _destroy(self\x2C err\x2C cb) {\n  let called = false;\n\n  function onDestroy(err) {\n    if (called) {\n      return;\n    }\n    called = true;\n\n    const r = self._readableState;\n    const w = self._writableState;\n\n    checkError(err\x2C w\x2C r);\n\n    if (w) {\n      w.closed = true;\n    }\n    if (r) {\n      r.closed = true;\n    }\n\n    if (typeof cb === 'function') {\n      cb(err);\n    }\n\n    if (err) {\n      process.nextTick(emitErrorCloseNT\x2C self\x2C err);\n    } else {\n      process.nextTick(emitCloseNT\x2C self);\n    }\n  }\n  try {\n    self._destroy(err || null\x2C onDestroy);\n  } catch (err) {\n    onDestroy(err);\n  }\n}\n\nfunction emitErrorCloseNT(self\x2C err) {\n  emitErrorNT(self\x2C err);\n  emitCloseNT(self);\n}\n\nfunction emitCloseNT(self) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if (w) {\n    w.closeEmitted = true;\n  }\n  if (r) {\n    r.closeEmitted = true;\n  }\n\n  if ((w && w.emitClose) || (r && r.emitClose)) {\n    self.emit('close');\n  }\n}\n\nfunction emitErrorNT(self\x2C err) {\n  const r = self._readableState;\n  const w = self._writableState;\n\n  if ((w && w.errorEmitted) || (r && r.errorEmitted)) {\n    return;\n  }\n\n  if (w) {\n    w.errorEmitted = true;\n  }\n  if (r) {\n    r.errorEmitted = true;\n  }\n\n  self.emit('error'\x2C err);\n}\n\nfunction undestroy() {\n  const r = this._readableState;\n  const w = this._writableState;\n\n  if (r) {\n    r.constructed = true;\n    r.closed = false;\n    r.closeEmitted = false;\n    r.destroyed = false;\n    r.errored = null;\n    r.errorEmitted = false;\n    r.reading = false;\n    r.ended = r.readable === false;\n    r.endEmitted = r.readable === false;\n  }\n\n  if (w) {\n    w.constructed = true;\n    w.destroyed = false;\n    w.closed = false;\n    w.closeEmitted = false;\n    w.errored = null;\n    w.errorEmitted = false;\n    w.finalCalled = false;\n    w.prefinished = false;\n    w.ended = w.writable === false;\n    w.ending = w.writable === false;\n    w.finished = w.writable === false;\n  }\n}\n\nfunction errorOrDestroy(stream\x2C err\x2C sync) {\n  // We have tests that rely on errors being emitted\n  // in the same tick\x2C so changing this is semver major.\n  // For now when you opt-in to autoDestroy we allow\n  // the error to be emitted nextTick. In a future\n  // semver major update we should change the default to this.\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if ((w && w.destroyed) || (r && r.destroyed)) {\n    return this;\n  }\n\n  if ((r && r.autoDestroy) || (w && w.autoDestroy))\n    stream.destroy(err);\n  else if (err) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    err.stack; // eslint-disable-line no-unused-expressions\n\n    if (w && !w.errored) {\n      w.errored = err;\n    }\n    if (r && !r.errored) {\n      r.errored = err;\n    }\n    if (sync) {\n      process.nextTick(emitErrorNT\x2C stream\x2C err);\n    } else {\n      emitErrorNT(stream\x2C err);\n    }\n  }\n}\n\nfunction construct(stream\x2C cb) {\n  if (typeof stream._construct !== 'function') {\n    return;\n  }\n\n  const r = stream._readableState;\n  const w = stream._writableState;\n\n  if (r) {\n    r.constructed = false;\n  }\n  if (w) {\n    w.constructed = false;\n  }\n\n  stream.once(kConstruct\x2C cb);\n\n  if (stream.listenerCount(kConstruct) > 1) {\n    // Duplex\n    return;\n  }\n\n  process.nextTick(constructNT\x2C stream);\n}\n\nfunction constructNT(stream) {\n  let called = false;\n\n  function onConstruct(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? new ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    const r = stream._readableState;\n    const w = stream._writableState;\n    const s = w || r;\n\n    if (r) {\n      r.constructed = true;\n    }\n    if (w) {\n      w.constructed = true;\n    }\n\n    if (s.destroyed) {\n      stream.emit(kDestroy\x2C err);\n    } else if (err) {\n      errorOrDestroy(stream\x2C err\x2C true);\n    } else {\n      process.nextTick(emitConstructNT\x2C stream);\n    }\n  }\n\n  try {\n    stream._construct(onConstruct);\n  } catch (err) {\n    onConstruct(err);\n  }\n}\n\nfunction emitConstructNT(stream) {\n  stream.emit(kConstruct);\n}\n\nfunction isRequest(stream) {\n  return stream && stream.setHeader && typeof stream.abort === 'function';\n}\n\nfunction emitCloseLegacy(stream) {\n  stream.emit('close');\n}\n\nfunction emitErrorCloseLegacy(stream\x2C err) {\n  stream.emit('error'\x2C err);\n  process.nextTick(emitCloseLegacy\x2C stream);\n}\n\n// Normalize destroy for legacy.\nfunction destroyer(stream\x2C err) {\n  if (!stream || isDestroyed(stream)) {\n    return;\n  }\n\n  if (!err && !isFinished(stream)) {\n    err = new AbortError();\n  }\n\n  // TODO: Remove isRequest branches.\n  if (isServerRequest(stream)) {\n    stream.socket = null;\n    stream.destroy(err);\n  } else if (isRequest(stream)) {\n    stream.abort();\n  } else if (isRequest(stream.req)) {\n    stream.req.abort();\n  } else if (typeof stream.destroy === 'function') {\n    stream.destroy(err);\n  } else if (typeof stream.close === 'function') {\n    // TODO: Don't lose err?\n    stream.close();\n  } else if (err) {\n    process.nextTick(emitErrorCloseLegacy\x2C stream\x2C err);\n  } else {\n    process.nextTick(emitCloseLegacy\x2C stream);\n  }\n\n  if (!stream.destroyed) {\n    stream[kDestroyed] = true;\n  }\n}\n\nmodule.exports = {\n  construct\x2C\n  destroyer\x2C\n  destroy\x2C\n  undestroy\x2C\n  errorOrDestroy\n};\n
code-source-info,0xb46b96bc5c0,56,4490,4878,C0O4525C8O4558C9O4565C10O4590C15O4625C20O4644C24O4657C25O4671C29O4686C33O4699C34O4713C38O4736C45O4741C48O4736C54O4772C61O4786C64O4772C72O4798C77O4823C78O4830C79O4838C82O4846C90O4846C97O4877,,
tick,0x7ff805ede983,208297,0,0x0,3,0x102d5e910,0xb46b96b7ff4,0xb46b96b777c,0xb46b96b7180,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,208367,0xb46b96bd2e8,266,Writable node:internal/streams/writable:220:18,0xb468069a478,~
script-source,65,node:internal/streams/writable,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk\x2C encoding\x2C cb)\x2C and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  Error\x2C\n  FunctionPrototypeSymbolHasInstance\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nmodule.exports = Writable;\nWritable.WritableState = WritableState;\n\nconst EE = require('events');\nconst Stream = require('internal/streams/legacy').Stream;\nconst { Buffer } = require('buffer');\nconst destroyImpl = require('internal/streams/destroy');\n\nconst {\n  addAbortSignal\x2C\n} = require('internal/streams/add-abort-signal');\n\nconst {\n  getHighWaterMark\x2C\n  getDefaultHighWaterMark\n} = require('internal/streams/state');\nconst {\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\n  ERR_MULTIPLE_CALLBACK\x2C\n  ERR_STREAM_CANNOT_PIPE\x2C\n  ERR_STREAM_DESTROYED\x2C\n  ERR_STREAM_ALREADY_FINISHED\x2C\n  ERR_STREAM_NULL_VALUES\x2C\n  ERR_STREAM_WRITE_AFTER_END\x2C\n  ERR_UNKNOWN_ENCODING\n} = require('internal/errors').codes;\n\nconst { errorOrDestroy } = destroyImpl;\n\nObjectSetPrototypeOf(Writable.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(Writable\x2C Stream);\n\nfunction nop() {}\n\nconst kOnFinished = Symbol('kOnFinished');\n\nfunction WritableState(options\x2C stream\x2C isDuplex) {\n  // Duplex streams are both readable and writable\x2C but share\n  // the same options object.\n  // However\x2C some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream\x2C\n  // e.g. options.readableObjectMode vs. options.writableObjectMode\x2C etc.\n  if (typeof isDuplex !== 'boolean')\n    isDuplex = stream instanceof Stream.Duplex;\n\n  // Object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!(options && options.objectMode);\n\n  if (isDuplex)\n    this.objectMode = this.objectMode ||\n      !!(options && options.writableObjectMode);\n\n  // The point at which write() starts returning false\n  // Note: 0 is a valid value\x2C means that we always return false if\n  // the entire buffer is not flushed immediately on write().\n  this.highWaterMark = options ?\n    getHighWaterMark(this\x2C options\x2C 'writableHighWaterMark'\x2C isDuplex) :\n    getDefaultHighWaterMark(false);\n\n  // if _final has been called.\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // At the start of calling end()\n  this.ending = false;\n  // When end() has been called\x2C and returned.\n  this.ended = false;\n  // When 'finish' is emitted.\n  this.finished = false;\n\n  // Has it been destroyed\n  this.destroyed = false;\n\n  // Should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  const noDecode = !!(options && options.decodeStrings === false);\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8'\x2C though.\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\n\n  // Not an actual buffer we keep track of\x2C but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // A flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // When true all writes will be buffered until .uncork() call.\n  this.corked = 0;\n\n  // A flag to be able to tell if the onwrite cb is called immediately\x2C\n  // or on a later tick.  We set this to true at first\x2C because any\n  // actions that shouldn't happen until "later" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // A flag to know if we're processing previously buffered items\x2C which\n  // may call the _write() callback in the same tick\x2C so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // The callback that's passed to _write(chunk\x2C cb).\n  this.onwrite = onwrite.bind(undefined\x2C stream);\n\n  // The callback that the user supplies to write(chunk\x2C encoding\x2C cb).\n  this.writecb = null;\n\n  // The amount that is being written when _write is called.\n  this.writelen = 0;\n\n  // Storage for data passed to the afterWrite() callback in case of\n  // synchronous _write() completion.\n  this.afterWriteTickInfo = null;\n\n  resetBuffer(this);\n\n  // Number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted.\n  this.pendingcb = 0;\n\n  // Stream is still being constructed and cannot be\n  // destroyed until construction finished or failed.\n  // Async construction is opt in\x2C therefore we start as\n  // constructed.\n  this.constructed = true;\n\n  // Emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams.\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again.\n  this.errorEmitted = false;\n\n  // Should close be emitted on destroy. Defaults to true.\n  this.emitClose = !options || options.emitClose !== false;\n\n  // Should .destroy() be called after 'finish' (and potentially 'end').\n  this.autoDestroy = !options || options.autoDestroy !== false;\n\n  // Indicates whether the stream has errored. When true all write() calls\n  // should return false. This is needed since when autoDestroy\n  // is disabled we need a way to tell whether the stream has failed.\n  this.errored = null;\n\n  // Indicates whether the stream has finished destroying.\n  this.closed = false;\n\n  // True if close has been emitted or would have been emitted\n  // depending on emitClose.\n  this.closeEmitted = false;\n\n  this[kOnFinished] = [];\n}\n\nfunction resetBuffer(state) {\n  state.buffered = [];\n  state.bufferedIndex = 0;\n  state.allBuffers = true;\n  state.allNoop = true;\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  return ArrayPrototypeSlice(this.buffered\x2C this.bufferedIndex);\n};\n\nObjectDefineProperty(WritableState.prototype\x2C 'bufferedRequestCount'\x2C {\n  __proto__: null\x2C\n  get() {\n    return this.buffered.length - this.bufferedIndex;\n  }\n});\n\nfunction Writable(options) {\n  // Writable ctor is applied to Duplexes\x2C too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false\x2C as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation\x2C which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n\n  // Checking for a Stream.Duplex instance is faster here instead of inside\n  // the WritableState constructor\x2C at least with V8 6.5.\n  const isDuplex = (this instanceof Stream.Duplex);\n\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable\x2C this))\n    return new Writable(options);\n\n  this._writableState = new WritableState(options\x2C this\x2C isDuplex);\n\n  if (options) {\n    if (typeof options.write === 'function')\n      this._write = options.write;\n\n    if (typeof options.writev === 'function')\n      this._writev = options.writev;\n\n    if (typeof options.destroy === 'function')\n      this._destroy = options.destroy;\n\n    if (typeof options.final === 'function')\n      this._final = options.final;\n\n    if (typeof options.construct === 'function')\n      this._construct = options.construct;\n\n    if (options.signal)\n      addAbortSignal(options.signal\x2C this);\n  }\n\n  Stream.call(this\x2C options);\n\n  destroyImpl.construct(this\x2C () => {\n    const state = this._writableState;\n\n    if (!state.writing) {\n      clearBuffer(this\x2C state);\n    }\n\n    finishMaybe(this\x2C state);\n  });\n}\n\nObjectDefineProperty(Writable\x2C SymbolHasInstance\x2C {\n  __proto__: null\x2C\n  value: function(object) {\n    if (FunctionPrototypeSymbolHasInstance(this\x2C object)) return true;\n    if (this !== Writable) return false;\n\n    return object && object._writableState instanceof WritableState;\n  }\x2C\n});\n\n// Otherwise people can pipe Writable streams\x2C which is just wrong.\nWritable.prototype.pipe = function() {\n  errorOrDestroy(this\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nfunction _write(stream\x2C chunk\x2C encoding\x2C cb) {\n  const state = stream._writableState;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = state.defaultEncoding;\n  } else {\n    if (!encoding)\n      encoding = state.defaultEncoding;\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding))\n      throw new ERR_UNKNOWN_ENCODING(encoding);\n    if (typeof cb !== 'function')\n      cb = nop;\n  }\n\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      if (state.decodeStrings !== false) {\n        chunk = Buffer.from(chunk\x2C encoding);\n        encoding = 'buffer';\n      }\n    } else if (chunk instanceof Buffer) {\n      encoding = 'buffer';\n    } else if (Stream._isUint8Array(chunk)) {\n      chunk = Stream._uint8ArrayToBuffer(chunk);\n      encoding = 'buffer';\n    } else {\n      throw new ERR_INVALID_ARG_TYPE(\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n    }\n  }\n\n  let err;\n  if (state.ending) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    process.nextTick(cb\x2C err);\n    errorOrDestroy(stream\x2C err\x2C true);\n    return err;\n  }\n  state.pendingcb++;\n  return writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C cb);\n}\n\nWritable.prototype.write = function(chunk\x2C encoding\x2C cb) {\n  return _write(this\x2C chunk\x2C encoding\x2C cb) === true;\n};\n\nWritable.prototype.cork = function() {\n  this._writableState.corked++;\n};\n\nWritable.prototype.uncork = function() {\n  const state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing)\n      clearBuffer(this\x2C state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string')\n    encoding = StringPrototypeToLowerCase(encoding);\n  if (!Buffer.isEncoding(encoding))\n    throw new ERR_UNKNOWN_ENCODING(encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\n// If we're already writing something\x2C then just put this\n// in the queue\x2C and wait our turn.  Otherwise\x2C call _write\n// If we return false\x2C then we need a drain event\x2C so set that flag.\nfunction writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C callback) {\n  const len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  // stream._write resets state.length\n  const ret = state.length < state.highWaterMark;\n  // We must ensure that previous needDrain will not be reset to false.\n  if (!ret)\n    state.needDrain = true;\n\n  if (state.writing || state.corked || state.errored || !state.constructed) {\n    state.buffered.push({ chunk\x2C encoding\x2C callback });\n    if (state.allBuffers && encoding !== 'buffer') {\n      state.allBuffers = false;\n    }\n    if (state.allNoop && callback !== nop) {\n      state.allNoop = false;\n    }\n  } else {\n    state.writelen = len;\n    state.writecb = callback;\n    state.writing = true;\n    state.sync = true;\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n    state.sync = false;\n  }\n\n  // Return false if errored or destroyed in order to break\n  // any synchronous while(stream.write(data)) loops.\n  return ret && !state.errored && !state.destroyed;\n}\n\nfunction doWrite(stream\x2C state\x2C writev\x2C len\x2C chunk\x2C encoding\x2C cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (state.destroyed)\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\n  else if (writev)\n    stream._writev(chunk\x2C state.onwrite);\n  else\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream\x2C state\x2C er\x2C cb) {\n  --state.pendingcb;\n\n  cb(er);\n  // Ensure callbacks are invoked even when autoDestroy is\n  // not enabled. Passing `er` here doesn't make sense since\n  // it's related to one specific write\x2C not to the buffered\n  // writes.\n  errorBuffer(state);\n  // This can emit error\x2C but error must always follow cb.\n  errorOrDestroy(stream\x2C er);\n}\n\nfunction onwrite(stream\x2C er) {\n  const state = stream._writableState;\n  const sync = state.sync;\n  const cb = state.writecb;\n\n  if (typeof cb !== 'function') {\n    errorOrDestroy(stream\x2C new ERR_MULTIPLE_CALLBACK());\n    return;\n  }\n\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n\n  if (er) {\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\n    er.stack; // eslint-disable-line no-unused-expressions\n\n    if (!state.errored) {\n      state.errored = er;\n    }\n\n    // In case of duplex streams we need to notify the readable side of the\n    // error.\n    if (stream._readableState && !stream._readableState.errored) {\n      stream._readableState.errored = er;\n    }\n\n    if (sync) {\n      process.nextTick(onwriteError\x2C stream\x2C state\x2C er\x2C cb);\n    } else {\n      onwriteError(stream\x2C state\x2C er\x2C cb);\n    }\n  } else {\n    if (state.buffered.length > state.bufferedIndex) {\n      clearBuffer(stream\x2C state);\n    }\n\n    if (sync) {\n      // It is a common case that the callback passed to .write() is always\n      // the same. In that case\x2C we do not schedule a new nextTick()\x2C but\n      // rather just increase a counter\x2C to improve performance and avoid\n      // memory allocations.\n      if (state.afterWriteTickInfo !== null &&\n          state.afterWriteTickInfo.cb === cb) {\n        state.afterWriteTickInfo.count++;\n      } else {\n        state.afterWriteTickInfo = { count: 1\x2C cb\x2C stream\x2C state };\n        process.nextTick(afterWriteTick\x2C state.afterWriteTickInfo);\n      }\n    } else {\n      afterWrite(stream\x2C state\x2C 1\x2C cb);\n    }\n  }\n}\n\nfunction afterWriteTick({ stream\x2C state\x2C count\x2C cb }) {\n  state.afterWriteTickInfo = null;\n  return afterWrite(stream\x2C state\x2C count\x2C cb);\n}\n\nfunction afterWrite(stream\x2C state\x2C count\x2C cb) {\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&\n    state.needDrain;\n  if (needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n\n  while (count-- > 0) {\n    state.pendingcb--;\n    cb();\n  }\n\n  if (state.destroyed) {\n    errorBuffer(state);\n  }\n\n  finishMaybe(stream\x2C state);\n}\n\n// If there's something in the buffer waiting\x2C then invoke callbacks.\nfunction errorBuffer(state) {\n  if (state.writing) {\n    return;\n  }\n\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\n    const { chunk\x2C callback } = state.buffered[n];\n    const len = state.objectMode ? 1 : chunk.length;\n    state.length -= len;\n    callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));\n  }\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i](state.errored ?? new ERR_STREAM_DESTROYED('end'));\n  }\n\n  resetBuffer(state);\n}\n\n// If there's something in the buffer waiting\x2C then process it.\nfunction clearBuffer(stream\x2C state) {\n  if (state.corked ||\n      state.bufferProcessing ||\n      state.destroyed ||\n      !state.constructed) {\n    return;\n  }\n\n  const { buffered\x2C bufferedIndex\x2C objectMode } = state;\n  const bufferedLength = buffered.length - bufferedIndex;\n\n  if (!bufferedLength) {\n    return;\n  }\n\n  let i = bufferedIndex;\n\n  state.bufferProcessing = true;\n  if (bufferedLength > 1 && stream._writev) {\n    state.pendingcb -= bufferedLength - 1;\n\n    const callback = state.allNoop ? nop : (err) => {\n      for (let n = i; n < buffered.length; ++n) {\n        buffered[n].callback(err);\n      }\n    };\n    // Make a copy of `buffered` if it's going to be used by `callback` above\x2C\n    // since `doWrite` will mutate the array.\n    const chunks = state.allNoop && i === 0 ?\n      buffered : ArrayPrototypeSlice(buffered\x2C i);\n    chunks.allBuffers = state.allBuffers;\n\n    doWrite(stream\x2C state\x2C true\x2C state.length\x2C chunks\x2C ''\x2C callback);\n\n    resetBuffer(state);\n  } else {\n    do {\n      const { chunk\x2C encoding\x2C callback } = buffered[i];\n      buffered[i++] = null;\n      const len = objectMode ? 1 : chunk.length;\n      doWrite(stream\x2C state\x2C false\x2C len\x2C chunk\x2C encoding\x2C callback);\n    } while (i < buffered.length && !state.writing);\n\n    if (i === buffered.length) {\n      resetBuffer(state);\n    } else if (i > 256) {\n      buffered.splice(0\x2C i);\n      state.bufferedIndex = 0;\n    } else {\n      state.bufferedIndex = i;\n    }\n  }\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function(chunk\x2C encoding\x2C cb) {\n  if (this._writev) {\n    this._writev([{ chunk\x2C encoding }]\x2C cb);\n  } else {\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\n  }\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function(chunk\x2C encoding\x2C cb) {\n  const state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  let err;\n\n  if (chunk !== null && chunk !== undefined) {\n    const ret = _write(this\x2C chunk\x2C encoding);\n    if (ret instanceof Error) {\n      err = ret;\n    }\n  }\n\n  // .end() fully uncorks.\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  if (err) {\n    // Do nothing...\n  } else if (!state.errored && !state.ending) {\n    // This is forgiving in terms of unnecessary calls to end() and can hide\n    // logic errors. However\x2C usually such errors are harmless and causing a\n    // hard error can be disproportionately destructive. It is not always\n    // trivial for the user to determine whether end() needs to be called\n    // or not.\n\n    state.ending = true;\n    finishMaybe(this\x2C state\x2C true);\n    state.ended = true;\n  } else if (state.finished) {\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\n  } else if (state.destroyed) {\n    err = new ERR_STREAM_DESTROYED('end');\n  }\n\n  if (typeof cb === 'function') {\n    if (err || state.finished) {\n      process.nextTick(cb\x2C err);\n    } else {\n      state[kOnFinished].push(cb);\n    }\n  }\n\n  return this;\n};\n\nfunction needFinish(state) {\n  return (state.ending &&\n          !state.destroyed &&\n          state.constructed &&\n          state.length === 0 &&\n          !state.errored &&\n          state.buffered.length === 0 &&\n          !state.finished &&\n          !state.writing &&\n          !state.errorEmitted &&\n          !state.closeEmitted);\n}\n\nfunction callFinal(stream\x2C state) {\n  let called = false;\n\n  function onFinish(err) {\n    if (called) {\n      errorOrDestroy(stream\x2C err ?? ERR_MULTIPLE_CALLBACK());\n      return;\n    }\n    called = true;\n\n    state.pendingcb--;\n    if (err) {\n      const onfinishCallbacks = state[kOnFinished].splice(0);\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\n        onfinishCallbacks[i](err);\n      }\n      errorOrDestroy(stream\x2C err\x2C state.sync);\n    } else if (needFinish(state)) {\n      state.prefinished = true;\n      stream.emit('prefinish');\n      // Backwards compat. Don't check state.sync here.\n      // Some streams assume 'finish' will be emitted\n      // asynchronously relative to _final callback.\n      state.pendingcb++;\n      process.nextTick(finish\x2C stream\x2C state);\n    }\n  }\n\n  state.sync = true;\n  state.pendingcb++;\n\n  try {\n    stream._final(onFinish);\n  } catch (err) {\n    onFinish(err);\n  }\n\n  state.sync = false;\n}\n\nfunction prefinish(stream\x2C state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function' && !state.destroyed) {\n      state.finalCalled = true;\n      callFinal(stream\x2C state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream\x2C state\x2C sync) {\n  if (needFinish(state)) {\n    prefinish(stream\x2C state);\n    if (state.pendingcb === 0) {\n      if (sync) {\n        state.pendingcb++;\n        process.nextTick((stream\x2C state) => {\n          if (needFinish(state)) {\n            finish(stream\x2C state);\n          } else {\n            state.pendingcb--;\n          }\n        }\x2C stream\x2C state);\n      } else if (needFinish(state)) {\n        state.pendingcb++;\n        finish(stream\x2C state);\n      }\n    }\n  }\n}\n\nfunction finish(stream\x2C state) {\n  state.pendingcb--;\n  state.finished = true;\n\n  const onfinishCallbacks = state[kOnFinished].splice(0);\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\n    onfinishCallbacks[i]();\n  }\n\n  stream.emit('finish');\n\n  if (state.autoDestroy) {\n    // In case of duplex streams we need a way to detect\n    // if the readable side is ready for autoDestroy as well.\n    const rState = stream._readableState;\n    const autoDestroy = !rState || (\n      rState.autoDestroy &&\n      // We don't expect the readable to ever 'end'\n      // if readable is explicitly set to false.\n      (rState.endEmitted || rState.readable === false)\n    );\n    if (autoDestroy) {\n      stream.destroy();\n    }\n  }\n}\n\nObjectDefineProperties(Writable.prototype\x2C {\n\n  closed: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.closed : false;\n    }\n  }\x2C\n\n  destroyed: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.destroyed : false;\n    }\x2C\n    set(value) {\n      // Backward compatibility\x2C the user is explicitly managing destroyed.\n      if (this._writableState) {\n        this._writableState.destroyed = value;\n      }\n    }\n  }\x2C\n\n  writable: {\n    __proto__: null\x2C\n    get() {\n      const w = this._writableState;\n      // w.writable === false means that this is part of a Duplex stream\n      // where the writable side was disabled upon construction.\n      // Compat. The user might manually disable writable side through\n      // deprecated setter.\n      return !!w && w.writable !== false && !w.destroyed && !w.errored &&\n        !w.ending && !w.ended;\n    }\x2C\n    set(val) {\n      // Backwards compatible.\n      if (this._writableState) {\n        this._writableState.writable = !!val;\n      }\n    }\n  }\x2C\n\n  writableFinished: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.finished : false;\n    }\n  }\x2C\n\n  writableObjectMode: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.objectMode : false;\n    }\n  }\x2C\n\n  writableBuffer: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState && this._writableState.getBuffer();\n    }\n  }\x2C\n\n  writableEnded: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.ending : false;\n    }\n  }\x2C\n\n  writableNeedDrain: {\n    __proto__: null\x2C\n    get() {\n      const wState = this._writableState;\n      if (!wState) return false;\n      return !wState.destroyed && !wState.ending && wState.needDrain;\n    }\n  }\x2C\n\n  writableHighWaterMark: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState && this._writableState.highWaterMark;\n    }\n  }\x2C\n\n  writableCorked: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState ? this._writableState.corked : 0;\n    }\n  }\x2C\n\n  writableLength: {\n    __proto__: null\x2C\n    get() {\n      return this._writableState && this._writableState.length;\n    }\n  }\x2C\n\n  errored: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get() {\n      return this._writableState ? this._writableState.errored : null;\n    }\n  }\x2C\n\n  writableAborted: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    get: function() {\n      return !!(\n        this._writableState.writable !== false &&\n        (this._writableState.destroyed || this._writableState.errored) &&\n        !this._writableState.finished\n      );\n    }\n  }\x2C\n});\n\nconst destroy = destroyImpl.destroy;\nWritable.prototype.destroy = function(err\x2C cb) {\n  const state = this._writableState;\n\n  // Invoke pending callbacks.\n  if (!state.destroyed &&\n    (state.bufferedIndex < state.buffered.length ||\n      state[kOnFinished].length)) {\n    process.nextTick(errorBuffer\x2C state);\n  }\n\n  destroy.call(this\x2C err\x2C cb);\n  return this;\n};\n\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function(err\x2C cb) {\n  cb(err);\n};\n\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\n  this.destroy(err);\n};\n\nlet webStreamsAdapters;\n\n// Lazy to avoid circular references\nfunction lazyWebStreams() {\n  if (webStreamsAdapters === undefined)\n    webStreamsAdapters = require('internal/webstreams/adapters');\n  return webStreamsAdapters;\n}\n\nWritable.fromWeb = function(writableStream\x2C options) {\n  return lazyWebStreams().newStreamWritableFromWritableStream(\n    writableStream\x2C\n    options);\n};\n\nWritable.toWeb = function(streamWritable) {\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\n};\n
code-source-info,0xb46b96bd2e8,65,7418,8929,C0O7418C9O7992C16O8009C19O8016C23O7998C27O8028C33O8046C44O8046C51O8102C58O8109C63O8131C64O8135C83O8157C88O8155C92O8204C96O8242C104O8270C107O8292C111O8282C115O8323C123O8352C126O8375C130O8365C134O8407C142O8437C145O8461C149O8451C153O8494C161O8522C164O8544C168O8534C172O8575C180O8607C183O8633C187O8623C191O8661C197O8675C204O8698C212O8675C217O8720C224O8727C232O8727C238O8751C245O8763C258O8763C265O8928,,
tick,0x7ff805dbddb1,211378,0,0x0,3,0x102d5e910,0xb46b96b778c,0xb46b96b7180,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805e4dd51,211390,0,0x0,3,0x102d5e910,0xb46b96b778c,0xb46b96b7180,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
tick,0x7ff805edeacb,211400,0,0x0,3,0x102d5e910,0xb46b96b778c,0xb46b96b7180,0xb46b96b08b1,0xb46b968d973,0xb46b9688bb5,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,LazyCompile,10,211438,0xb46b96bf4d0,341,WritableState node:internal/streams/writable:77:23,0xb468069a338,~
code-source-info,0xb46b96bf4d0,65,2472,6973,C0O2806C6O2845C8O2874C11O2881C15O2863C20O2989C25O3010C27O3029C33O3005C37O3045C41O3086C52O3109C54O3128C60O3079C64O3337C69O3358C73O3372C88O3372C97O3445C102O3445C106O3356C110O3512C111O3529C115O3564C116O3579C120O3625C121O3637C125O3695C126O3706C130O3748C131O3762C135O3801C136O3816C140O4015C144O4037C150O4051C156O4065C158O4087C159O4084C163O4295C168O4319C170O4338C178O4316C182O4516C183O4528C187O4592C188O4605C192O4682C193O4694C197O4958C198O4968C202O5171C203O5193C207O5259C210O5282C217O5282C223O5272C227O5382C228O5395C232O5467C233O5481C237O5596C238O5620C242O5631C245O5631C249O5758C250O5773C254O5963C255O5980C259O6118C260O6135C264O6222C265O6240C269O6311C271O6329C277O6348C283O6358C287O6326C291O6445C293O6465C299O6484C305O6496C309O6462C313O6719C314O6732C318O6802C319O6814C323O6918C324O6936C328O6948C330O6953C335O6966C340O6972,,
code-creation,LazyCompile,10,211551,0xb46b96bf8e0,23,resetBuffer node:internal/streams/writable:202:21,0xb468069a388,~
code-source-info,0xb46b96bf8e0,65,6995,7107,C0O7007C2O7022C6O7030C7O7050C11O7057C12O7074C16O7084C17O7098C22O7106,,
code-creation,LazyCompile,10,211623,0xb46b96bfa40,131,createHandle node:net:146:22,0xb469fbf42e0,~
code-source-info,0xb46b96bfa40,406,3816,4176,C0O3836C13O3836C18O3879C23O3879C28O3902C30O3911C35O3929C42O3952C46O3964C49O3978C57O3987C60O4001C67O3936C72O4014C73O4022C75O4031C80O4048C87O4070C91O4082C94O4095C102O4104C105O4117C112O4055C117O4130C118O4138C125O4144C130O4138,,
code-creation,LazyCompile,10,211724,0xb46b96bfbd8,14,set node:net:1848:6,0xb469fbf6438,~
code-source-info,0xb46b96bfbd8,406,49797,49830,C0O49803C2O49815C7O49824C13O49828,,
code-creation,LazyCompile,10,211754,0xb46b96bfcc0,8,get node:net:1847:6,0xb469fbf63e8,~
code-source-info,0xb46b96bfcc0,406,49762,49790,C0O49767C2O49779C4O49778C7O49788,,
code-creation,LazyCompile,10,211856,0xb46b96bfe68,196,Readable.on node:internal/streams/readable:886:33,0xb468068c520,~
code-source-info,0xb46b96bfe68,58,28013,28912,C0O28038C5O28045C10O28055C15O28058C29O28058C35O28099C40O28118C42O28125C47O28307C55O28307C62O28333C65O28300C69O28426C75O28434C80O28456C85O28456C91O28475C93O28482C98O28515C104O28536C110O28563C112O28608C118O28587C122O28622C123O28636C127O28651C128O28673C132O28688C140O28715C145O28729C150O28688C155O28755C161O28773C164O28773C170O28817C176O28836C179O28844C187O28844C193O28899C195O28910,,
code-creation,LazyCompile,10,211941,0xb46bbe7e918,135,initSocketHandle node:net:263:26,0xb469fbf44c0,~
code-source-info,0xb46bbe7e918,406,6540,7118,C0O6556C5O6556C9O6572C10O6587C14O6673C20O6693C27O6701C32O6715C36O6732C43O6749C45O6747C49O6767C51O6772C57O6810C62O6791C66O6789C70O6839C72O6844C74O6843C78O6858C80O6894C82O6899C84O6898C88O6918C90O6959C94O6977C99O6982C105O7015C106O7022C107O7031C109O7036C114O7045C118O7075C123O7083C128O7083C134O7117,,
code-creation,LazyCompile,10,212007,0xb46bbe7eb50,160,undestroy node:internal/streams/destroy:154:19,0xb46d2cbe188,~
code-source-info,0xb46bbe7eb50,56,2853,3525,C0O2875C5O2908C10O2927C14O2940C15O2954C19O2966C20O2975C24O2988C25O3003C29O3016C30O3028C34O3041C35O3051C39O3063C40O3078C44O3091C45O3101C49O3126C55O3135C58O3122C62O3167C68O3176C71O3163C75O3194C79O3207C80O3221C84O3233C85O3245C89O3258C90O3267C94O3280C95O3295C99O3308C100O3318C104O3330C105O3345C109O3358C110O3372C114O3385C115O3399C119O3424C125O3433C128O3420C132O3461C138O3470C141O3457C145O3500C151O3509C154O3496C159O3524,,
code-creation,LazyCompile,10,212086,0xb46bbe7ee08,32,getNewAsyncId node:net:165:23,0xb469fbf4330,~
code-source-info,0xb46bbe7ee08,406,4201,4317,C0O4214C4O4247C14O4280C17O4280C22O4302C27O4302C31O4315,,
code-creation,LazyCompile,10,212131,0xb46bbe7ef08,5,get node:internal/bootstrap/node:386:8,0xb466514f740,~
code-source-info,0xb46bbe7ef08,16,12550,12583,C0O12561C4O12577,,
code-creation,LazyCompile,10,212171,0xb46bbe7efe0,5,get /Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/redir-stdout.js:19:10,0xb46b96b05f8,~
code-source-info,0xb46bbe7efe0,432,392,404,C0O398C4O404,,
tick,0x113245ec5,212625,0,0x0,0,0x1031b8011,0xb46bbe770a9,0xb46bbe7527f,0xb46bbe73e4a,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Function,11,213192,0x1132483c0,7788,realpathSync node:fs:2474:22,0xb46d1098a30,^
code-source-info,0x1132483c0,73,65937,69828,,,
code-creation,Function,11,213217,0x11324a2c0,232,canBeRequiredByUsers node:internal/bootstrap/loaders:247:30,0xb466514b630,^
code-source-info,0x11324a2c0,15,7502,7598,,,
tick,0x7ff805ea50c6,213913,1,0x1026271f0,6,0x1027fed10,0xb46b968ab11,0xb46b968a855,0xb46b9688ebf,0xb46b9688a14,0xb46b9688068,0xb46bbe73f22,0xb46bbe73acc,0xb46bbe72c8d,0xb46bbe72a3f,0xb46f7df2f06,0xb46f7dee5f7
code-creation,Eval,10,214296,0xb46bbe7fc58,5, /Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/soft-exit.js:1:1,0xb46bbe7fb10,~
script-source,436,/Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/soft-exit.js,'use strict'\n\nprocess.on('SIGINT'\x2C process.exit)\nprocess.on('SIGTERM'\x2C process.exit)\n
code-source-info,0xb46bbe7fc58,436,0,85,C0O0C4O85,,
code-creation,Function,10,214359,0xb46bbe7fcf8,56, /Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events /node_modules/0x/lib/preload/soft-exit.js:1:1,0xb46bbe7fbd0,~
code-source-info,0xb46bbe7fcf8,436,0,85,C0O14C4O22C12O35C16O43C21O22C27O49C31O57C39O71C43O79C48O57C55O84,,
code-creation,LazyCompile,10,214662,0xb46f7dffed0,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:554:36,0xb46f7df0ec0,~
code-source-info,0xb46f7dffed0,389,17746,17968,C0O17753C8O17757C14O17802C17O17810C28O17810C34O17922C40O17922C45O17959C49O17967,,
new,MemoryChunk,0xb4611f00000,262144
code-creation,LazyCompile,10,214745,0xb4611f01168,80,executeUserEntryPoint node:internal/modules/run_main:74:31,0xb46bbe71dc0,~
code-source-info,0xb4611f01168,419,2325,2630,C7O2341C14O2345C22O2375C25O2375C30O2421C33O2421C38O2457C40O2481C45O2492C50O2481C56O2593C61O2600C73O2600C79O2629,,
code-creation,LazyCompile,10,214791,0xb4611f015b8,68,resolveMainPath node:internal/modules/run_main:15:25,0xb46bbe71c80,~
code-source-info,0xb4611f015b8,419,398,812,C0O570C5O577C12O587C15O592C20O592C30O577C36O622C38O641C39O648C40O681C48O681C53O727C55O758C60O769C65O794C67O810,,
tick,0x1030db163,215267,0,0x0,0,0xb46b9686852,0xb46b9686664,0x11324856e,0xb46bbe77a33,0xb46bbe7714d,0xb4611f015d6,0xb4611f01181,0xb46f7dee61b
code-creation,LazyCompile,10,215725,0xb4611f01828,118,shouldUseESMLoader node:internal/modules/run_main:30:28,0xb46bbe71cd0,~
code-source-info,0xb4611f01828,419,841,1564,C0O1026C8O1026C13O1085C19O1092C24O1101C25O1113C26O1156C34O1156C39O1213C41O1245C46O1261C47O1273C48O1321C54O1337C60O1337C67O1384C68O1396C69O1399C75O1416C81O1416C88O1463C89O1476C90O1491C95O1491C100O1521C102O1539C107O1544C114O1549C117O1562,,
code-creation,LazyCompile,10,215811,0xb4611f01aa8,70,runMainESM node:internal/modules/run_main:51:20,0xb46bbe71d20,~
code-source-info,0xb4611f01aa8,419,1585,1925,C0O1585C12O1620C20O1620C25O1608C30O1688C38O1688C43O1670C49O1716C54O1734C59O1734C64O1716C69O1924,,
code-creation,LazyCompile,10,215879,0xb4611f01ce8,216,loadESM node:internal/process/esm_loader:88:41,0xb469fbe0050,~
code-source-info,0xb4611f01ce8,398,2670,2983,C10O2670C21O2695C24O2701C35O2695C58O2725C60O2740C63O2731C75O2725C113O2774C120O2778C125O2825C130O2833C138O2833C143O2861C152O2868C153O2879C161O2879C166O2904C176O2905C193O2982,,
code-creation,LazyCompile,10,215946,0xb4611f02310,286,initializeLoader node:internal/process/esm_loader:54:32,0xb469fbdff20,~
code-source-info,0xb4611f02310,398,1681,2628,C10O1681C18O1688C24O1712C33O1719C34O1752C40O1752C45O1733C50O1805C53O1805C58O1867C64O1874C69O1881C78O1888C79O1896C84O1913C87O1927C92O1927C99O1933C106O1917C107O1956C110O2215C115O2215C121O2363C128O2394C131O2394C136O2412C143O2423C148O2423C159O2369C172O2339C198O2547C203O2563C208O2563C221O2547C244O2602C248O2619C263O2627,,
code-creation,LazyCompile,10,216019,0xb4611f02600,169,handleMainPromise node:internal/modules/run_main:62:33,0xb46bbe71d70,~
code-source-info,0xb4611f02600,419,1959,2109,C10O1959C18O1973C21O1981C31O1992C34O1981C43O2024C53O2031C90O2064C93O2072C103O2084C106O2072C146O2108,,
code-creation,LazyCompile,10,216220,0xb4611f027c0,77, node:internal/modules/run_main:55:29,0xb4611f019e0,~
code-source-info,0xb4611f027c0,419,1742,1920,C0O1776C7O1781C15O1781C24O1810C30O1810C35O1833C44O1872C55O1896C60O1896C71O1878C76O1916,,
code-creation,LazyCompile,10,216295,0xb4611f02a40,283,pathToFileURL node:internal/url:1524:23,0xb46d10a75d0,~
code-source-info,0xb4611f02a40,74,42501,43730,C0O42531C10O42531C16O42553C24O42570C30O42570C37O42683C45O42683C51O42735C58O42742C63O42756C79O42762C84O42756C85O42899C87O42904C91O42926C97O42933C102O42948C118O42954C123O42948C124O43069C127O43087C131O43085C135O43116C140O43157C145O43176C151O43176C160O43157C166O43134C170O43132C176O43244C181O43249C186O43249C192O43362C197O43458C201O43465C205O43362C211O43475C213O43497C215O43493C222O43529C228O43559C230O43555C235O43610C239O43617C242O43600C248O43626C251O43631C255O43622C260O43642C269O43663C272O43681C276O43679C280O43714C282O43728,,
tick,0x7ff805edea8e,216375,0,0x0,3,0x102d5e910,0xb4611f027de,0xb4611f01d27,0x10311893f
code-creation,LazyCompile,10,216402,0xb4611f02d08,136,URL node:internal/url:636:14,0xb46d10a6458,~
code-source-info,0xb4611f02d08,74,17618,18011,C13O17684C17O17712C19O17730C23O17762C30O17777C40O17791C42O17790C46O17811C50O17816C57O17831C60O17827C65O17825C69O17849C85O17901C93O17901C103O17957C117O17957C129O17849C135O18010,,
code-creation,LazyCompile,10,216450,0xb4611f02ee0,51,URLContext node:internal/url:161:14,0xb46d10a5c38,~
code-source-info,0xb4611f02ee0,74,3723,3935,C0O3732C1O3743C5O3752C7O3764C11O3775C13O3789C17O3799C19O3813C23O3823C24O3833C28O3845C29O3855C33O3867C35O3877C39O3887C40O3898C44O3910C45O3924C50O3934,,
code-creation,LazyCompile,10,216545,0xb4611f03120,190,onParseComplete node:internal/url:544:25,0xb46d10a6138,~
code-source-info,0xb4611f03120,74,14715,15384,C0O14829C2O14834C4O14833C8O14846C10O14856C14O14867C16O14878C20O14892C22O14916C24O14914C29O14940C43O14905C47O14965C49O14989C51O14987C56O15013C70O14978C74O15038C76O15047C80O15057C82O15077C84O15075C89O15097C101O15105C103O15066C107O15118C109O15128C113O15139C115O15152C119O15166C121O15175C125O15185C127O15195C129O15194C134O15248C136O15253C141O15273C144O15269C149O15267C153O15296C155O15301C157O15300C163O15315C168O15324C172O15338C177O15360C179O15359C183O15338C189O15383,,
code-creation,LazyCompile,10,216692,0xb4611f03598,934,URLSearchParams node:internal/url:183:14,0xb46d10a5cd8,~
code-source-info,0xb4611f03598,74,4348,7204,C10O4373C16O4422C18O4427C24O4441C30O4458C42O4541C44O4546C46O4545C50O4569C52O4589C54O4588C57O4580C62O4787C64O4792C66O4791C71O4815C73O4820C77O4848C83O4848C87O4834C93O4870C101O4925C107O4971C119O4977C124O4971C125O5171C128O5202C156O5194C187O5194C190O5220C208O5341C210O5340C217O5387C233O5393C238O5387C239O5496C243O5532C271O5521C302O5521C305O5550C313O5584C317O5584C323O5550C331O5510C407O5617C413O5617C418O5183C492O5678C494O5683C500O5697C504O5730C532O5722C563O5722C566O5758C574O5765C579O5786C595O5792C600O5786C601O5873C609O5897C611O5896C617O5916C624O5925C629O5873C634O5711C707O6085C709O6097C711O6102C717O6116C721O6143C727O6143C732O6186C734O6198C738O6191C743O6235C745O6239C749O6267C755O6267C761O6321C763O6352C769O6395C775O6395C780O6444C788O6460C793O6444C798O6612C800O6623C805O6665C807O6670C809O6669C816O6691C823O6703C829O6752C831O6772C837O6796C839O6795C850O6772C855O6939C858O6770C862O6207C867O6173C872O7026C878O7033C883O7058C884O7066C891O7070C896O7091C906O7091C912O7107C916O7107C921O7179C923O7184C928O7193C933O7203,,
code-creation,LazyCompile,10,216801,0xb4611f03bb8,35,initSearchParams node:internal/url:1082:26,0xb46d10a7170,~
code-source-info,0xb4611f03bb8,74,29398,29513,C0O29414C4O29431C6O29435C11O29449C15O29459C16O29466C17O29473C19O29477C25O29493C29O29491C34O29512,,
code-creation,LazyCompile,10,216864,0xb4611f03d68,199,encodePathChars node:internal/url:1509:25,0xb46d10a7580,~
code-source-info,0xb4611f03d68,74,41785,42477,C0O41800C8O41804C15O41848C22O41892C31O41859C38O41972C46O41990C52O41990C59O42035C66O42079C75O42046C82O42105C90O42109C97O42154C104O42198C113O42165C120O42222C128O42226C135O42271C142O42315C151O42282C158O42346C166O42350C173O42395C180O42439C189O42406C196O42459C198O42475,,
code-creation,LazyCompile,10,216931,0xb4611f03fa0,99,set pathname node:internal/url:936:15,0xb46d10a6da0,~
code-source-info,0xb4611f03fa0,74,25485,25754,C0O25498C5O25503C11O25526C23O25532C28O25526C29O25599C34O25621C38O25630C40O25629C45O25651C46O25658C47O25663C58O25675C67O25698C69O25697C78O25738C83O25738C92O25663C98O25753,,
code-creation,LazyCompile,10,216972,0xb4611f04108,22,isURLThis node:internal/url:631:19,0xb46d10a6408,~
code-source-info,0xb4611f04108,74,17502,17591,C0O17513C3O17526C9O17548C14O17565C16O17564C20O17574C21O17589,,
code-creation,LazyCompile,10,217004,0xb4611f04210,31, node:internal/url:653:21,0xb46d10a6540,~
code-source-info,0xb4611f04210,74,18118,18193,C0O18127C4O18140C6O18139C10O18149C19O18157C21O18155C26O18183C30O18189,,
code-creation,LazyCompile,10,217060,0xb4611f04338,108,onParsePathComplete node:internal/url:603:29,0xb46d10a6318,~
code-source-info,0xb4611f04338,74,16674,17140,C0O16792C2O16797C4O16796C8O16809C10O16822C12O16820C17O16842C22O16855C24O16864C28O16876C35O16889C40O16886C46O16924C48O16933C52O16943C59O16957C61O16956C66O16953C70O17035C72O17048C74O17046C79O17068C84O17081C86O17090C90O17102C97O17115C102O17112C107O17139,,
code-creation,LazyCompile,10,217110,0xb4611f044e0,47,get href node:internal/url:753:11,0xb46d10a66d0,~
code-source-info,0xb4611f044e0,74,20850,20955,C0O20859C5O20864C11O20887C23O20893C28O20887C29O20926C33O20938C35O20937C41O20946C46O20951,,
code-creation,LazyCompile,10,217186,0xb4611f047a8,393, node:internal/url:699:12,0xb46d10a6630,~
code-source-info,0xb4611f047a8,74,19418,20668,C0O19434C4O19453C14O19453C19O19494C30O19597C37O19628C41O19633C43O19632C47O19713C52O19733C58O19756C67O19800C74O19809C79O19848C86O19857C91O19883C99O19892C103O19908C105O19933C109O19972C120O19990C124O20018C127O20033C142O20053C151O20094C165O20132C170O20112C176O20144C184O20164C190O20187C193O20202C208O20220C212O20229C214O20228C219O20263C225O20267C237O20299C243O20320C248O20325C255O20332C260O20343C266O20347C272O20351C277O20369C286O20404C291O20409C297O20427C304O20440C307O20463C315O20440C320O20438C330O20505C336O20519C342O20541C345O20556C360O20581C366O20597C372O20622C375O20637C390O20653C392O20664,,
code-creation,LazyCompile,10,217308,0xb4611f04c50,371,import node:internal/modules/esm/loader:520:15,0xb469fbe1aa8,~
code-source-info,0xb4611f04c50,399,15215,16577,C10O15215C18O15843C25O15843C30O15873C32O15888C41O15902C50O15947C55O15972C64O15972C70O16008C81O16199C90O16023C98O16013C100O16013C116O16050C124O16073C138O16050C145O16115C157O16116C164O16149C175O16150C180O16043C191O15995C206O16225C217O16246C222O16242C228O16231C240O16225C266O16277C270O16292C271O16309C282O16313C283O16367C285O16372C287O16372C292O16412C301O16412C306O16438C308O16464C311O16452C315O16475C317O16505C320O16493C324O16517C326O16531C330O16382C335O16354C338O16555C348O16573,,
code-creation,LazyCompile,10,217400,0xb4611f05028,247,getModuleJob node:internal/modules/esm/loader:425:21,0xb469fbe1a58,~
code-source-info,0xb4611f05028,399,12066,12987,C10O12066C18O12117C20O12226C22O12235C26O12244C33O12251C38O12415C49O12466C54O12466C59O12444C65O12573C82O12573C95O12562C118O12540C123O12548C128O12652C133O12662C138O12688C143O12662C150O12760C154O12804C159O12814C166O12840C176O12814C181O12859C185O12890C187O12901C208O12917C214O12972C224O12983,,
code-creation,LazyCompile,10,217521,0xb4611f05728,560,resolve node:internal/modules/esm/loader:799:16,0xb469fbe1be8,~
code-source-info,0xb4611f05728,399,23731,26431,C10O23731C32O23794C39O23794C77O23838C81O23868C93O23936C97O23936C103O23975C126O23981C131O23975C132O24107C134O24112C138O24144C148O24164C156O24190C162O24214C169O24249C177O24284C181O24345C185O24352C195O24446C200O24754C205O25018C211O25041C219O25049C225O25063C235O25018C241O25112C255O25106C283O25165C288O25238C293O25290C300O25304C310O25319C315O25331C316O25351C320O25376C326O25399C332O25423C342O25429C347O25423C348O25506C353O25520C358O25550C369O25633C393O25639C398O25633C399O25779C405O25923C429O25929C434O25923C435O26145C441O26155C447O26155C457O26187C467O26187C476O26225C500O26231C505O26225C506O26387C514O26402C520O26416C535O26427,,
tick,0x102ce12b2,217630,0,0x0,2,0x102d5e910,0xb4611f05813,0xb4611f0507a,0xb4611f04cda,0xb4611f02807,0xb4611f01d27,0x10311893f
code-creation,LazyCompile,10,218145,0xb4611f05f30,278,nextHookFactory node:internal/modules/esm/loader:117:25,0xb469fbe1848,~
code-source-info,0xb4611f05f30,399,3387,5701,C0O3387C25O3403C31O3417C59O3492C64O3479C70O3551C80O3562C84O3556C88O3516C94O3531C100O3620C107O3632C114O3667C118O3632C127O3678C136O3678C141O3672C148O3620C150O3902C155O3907C159O3902C161O3924C162O3924C164O3940C169O3949C175O3959C180O4099C191O4113C195O4122C210O4160C219O4168C227O4182C231O4137C236O4135C240O4267C244O4280C246O4458C268O5679C272O4465C277O5699,,
code-creation,LazyCompile,10,218249,0xb4611f06358,445,ObjectDefineProperty.__proto__ node:internal/modules/esm/loader:151:5,0xb4611f05d68,~
code-source-info,0xb4611f06358,399,4491,5635,C4O4491C52O4598C61O4626C73O4643C85O4621C89O4663C100O4679C103O4684C117O4712C130O4663C135O4772C144O4781C146O4780C150O4801C164O4809C179O4829C192O4927C198O4950C203O4959C211O4978C215O5093C236O5175C247O5200C250O5205C255O5175C260O5225C262O5309C273O5322C276O5327C283O5340C287O5309C292O5356C294O5378C303O5403C306O5378C311O5439C320O5458C328O5445C341O5439C367O5489C374O5489C379O5541C386O5551C395O5566C400O5578C408O5598C412O5614C422O5628,,
code-creation,LazyCompile,10,218318,0xb4611f06688,66,validateArgs node:internal/modules/esm/loader:832:26,0xb4611f05380,~
code-source-info,0xb4611f06688,399,24446,24725,C3O24471C9O24493C16O24511C25O24565C33O24511C38O24658C42O24667C51O24690C59O24667C65O24724,,
code-creation,LazyCompile,10,218489,0xb4611f06b30,912,defaultResolve node:internal/modules/esm/resolve:1083:30,0xb469fbeb5c8,~
code-source-info,0xb4611f06b30,403,34813,38704,C6O34813C57O34849C62O34860C67O34886C73O34903C79O34909C88O34945C94O34952C100O34961C106O34961C112O34997C114O35028C119O35037C124O35087C126O35110C132O35106C139O35087C146O35152C149O35164C150O35180C155O35200C160O35230C164O35282C170O35296C178O35310C193O35317C194O35332C198O35543C200O35556C206O35641C212O35664C219O35641C234O35552C241O35543C245O35720C247O35739C254O35772C262O35790C271O35788C274O35867C279O35887C283O35891C289O35951C303O35960C311O36016C319O36025C325O36067C333O36076C340O36098C344O36155C352O36164C357O36197C365O36206C370O36250C376O36271C395O36278C402O36560C415O36560C421O36641C423O36658C433O36677C434O36731C438O36752C446O36761C451O36774C459O36788C474O36800C475O36804C481O36840C485O36804C490O36887C494O36914C496O36932C506O36969C512O36969C526O36944C532O36978C537O37390C543O37404C549O37410C554O37404C555O37451C559O37464C564O37500C569O37517C584O37596C588O37605C594O37628C598O37523C608O37521C619O37771C623O37781C631O37786C640O37830C648O37835C653O37877C665O37881C672O37940C680O37952C685O38006C691O38006C697O38053C699O38155C711O38182C721O38155C727O38217C733O38243C745O38261C753O38285C757O38285C765O38312C772O38319C779O38336C788O38355C796O38355C801O38343C804O38273C808O38396C824O38418C831O38410C835O38444C837O38444C838O38464C842O38464C846O38503C852O38635C862O38653C866O38653C886O38702,,
code-creation,LazyCompile,10,218605,0xb4611f09808,31,shouldBeTreatedAsRelativeOrAbsolutePath node:internal/modules/esm/resolve:930:49,0xb469fbeb3e8,~
code-source-info,0xb4611f09808,403,30118,30253,C0O30134C2O30148C7O30156C8O30169C9O30172C10O30185C16O30189C21O30198C22O30210C23O30213C26O30220C30O30251,,
code-creation,LazyCompile,10,218645,0xb4611f09920,81,isRelativeSpecifier node:internal/modules/esm/resolve:920:29,0xb469fbeb398,~
code-source-info,0xb4611f09920,403,29825,30068,C0O29841C1O29854C7O29858C12O29887C19O29894C26O29912C32O29916C37O29925C38O29937C39O29942C41O29955C47O29959C52O29990C59O29997C66O30015C72O30019C77O30028C78O30040C79O30053C80O30066,,
code-creation,LazyCompile,10,218702,0xb4611f09ac0,44,get protocol node:internal/url:795:15,0xb46d10a6810,~
code-source-info,0xb4611f09ac0,74,21935,22043,C0O21944C5O21949C11O21972C23O21978C28O21972C29O22011C33O22023C35O22022C39O22032C43O22039,,
code-creation,LazyCompile,10,218758,0xb4611f09ce8,183,checkIfDisallowedImport node:internal/modules/esm/resolve:1015:33,0xb469fbeb4d8,~
code-source-info,0xb4611f09ce8,403,32934,34092,C0O32975C4O33029C11O33038C16O33075C23O33084C28O33111C31O33115C37O33271C41O33302C48O33311C53O33344C60O33353C65O33387C81O33393C86O33387C87O33578C92O33599C102O33606C103O33621C108O33638C113O33638C122O33683C125O33696C130O33696C137O33745C153O33751C158O33745C159O33924C175O33930C180O33924C182O34091,,
code-creation,LazyCompile,10,218816,0xb4611f09f48,104,throwIfUnsupportedURLScheme node:internal/modules/esm/resolve:1062:37,0xb469fbeb578,~
code-source-info,0xb4611f09f48,403,34330,34782,C0O34371C4O34401C11O34410C16O34436C23O34445C30O34473C32O34526C39O34535C44O34566C51O34575C56O34611C63O34660C77O34716C88O34660C96O34617C101O34611C103O34781,,
tick,0x1031f3dbb,219174,0,0x0,0,0xb4611f02b3b,0xb4611f06d3e,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f04cda,0xb4611f02807,0xb4611f01d27,0x10311893f
code-creation,LazyCompile,10,219227,0xb4611f0a100,64,getConditionsSet node:internal/modules/esm/resolve:145:26,0xb469fbeac18,~
code-source-info,0xb4611f0a100,403,4472,4799,C0O4489C6O4536C8O4532C13O4562C18O4567C24O4601C40O4607C45O4601C46O4729C53O4736C58O4760C59O4767C63O4797,,
code-creation,LazyCompile,10,219283,0xb4611f0a278,166,moduleResolve node:internal/modules/esm/resolve:943:23,0xb469fbeb438,~
code-source-info,0xb4611f0a278,403,30468,31237,C0O30542C7O30551C12O30575C19O30584C23O30704C25O30716C28O30720C34O30778C47O30789C55O30824C60O30850C66O30854C71O30869C83O30880C94O30959C101O30970C110O30968C111O31010C115O31035C127O31046C133O31124C140O31133C145O31152C147O31168C148O31175C160O31182C165O31235,,
code-creation,LazyCompile,10,219390,0xb4611f0a568,454,finalizeResolution node:internal/modules/esm/resolve:371:28,0xb469fbeae98,~
code-source-info,0xb4611f0a568,403,11468,13058,C0O11507C7O11531C10O11557C15O11511C22O11581C27O11636C37O11703C40O11703C47O11587C52O11581C53O11739C58O11739C63O11766C71O11770C78O11824C83O11853C86O11853C91O11920C93O11952C101O11959C111O12005C126O12078C131O12085C141O12074C147O12052C152O12107C154O12116C159O12130C161O12142C162O12150C166O12184C171O12235C178O12245C181O12245C191O12190C196O12184C197O12296C202O12330C209O12342C215O12342C224O12383C230O12383C240O12330C245O12435C250O12435C256O12468C263O12505C266O12505C276O12468C282O12531C284O12541C287O12541C291O12539C295O12563C297O12563C298O12594C303O12594C309O12610C316O12648C318O12665C325O12675C329O12683C332O12683C342O12616C347O12610C348O12722C352O12764C357O12777C364O12792C367O12803C375O12822C382O12764C388O12856C393O12864C398O12887C405O12928C410O12958C413O12928C429O12925C433O12906C439O12981C441O12997C445O13011C447O13025C451O13040C453O13056,,
code-creation,LazyCompile,10,219482,0xb4611f0a960,107,get pathname node:internal/url:925:15,0xb46d10a6d30,~
code-source-info,0xb4611f0a960,74,25209,25469,C0O25218C5O25223C11O25246C23O25252C28O25246C29O25297C33O25302C35O25301C39O25316C43O25325C45O25324C50O25357C56O25361C59O25365C60O25378C65O25383C71O25390C76O25403C78O25413C79O25418C86O25429C89O25452C97O25429C106O25465,,
code-creation,LazyCompile,10,219613,0xb4611f0ac20,106,fileURLToPath node:internal/url:1482:23,0xb46d10a7530,~
code-source-info,0xb4611f0ac20,74,40676,41001,C0O40687C6O40721C13O40728C22O40750C25O40755C31O40780C49O40786C54O40780C55O40856C62O40865C67O40882C77O40888C82O40882C83O40926C92O40945C101O40973C105O40999,,
code-creation,LazyCompile,10,219670,0xb4611f0ae60,179,get origin node:internal/url:770:13,0xb46d10a67a0,~
code-source-info,0xb4611f0ae60,74,21293,21919,C0O21302C5O21307C11O21330C23O21336C28O21330C29O21442C33O21447C35O21446C39O21473C88O21519C93O21524C99O21531C107O21566C112O21586C118O21590C124O21574C130O21596C134O21603C139O21696C145O21717C146O21823C151O21855C156O21867C161O21877C166O21830C171O21883C172O21894C178O21915,,
code-creation,LazyCompile,10,219731,0xb4611f0b0e0,136,getPathFromURLPosix node:internal/url:1464:29,0xb46d10a74e0,~
code-source-info,0xb4611f0b0e0,74,40176,40652,C0O40194C7O40203C12O40217C19O40253C24O40223C29O40217C30O40291C35O40316C37O40332C41O40321C46O40351C48O40363C54O40367C59O40407C66O40421C70O40407C75O40426C79O40440C81O40455C84O40452C90O40460C97O40477C102O40496C112O40502C117O40496C118O40341C123O40303C126O40614C131O40621C135O40650,,
code-creation,LazyCompile,10,219782,0xb4611f0b2c8,48,get hostname node:internal/url:883:15,0xb46d10a6b80,~
code-source-info,0xb4611f0b2c8,74,24151,24263,C0O24160C5O24165C11O24188C23O24194C28O24188C29O24227C33O24239C35O24238C39O24248C47O24259,,
code-creation,LazyCompile,10,219848,0xb4611f0b558,30,tryStatSync node:internal/modules/esm/resolve:164:3,0xb469fbeb618,~
code-source-info,0xb4611f0b558,403,5002,5068,C0O5057C5O5021C10O5012C21O5061C24O5057C29O5068,,
code-creation,LazyCompile,10,219896,0xb4611f0b710,123,statSync node:fs:1588:18,0xb46d1097e50,~
code-source-info,0xb4611f0b710,73,40613,41017,C7O40613C16O40675C21O40682C26O40720C33O40722C40O40746C45O40754C52O40759C55O40770C60O40770C66O40831C76O40754C82O40870C88O40885C96O40898C102O40926C103O40943C104O40950C109O40950C113O40981C118O40988C122O41015,,
code-creation,LazyCompile,10,219956,0xb4611f0b920,64,hasNoEntryError node:fs:1525:25,0xb46d1097d60,~
code-source-info,0xb4611f0b920,73,39050,39241,C0O39068C6O39095C11O39111C16O39095C21O39123C27O39137C36O39141C39O39154C40O39170C46O39194C51O39200C58O39205C61O39218C62O39226C63O39239,,
code-creation,LazyCompile,10,220018,0xb4611f0ba58,576,getStatsFromBinding node:internal/fs/utils:536:29,0xb46d10b5220,~
code-source-info,0xb4611f0ba58,77,14156,15205,C13O14180C18O14184C24O14214C31O14252C34O14249C43O14271C46O14268C55O14290C58O14287C67O14315C70O14312C79O14334C82O14331C91O14353C94O14350C103O14378C106O14375C115O14397C118O14394C127O14416C130O14413C139O14441C142O14438C154O14488C157O14484C167O14508C170O14504C174O14458C189O14556C192O14552C202O14576C205O14572C210O14526C225O14624C228O14620C239O14644C242O14640C247O14594C263O14692C266O14688C277O14712C280O14708C285O14662C294O14221C299O14729C300O14736C307O14766C310O14763C319O14785C322O14782C331O14804C334O14801C343O14827C346O14824C355O14846C358O14843C367O14865C370O14862C379O14888C382O14885C391O14907C394O14904C403O14926C406O14923C415O14949C418O14946C430O14988C433O14984C443O15008C446O15004C450O14964C465O15048C468O15044C478O15068C481O15064C486O15024C501O15108C504O15104C515O15128C518O15124C523O15084C539O15168C542O15164C553O15188C556O15184C561O15144C570O14743C575O15203,,
code-creation,LazyCompile,10,220099,0xb4611f0be88,16,isBigInt64Array node:internal/util/types:49:25,0xb466517baf0,~
code-source-info,0xb4611f0be88,23,1256,1344,C0O1268C5O1275C12O1322C15O1342,,
tick,0x1027cdb12,220152,0,0x0,2,0x102d5e910,0xb4611f0bc1a,0xb4611f0b786,0xb4611f0b562,0xb4611f0a658,0xb4611f0a318,0xb4611f06d86,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f04cda,0xb4611f02807,0xb4611f01d27,0x10311893f
code-creation,LazyCompile,10,220260,0xb4611f0bfa8,19,msFromTimeSpec node:internal/fs/utils:450:24,0xb46d10b4f70,~
code-source-info,0xb4611f0bfa8,77,11068,11127,C0O11084C2O11097C4O11095C10O11116C12O11114C15O11107C18O11125,,
code-creation,LazyCompile,10,220315,0xb4611f0c1e0,116,Stats node:internal/fs/utils:501:15,0xb46d10b5140,~
code-source-info,0xb4611f0c1e0,77,12911,13439,C0O13048C41O13048C46O13176C48O13189C52O13202C54O13215C58O13228C60O13241C64O13254C66O13271C70O13288C73O13301C77O13299C81O13324C84O13337C88O13335C92O13360C95O13373C99O13371C103O13396C106O13413C110O13411C115O13438,,
code-creation,LazyCompile,10,220362,0xb4611f0c3b0,62,StatsBase node:internal/fs/utils:404:19,0xb46d10b4b40,~
code-source-info,0xb4611f0c3b0,77,9975,10264,C0O10061C2O10070C6O10079C8O10089C12O10099C14O10110C18O10121C20O10130C24O10139C26O10148C30O10157C32O10167C36O10177C38O10190C42O10203C44O10212C48O10221C50O10231C54O10241C56O10253C61O10263,,
code-creation,LazyCompile,10,220420,0xb4611f0c598,33,dateFromMs node:internal/fs/utils:465:20,0xb46d10b5010,~
code-source-info,0xb4611f0c598,77,11633,11725,C0O11684C7O11700C12O11710C15O11710C20O11700C27O11691C32O11723,,
code-creation,LazyCompile,10,220466,0xb4611f0c6a8,16,StatsBase.isDirectory node:internal/fs/utils:418:43,0xb46d10b4b90,~
code-source-info,0xb4611f0c6a8,77,10308,10357,C0O10327C7O10346C10O10327C15O10355,,
code-creation,LazyCompile,10,220501,0xb4611f0c7b8,54,Stats._checkModeProperty node:internal/fs/utils:523:46,0xb46d10b5190,~
code-source-info,0xb4611f0c7b8,77,13788,14010,C0O13803C8O13834C10O13830C17O13858C19O13854C26O13886C28O13882C33O13903C34O13916C35O13980C42O13987C44O13985C50O13995C53O14008,,
code-creation,LazyCompile,10,220540,0xb4611f0c8e8,16,StatsBase.isFile node:internal/fs/utils:422:38,0xb46d10b4c20,~
code-source-info,0xb4611f0c8e8,77,10397,10446,C0O10416C7O10435C10O10416C15O10444,,
code-creation,LazyCompile,10,220671,0xb4611f0cab8,66,get search node:internal/url:947:13,0xb46d10a6e10,~
code-source-info,0xb4611f0cab8,74,25768,25961,C0O25777C5O25782C11O25805C23O25811C28O25805C29O25862C33O25867C35O25866C39O25852C44O25881C48O25909C53O25923C55O25933C56O25938C61O25949C65O25957,,
code-creation,LazyCompile,10,220713,0xb4611f0cc30,66,get hash node:internal/url:983:11,0xb46d10a6f60,~
code-source-info,0xb4611f0cc30,74,26701,26906,C0O26710C5O26715C11O26738C23O26744C28O26738C29O26798C33O26803C35O26802C39O26785C44O26817C48O26851C53O26865C55O26875C56O26880C61O26891C65O26902,,
code-creation,LazyCompile,10,220799,0xb4611f0cdf0,210,set search node:internal/url:956:13,0xb46d10a6e80,~
code-source-info,0xb4611f0cdf0,74,25975,26549,C0O25990C5O25995C11O26018C23O26024C28O26018C29O26069C33O26074C35O26073C39O26088C46O26097C52O26122C54O26133C59O26149C60O26159C64O26173C73O26187C75O26186C80O26183C86O26227C87O26237C93O26241C98O26250C108O26259C115O26298C117O26308C121O26320C130O26333C135O26330C139O26360C143O26382C154O26396C163O26429C171O26429C183O26382C188O26500C197O26522C199O26521C203O26500C209O26548,,
code-creation,LazyCompile,10,220855,0xb4611f0d018,41,toUSVString node:internal/util:59:21,0xb4665176ee8,~
code-source-info,0xb4611f0d018,21,1344,1636,C0O1366C4O1517C11O1537C14O1517C20O1566C22O1582C24O1593C25O1596C30O1627C35O1603C40O1634,,
code-creation,LazyCompile,10,220921,0xb4611f0d1a0,173,set hash node:internal/url:992:11,0xb46d10a6fc8,~
code-source-info,0xb4611f0d1a0,74,26918,27418,C0O26931C5O26936C11O26959C23O26965C28O26959C29O27010C33O27015C35O27014C39O27063C44O27085C46O27104C47O27117C51O27131C60O27145C62O27144C67O27141C71O27175C72O27182C73O27193C74O27201C80O27205C85O27214C95O27221C102O27256C104O27269C108O27279C117O27292C122O27289C126O27320C137O27332C146O27364C154O27364C166O27320C172O27417,,
code-creation,LazyCompile,10,220971,0xb4611f0d398,51,throwIfUnsupportedURLProtocol node:internal/modules/esm/resolve:1055:39,0xb469fbeb528,~
code-source-info,0xb4611f0d398,403,34132,34292,C0O34150C7O34159C12O34178C19O34187C24O34212C31O34221C36O34240C43O34246C48O34240C50O34291,,
code-creation,LazyCompile,10,221026,0xb4611f0d580,64,defaultGetFormatWithoutErrors node:internal/modules/esm/get_format:107:39,0xb469fbef5f8,~
code-source-info,0xb4611f0d580,404,3505,3711,C0O3539C7O3539C13O3555C20O3590C23O3615C28O3560C35O3630C36O3642C37O3645C42O3676C46O3668C58O3685C63O3709,,
code-creation,LazyCompile,10,221064,0xb4611f0dae8,47,toString node:internal/url:747:11,0xb46d10a6680,~
code-source-info,0xb4611f0dae8,74,20733,20838,C0O20742C5O20747C11O20770C23O20776C28O20770C29O20809C33O20821C35O20820C41O20829C46O20834,,
code-creation,LazyCompile,10,221149,0xb4611f0dec0,280,getFileProtocolModuleFormat node:internal/modules/esm/get_format:55:37,0xb469fbef558,~
code-source-info,0xb4611f0dec0,404,1597,2902,C0O1647C5O1647C10O1681C15O1681C20O1702C22O1710C27O1727C32O1734C39O1754C50O1791C51O1814C58O1832C62O1841C64O1853C66O1867C67O1871C74O1907C79O2004C83O2022C84O2039C85O2061C88O2069C93O2073C100O2093C107O2113C112O2144C117O2144C122O2199C127O2199C132O2246C139O2267C142O2283C147O2267C156O2246C162O2315C167O2386C171O2480C182O2460C191O2556C201O2534C207O2609C216O2733C229O2751C239O2695C243O2783C259O2789C264O2783C265O2855C270O2862C279O2900,,
code-creation,LazyCompile,10,221259,0xb4611f0e240,211,extname node:path:1385:10,0xb46806ad018,~
code-source-info,0xb4611f0e240,71,41976,43659,C0O41989C8O41989C13O42038C16O42062C18O42079C21O42106C23O42252C25O42277C29O42284C33O42291C34O42291C39O42323C44O42323C50O42365C52O42378C54O42374C59O42542C63O42573C65O42587C69O42602C71O42627C73O42651C75O42659C80O42774C82O42804C84O42812C88O42831C90O42844C92O42840C97O42939C99O42952C104O42970C111O42997C113O43013C118O43030C123O43060C125O43073C130O43233C133O42299C138O42259C141O43270C143O43283C150O43305C156O43400C163O43497C170O43532C173O43524C180O43571C183O43557C188O43585C190O43595C191O43606C205O43613C210O43655,,
code-creation,LazyCompile,10,221329,0xb4611f0e470,13,getPackageType node:internal/modules/esm/resolve:804:24,0xb469fbeb258,~
code-source-info,0xb4611f0e470,403,26069,26159,C0O26101C3O26101C8O26152C12O26157,,
tick,0x102a71f50,221406,0,0x0,3,0x102d5e910,0xb4611f0e473,0xb4611f0dee0,0xb4611f0d5ba,0xb4611f06e92,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f04cda,0xb4611f02807,0xb4611f01d27,0x10311893f
code-creation,LazyCompile,10,221694,0xb4611f0e6c8,173,getPackageScopeConfig node:internal/modules/esm/resolve:228:31,0xb469fbeacb8,~
code-source-info,0xb4611f0e6c8,403,6642,7712,C0O6678C13O6678C19O6775C24O6789C32O6793C39O6870C41O6903C46O6920C49O6920C54O6903C60O7027C66O7035C68O7056C69O7089C72O7109C85O7126C91O7331C96O7363C100O7340C105O7373C107O6717C110O7410C115O7410C120O7465C127O7482C132O7528C137O7549C142O7591C147O7615C154O7633C159O7650C164O7650C170O7689C172O7710,,
code-creation,LazyCompile,10,221824,0xb4611f0eb68,331,getPackageConfig node:internal/modules/esm/resolve:172:26,0xb469fbeac68,~
code-source-info,0xb4611f0eb68,403,5227,6540,C0O5272C5O5289C10O5289C16O5302C18O5336C20O5352C21O5374C26O5392C31O5392C37O5402C42O5413C44O5467C51O5486C56O5525C61O5548C66O5594C71O5620C78O5642C83O5659C88O5659C94O5689C96O5710C97O5722C102O5747C107O5761C115O5759C125O5804C137O5861C144O5872C163O5899C168O5913C174O5899C178O5897C185O5945C192O5810C197O5804C198O5973C203O5982C208O5988C213O5994C218O6026C223O6053C233O6106C235O6129C241O6159C243O6179C249O6209C251O6282C253O6291C260O6312C265O6328C268O6368C275O6385C281O6413C287O6423C293O6433C299O6443C305O6456C312O6472C317O6489C322O6489C328O6517C330O6538,,
code-creation,LazyCompile,10,222191,0xb4611f0ee40,36,validateOutput node:internal/modules/esm/loader:840:28,0xb4611f053d0,~
code-source-info,0xb4611f0ee40,399,24754,24991,C0O24793C10O24861C28O24867C33O24861C35O24990,,
code-creation,LazyCompile,10,222235,0xb4611f0ef68,80,has node:internal/modules/esm/module_map:37:6,0xb469fbe4b10,~
code-source-info,0xb4611f0ef68,400,1259,1413,C11O1272C18O1299C28O1299C33O1331C43O1331C48O1365C50O1378C61O1378C71O1388C78O1395C79O1409,,
code-creation,Function,11,222338,0x11324a440,1400,onParseComplete node:internal/url:544:25,0xb46d10a6138,^
code-source-info,0x11324a440,74,14715,15384,,,
code-creation,Function,11,222368,0x11324aa40,1144,readPackageScope node:internal/modules/cjs/loader:332:26,0xb469fbd96d8,^
code-source-info,0x11324aa40,396,9253,9771,,,
code-creation,Function,11,222395,0x11324af40,320,isURLThis node:internal/url:631:19,0xb46d10a6408,^
code-source-info,0x11324af40,74,17502,17591,,,
code-creation,Function,11,222420,0x11324b100,1072,getPathFromURLPosix node:internal/url:1464:29,0xb46d10a74e0,^
code-source-info,0x11324b100,74,40176,40652,,,
code-creation,Function,11,222439,0x11324b5c0,152,isUint8Array node:internal/util/types:13:22,0xb466517b820,^
code-source-info,0x11324b5c0,23,257,342,,,
code-creation,Function,11,222458,0x11324b700,196,isURLInstance node:internal/url:1561:23,0xb46d10a7620,^
code-source-info,0x11324b700,74,43754,43851,,,
code-creation,Function,11,222476,0x11324b880,260,getOwnPropertyValueOrDefault node:internal/validators:148:38,0xb466517a750,^
code-source-info,0x11324b880,22,4358,4502,,,
code-creation,Function,11,222495,0x11324ba40,268, node:internal/url:653:21,0xb46d10a6540,^
code-source-info,0x11324ba40,74,18118,18193,,,
code-creation,Function,11,222517,0x11324bc00,844, node:internal/validators:164:3,0xb466517a7a0,^
code-source-info,0x11324bc00,22,4714,5262,,,
code-creation,Function,11,222537,0x11324c000,332,URLContext node:internal/url:161:14,0xb46d10a5c38,^
code-source-info,0x11324c000,74,3723,3935,,,
tick,0x1026b04e4,222739,1,0x1026af2d0,6,0x102d66340,0xb4611f02d89,0xb4611f058fb,0x10311893f
code-creation,LazyCompile,10,222761,0xb4611f0f638,78,get node:internal/modules/esm/module_map:18:6,0xb469fbe4a70,~
code-source-info,0xb4611f0f638,400,587,727,C11O600C18O627C28O627C33O659C43O659C48O693C50O706C61O706C71O716C77O723,,
code-creation,LazyCompile,10,222855,0xb4611f0f828,111,#createModuleJob node:internal/modules/esm/loader:466:19,0xb469fbe18c8,~
code-source-info,0xb4611f0f828,399,13641,14493,C0O13641C17O13713C22O14179C31O14220C37O14220C42O14276C70O14276C76O14420C79O14425C84O14435C92O14461C103O14435C108O14478C110O14489,,
code-creation,LazyCompile,10,222995,0xb4611f0fb48,196,ModuleJob node:internal/modules/esm/module_job:53:14,0xb469fbe5970,~
code-source-info,0xb4611f0fb48,401,1256,3022,C0O1256C27O1289C32O1289C50O1365C55O1377C59O1391C64O1413C68O1437C73O1449C77O1463C82O1479C86O1498C90O1510C94O1645C101O1666C104O1695C113O1704C122O1709C135O1666C140O1664C144O1813C149O2706C152O2720C155O2718C159O2827C169O2854C178O2862C181O2827C186O2988C190O3006C195O3021,,
code-creation,LazyCompile,10,223066,0xb4611f105a0,194,moduleProvider node:internal/modules/esm/loader:467:28,0xb4611f0f750,~
code-source-info,0xb4611f105a0,399,13713,14153,C10O13713C18O13828C21O13839C26O13844C33O13859C39O13875C43O13839C57O13828C80O13768C85O13789C90O13810C95O13929C102O13941C107O13941C113O13966C115O13993C130O13999C135O13993C136O14071C158O14078C171O14147,,
code-creation,LazyCompile,10,223188,0xb4611f10bc0,592,load node:internal/modules/esm/loader:567:13,0xb469fbe1af8,~
code-source-info,0xb4611f10bc0,399,17077,20298,C4O17077C70O17117C78O17122C82O17149C90O17184C94O17245C98O17252C108O17343C113O18135C118O18396C124O18419C132O18427C138O18441C148O18396C154O18486C168O18480C196O18522C201O18595C206O18643C213O18653C223O18668C228O18680C229O18700C233O18725C239O18748C245O18772C255O18778C260O18772C261O18855C266O18869C271O18922C276O18940C278O18979C283O19013C285O19033C294O19092C304O19109C313O19107C316O19231C323O19249C334O19256C339O19281C363O19287C368O19281C369O19469C374O19513C388O19513C394O19617C404O19662C408O19679C422O19623C427O19617C428O19718C434O19765C458O19771C463O19765C464O19911C479O19983C483O19983C493O20018C497O20018C503O20058C525O20064C530O20058C531O20232C539O20247C545O20261C551O20280C566O20294,,
code-creation,LazyCompile,10,223292,0xb4611f11068,153,validateArgs node:internal/modules/esm/loader:578:26,0xb4611f10898,~
code-source-info,0xb4611f11068,399,17343,18106,C3O17368C9O17380C16O17398C22O17552C31O17597C47O17558C52O17552C53O17763C56O17773C61O17783C66O17783C76O17823C85O17823C94O17869C103O17917C119O17875C124O17869C125O18039C129O18048C138O18071C146O18048C152O18105,,
code-creation,LazyCompile,10,223527,0xb4611f11408,234,defaultLoad node:internal/modules/esm/load:72:27,0xb46bbe555e8,~
code-source-info,0xb4611f11408,413,2199,2706,C10O2199C18O2236C21O2251C26O2293C31O2305C36O2331C41O2357C46O2372C59O2366C87O2411C101O2411C106O2465C108O2481C115O2509C120O2534C124O2558C129O2584C132O2617C145O2611C168O2587C173O2600C178O2650C185O2663C191O2675C197O2692C211O2704,,
code-creation,LazyCompile,10,223587,0xb4611f11990,150,validateAssertions node:internal/modules/esm/assert:55:28,0xb469fbe79f8,~
code-source-info,0xb4611f11990,402,1781,2908,C12O1842C17O1842C26O1884C33O1897C37O1910C38O1940C48O2091C55O2433C66O2068C67O2080C68O2253C76O2258C83O2325C84O2337C85O2352C88O2399C93O2359C98O2405C99O2507C100O2519C101O2666C109O2671C116O2781C129O2787C134O2781C135O2856C138O2896C143O2856C149O2907,,
code-creation,LazyCompile,10,223667,0xb4611f11d40,446,getSource node:internal/modules/esm/load:32:25,0xb46bbe55598,~
code-source-info,0xb4611f11d40,413,1000,2061,C10O1000C18O1034C25O1034C31O1068C34O1079C36O1100C43O1109C48O1128C53O1143C65O1137C95O1186C102O1195C107O1228C114O1248C117O1273C122O1228C128O1288C130O1308C137O1314C142O1308C143O1361C150O1372C157O1392C164O1412C167O1412C174O1438C183O1401C191O1476C197O1523C204O1532C209O1559C216O1568C221O1603C226O1609C239O1603C265O1662C277O1652C303O1690C310O1744C315O1766C321O1806C335O1806C340O1871C353O1877C358O1871C359O1945C366O1955C375O1973C380O1980C385O1989C390O1989C396O2028C403O2037C409O2050C423O2059,,
code-creation,LazyCompile,10,223822,0xb4611f12138,188,readFile node:internal/fs/promises:863:24,0xb46bbe58a90,~
code-source-info,0xb4611f12138,414,23904,24225,C10O23904C18O23924C23O23945C28O23934C35O23993C44O24009C46O24029C48O24018C53O24045C56O24052C69O24082C70O24086C73O24107C78O24086C82O24130C96O24136C109O24130C135O24163C141O24184C147O24216C152O24170C165O24223,,
code-creation,LazyCompile,10,223880,0xb4611f13fe8,56,checkAborted node:internal/fs/promises:377:22,0xb46bbe57dc0,~
code-source-info,0xb4611f13fe8,414,8563,8662,C0O8576C7O8586C16O8601C23O8622C35O8648C48O8607C53O8601C55O8661,,
tick,0x7ff805ea76fa,223939,0,0x0,3,0x102d5e910,0xb4611f12186,0xb4611f11d75,0xb4611f1148c,0xb4611f064a0,0xb4611f10c5a,0xb4611f105cb,0xb4611f0fbcf,0xb4611f0f86e,0xb4611f050f8,0x10311893f
code-creation,LazyCompile,10,223957,0xb4611f141b0,178,open node:internal/fs/promises:507:20,0xb46bbe57fa0,~
code-source-info,0xb4611f141b0,414,12752,13058,C10O12752C18O12776C23O12783C29O12829C34O12829C39O12853C55O12860C62O12898C69O12931C72O12939C79O12954C82O12965C87O12965C95O13041C104O12939C117O12925C142O12905C155O13056,,
code-creation,LazyCompile,10,224302,0xb4611f14530,229,link node:internal/modules/esm/module_job:66:18,0xb4611f0f9c8,~
code-source-info,0xb4611f14530,401,1813,2649,C4O1813C26O1833C36O1858C48O1847C73O1845C77O1879C89O1891C98O1909C100O1898C104O1879C108O2225C110O2225C112O2252C117O2257C122O2264C132O2264C138O2530C140O2566C147O2572C159O2566C184O2605C194O2612C206O2643,,
code-creation,LazyCompile,10,224355,0xb4611f14790,19,primordials.PromisePrototypeCatch node:internal/per_context/primordials:412:37,0xb4665146388,~
code-source-info,0xb4611f14790,12,11847,11934,C0O11878C13O11878C18O11934,,
code-creation,LazyCompile,10,224416,0xb4611f14960,216,set node:internal/modules/esm/module_map:23:6,0xb469fbe4ac0,~
code-source-info,0xb4611f14960,400,733,1253,C11O746C21O778C31O778C36O810C46O810C51O844C55O863C57O852C62O873C73O928C91O934C96O928C97O995C109O1012C124O1036C126O1032C137O1076C148O995C152O1133C154O1139C165O1139C178O1151C183O1151C188O1175C190O1198C194O1209C196O1222C210O1222C215O1249,,
code-creation,LazyCompile,10,224468,0xb4611f14b68,10, node:internal/modules/esm/module_map:9:63,0xb469fbe49d0,~
code-source-info,0xb4611f14b68,400,263,288,C0O275C2O281C9O287,,
code-creation,LazyCompile,10,224512,0xb4611f14c38,10, node:internal/modules/esm/loader:537:15,0xb4611f04aa0,~
code-source-info,0xb4611f14c38,399,16121,16139,C0O16134C5O16134C9O16139,,
code-creation,LazyCompile,10,224587,0xb4611f15068,431,run node:internal/modules/esm/module_job:188:12,0xb469fbe5a60,~
code-source-info,0xb4611f15068,401,6797,7979,C10O6797C18O6817C23O6817C35O6806C58O6852C61O6882C66O6916C71O6923C76O6923C90O6905C128O6981C133O6986C143O6993C152O7027C158O7065C163O7027C169O7085C182O7095C186O7130C196O7162C204O7134C211O7196C224O7206C228O7292C235O7323C240O7330C248O7292C259O7361C267O7411C272O7418C277O7361C283O7423C294O7447C299O7501C304O7529C309O7536C314O7502C320O7568C327O7573C332O7599C346O7746C360O7689C366O7769C372O7848C378O7609C382O7925C384O7925C385O7944C390O7966C408O7975,,
code-creation,LazyCompile,10,224650,0xb4611f15398,24,instantiate node:internal/modules/esm/module_job:98:14,0xb469fbe59c0,~
code-source-info,0xb4611f15398,401,3037,3171,C0O3055C6O3116C11O3116C15O3109C19O3154C23O3167,,
code-creation,LazyCompile,10,224770,0xb4611f159f0,929,_instantiate node:internal/modules/esm/module_job:105:21,0xb469fbe5a10,~
code-source-info,0xb4611f159f0,401,3193,6784,C4O3193C29O3222C37O3222C42O3222C44O3274C48O3274C50O3530C54O3536C67O3530C97O3585C105O3613C111O3635C118O3650C126O3686C136O3686C142O3714C147O3761C153O3768C159O3786C165O3744C172O3823C178O3830C184O3830C203O3877C215O3877C219O4217C227O4222C236O4258C244O4284C254O4258C261O4394C273O4417C283O4394C289O4461C304O4530C313O4461C319O4606C337O4706C343O4606C350O4578C358O4597C366O4765C372O4772C378O4772C393O4754C418O4737C423O4845C428O5149C434O5156C440O5156C454O5138C479O5115C490O5257C492O5268C497O5320C499O5330C503O5650C517O5650C523O5738C529O5773C546O5773C552O5853C562O5882C581O5941C592O5922C599O6003C606O6080C617O6196C632O6232C640O6283C659O6158C662O5863C666O6353C678O6376C688O6353C694O6400C706O6432C714O6412C718O6453C726O6463C734O6463C739O6461C743O6523C745O6523C746O6571C778O6554C809O6554C812O6729C816O6758C818O6756C822O6543C903O6783,,
code-creation,LazyCompile,10,224895,0xb4611f16050,146,addJobsToDependencyGraph node:internal/modules/esm/module_job:107:38,0xb4611f15730,~
code-source-info,0xb4611f16050,401,3274,3524,C10O3274C18O3303C23O3319C28O3319C35O3345C44O3352C45O3367C50O3379C55O3379C60O3440C72O3424C98O3454C107O3492C110O3461C123O3518,,
tick,0x1028f8b9b,225182,0,0x0,6
code-creation,LazyCompile,10,225370,0xb4611f16200,112,FileHandle node:internal/fs/promises:134:14,0xb46bbe58ae0,~
code-source-info,0xb4611f16200,414,3182,3348,C3O3201C11O3201C40O3214C45O3219C50O3228C54O3246C59O3251C67O3258C69O3282C77O3256C81O3296C86O3301C91O3308C95O3317C100O3322C104O3337C111O3347,,
code-creation,LazyCompile,10,225418,0xb4611f16378,63,MixedEventEmitter node:internal/event_target:1017:16,0xb46bbe62a40,~
code-source-info,0xb4611f16378,46,26575,26705,C0O26575C8O26593C15O26600C21O26635C25O26644C29O26635C41O26657C48O26679C54O26657C62O26704,,
code-creation,LazyCompile,10,225563,0xb4611f16660,595,readFileHandle node:internal/fs/promises:417:30,0xb46bbe57e60,~
code-source-info,0xb4611f16660,414,9836,11608,C10O9836C18O9877C25O9884C33O9897C37O9897C41O9941C47O9955C53O9972C64O9983C68O9955C82O9941C110O10001C114O10001C118O10030C120O10038C122O10053C129O10069C131O10067C138O10081C140O10077C145O10096C147O10113C153O10143C155O10160C157O10171C159O10169C164O10189C172O10195C177O10189C178O10247C180O10272C182O10292C183O10297C187O10322C190O10347C199O10368C203O10375C209O10375C215O10409C219O10409C223O10439C225O10455C227O10471C229O10483C233O10503C239O10519C247O10535C251O10519C257O10572C259O10590C266O10648C269O10675C272O10701C280O10723C287O10736C291O10710C297O10789C303O10804C309O10820C321O10894C334O10804C348O10790C379O10919C381O10932C388O10947C389O10969C396O10988C400O11002C405O11026C410O11060C412O11074C414O11070C418O11130C424O11161C433O11161C440O11188C446O11188C451O11247C455O10400C458O11267C460O11277C461O11286C466O11297C468O11316C477O11351C486O11351C495O11404C503O11411C509O11426C516O11432C520O11439C526O11439C533O11552C539O11570C545O11587C551O11570C565O11599C569O11606,,
code-creation,LazyCompile,10,225654,0xb4611f16aa0,8,get fd node:internal/fs/promises:147:9,0xb46bbe58b98,~
code-source-info,0xb4611f16aa0,414,3419,3449,C0O3428C2O3440C4O3439C7O3445,,
code-creation,LazyCompile,10,225707,0xb4611f16ca8,79,handleFdClose node:internal/fs/promises:344:29,0xb46bbe57d20,~
code-source-info,0xb4611f16ca8,414,7737,8078,C0O7737C23O7768C30O7801C43O7775C56O8076,,
code-creation,LazyCompile,10,225761,0xb4611f16e28,19,allocUnsafeSlow node:buffer:388:50,0xb469fcee9e8,~
code-source-info,0xb4611f16e28,30,11330,11395,C0O11341C5O11341C9O11361C14O11368C18O11393,,
code-creation,LazyCompile,10,225797,0xb4611f16f50,71,createUnsafeBuffer node:internal/buffer:1059:28,0xb469fcfb730,~
code-source-info,0xb4611f16f50,31,30321,30430,C0O30332C8O30344C15O30361C22O30368C39O30408C48O30420C70O30429,,
code-creation,LazyCompile,10,225975,0xb4611f170e8,36, node:internal/fs/promises:347:5,0xb4611f16b78,~
code-source-info,0xb4611f170e8,414,7820,7879,C0O7820C9O7832C21O7853C30O7832C35O7879,,
code-creation,LazyCompile,10,226030,0xb4611f173e0,248,close node:internal/fs/promises:207:11,0xb46bbe5ae48,~
code-source-info,0xb4611f173e0,414,4545,5335,C0O4557C7O4566C9O4565C15O4571C20O4587C27O4594C30O4611C31O4623C38O4632C40O4631C45O4656C52O4668C54O4667C57O4683C58O4695C65O4700C73O4706C77O4714C84O4723C86O4722C91O4730C96O4745C103O4750C108O4755C112O4767C119O4772C126O4789C136O4831C138O4830C142O4840C147O4840C157O4789C162O4787C168O4928C175O4933C182O4950C189O4991C199O4987C210O4950C215O4948C219O5280C222O5285C230O5285C235O5304C242O5316C244O5315C247O5331,,
code-creation,LazyCompile,10,226109,0xb4611f177a8,33,primordials.SafePromisePrototypeFinally node:internal/per_context/primordials:424:43,0xb4665146418,~
code-source-info,0xb4611f177a8,12,12431,12704,C0O12431C13O12564C27O12564C32O12704,,
code-creation,LazyCompile,10,226149,0xb4611f17940,46, node:internal/per_context/primordials:427:15,0xb4611f176f8,~
code-source-info,0xb4611f17940,12,12576,12700,C0O12690C14O12590C20O12664C28O12671C34O12689C39O12690C45O12700,,
code-creation,LazyCompile,10,226183,0xb4611f17a80,27,SafePromise node:internal/per_context/primordials:408:16,0xb4665146338,~
code-source-info,0xb4611f17a80,12,11771,11802,C3O11784C7O11790C11O11784C26O11801,,
code-creation,LazyCompile,10,226221,0xb4611f17b78,22, node:internal/per_context/primordials:428:21,0xb4611f17888,~
code-source-info,0xb4611f17b78,12,12606,12655,C0O12616C16O12616C21O12655,,
code-creation,LazyCompile,10,226269,0xb4611f17c68,17, node:internal/fs/promises:221:9,0xb4611f171c8,~
code-source-info,0xb4611f17c68,414,4857,4899,C0O4865C7O4870C11O4885C16O4898,,
code-creation,LazyCompile,10,226299,0xb4611f17d40,3, node:internal/fs/promises:347:51,0xb4611f17038,~
code-source-info,0xb4611f17d40,414,7866,7878,C0O7872C2O7878,,
code-creation,LazyCompile,10,226342,0xb4611f18078,36,validateOutput node:internal/modules/esm/loader:604:28,0xb4611f108e8,~
code-source-info,0xb4611f18078,399,18135,18372,C0O18174C10O18242C28O18248C33O18242C35O18371,,
tick,0x102ce228e,226422,0,0x0,2,0x102d5e910,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,226774,0xb4611f183d8,196,moduleStrategy node:internal/modules/esm/translators:114:56,0xb46bbe65b10,~
code-source-info,0xb4611f183d8,416,3147,3566,C0O3147C27O3173C40O3173C45O3217C50O3226C56O3247C66O3247C71O3283C83O3319C88O3283C92O3344C113O3344C119O3392C126O3403C131O3415C136O3419C141O3455C153O3517C157O3415C163O3550C173O3564,,
code-creation,LazyCompile,10,226830,0xb4611f19158,83,assertBufferSource node:internal/modules/esm/translators:78:28,0xb46bbe658e0,~
code-source-info,0xb4611f19158,416,2136,2529,C0O2170C10O2221C11O2228C12O2283C15O2283C19O2243C24O2262C29O2302C35O2329C41O2359C42O2366C43O2373C50O2425C77O2379C82O2373,,
code-creation,LazyCompile,10,226880,0xb4611f192b0,31,lazyTypes node:internal/modules/esm/translators:22:19,0xb46bbe65840,~
code-source-info,0xb4611f192b0,416,396,490,C0O403C6O424C10O438C11O441C17O457C24O455C30O488,,
code-creation,LazyCompile,10,227013,0xb4611f193c8,72,stringify node:internal/modules/esm/translators:94:19,0xb46bbe65930,~
code-source-info,0xb4611f193c8,416,2549,2749,C0O2560C6O2590C8O2602C9O2605C20O2605C25O2659C33O2692C36O2688C45O2708C50O2667C56O2719C61O2734C66O2734C71O2747,,
code-creation,LazyCompile,10,227095,0xb4611f195b8,211,TextDecoder node:internal/encoding:383:16,0xb46d2c859a8,~
script-source,33,node:internal/encoding,'use strict';\n\n// An implementation of the WHATWG Encoding Standard\n// https://encoding.spec.whatwg.org\n\nconst {\n  ObjectCreate\x2C\n  ObjectDefineProperties\x2C\n  ObjectGetOwnPropertyDescriptors\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  SafeMap\x2C\n  StringPrototypeSlice\x2C\n  Symbol\x2C\n  SymbolToStringTag\x2C\n  Uint32Array\x2C\n  Uint8Array\x2C\n} = primordials;\n\nconst {\n  ERR_ENCODING_INVALID_ENCODED_DATA\x2C\n  ERR_ENCODING_NOT_SUPPORTED\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_THIS\x2C\n  ERR_NO_ICU\n} = require('internal/errors').codes;\nconst kHandle = Symbol('handle');\nconst kFlags = Symbol('flags');\nconst kEncoding = Symbol('encoding');\nconst kDecoder = Symbol('decoder');\nconst kEncoder = Symbol('encoder');\n\nconst {\n  getConstructorOf\x2C\n  customInspectSymbol: inspect\x2C\n  kEmptyObject\x2C\n  kEnumerableProperty\x2C\n} = require('internal/util');\n\nconst {\n  isAnyArrayBuffer\x2C\n  isArrayBufferView\x2C\n  isUint8Array\n} = require('internal/util/types');\n\nconst {\n  validateString\x2C\n  validateObject\x2C\n} = require('internal/validators');\n\nconst {\n  encodeInto\x2C\n  encodeUtf8String\n} = internalBinding('buffer');\n\nlet Buffer;\nfunction lazyBuffer() {\n  if (Buffer === undefined)\n    Buffer = require('buffer').Buffer;\n  return Buffer;\n}\n\nfunction validateEncoder(obj) {\n  if (obj == null || obj[kEncoder] !== true)\n    throw new ERR_INVALID_THIS('TextEncoder');\n}\n\nfunction validateDecoder(obj) {\n  if (obj == null || obj[kDecoder] !== true)\n    throw new ERR_INVALID_THIS('TextDecoder');\n}\n\nconst CONVERTER_FLAGS_FLUSH = 0x1;\nconst CONVERTER_FLAGS_FATAL = 0x2;\nconst CONVERTER_FLAGS_IGNORE_BOM = 0x4;\n\nconst empty = new Uint8Array(0);\n\nconst encodings = new SafeMap([\n  ['unicode-1-1-utf-8'\x2C 'utf-8']\x2C\n  ['utf8'\x2C 'utf-8']\x2C\n  ['utf-8'\x2C 'utf-8']\x2C\n  ['866'\x2C 'ibm866']\x2C\n  ['cp866'\x2C 'ibm866']\x2C\n  ['csibm866'\x2C 'ibm866']\x2C\n  ['ibm866'\x2C 'ibm866']\x2C\n  ['csisolatin2'\x2C 'iso-8859-2']\x2C\n  ['iso-8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso-ir-101'\x2C 'iso-8859-2']\x2C\n  ['iso8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso88592'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2'\x2C 'iso-8859-2']\x2C\n  ['iso_8859-2:1987'\x2C 'iso-8859-2']\x2C\n  ['l2'\x2C 'iso-8859-2']\x2C\n  ['latin2'\x2C 'iso-8859-2']\x2C\n  ['csisolatin3'\x2C 'iso-8859-3']\x2C\n  ['iso-8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso-ir-109'\x2C 'iso-8859-3']\x2C\n  ['iso8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso88593'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3'\x2C 'iso-8859-3']\x2C\n  ['iso_8859-3:1988'\x2C 'iso-8859-3']\x2C\n  ['l3'\x2C 'iso-8859-3']\x2C\n  ['latin3'\x2C 'iso-8859-3']\x2C\n  ['csisolatin4'\x2C 'iso-8859-4']\x2C\n  ['iso-8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso-ir-110'\x2C 'iso-8859-4']\x2C\n  ['iso8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso88594'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4'\x2C 'iso-8859-4']\x2C\n  ['iso_8859-4:1988'\x2C 'iso-8859-4']\x2C\n  ['l4'\x2C 'iso-8859-4']\x2C\n  ['latin4'\x2C 'iso-8859-4']\x2C\n  ['csisolatincyrillic'\x2C 'iso-8859-5']\x2C\n  ['cyrillic'\x2C 'iso-8859-5']\x2C\n  ['iso-8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso-ir-144'\x2C 'iso-8859-5']\x2C\n  ['iso8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso88595'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5'\x2C 'iso-8859-5']\x2C\n  ['iso_8859-5:1988'\x2C 'iso-8859-5']\x2C\n  ['arabic'\x2C 'iso-8859-6']\x2C\n  ['asmo-708'\x2C 'iso-8859-6']\x2C\n  ['csiso88596e'\x2C 'iso-8859-6']\x2C\n  ['csiso88596i'\x2C 'iso-8859-6']\x2C\n  ['csisolatinarabic'\x2C 'iso-8859-6']\x2C\n  ['ecma-114'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-e'\x2C 'iso-8859-6']\x2C\n  ['iso-8859-6-i'\x2C 'iso-8859-6']\x2C\n  ['iso-ir-127'\x2C 'iso-8859-6']\x2C\n  ['iso8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso88596'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6'\x2C 'iso-8859-6']\x2C\n  ['iso_8859-6:1987'\x2C 'iso-8859-6']\x2C\n  ['csisolatingreek'\x2C 'iso-8859-7']\x2C\n  ['ecma-118'\x2C 'iso-8859-7']\x2C\n  ['elot_928'\x2C 'iso-8859-7']\x2C\n  ['greek'\x2C 'iso-8859-7']\x2C\n  ['greek8'\x2C 'iso-8859-7']\x2C\n  ['iso-8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso-ir-126'\x2C 'iso-8859-7']\x2C\n  ['iso8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso88597'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7'\x2C 'iso-8859-7']\x2C\n  ['iso_8859-7:1987'\x2C 'iso-8859-7']\x2C\n  ['sun_eu_greek'\x2C 'iso-8859-7']\x2C\n  ['csiso88598e'\x2C 'iso-8859-8']\x2C\n  ['csisolatinhebrew'\x2C 'iso-8859-8']\x2C\n  ['hebrew'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso-8859-8-e'\x2C 'iso-8859-8']\x2C\n  ['iso-ir-138'\x2C 'iso-8859-8']\x2C\n  ['iso8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso88598'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8'\x2C 'iso-8859-8']\x2C\n  ['iso_8859-8:1988'\x2C 'iso-8859-8']\x2C\n  ['visual'\x2C 'iso-8859-8']\x2C\n  ['csiso88598i'\x2C 'iso-8859-8-i']\x2C\n  ['iso-8859-8-i'\x2C 'iso-8859-8-i']\x2C\n  ['logical'\x2C 'iso-8859-8-i']\x2C\n  ['csisolatin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso-ir-157'\x2C 'iso-8859-10']\x2C\n  ['iso8859-10'\x2C 'iso-8859-10']\x2C\n  ['iso885910'\x2C 'iso-8859-10']\x2C\n  ['l6'\x2C 'iso-8859-10']\x2C\n  ['latin6'\x2C 'iso-8859-10']\x2C\n  ['iso-8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso8859-13'\x2C 'iso-8859-13']\x2C\n  ['iso885913'\x2C 'iso-8859-13']\x2C\n  ['iso-8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso8859-14'\x2C 'iso-8859-14']\x2C\n  ['iso885914'\x2C 'iso-8859-14']\x2C\n  ['csisolatin9'\x2C 'iso-8859-15']\x2C\n  ['iso-8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso8859-15'\x2C 'iso-8859-15']\x2C\n  ['iso885915'\x2C 'iso-8859-15']\x2C\n  ['iso_8859-15'\x2C 'iso-8859-15']\x2C\n  ['l9'\x2C 'iso-8859-15']\x2C\n  ['cskoi8r'\x2C 'koi8-r']\x2C\n  ['koi'\x2C 'koi8-r']\x2C\n  ['koi8'\x2C 'koi8-r']\x2C\n  ['koi8-r'\x2C 'koi8-r']\x2C\n  ['koi8_r'\x2C 'koi8-r']\x2C\n  ['koi8-ru'\x2C 'koi8-u']\x2C\n  ['koi8-u'\x2C 'koi8-u']\x2C\n  ['csmacintosh'\x2C 'macintosh']\x2C\n  ['mac'\x2C 'macintosh']\x2C\n  ['macintosh'\x2C 'macintosh']\x2C\n  ['x-mac-roman'\x2C 'macintosh']\x2C\n  ['dos-874'\x2C 'windows-874']\x2C\n  ['iso-8859-11'\x2C 'windows-874']\x2C\n  ['iso8859-11'\x2C 'windows-874']\x2C\n  ['iso885911'\x2C 'windows-874']\x2C\n  ['tis-620'\x2C 'windows-874']\x2C\n  ['windows-874'\x2C 'windows-874']\x2C\n  ['cp1250'\x2C 'windows-1250']\x2C\n  ['windows-1250'\x2C 'windows-1250']\x2C\n  ['x-cp1250'\x2C 'windows-1250']\x2C\n  ['cp1251'\x2C 'windows-1251']\x2C\n  ['windows-1251'\x2C 'windows-1251']\x2C\n  ['x-cp1251'\x2C 'windows-1251']\x2C\n  ['ansi_x3.4-1968'\x2C 'windows-1252']\x2C\n  ['ascii'\x2C 'windows-1252']\x2C\n  ['cp1252'\x2C 'windows-1252']\x2C\n  ['cp819'\x2C 'windows-1252']\x2C\n  ['csisolatin1'\x2C 'windows-1252']\x2C\n  ['ibm819'\x2C 'windows-1252']\x2C\n  ['iso-8859-1'\x2C 'windows-1252']\x2C\n  ['iso-ir-100'\x2C 'windows-1252']\x2C\n  ['iso8859-1'\x2C 'windows-1252']\x2C\n  ['iso88591'\x2C 'windows-1252']\x2C\n  ['iso_8859-1'\x2C 'windows-1252']\x2C\n  ['iso_8859-1:1987'\x2C 'windows-1252']\x2C\n  ['l1'\x2C 'windows-1252']\x2C\n  ['latin1'\x2C 'windows-1252']\x2C\n  ['us-ascii'\x2C 'windows-1252']\x2C\n  ['windows-1252'\x2C 'windows-1252']\x2C\n  ['x-cp1252'\x2C 'windows-1252']\x2C\n  ['cp1253'\x2C 'windows-1253']\x2C\n  ['windows-1253'\x2C 'windows-1253']\x2C\n  ['x-cp1253'\x2C 'windows-1253']\x2C\n  ['cp1254'\x2C 'windows-1254']\x2C\n  ['csisolatin5'\x2C 'windows-1254']\x2C\n  ['iso-8859-9'\x2C 'windows-1254']\x2C\n  ['iso-ir-148'\x2C 'windows-1254']\x2C\n  ['iso8859-9'\x2C 'windows-1254']\x2C\n  ['iso88599'\x2C 'windows-1254']\x2C\n  ['iso_8859-9'\x2C 'windows-1254']\x2C\n  ['iso_8859-9:1989'\x2C 'windows-1254']\x2C\n  ['l5'\x2C 'windows-1254']\x2C\n  ['latin5'\x2C 'windows-1254']\x2C\n  ['windows-1254'\x2C 'windows-1254']\x2C\n  ['x-cp1254'\x2C 'windows-1254']\x2C\n  ['cp1255'\x2C 'windows-1255']\x2C\n  ['windows-1255'\x2C 'windows-1255']\x2C\n  ['x-cp1255'\x2C 'windows-1255']\x2C\n  ['cp1256'\x2C 'windows-1256']\x2C\n  ['windows-1256'\x2C 'windows-1256']\x2C\n  ['x-cp1256'\x2C 'windows-1256']\x2C\n  ['cp1257'\x2C 'windows-1257']\x2C\n  ['windows-1257'\x2C 'windows-1257']\x2C\n  ['x-cp1257'\x2C 'windows-1257']\x2C\n  ['cp1258'\x2C 'windows-1258']\x2C\n  ['windows-1258'\x2C 'windows-1258']\x2C\n  ['x-cp1258'\x2C 'windows-1258']\x2C\n  ['x-mac-cyrillic'\x2C 'x-mac-cyrillic']\x2C\n  ['x-mac-ukrainian'\x2C 'x-mac-cyrillic']\x2C\n  ['chinese'\x2C 'gbk']\x2C\n  ['csgb2312'\x2C 'gbk']\x2C\n  ['csiso58gb231280'\x2C 'gbk']\x2C\n  ['gb2312'\x2C 'gbk']\x2C\n  ['gb_2312'\x2C 'gbk']\x2C\n  ['gb_2312-80'\x2C 'gbk']\x2C\n  ['gbk'\x2C 'gbk']\x2C\n  ['iso-ir-58'\x2C 'gbk']\x2C\n  ['x-gbk'\x2C 'gbk']\x2C\n  ['gb18030'\x2C 'gb18030']\x2C\n  ['big5'\x2C 'big5']\x2C\n  ['big5-hkscs'\x2C 'big5']\x2C\n  ['cn-big5'\x2C 'big5']\x2C\n  ['csbig5'\x2C 'big5']\x2C\n  ['x-x-big5'\x2C 'big5']\x2C\n  ['cseucpkdfmtjapanese'\x2C 'euc-jp']\x2C\n  ['euc-jp'\x2C 'euc-jp']\x2C\n  ['x-euc-jp'\x2C 'euc-jp']\x2C\n  ['csiso2022jp'\x2C 'iso-2022-jp']\x2C\n  ['iso-2022-jp'\x2C 'iso-2022-jp']\x2C\n  ['csshiftjis'\x2C 'shift_jis']\x2C\n  ['ms932'\x2C 'shift_jis']\x2C\n  ['ms_kanji'\x2C 'shift_jis']\x2C\n  ['shift-jis'\x2C 'shift_jis']\x2C\n  ['shift_jis'\x2C 'shift_jis']\x2C\n  ['sjis'\x2C 'shift_jis']\x2C\n  ['windows-31j'\x2C 'shift_jis']\x2C\n  ['x-sjis'\x2C 'shift_jis']\x2C\n  ['cseuckr'\x2C 'euc-kr']\x2C\n  ['csksc56011987'\x2C 'euc-kr']\x2C\n  ['euc-kr'\x2C 'euc-kr']\x2C\n  ['iso-ir-149'\x2C 'euc-kr']\x2C\n  ['korean'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1987'\x2C 'euc-kr']\x2C\n  ['ks_c_5601-1989'\x2C 'euc-kr']\x2C\n  ['ksc5601'\x2C 'euc-kr']\x2C\n  ['ksc_5601'\x2C 'euc-kr']\x2C\n  ['windows-949'\x2C 'euc-kr']\x2C\n  ['utf-16be'\x2C 'utf-16be']\x2C\n  ['utf-16le'\x2C 'utf-16le']\x2C\n  ['utf-16'\x2C 'utf-16le']\x2C\n]);\n\n// Unfortunately\x2C String.prototype.trim also removes non-ascii whitespace\x2C\n// so we have to do this manually\nfunction trimAsciiWhitespace(label) {\n  let s = 0;\n  let e = label.length;\n  while (s < e && (\n    label[s] === '\\u0009' ||\n    label[s] === '\\u000a' ||\n    label[s] === '\\u000c' ||\n    label[s] === '\\u000d' ||\n    label[s] === '\\u0020')) {\n    s++;\n  }\n  while (e > s && (\n    label[e - 1] === '\\u0009' ||\n    label[e - 1] === '\\u000a' ||\n    label[e - 1] === '\\u000c' ||\n    label[e - 1] === '\\u000d' ||\n    label[e - 1] === '\\u0020')) {\n    e--;\n  }\n  return StringPrototypeSlice(label\x2C s\x2C e);\n}\n\nfunction getEncodingFromLabel(label) {\n  const enc = encodings.get(label);\n  if (enc !== undefined) return enc;\n  return encodings.get(trimAsciiWhitespace(label.toLowerCase()));\n}\n\nconst encodeIntoResults = new Uint32Array(2);\n\nclass TextEncoder {\n  constructor() {\n    this[kEncoder] = true;\n  }\n\n  get encoding() {\n    validateEncoder(this);\n    return 'utf-8';\n  }\n\n  encode(input = '') {\n    validateEncoder(this);\n    return encodeUtf8String(`${input}`);\n  }\n\n  encodeInto(src\x2C dest) {\n    validateEncoder(this);\n    validateString(src\x2C 'src');\n    if (!dest || !isUint8Array(dest))\n      throw new ERR_INVALID_ARG_TYPE('dest'\x2C 'Uint8Array'\x2C dest);\n    encodeInto(src\x2C dest\x2C encodeIntoResults);\n    return { read: encodeIntoResults[0]\x2C written: encodeIntoResults[1] };\n  }\n\n  [inspect](depth\x2C opts) {\n    validateEncoder(this);\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n    const ctor = getConstructorOf(this);\n    const obj = ObjectCreate({\n      constructor: ctor === null ? TextEncoder : ctor\n    });\n    obj.encoding = this.encoding;\n    // Lazy to avoid circular dependency\n    return require('internal/util/inspect').inspect(obj\x2C opts);\n  }\n}\n\nObjectDefineProperties(\n  TextEncoder.prototype\x2C {\n    'encode': kEnumerableProperty\x2C\n    'encodeInto': kEnumerableProperty\x2C\n    'encoding': kEnumerableProperty\x2C\n    [SymbolToStringTag]: { __proto__: null\x2C configurable: true\x2C value: 'TextEncoder' }\x2C\n  });\n\nconst TextDecoder =\n  internalBinding('config').hasIntl ?\n    makeTextDecoderICU() :\n    makeTextDecoderJS();\n\nfunction makeTextDecoderICU() {\n  const {\n    decode: _decode\x2C\n    getConverter\x2C\n  } = internalBinding('icu');\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = kEmptyObject) {\n      encoding = `${encoding}`;\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        flags |= options.fatal ? CONVERTER_FLAGS_FATAL : 0;\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      const handle = getConverter(enc\x2C flags);\n      if (handle === undefined)\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      this[kDecoder] = true;\n      this[kHandle] = handle;\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n    }\n\n\n    decode(input = empty\x2C options = kEmptyObject) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (!isArrayBufferView(input)) {\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n                                       input);\n      }\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      let flags = 0;\n      if (options !== null)\n        flags |= options.stream ? 0 : CONVERTER_FLAGS_FLUSH;\n\n      const ret = _decode(this[kHandle]\x2C input\x2C flags);\n      if (typeof ret === 'number') {\n        throw new ERR_ENCODING_INVALID_ENCODED_DATA(this.encoding\x2C ret);\n      }\n      return ret.toString('ucs2');\n    }\n  }\n\n  return TextDecoder;\n}\n\nfunction makeTextDecoderJS() {\n  let StringDecoder;\n  function lazyStringDecoder() {\n    if (StringDecoder === undefined)\n      ({ StringDecoder } = require('string_decoder'));\n    return StringDecoder;\n  }\n\n  const kBOMSeen = Symbol('BOM seen');\n\n  function hasConverter(encoding) {\n    return encoding === 'utf-8' || encoding === 'utf-16le';\n  }\n\n  class TextDecoder {\n    constructor(encoding = 'utf-8'\x2C options = kEmptyObject) {\n      encoding = `${encoding}`;\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      const enc = getEncodingFromLabel(encoding);\n      if (enc === undefined || !hasConverter(enc))\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\n\n      let flags = 0;\n      if (options !== null) {\n        if (options.fatal) {\n          throw new ERR_NO_ICU('"fatal" option');\n        }\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\n      }\n\n      this[kDecoder] = true;\n      // StringDecoder will normalize WHATWG encoding to Node.js encoding.\n      this[kHandle] = new (lazyStringDecoder())(enc);\n      this[kFlags] = flags;\n      this[kEncoding] = enc;\n      this[kBOMSeen] = false;\n    }\n\n    decode(input = empty\x2C options = kEmptyObject) {\n      validateDecoder(this);\n      if (isAnyArrayBuffer(input)) {\n        input = lazyBuffer().from(input);\n      } else if (isArrayBufferView(input)) {\n        input = lazyBuffer().from(input.buffer\x2C input.byteOffset\x2C\n                                  input.byteLength);\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\n                                       input);\n      }\n      validateObject(options\x2C 'options'\x2C {\n        nullable: true\x2C\n        allowArray: true\x2C\n        allowFunction: true\x2C\n      });\n\n      if (this[kFlags] & CONVERTER_FLAGS_FLUSH) {\n        this[kBOMSeen] = false;\n      }\n\n      if (options !== null && options.stream) {\n        this[kFlags] &= ~CONVERTER_FLAGS_FLUSH;\n      } else {\n        this[kFlags] |= CONVERTER_FLAGS_FLUSH;\n      }\n\n      let result = this[kFlags] & CONVERTER_FLAGS_FLUSH ?\n        this[kHandle].end(input) :\n        this[kHandle].write(input);\n\n      if (result.length > 0 &&\n          !this[kBOMSeen] &&\n          !(this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM)) {\n        // If the very first result in the stream is a BOM\x2C and we are not\n        // explicitly told to ignore it\x2C then we discard it.\n        if (result[0] === '\\ufeff') {\n          result = StringPrototypeSlice(result\x2C 1);\n        }\n        this[kBOMSeen] = true;\n      }\n\n      return result;\n    }\n  }\n\n  return TextDecoder;\n}\n\n// Mix in some shared properties.\nconst sharedProperties = ObjectGetOwnPropertyDescriptors({\n  get encoding() {\n    validateDecoder(this);\n    return this[kEncoding];\n  }\x2C\n\n  get fatal() {\n    validateDecoder(this);\n    return (this[kFlags] & CONVERTER_FLAGS_FATAL) === CONVERTER_FLAGS_FATAL;\n  }\x2C\n\n  get ignoreBOM() {\n    validateDecoder(this);\n    return (this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM) ===\n              CONVERTER_FLAGS_IGNORE_BOM;\n  }\x2C\n\n  [inspect](depth\x2C opts) {\n    validateDecoder(this);\n    if (typeof depth === 'number' && depth < 0)\n      return this;\n    const constructor = getConstructorOf(this) || TextDecoder;\n    const obj = ObjectCreate({ constructor });\n    obj.encoding = this.encoding;\n    obj.fatal = this.fatal;\n    obj.ignoreBOM = this.ignoreBOM;\n    if (opts.showHidden) {\n      obj[kFlags] = this[kFlags];\n      obj[kHandle] = this[kHandle];\n    }\n    // Lazy to avoid circular dependency\n    const { inspect } = require('internal/util/inspect');\n    return `${constructor.name} ${inspect(obj)}`;\n  }\n});\nconst propertiesValues = ObjectValues(sharedProperties);\nfor (let i = 0; i < propertiesValues.length; i++) {\n  // We want to use null-prototype objects to not rely on globally mutable\n  // %Object.prototype%.\n  ObjectSetPrototypeOf(propertiesValues[i]\x2C null);\n}\nsharedProperties[inspect].enumerable = false;\n\nObjectDefineProperties(TextDecoder.prototype\x2C {\n  decode: kEnumerableProperty\x2C\n  ...sharedProperties\x2C\n  [SymbolToStringTag]: {\n    __proto__: null\x2C\n    configurable: true\x2C\n    value: 'TextDecoder'\n  }\n});\n\nmodule.exports = {\n  getEncodingFromLabel\x2C\n  TextDecoder\x2C\n  TextEncoder\n};\n
code-source-info,0xb4611f195b8,33,10393,11187,C19O10424C26O10446C30O10478C40O10493C48O10478C53O10623C58O10623C63O10661C65O10692C74O10698C79O10692C80O10759C82O10768C86O10817C99O10825C108O10877C121O10889C130O10951C135O10951C141O10983C143O11017C152O11023C157O11017C158O11072C162O11077C166O11087C170O11101C174O11106C179O11115C183O11131C187O11136C192O11144C196O11159C200O11164C205O11175C210O11186,,
tick,0x7ff805e2d43e,229203,0,0x0,3,0x102d6ee20,0xb4611f193ec,0xb4611f1840a,0xb4611f1063e,0x10311893f
tick,0x7ff805dd2be4,229214,0,0x0,3,0x102d6ee20,0xb4611f193ec,0xb4611f1840a,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,229253,0xb4611f1aa88,55,getEncodingFromLabel node:internal/encoding:317:30,0xb46d2c85710,~
code-source-info,0xb4611f1aa88,33,8725,8875,C0O8749C5O8759C10O8759C16O8773C18O8796C20O8807C21O8810C26O8827C34O8857C39O8857C44O8831C49O8827C54O8873,,
code-creation,LazyCompile,10,229357,0xb4611f1ad98,232,decode node:internal/encoding:412:11,0xb46d2c85a68,~
code-source-info,0xb4611f1ad98,33,11200,12032,C8O11209C23O11226C30O11248C35O11248C39O11277C46O11281C52O11316C57O11324C61O11336C66O11337C74O11363C81O11368C87O11404C107O11410C112O11404C113O11580C123O11595C131O11580C136O11725C138O11734C142O11781C158O11794C164O11836C173O11849C175O11848C185O11836C191O11880C195O11919C202O11968C212O11925C217O11919C218O12009C226O12009C231O12026,,
code-creation,LazyCompile,10,229413,0xb4611f1afc0,37,validateDecoder node:internal/encoding:68:25,0xb46d2c85670,~
code-source-info,0xb4611f1afc0,33,1349,1450,C0O1359C7O1382C9O1381C14O1392C19O1406C29O1412C34O1406C36O1449,,
code-creation,LazyCompile,10,229479,0xb4611f1b110,12,slice node:buffer:608:12,0xb469fcef218,~
code-source-info,0xb4611f1b110,30,17110,17156,C0O17135C5O17135C11O17156,,
code-creation,LazyCompile,10,229525,0xb4611f1b1f8,10, node:internal/modules/esm/translators:42:63,0xb46bbe65ac0,~
code-source-info,0xb4611f1b1f8,416,1017,1042,C0O1029C2O1035C9O1041,,
code-creation,Script,10,229625,0xb4611f1b850,124, file:///Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events%20/index.js:1:1,0xb4611f1b3a8,~
script-source,437,file:///Users/tiagolandim/Desktop/codigos/JS-Expert-Performance/02-memoryLeaks/exemple_02-memleak-events%20/index.js,import { createServer } from "http";\nimport { randomBytes } from "crypto";\nimport Events from "events";\n\nconst myEvent = new Events();\n\nfunction getBytes() {\n  return randomBytes(10000);\n}\n\nfunction onData() {\n  getBytes();\n  const itens = [];\n  setInterval(function myInterval() {\n    itens.push(Date.now());\n  });\n}\n\nmyEvent.on("data"\x2C onData);\ncreateServer(function handler(req\x2C res) {\n  myEvent.emit("data"\x2C Date.now());\n\n  res.end("ok");\n}).listen(3000\x2C () => console.log("running at 3000"));\n
code-source-info,0xb4611f1b850,437,0,498,C10O0C31O0C51O0C55O121C61O121C66O121C68O319C71O327C79O327C85O347C96O347C101O445C116O446C123O498,,
code-creation,LazyCompile,10,229798,0xb4611f1bbb8,140, node:internal/modules/esm/module_job:75:41,0xb4611f14420,~
code-source-info,0xb4611f1bbb8,401,2269,2520,C10O2269C18O2331C23O2336C28O2343C37O2367C46O2343C52O2393C61O2412C64O2393C69O2461C79O2461C105O2498C117O2512,,
code-creation,LazyCompile,10,229885,0xb4611f1bd38,13,onParseError node:internal/url:563:22,0xb46d10a6188,~
code-source-info,0xb4611f1bd38,74,15407,15461,C0O15426C7O15432C12O15426,,
code-creation,LazyCompile,10,230017,0xb4611f1bff8,187,NodeError node:internal/errors:355:28,0xb46651603b8,~
script-source,17,node:internal/errors,/* eslint node-core/documented-errors: "error" */\n/* eslint node-core/alphabetize-errors: "error" */\n/* eslint node-core/prefer-util-format-errors: "error" */\n\n'use strict';\n\n// The whole point behind this internal module is to allow Node.js to no\n// longer be forced to treat every error message change as a semver-major\n// change. The NodeError classes here all expose a `code` property whose\n// value statically and permanently identifies the error. While the error\n// message may change\x2C the code should not.\n\nconst {\n  AggregateError\x2C\n  ArrayFrom\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypeJoin\x2C\n  ArrayPrototypeMap\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSplice\x2C\n  ArrayPrototypeUnshift\x2C\n  Error\x2C\n  ErrorCaptureStackTrace\x2C\n  ErrorPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGet\x2C\n  MathAbs\x2C\n  MathMax\x2C\n  Number\x2C\n  NumberIsInteger\x2C\n  ObjectAssign\x2C\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n  ObjectIsExtensible\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  RangeError\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  SafeArrayIterator\x2C\n  SafeMap\x2C\n  SafeWeakMap\x2C\n  String\x2C\n  StringPrototypeEndsWith\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n  SyntaxError\x2C\n  TypeError\x2C\n  URIError\x2C\n} = primordials;\n\nconst kIsNodeError = Symbol('kIsNodeError');\n\nconst isWindows = process.platform === 'win32';\n\nconst messages = new SafeMap();\nconst codes = {};\n\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\n// Sorted by a rough estimate on most frequently used entries.\nconst kTypes = [\n  'string'\x2C\n  'function'\x2C\n  'number'\x2C\n  'object'\x2C\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\n  'Function'\x2C\n  'Object'\x2C\n  'boolean'\x2C\n  'bigint'\x2C\n  'symbol'\x2C\n];\n\nconst MainContextError = Error;\nconst overrideStackTrace = new SafeWeakMap();\nconst kNoOverride = Symbol('kNoOverride');\nlet userStackTraceLimit;\nconst nodeInternalPrefix = '__node_internal_';\nconst prepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // API for node internals to override error stack formatting\n  // without interfering with userland code.\n  if (overrideStackTrace.has(error)) {\n    const f = overrideStackTrace.get(error);\n    overrideStackTrace.delete(error);\n    return f(error\x2C trace);\n  }\n\n  const firstFrame = trace[0]?.getFunctionName();\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\x2C nodeInternalPrefix)) {\n    for (let l = trace.length - 1; l >= 0; l--) {\n      const fn = trace[l]?.getFunctionName();\n      if (fn && StringPrototypeStartsWith(fn\x2C nodeInternalPrefix)) {\n        ArrayPrototypeSplice(trace\x2C 0\x2C l + 1);\n        break;\n      }\n    }\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\x2C\n    // it is updated at every new exception in `captureLargerStackTrace`.\n    if (trace.length > userStackTraceLimit)\n      ArrayPrototypeSplice(trace\x2C userStackTraceLimit);\n  }\n\n  const globalOverride =\n    maybeOverridePrepareStackTrace(globalThis\x2C error\x2C trace);\n  if (globalOverride !== kNoOverride) return globalOverride;\n\n  // Normal error formatting:\n  //\n  // Error: Message\n  //     at function (file)\n  //     at file\n  let errorString;\n  if (kIsNodeError in error) {\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\n  } else {\n    errorString = ErrorPrototypeToString(error);\n  }\n  if (trace.length === 0) {\n    return errorString;\n  }\n  return `${errorString}\\n    at ${ArrayPrototypeJoin(trace\x2C '\\n    at ')}`;\n};\n\nconst maybeOverridePrepareStackTrace = (globalThis\x2C error\x2C trace) => {\n  // Polyfill of V8's Error.prepareStackTrace API.\n  // https://crbug.com/v8/7848\n  // `globalThis` is the global that contains the constructor which\n  // created `error`.\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\n    return globalThis.Error.prepareStackTrace(error\x2C trace);\n  }\n  // We still have legacy usage that depends on the main context's `Error`\n  // being used\x2C even when the error is from a different context.\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\n  if (typeof MainContextError.prepareStackTrace === 'function') {\n    return MainContextError.prepareStackTrace(error\x2C trace);\n  }\n\n  return kNoOverride;\n};\n\nconst aggregateTwoErrors = hideStackFrames((innerError\x2C outerError) => {\n  if (innerError && outerError && innerError !== outerError) {\n    if (ArrayIsArray(outerError.errors)) {\n      // If `outerError` is already an `AggregateError`.\n      ArrayPrototypePush(outerError.errors\x2C innerError);\n      return outerError;\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new AggregateError(new SafeArrayIterator([\n      outerError\x2C\n      innerError\x2C\n    ])\x2C outerError.message);\n    err.code = outerError.code;\n    return err;\n  }\n  return innerError || outerError;\n});\n\n// Lazily loaded\nlet util;\nlet assert;\n\nlet internalUtil = null;\nfunction lazyInternalUtil() {\n  internalUtil ??= require('internal/util');\n  return internalUtil;\n}\n\nlet internalUtilInspect = null;\nfunction lazyInternalUtilInspect() {\n  internalUtilInspect ??= require('internal/util/inspect');\n  return internalUtilInspect;\n}\n\nlet buffer;\nfunction lazyBuffer() {\n  buffer ??= require('buffer').Buffer;\n  return buffer;\n}\n\nfunction isErrorStackTraceLimitWritable() {\n  const desc = ObjectGetOwnPropertyDescriptor(Error\x2C 'stackTraceLimit');\n  if (desc === undefined) {\n    return ObjectIsExtensible(Error);\n  }\n\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'writable') ?\n    desc.writable :\n    desc.set !== undefined;\n}\n\nfunction inspectWithNoCustomRetry(obj\x2C options) {\n  const utilInspect = lazyInternalUtilInspect();\n\n  try {\n    return utilInspect.inspect(obj\x2C options);\n  } catch {\n    return utilInspect.inspect(obj\x2C { ...options\x2C customInspect: false });\n  }\n}\n\n// A specialized Error that includes an additional info property with\n// additional information about the error condition.\n// It has the properties present in a UVException but with a custom error\n// message followed by the uv error code and uv error message.\n// It also has its own error code with the original uv error context put into\n// `err.info`.\n// The context passed into this error must have .code\x2C .syscall and .message\x2C\n// and may have .path and .dest.\nclass SystemError extends Error {\n  constructor(key\x2C context) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    super();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const prefix = getMessage(key\x2C []\x2C this);\n    let message = `${prefix}: ${context.syscall} returned ` +\n                  `${context.code} (${context.message})`;\n\n    if (context.path !== undefined)\n      message += ` ${context.path}`;\n    if (context.dest !== undefined)\n      message += ` => ${context.dest}`;\n\n    captureLargerStackTrace(this);\n\n    this.code = key;\n\n    ObjectDefineProperties(this\x2C {\n      [kIsNodeError]: {\n        __proto__: null\x2C\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      name: {\n        __proto__: null\x2C\n        value: 'SystemError'\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        __proto__: null\x2C\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      info: {\n        __proto__: null\x2C\n        value: context\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n        writable: false\x2C\n      }\x2C\n      errno: {\n        __proto__: null\x2C\n        get() {\n          return context.errno;\n        }\x2C\n        set: (value) => {\n          context.errno = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      syscall: {\n        __proto__: null\x2C\n        get() {\n          return context.syscall;\n        }\x2C\n        set: (value) => {\n          context.syscall = value;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n\n    if (context.path !== undefined) {\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\n      // introduced. The `path` and `dest` properties in the context seem to\n      // always be of type string. We should probably just remove the\n      // `.toString()` and `Buffer.from()` operations and set the value on the\n      // context as the user did.\n      ObjectDefineProperty(this\x2C 'path'\x2C {\n        __proto__: null\x2C\n        get() {\n          return context.path != null ?\n            context.path.toString() : context.path;\n        }\x2C\n        set: (value) => {\n          context.path = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n\n    if (context.dest !== undefined) {\n      ObjectDefineProperty(this\x2C 'dest'\x2C {\n        __proto__: null\x2C\n        get() {\n          return context.dest != null ?\n            context.dest.toString() : context.dest;\n        }\x2C\n        set: (value) => {\n          context.dest = value ?\n            lazyBuffer().from(value.toString()) : undefined;\n        }\x2C\n        enumerable: true\x2C\n        configurable: true\n      });\n    }\n  }\n\n  toString() {\n    return `${this.name} [${this.code}]: ${this.message}`;\n  }\n\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\x2C ctx) {\n    return lazyInternalUtilInspect().inspect(this\x2C {\n      ...ctx\x2C\n      getters: true\x2C\n      customInspect: false\n    });\n  }\n}\n\nfunction makeSystemErrorWithCode(key) {\n  return class NodeError extends SystemError {\n    constructor(ctx) {\n      super(key\x2C ctx);\n    }\n  };\n}\n\nfunction makeNodeErrorWithCode(Base\x2C key) {\n  return function NodeError(...args) {\n    const limit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    const error = new Base();\n    // Reset the limit and setting the name property.\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\n    const message = getMessage(key\x2C args\x2C error);\n    ObjectDefineProperties(error\x2C {\n      [kIsNodeError]: {\n        __proto__: null\x2C\n        value: true\x2C\n        enumerable: false\x2C\n        writable: false\x2C\n        configurable: true\x2C\n      }\x2C\n      message: {\n        __proto__: null\x2C\n        value: message\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n      toString: {\n        __proto__: null\x2C\n        value() {\n          return `${this.name} [${key}]: ${this.message}`;\n        }\x2C\n        enumerable: false\x2C\n        writable: true\x2C\n        configurable: true\x2C\n      }\x2C\n    });\n    captureLargerStackTrace(error);\n    error.code = key;\n    return error;\n  };\n}\n\n/**\n * This function removes unnecessary frames from Node.js core errors.\n * @template {(...args: any[]) => any} T\n * @type {(fn: T) => T}\n */\nfunction hideStackFrames(fn) {\n  // We rename the functions that will be hidden to cut off the stacktrace\n  // at the outermost one\n  const hidden = nodeInternalPrefix + fn.name;\n  ObjectDefineProperty(fn\x2C 'name'\x2C { __proto__: null\x2C value: hidden });\n  return fn;\n}\n\n// Utility function for registering the error codes. Only used here. Exported\n// *only* to allow for testing.\nfunction E(sym\x2C val\x2C def\x2C ...otherClasses) {\n  // Special case for SystemError that formats the error message differently\n  // The SystemErrors only have SystemError as their base classes.\n  messages.set(sym\x2C val);\n  if (def === SystemError) {\n    def = makeSystemErrorWithCode(sym);\n  } else {\n    def = makeNodeErrorWithCode(def\x2C sym);\n  }\n\n  if (otherClasses.length !== 0) {\n    otherClasses.forEach((clazz) => {\n      def[clazz.name] = makeNodeErrorWithCode(clazz\x2C sym);\n    });\n  }\n  codes[sym] = def;\n}\n\nfunction getMessage(key\x2C args\x2C self) {\n  const msg = messages.get(key);\n\n  assert ??= require('internal/assert');\n\n  if (typeof msg === 'function') {\n    assert(\n      msg.length <= args.length\x2C // Default options do not count.\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n        `match the required ones (${msg.length}).`\n    );\n    return ReflectApply(msg\x2C self\x2C args);\n  }\n\n  const regex = /%[dfijoOs]/g;\n  let expectedLength = 0;\n  while (RegExpPrototypeExec(regex\x2C msg) !== null) expectedLength++;\n  assert(\n    expectedLength === args.length\x2C\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\n      `match the required ones (${expectedLength}).`\n  );\n  if (args.length === 0)\n    return msg;\n\n  ArrayPrototypeUnshift(args\x2C msg);\n  return ReflectApply(lazyInternalUtilInspect().format\x2C null\x2C args);\n}\n\nlet uvBinding;\n\nfunction lazyUv() {\n  uvBinding ??= internalBinding('uv');\n  return uvBinding;\n}\n\nconst uvUnmappedError = ['UNKNOWN'\x2C 'unknown error'];\n\nfunction uvErrmapGet(name) {\n  uvBinding = lazyUv();\n  uvBinding.errmap ??= uvBinding.getErrorMap();\n  return MapPrototypeGet(uvBinding.errmap\x2C name);\n}\n\nconst captureLargerStackTrace = hideStackFrames(\n  function captureLargerStackTrace(err) {\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\n    if (stackTraceLimitIsWritable) {\n      userStackTraceLimit = Error.stackTraceLimit;\n      Error.stackTraceLimit = Infinity;\n    }\n    ErrorCaptureStackTrace(err);\n    // Reset the limit\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\n\n    return err;\n  });\n\n/**\n * This creates an error compatible with errors produced in the C++\n * function UVException using a context object with data assembled in C++.\n * The goal is to migrate them to ERR_* errors later when compatibility is\n * not a concern.\n *\n * @param {object} ctx\n * @returns {Error}\n */\nconst uvException = hideStackFrames(function uvException(ctx) {\n  const { 0: code\x2C 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\n  let message = `${code}: ${ctx.message || uvmsg}\x2C ${ctx.syscall}`;\n\n  let path;\n  let dest;\n  if (ctx.path) {\n    path = ctx.path.toString();\n    message += ` '${path}'`;\n  }\n  if (ctx.dest) {\n    dest = ctx.dest.toString();\n    message += ` -> '${dest}'`;\n  }\n\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // Pass the message to the constructor instead of setting it on the object\n  // to make sure it is the same as the one created in C++\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n\n  for (const prop of ObjectKeys(ctx)) {\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\n      continue;\n    }\n    err[prop] = ctx[prop];\n  }\n\n  err.code = code;\n  if (path) {\n    err.path = path;\n  }\n  if (dest) {\n    err.dest = dest;\n  }\n\n  return captureLargerStackTrace(err);\n});\n\n/**\n * This creates an error compatible with errors produced in the C++\n * This function should replace the deprecated\n * `exceptionWithHostPort()` function.\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @returns {Error}\n */\nconst uvExceptionWithHostPort = hideStackFrames(\n  function uvExceptionWithHostPort(err\x2C syscall\x2C address\x2C port) {\n    const { 0: code\x2C 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\n    const message = `${syscall} ${code}: ${uvmsg}`;\n    let details = '';\n\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${message}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.code = code;\n    ex.errno = err;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * This used to be util._errnoException().\n *\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} [original]\n * @returns {Error}\n */\nconst errnoException = hideStackFrames(\n  function errnoException(err\x2C syscall\x2C original) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    util ??= require('util');\n    const code = util.getSystemErrorName(err);\n    const message = original ?\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\n\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(message);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * Deprecated\x2C new function is `uvExceptionWithHostPort()`\n * New function added the error description directly\n * from C++. this method for backwards compatibility\n * @param {number} err - A libuv error number\n * @param {string} syscall\n * @param {string} address\n * @param {number} [port]\n * @param {string} [additional]\n * @returns {Error}\n */\nconst exceptionWithHostPort = hideStackFrames(\n  function exceptionWithHostPort(err\x2C syscall\x2C address\x2C port\x2C additional) {\n    // TODO(joyeecheung): We have to use the type-checked\n    // getSystemErrorName(err) to guard against invalid arguments from users.\n    // This can be replaced with [ code ] = errmap.get(err) when this method\n    // is no longer exposed to user land.\n    util ??= require('util');\n    const code = util.getSystemErrorName(err);\n    let details = '';\n    if (port && port > 0) {\n      details = ` ${address}:${port}`;\n    } else if (address) {\n      details = ` ${address}`;\n    }\n    if (additional) {\n      details += ` - Local (${additional})`;\n    }\n\n    // Reducing the limit improves the performance significantly. We do not\n    // lose the stack frames due to the `captureStackTrace()` function that\n    // is called later.\n    const tmpLimit = Error.stackTraceLimit;\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n    // eslint-disable-next-line no-restricted-syntax\n    const ex = new Error(`${syscall} ${code}${details}`);\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n    ex.errno = err;\n    ex.code = code;\n    ex.syscall = syscall;\n    ex.address = address;\n    if (port) {\n      ex.port = port;\n    }\n\n    return captureLargerStackTrace(ex);\n  });\n\n/**\n * @param {number|string} code - A libuv error number or a c-ares error code\n * @param {string} syscall\n * @param {string} [hostname]\n * @returns {Error}\n */\nconst dnsException = hideStackFrames(function(code\x2C syscall\x2C hostname) {\n  let errno;\n  // If `code` is of type number\x2C it is a libuv error number\x2C else it is a\n  // c-ares error code.\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\n  // make them available in a property that's not error.errno (since they\n  // can be in conflict with libuv error codes). Also make sure\n  // util.getSystemErrorName() can understand them when an being informed that\n  // the number is a c-ares error code.\n  if (typeof code === 'number') {\n    errno = code;\n    // ENOTFOUND is not a proper POSIX error\x2C but this error has been in place\n    // long enough that it's not practical to remove it.\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\n      code = 'ENOTFOUND'; // Fabricated error name.\n    } else {\n      code = lazyInternalUtil().getSystemErrorName(code);\n    }\n  }\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\n  // Reducing the limit improves the performance significantly. We do not lose\n  // the stack frames due to the `captureStackTrace()` function that is called\n  // later.\n  const tmpLimit = Error.stackTraceLimit;\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(message);\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\n  ex.errno = errno;\n  ex.code = code;\n  ex.syscall = syscall;\n  if (hostname) {\n    ex.hostname = hostname;\n  }\n\n  return captureLargerStackTrace(ex);\n});\n\nfunction connResetException(msg) {\n  // eslint-disable-next-line no-restricted-syntax\n  const ex = new Error(msg);\n  ex.code = 'ECONNRESET';\n  return ex;\n}\n\nlet maxStack_ErrorName;\nlet maxStack_ErrorMessage;\n/**\n * Returns true if `err.name` and `err.message` are equal to engine-specific\n * values indicating max call stack size has been exceeded.\n * "Maximum call stack size exceeded" in V8.\n *\n * @param {Error} err\n * @returns {boolean}\n */\nfunction isStackOverflowError(err) {\n  if (maxStack_ErrorMessage === undefined) {\n    try {\n      function overflowStack() { overflowStack(); }\n      overflowStack();\n    } catch (err) {\n      maxStack_ErrorMessage = err.message;\n      maxStack_ErrorName = err.name;\n    }\n  }\n\n  return err && err.name === maxStack_ErrorName &&\n         err.message === maxStack_ErrorMessage;\n}\n\n// Only use this for integers! Decimal numbers do not work with this function.\nfunction addNumericalSeparator(val) {\n  let res = '';\n  let i = val.length;\n  const start = val[0] === '-' ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    res = `_${StringPrototypeSlice(val\x2C i - 3\x2C i)}${res}`;\n  }\n  return `${StringPrototypeSlice(val\x2C 0\x2C i)}${res}`;\n}\n\n// Used to enhance the stack that will be picked up by the inspector\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\n\n// These are supposed to be called only on fatal exceptions before\n// the process exits.\nconst fatalExceptionStackEnhancers = {\n  beforeInspector(error) {\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\n      return error.stack;\n    }\n\n    try {\n      // Set the error.stack here so it gets picked up by the\n      // inspector.\n      error.stack = error[kEnhanceStackBeforeInspector]();\n    } catch {\n      // We are just enhancing the error. If it fails\x2C ignore it.\n    }\n    return error.stack;\n  }\x2C\n  afterInspector(error) {\n    const originalStack = error.stack;\n    let useColors = true;\n    // Some consoles do not convert ANSI escape sequences to colors\x2C\n    // rather display them directly to the stdout. On those consoles\x2C\n    // libuv emulates colors by intercepting stdout stream and calling\n    // corresponding Windows API functions for setting console colors.\n    // However\x2C fatal error are handled differently and we cannot easily\n    // highlight them. On Windows\x2C detecting whether a console supports\n    // ANSI escape sequences is not reliable.\n    if (process.platform === 'win32') {\n      const info = internalBinding('os').getOSInformation();\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2]\x2C '.')\x2C\n                                    Number);\n      if (ver[0] !== 10 || ver[2] < 14393) {\n        useColors = false;\n      }\n    }\n    const {\n      inspect\x2C\n      inspectDefaultOptions: {\n        colors: defaultColors\n      }\n    } = lazyInternalUtilInspect();\n    const colors = useColors &&\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\n                   require('internal/tty').hasColors()) ||\n                   defaultColors);\n    try {\n      return inspect(error\x2C {\n        colors\x2C\n        customInspect: false\x2C\n        depth: MathMax(inspect.defaultOptions.depth\x2C 5)\n      });\n    } catch {\n      return originalStack;\n    }\n  }\n};\n\n// Ensures the printed error line is from user code.\nlet _kArrowMessagePrivateSymbol\x2C _setHiddenValue;\nfunction setArrowMessage(err\x2C arrowMessage) {\n  if (!_kArrowMessagePrivateSymbol) {\n    ({\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol\x2C\n      setHiddenValue: _setHiddenValue\x2C\n    } = internalBinding('util'));\n  }\n  _setHiddenValue(err\x2C _kArrowMessagePrivateSymbol\x2C arrowMessage);\n}\n\n// Hide stack lines before the first user code line.\nfunction hideInternalStackFrames(error) {\n  overrideStackTrace.set(error\x2C (error\x2C stackFrames) => {\n    let frames = stackFrames;\n    if (typeof stackFrames === 'object') {\n      frames = ArrayPrototypeFilter(\n        stackFrames\x2C\n        (frm) => !StringPrototypeStartsWith(frm.getFileName() || ''\x2C\n                                            'node:internal')\n      );\n    }\n    ArrayPrototypeUnshift(frames\x2C error);\n    return ArrayPrototypeJoin(frames\x2C '\\n    at ');\n  });\n}\n\n// Node uses an AbortError that isn't exactly the same as the DOMException\n// to make usage of the error in userland and readable-stream easier.\n// It is a regular error with `.code` and `.name`.\nclass AbortError extends Error {\n  constructor(message = 'The operation was aborted'\x2C options = undefined) {\n    if (options !== undefined && typeof options !== 'object') {\n      throw new codes.ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\n    }\n    super(message\x2C options);\n    this.code = 'ABORT_ERR';\n    this.name = 'AbortError';\n  }\n}\n\n/**\n * This creates a generic Node.js error.\n *\n * @param {string} message The error message.\n * @param {object} errorProperties Object with additional properties to be added to the error.\n * @returns {Error}\n */\nconst genericNodeError = hideStackFrames(function genericNodeError(message\x2C errorProperties) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  ObjectAssign(err\x2C errorProperties);\n  return err;\n});\n\n/**\n * Determine the specific type of a value for type-mismatch errors.\n * @param {*} value\n * @returns {string}\n */\nfunction determineSpecificType(value) {\n  if (value == null) {\n    return '' + value;\n  }\n  if (typeof value === 'function' && value.name) {\n    return `function ${value.name}`;\n  }\n  if (typeof value === 'object') {\n    if (value.constructor?.name) {\n      return `an instance of ${value.constructor.name}`;\n    }\n    return `${lazyInternalUtilInspect().inspect(value\x2C { depth: -1 })}`;\n  }\n  let inspected = lazyInternalUtilInspect()\n    .inspect(value\x2C { colors: false });\n  if (inspected.length > 28) { inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 25)}...`; }\n\n  return `type ${typeof value} (${inspected})`;\n}\n\nmodule.exports = {\n  AbortError\x2C\n  aggregateTwoErrors\x2C\n  captureLargerStackTrace\x2C\n  codes\x2C\n  connResetException\x2C\n  dnsException\x2C\n  // This is exported only to facilitate testing.\n  determineSpecificType\x2C\n  E\x2C\n  errnoException\x2C\n  exceptionWithHostPort\x2C\n  fatalExceptionStackEnhancers\x2C\n  genericNodeError\x2C\n  getMessage\x2C\n  hideInternalStackFrames\x2C\n  hideStackFrames\x2C\n  inspectWithNoCustomRetry\x2C\n  isErrorStackTraceLimitWritable\x2C\n  isStackOverflowError\x2C\n  kEnhanceStackBeforeInspector\x2C\n  kIsNodeError\x2C\n  kNoOverride\x2C\n  maybeOverridePrepareStackTrace\x2C\n  overrideStackTrace\x2C\n  prepareStackTrace\x2C\n  setArrowMessage\x2C\n  SystemError\x2C\n  uvErrmapGet\x2C\n  uvException\x2C\n  uvExceptionWithHostPort\x2C\n};\n\n// To declare an error message\x2C use the E(sym\x2C val\x2C def) function above. The sym\n// must be an upper case string. The val can be either a function or a string.\n// The def must be an error class.\n// The return value of the function must be a string.\n// Examples:\n// E('EXAMPLE_KEY1'\x2C 'This is the error value'\x2C Error);\n// E('EXAMPLE_KEY2'\x2C (a\x2C b) => return `${a} ${b}`\x2C RangeError);\n//\n// Once an error code has been assigned\x2C the code itself MUST NOT change and\n// any given error code must never be reused to identify a different error.\n//\n// Any error code added here should also be added to the documentation\n//\n// Note: Please try to keep these in alphabetical order\n//\n// Note: Node.js specific errors must begin with the prefix ERR_\n\nE('ERR_AMBIGUOUS_ARGUMENT'\x2C 'The "%s" argument is ambiguous. %s'\x2C TypeError);\nE('ERR_ARG_NOT_ITERABLE'\x2C '%s must be iterable'\x2C TypeError);\nE('ERR_ASSERTION'\x2C '%s'\x2C Error);\nE('ERR_ASYNC_CALLBACK'\x2C '%s must be a function'\x2C TypeError);\nE('ERR_ASYNC_TYPE'\x2C 'Invalid name for async "type": %s'\x2C TypeError);\nE('ERR_BROTLI_INVALID_PARAM'\x2C '%s is not a valid Brotli parameter'\x2C RangeError);\nE('ERR_BUFFER_OUT_OF_BOUNDS'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name = undefined) => {\n    if (name) {\n      return `"${name}" is outside of buffer bounds`;\n    }\n    return 'Attempt to access memory outside buffer bounds';\n  }\x2C RangeError);\nE('ERR_BUFFER_TOO_LARGE'\x2C\n  'Cannot create a Buffer larger than %s bytes'\x2C\n  RangeError);\nE('ERR_CANNOT_WATCH_SIGINT'\x2C 'Cannot watch for SIGINT signals'\x2C Error);\nE('ERR_CHILD_CLOSED_BEFORE_REPLY'\x2C\n  'Child closed before reply received'\x2C Error);\nE('ERR_CHILD_PROCESS_IPC_REQUIRED'\x2C\n  "Forked processes must have an IPC channel\x2C missing value 'ipc' in %s"\x2C\n  Error);\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER'\x2C '%s maxBuffer length exceeded'\x2C\n  RangeError);\nE('ERR_CONSOLE_WRITABLE_STREAM'\x2C\n  'Console expects a writable stream instance for %s'\x2C TypeError);\nE('ERR_CONTEXT_NOT_INITIALIZED'\x2C 'context used is not initialized'\x2C Error);\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED'\x2C\n  'Custom engines not supported by this OpenSSL'\x2C Error);\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT'\x2C 'Invalid ECDH format: %s'\x2C TypeError);\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY'\x2C\n  'Public key is not valid for specified curve'\x2C Error);\nE('ERR_CRYPTO_ENGINE_UNKNOWN'\x2C 'Engine "%s" was not found'\x2C Error);\nE('ERR_CRYPTO_FIPS_FORCED'\x2C\n  'Cannot set FIPS mode\x2C it was forced with --force-fips at startup.'\x2C Error);\nE('ERR_CRYPTO_FIPS_UNAVAILABLE'\x2C 'Cannot set FIPS mode in a non-FIPS build.'\x2C\n  Error);\nE('ERR_CRYPTO_HASH_FINALIZED'\x2C 'Digest already called'\x2C Error);\nE('ERR_CRYPTO_HASH_UPDATE_FAILED'\x2C 'Hash update failed'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY'\x2C 'Incompatible %s: %s'\x2C Error);\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'\x2C 'The selected key encoding %s %s.'\x2C\n  Error);\nE('ERR_CRYPTO_INVALID_DIGEST'\x2C 'Invalid digest: %s'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_JWK'\x2C 'Invalid JWK data'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE'\x2C\n  'Invalid key object type %s\x2C expected %s.'\x2C TypeError);\nE('ERR_CRYPTO_INVALID_STATE'\x2C 'Invalid state for operation %s'\x2C Error);\nE('ERR_CRYPTO_PBKDF2_ERROR'\x2C 'PBKDF2 error'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER'\x2C 'Invalid scrypt parameter'\x2C Error);\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED'\x2C 'Scrypt algorithm not supported'\x2C Error);\n// Switch to TypeError. The current implementation does not seem right.\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED'\x2C 'No key provided to sign'\x2C Error);\nE('ERR_DEBUGGER_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DEBUGGER_STARTUP_ERROR'\x2C '%s'\x2C Error);\nE('ERR_DIR_CLOSED'\x2C 'Directory handle was closed'\x2C Error);\nE('ERR_DIR_CONCURRENT_OPERATION'\x2C\n  'Cannot do synchronous work on directory handle with concurrent ' +\n  'asynchronous operations'\x2C Error);\nE('ERR_DNS_SET_SERVERS_FAILED'\x2C 'c-ares failed to set servers: "%s" [%s]'\x2C\n  Error);\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE'\x2C\n  'A callback was registered through ' +\n     'process.setUncaughtExceptionCaptureCallback()\x2C which is mutually ' +\n     'exclusive with using the `domain` module'\x2C\n  Error);\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE'\x2C\n  'The `domain` module is in use\x2C which is mutually exclusive with calling ' +\n     'process.setUncaughtExceptionCaptureCallback()'\x2C\n  Error);\nE('ERR_DUPLICATE_STARTUP_SNAPSHOT_MAIN_FUNCTION'\x2C\n  'Deserialize main function is already configured.'\x2C Error);\nE('ERR_ENCODING_INVALID_ENCODED_DATA'\x2C function(encoding\x2C ret) {\n  this.errno = ret;\n  return `The encoded data was not valid for encoding ${encoding}`;\n}\x2C TypeError);\nE('ERR_ENCODING_NOT_SUPPORTED'\x2C 'The "%s" encoding is not supported'\x2C\n  RangeError);\nE('ERR_EVAL_ESM_CANNOT_PRINT'\x2C '--print cannot be used with ESM input'\x2C Error);\nE('ERR_EVENT_RECURSION'\x2C 'The event "%s" is already being dispatched'\x2C Error);\nE('ERR_FALSY_VALUE_REJECTION'\x2C function(reason) {\n  this.reason = reason;\n  return 'Promise was rejected with falsy value';\n}\x2C Error);\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM'\x2C\n  'The feature %s is unavailable on the current platform' +\n  '\x2C which is being used to run Node.js'\x2C\n  TypeError);\nE('ERR_FS_CP_DIR_TO_NON_DIR'\x2C\n  'Cannot overwrite directory with non-directory'\x2C SystemError);\nE('ERR_FS_CP_EEXIST'\x2C 'Target already exists'\x2C SystemError);\nE('ERR_FS_CP_EINVAL'\x2C 'Invalid src or dest'\x2C SystemError);\nE('ERR_FS_CP_FIFO_PIPE'\x2C 'Cannot copy a FIFO pipe'\x2C SystemError);\nE('ERR_FS_CP_NON_DIR_TO_DIR'\x2C\n  'Cannot overwrite non-directory with directory'\x2C SystemError);\nE('ERR_FS_CP_SOCKET'\x2C 'Cannot copy a socket file'\x2C SystemError);\nE('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY'\x2C\n  'Cannot overwrite symlink in subdirectory of self'\x2C SystemError);\nE('ERR_FS_CP_UNKNOWN'\x2C 'Cannot copy an unknown file type'\x2C SystemError);\nE('ERR_FS_EISDIR'\x2C 'Path is a directory'\x2C SystemError);\nE('ERR_FS_FILE_TOO_LARGE'\x2C 'File size (%s) is greater than 2 GiB'\x2C RangeError);\nE('ERR_FS_INVALID_SYMLINK_TYPE'\x2C\n  'Symlink type must be one of "dir"\x2C "file"\x2C or "junction". Received "%s"'\x2C\n  Error); // Switch to TypeError. The current implementation does not seem right\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN'\x2C\n  'HTTP/2 ALTSVC frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_ALTSVC_LENGTH'\x2C\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_CONNECT_AUTHORITY'\x2C\n  ':authority header is required for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_PATH'\x2C\n  'The :path header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_CONNECT_SCHEME'\x2C\n  'The :scheme header is forbidden for CONNECT requests'\x2C Error);\nE('ERR_HTTP2_GOAWAY_SESSION'\x2C\n  'New streams cannot be created after receiving a GOAWAY'\x2C Error);\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND'\x2C\n  'Cannot specify additional headers after response initiated'\x2C Error);\nE('ERR_HTTP2_HEADERS_SENT'\x2C 'Response has already been initiated.'\x2C Error);\nE('ERR_HTTP2_HEADER_SINGLE_VALUE'\x2C\n  'Header field "%s" must only have a single value'\x2C TypeError);\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED'\x2C\n  'Informational status codes cannot be used'\x2C RangeError);\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS'\x2C\n  'HTTP/1 Connection specific headers are forbidden: "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP2_INVALID_INFO_STATUS'\x2C\n  'Invalid informational status code: %s'\x2C RangeError);\nE('ERR_HTTP2_INVALID_ORIGIN'\x2C\n  'HTTP/2 ORIGIN frames require a valid origin'\x2C TypeError);\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH'\x2C\n  'Packed settings length must be a multiple of six'\x2C RangeError);\nE('ERR_HTTP2_INVALID_PSEUDOHEADER'\x2C\n  '"%s" is an invalid pseudoheader or is used incorrectly'\x2C TypeError);\nE('ERR_HTTP2_INVALID_SESSION'\x2C 'The session has been destroyed'\x2C Error);\nE('ERR_HTTP2_INVALID_SETTING_VALUE'\x2C\n  // Using default arguments here is important so the arguments are not counted\n  // towards `Function#length`.\n  function(name\x2C actual\x2C min = undefined\x2C max = undefined) {\n    this.actual = actual;\n    if (min !== undefined) {\n      this.min = min;\n      this.max = max;\n    }\n    return `Invalid value for setting "${name}": ${actual}`;\n  }\x2C TypeError\x2C RangeError);\nE('ERR_HTTP2_INVALID_STREAM'\x2C 'The stream has been destroyed'\x2C Error);\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK'\x2C\n  'Maximum number of pending settings acknowledgements'\x2C Error);\nE('ERR_HTTP2_NESTED_PUSH'\x2C\n  'A push stream cannot initiate another push stream.'\x2C Error);\nE('ERR_HTTP2_NO_MEM'\x2C 'Out of memory'\x2C Error);\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION'\x2C\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)'\x2C\n  Error);\nE('ERR_HTTP2_ORIGIN_LENGTH'\x2C\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes'\x2C TypeError);\nE('ERR_HTTP2_OUT_OF_STREAMS'\x2C\n  'No stream ID is available because maximum stream ID has been reached'\x2C\n  Error);\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN'\x2C\n  'Responses with %s status must not have a payload'\x2C Error);\nE('ERR_HTTP2_PING_CANCEL'\x2C 'HTTP2 ping cancelled'\x2C Error);\nE('ERR_HTTP2_PING_LENGTH'\x2C 'HTTP2 ping payload must be 8 bytes'\x2C RangeError);\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED'\x2C\n  'Cannot set HTTP/2 pseudo-headers'\x2C TypeError);\nE('ERR_HTTP2_PUSH_DISABLED'\x2C 'HTTP/2 client has disabled push streams'\x2C Error);\nE('ERR_HTTP2_SEND_FILE'\x2C 'Directories cannot be sent'\x2C Error);\nE('ERR_HTTP2_SEND_FILE_NOSEEK'\x2C\n  'Offset or length can only be specified for regular files'\x2C Error);\nE('ERR_HTTP2_SESSION_ERROR'\x2C 'Session closed with error code %s'\x2C Error);\nE('ERR_HTTP2_SETTINGS_CANCEL'\x2C 'HTTP2 session settings canceled'\x2C Error);\nE('ERR_HTTP2_SOCKET_BOUND'\x2C\n  'The socket is already bound to an Http2Session'\x2C Error);\nE('ERR_HTTP2_SOCKET_UNBOUND'\x2C\n  'The socket has been disconnected from the Http2Session'\x2C Error);\nE('ERR_HTTP2_STATUS_101'\x2C\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2'\x2C Error);\nE('ERR_HTTP2_STATUS_INVALID'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP2_STREAM_CANCEL'\x2C function(error) {\n  let msg = 'The pending stream has been canceled';\n  if (error) {\n    this.cause = error;\n    if (typeof error.message === 'string')\n      msg += ` (caused by: ${error.message})`;\n  }\n  return msg;\n}\x2C Error);\nE('ERR_HTTP2_STREAM_ERROR'\x2C 'Stream closed with error code %s'\x2C Error);\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY'\x2C\n  'A stream cannot depend on itself'\x2C Error);\nE('ERR_HTTP2_TOO_MANY_INVALID_FRAMES'\x2C 'Too many invalid HTTP/2 frames'\x2C Error);\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT'\x2C\n  'Trailing headers have already been sent'\x2C Error);\nE('ERR_HTTP2_TRAILERS_NOT_READY'\x2C\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\n  'emitted'\x2C Error);\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL'\x2C 'protocol "%s" is unsupported.'\x2C Error);\nE('ERR_HTTP_HEADERS_SENT'\x2C\n  'Cannot %s headers after they are sent to the client'\x2C Error);\nE('ERR_HTTP_INVALID_HEADER_VALUE'\x2C\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\nE('ERR_HTTP_INVALID_STATUS_CODE'\x2C 'Invalid status code: %s'\x2C RangeError);\nE('ERR_HTTP_REQUEST_TIMEOUT'\x2C 'Request timeout'\x2C Error);\nE('ERR_HTTP_SOCKET_ENCODING'\x2C\n  'Changing the socket encoding is not allowed per RFC7230 Section 3.'\x2C Error);\nE('ERR_HTTP_TRAILER_INVALID'\x2C\n  'Trailers are invalid with this transfer encoding'\x2C Error);\nE('ERR_ILLEGAL_CONSTRUCTOR'\x2C 'Illegal constructor'\x2C TypeError);\nE('ERR_IMPORT_ASSERTION_TYPE_FAILED'\x2C\n  'Module "%s" is not of type "%s"'\x2C TypeError);\nE('ERR_IMPORT_ASSERTION_TYPE_MISSING'\x2C\n  'Module "%s" needs an import assertion of type "%s"'\x2C TypeError);\nE('ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED'\x2C\n  'Import assertion type "%s" is unsupported'\x2C TypeError);\nE('ERR_INCOMPATIBLE_OPTION_PAIR'\x2C\n  'Option "%s" cannot be used in combination with option "%s"'\x2C TypeError);\nE('ERR_INPUT_TYPE_NOT_ALLOWED'\x2C '--input-type can only be used with string ' +\n  'input via --eval\x2C --print\x2C or STDIN'\x2C Error);\nE('ERR_INSPECTOR_ALREADY_ACTIVATED'\x2C\n  'Inspector is already activated. Close it with inspector.close() ' +\n  'before activating it again.'\x2C\n  Error);\nE('ERR_INSPECTOR_ALREADY_CONNECTED'\x2C '%s is already connected'\x2C Error);\nE('ERR_INSPECTOR_CLOSED'\x2C 'Session was closed'\x2C Error);\nE('ERR_INSPECTOR_COMMAND'\x2C 'Inspector error %d: %s'\x2C Error);\nE('ERR_INSPECTOR_NOT_ACTIVE'\x2C 'Inspector is not active'\x2C Error);\nE('ERR_INSPECTOR_NOT_AVAILABLE'\x2C 'Inspector is not available'\x2C Error);\nE('ERR_INSPECTOR_NOT_CONNECTED'\x2C 'Session is not connected'\x2C Error);\nE('ERR_INSPECTOR_NOT_WORKER'\x2C 'Current thread is not a worker'\x2C Error);\nE('ERR_INTERNAL_ASSERTION'\x2C (message) => {\n  const suffix = 'This is caused by either a bug in Node.js ' +\n    'or incorrect usage of Node.js internals.\\n' +\n    'Please open an issue with this stack trace at ' +\n    'https://github.com/nodejs/node/issues\\n';\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\n}\x2C Error);\nE('ERR_INVALID_ADDRESS_FAMILY'\x2C function(addressType\x2C host\x2C port) {\n  this.host = host;\n  this.port = port;\n  return `Invalid address family: ${addressType} ${host}:${port}`;\n}\x2C RangeError);\nE('ERR_INVALID_ARG_TYPE'\x2C\n  (name\x2C expected\x2C actual) => {\n    assert(typeof name === 'string'\x2C "'name' must be a string");\n    if (!ArrayIsArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (StringPrototypeEndsWith(name\x2C ' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n      msg += `"${name}" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string'\x2C\n             'All expected entries have to be of type string');\n      if (ArrayPrototypeIncludes(kTypes\x2C value)) {\n        ArrayPrototypePush(types\x2C StringPrototypeToLowerCase(value));\n      } else if (RegExpPrototypeExec(classRegExp\x2C value) !== null) {\n        ArrayPrototypePush(instances\x2C value);\n      } else {\n        assert(value !== 'object'\x2C\n               'The value "object" should be written as "Object"');\n        ArrayPrototypePush(other\x2C value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = ArrayPrototypeIndexOf(types\x2C 'object');\n      if (pos !== -1) {\n        ArrayPrototypeSplice(types\x2C pos\x2C 1);\n        ArrayPrototypePush(instances\x2C 'Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = ArrayPrototypePop(types);\n        msg += `one of type ${ArrayPrototypeJoin(types\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = ArrayPrototypePop(instances);\n        msg +=\n          `an instance of ${ArrayPrototypeJoin(instances\x2C '\x2C ')}\x2C or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = ArrayPrototypePop(other);\n        msg += `one of ${ArrayPrototypeJoin(other\x2C '\x2C ')}\x2C or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    msg += `. Received ${determineSpecificType(actual)}`;\n\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_ARG_VALUE'\x2C (name\x2C value\x2C reason = 'is invalid') => {\n  let inspected = lazyInternalUtilInspect().inspect(value);\n  if (inspected.length > 128) {\n    inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 128)}...`;\n  }\n  const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_ASYNC_ID'\x2C 'Invalid %s value: %s'\x2C RangeError);\nE('ERR_INVALID_BUFFER_SIZE'\x2C\n  'Buffer size must be a multiple of %s'\x2C RangeError);\nE('ERR_INVALID_CHAR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (name\x2C field = undefined) => {\n    let msg = `Invalid character in ${name}`;\n    if (field !== undefined) {\n      msg += ` ["${field}"]`;\n    }\n    return msg;\n  }\x2C TypeError);\nE('ERR_INVALID_CURSOR_POS'\x2C\n  'Cannot set cursor row without setting its column'\x2C TypeError);\nE('ERR_INVALID_FD'\x2C\n  '"fd" must be a positive integer: %s'\x2C RangeError);\nE('ERR_INVALID_FD_TYPE'\x2C 'Unsupported fd type: %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_HOST'\x2C\n  'File URL host must be "localhost" or empty on %s'\x2C TypeError);\nE('ERR_INVALID_FILE_URL_PATH'\x2C 'File URL path %s'\x2C TypeError);\nE('ERR_INVALID_HANDLE_TYPE'\x2C 'This handle type cannot be sent'\x2C TypeError);\nE('ERR_INVALID_HTTP_TOKEN'\x2C '%s must be a valid HTTP token ["%s"]'\x2C TypeError);\nE('ERR_INVALID_IP_ADDRESS'\x2C 'Invalid IP address: %s'\x2C TypeError);\nE('ERR_INVALID_MODULE_SPECIFIER'\x2C (request\x2C reason\x2C base = undefined) => {\n  return `Invalid module "${request}" ${reason}${base ?\n    ` imported from ${base}` : ''}`;\n}\x2C TypeError);\nE('ERR_INVALID_PACKAGE_CONFIG'\x2C (path\x2C base\x2C message) => {\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\n    ''}${message ? `. ${message}` : ''}`;\n}\x2C Error);\nE('ERR_INVALID_PACKAGE_TARGET'\x2C\n  (pkgPath\x2C key\x2C target\x2C isImport = false\x2C base = undefined) => {\n    const relError = typeof target === 'string' && !isImport &&\n      target.length && !StringPrototypeStartsWith(target\x2C './');\n    if (key === '.') {\n      assert(isImport === false);\n      return `Invalid "exports" main target ${JSONStringify(target)} defined ` +\n        `in the package config ${pkgPath}package.json${base ?\n          ` imported from ${base}` : ''}${relError ?\n          '; targets must start with "./"' : ''}`;\n    }\n    return `Invalid "${isImport ? 'imports' : 'exports'}" target ${\n      JSONStringify(target)} defined for '${key}' in the package config ${\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\n      '; targets must start with "./"' : ''}`;\n  }\x2C Error);\nE('ERR_INVALID_PROTOCOL'\x2C\n  'Protocol "%s" not supported. Expected "%s"'\x2C\n  TypeError);\nE('ERR_INVALID_REPL_EVAL_CONFIG'\x2C\n  'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'\x2C TypeError);\nE('ERR_INVALID_REPL_INPUT'\x2C '%s'\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY'\x2C (input\x2C name\x2C prop\x2C value) => {\n  return `Expected a valid ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${value}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_PROPERTY_VALUE'\x2C (input\x2C name\x2C prop\x2C value) => {\n  let type;\n  if (value && value.constructor && value.constructor.name) {\n    type = `instance of ${value.constructor.name}`;\n  } else {\n    type = `type ${typeof value}`;\n  }\n  return `Expected ${input} to be returned for the "${prop}" from the` +\n         ` "${name}" function but got ${type}.`;\n}\x2C TypeError);\nE('ERR_INVALID_RETURN_VALUE'\x2C (input\x2C name\x2C value) => {\n  const type = determineSpecificType(value);\n\n  return `Expected ${input} to be returned from the "${name}"` +\n         ` function but got ${type}.`;\n}\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_STATE'\x2C 'Invalid state: %s'\x2C Error\x2C TypeError\x2C RangeError);\nE('ERR_INVALID_SYNC_FORK_INPUT'\x2C\n  'Asynchronous forks do not support ' +\n    'Buffer\x2C TypedArray\x2C DataView or string input: %s'\x2C\n  TypeError);\nE('ERR_INVALID_THIS'\x2C 'Value of "this" must be of type %s'\x2C TypeError);\nE('ERR_INVALID_TUPLE'\x2C '%s must be an iterable %s tuple'\x2C TypeError);\nE('ERR_INVALID_URI'\x2C 'URI malformed'\x2C URIError);\nE('ERR_INVALID_URL'\x2C function(input) {\n  this.input = input;\n  // Don't include URL in message.\n  // (See https://github.com/nodejs/node/pull/38614)\n  return 'Invalid URL';\n}\x2C TypeError);\nE('ERR_INVALID_URL_SCHEME'\x2C\n  (expected) => {\n    if (typeof expected === 'string')\n      expected = [expected];\n    assert(expected.length <= 2);\n    const res = expected.length === 2 ?\n      `one of scheme ${expected[0]} or ${expected[1]}` :\n      `of scheme ${expected[0]}`;\n    return `The URL must be ${res}`;\n  }\x2C TypeError);\nE('ERR_IPC_CHANNEL_CLOSED'\x2C 'Channel closed'\x2C Error);\nE('ERR_IPC_DISCONNECTED'\x2C 'IPC channel is already disconnected'\x2C Error);\nE('ERR_IPC_ONE_PIPE'\x2C 'Child process can have only one IPC pipe'\x2C Error);\nE('ERR_IPC_SYNC_FORK'\x2C 'IPC cannot be used with synchronous forks'\x2C Error);\nE(\n  'ERR_LOADER_CHAIN_INCOMPLETE'\x2C\n  '"%s" did not call the next hook in its chain and did not' +\n  ' explicitly signal a short circuit. If this is intentional\x2C include' +\n  ' `shortCircuit: true` in the hook\\'s return.'\x2C\n  Error\n);\nE('ERR_MANIFEST_ASSERT_INTEGRITY'\x2C\n  (moduleURL\x2C realIntegrities) => {\n    let msg = `The content of "${\n      moduleURL\n    }" does not match the expected integrity.`;\n    if (realIntegrities.size) {\n      const sri = ArrayPrototypeJoin(\n        ArrayFrom(realIntegrities.entries()\x2C\n                  ({ 0: alg\x2C 1: dgs }) => `${alg}-${dgs}`)\x2C\n        ' '\n      );\n      msg += ` Integrities found are: ${sri}`;\n    } else {\n      msg += ' The resource was not found in the policy.';\n    }\n    return msg;\n  }\x2C Error);\nE('ERR_MANIFEST_DEPENDENCY_MISSING'\x2C\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\n  'conditions: %s'\x2C\n  Error);\nE('ERR_MANIFEST_INTEGRITY_MISMATCH'\x2C\n  'Manifest resource %s has multiple entries but integrity lists do not match'\x2C\n  SyntaxError);\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD'\x2C\n  'Manifest resource %s has invalid property value for %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_INVALID_SPECIFIER'\x2C\n  'Manifest resource %s has invalid dependency mapping %s'\x2C\n  TypeError);\nE('ERR_MANIFEST_TDZ'\x2C 'Manifest initialization has not yet run'\x2C Error);\nE('ERR_MANIFEST_UNKNOWN_ONERROR'\x2C\n  'Manifest specified unknown error behavior "%s".'\x2C\n  SyntaxError);\nE('ERR_METHOD_NOT_IMPLEMENTED'\x2C 'The %s method is not implemented'\x2C Error);\nE('ERR_MISSING_ARGS'\x2C\n  (...args) => {\n    assert(args.length > 0\x2C 'At least one arg needs to be specified');\n    let msg = 'The ';\n    const len = args.length;\n    const wrap = (a) => `"${a}"`;\n    args = ArrayPrototypeMap(\n      args\x2C\n      (a) => (ArrayIsArray(a) ?\n        ArrayPrototypeJoin(ArrayPrototypeMap(a\x2C wrap)\x2C ' or ') :\n        wrap(a))\n    );\n    switch (len) {\n      case 1:\n        msg += `${args[0]} argument`;\n        break;\n      case 2:\n        msg += `${args[0]} and ${args[1]} arguments`;\n        break;\n      default:\n        msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args\x2C 0\x2C len - 1)\x2C '\x2C ');\n        msg += `\x2C and ${args[len - 1]} arguments`;\n        break;\n    }\n    return `${msg} must be specified`;\n  }\x2C TypeError);\nE('ERR_MISSING_OPTION'\x2C '%s is required'\x2C TypeError);\nE('ERR_MODULE_NOT_FOUND'\x2C (path\x2C base\x2C type = 'package') => {\n  return `Cannot find ${type} '${path}' imported from ${base}`;\n}\x2C Error);\nE('ERR_MULTIPLE_CALLBACK'\x2C 'Callback called multiple times'\x2C Error);\nE('ERR_NAPI_CONS_FUNCTION'\x2C 'Constructor must be a function'\x2C TypeError);\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS'\x2C\n  'byte_offset + byte_length should be less than or equal to the size in ' +\n    'bytes of the array passed in'\x2C\n  RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT'\x2C\n  'start offset of %s should be a multiple of %s'\x2C RangeError);\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH'\x2C\n  'Invalid typed array length'\x2C RangeError);\nE('ERR_NETWORK_IMPORT_BAD_RESPONSE'\x2C\n  "import '%s' received a bad response: %s"\x2C Error);\nE('ERR_NETWORK_IMPORT_DISALLOWED'\x2C\n  "import of '%s' by %s is not supported: %s"\x2C Error);\nE('ERR_NOT_BUILDING_SNAPSHOT'\x2C\n  'Operation cannot be invoked when not building startup snapshot'\x2C Error);\nE('ERR_NO_CRYPTO'\x2C\n  'Node.js is not compiled with OpenSSL crypto support'\x2C Error);\nE('ERR_NO_ICU'\x2C\n  '%s is not supported on Node.js compiled without ICU'\x2C TypeError);\nE('ERR_OPERATION_FAILED'\x2C 'Operation failed: %s'\x2C Error\x2C TypeError);\nE('ERR_OUT_OF_RANGE'\x2C\n  (str\x2C range\x2C input\x2C replaceDefaultBoolean = false) => {\n    assert(range\x2C 'Missing "range" argument');\n    let msg = replaceDefaultBoolean ? str :\n      `The value of "${str}" is out of range.`;\n    let received;\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input));\n    } else if (typeof input === 'bigint') {\n      received = String(input);\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\n        received = addNumericalSeparator(received);\n      }\n      received += 'n';\n    } else {\n      received = lazyInternalUtilInspect().inspect(input);\n    }\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }\x2C RangeError);\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED'\x2C (specifier\x2C packagePath\x2C base) => {\n  return `Package import specifier "${specifier}" is not defined${packagePath ?\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\n}\x2C TypeError);\nE('ERR_PACKAGE_PATH_NOT_EXPORTED'\x2C (pkgPath\x2C subpath\x2C base = undefined) => {\n  if (subpath === '.')\n    return `No "exports" main defined in ${pkgPath}package.json${base ?\n      ` imported from ${base}` : ''}`;\n  return `Package subpath '${subpath}' is not defined by "exports" in ${\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\n}\x2C Error);\nE('ERR_PARSE_ARGS_INVALID_OPTION_VALUE'\x2C '%s'\x2C TypeError);\nE('ERR_PARSE_ARGS_UNEXPECTED_POSITIONAL'\x2C "Unexpected argument '%s'. This " +\n  'command does not take positional arguments'\x2C TypeError);\nE('ERR_PARSE_ARGS_UNKNOWN_OPTION'\x2C (option\x2C allowPositionals) => {\n  const suggestDashDash = allowPositionals ? '. To specify a positional ' +\n    "argument starting with a '-'\x2C place it at the end of the command after " +\n    `'--'\x2C as in '-- ${JSONStringify(option)}` : '';\n  return `Unknown option '${option}'${suggestDashDash}`;\n}\x2C TypeError);\nE('ERR_PERFORMANCE_INVALID_TIMESTAMP'\x2C\n  '%d is not a valid timestamp'\x2C TypeError);\nE('ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS'\x2C '%s'\x2C TypeError);\nE('ERR_REQUIRE_ESM'\x2C\n  function(filename\x2C hasEsmSyntax\x2C parentPath = null\x2C packageJsonPath = null) {\n    hideInternalStackFrames(this);\n    let msg = `require() of ES Module ${filename}${parentPath ? ` from ${\n      parentPath}` : ''} not supported.`;\n    if (!packageJsonPath) {\n      if (StringPrototypeEndsWith(filename\x2C '.mjs'))\n        msg += `\\nInstead change the require of ${filename} to a dynamic ` +\n            'import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    const path = require('path');\n    const basename = parentPath && path.basename(filename) ===\n      path.basename(parentPath) ? filename : path.basename(filename);\n    if (hasEsmSyntax) {\n      msg += `\\nInstead change the require of ${basename} in ${parentPath} to` +\n        ' a dynamic import() which is available in all CommonJS modules.';\n      return msg;\n    }\n    msg += `\\n${basename} is treated as an ES module file as it is a .js ` +\n      'file whose nearest parent package.json contains "type": "module" ' +\n      'which declares all .js files in that package scope as ES modules.' +\n      `\\nInstead rename ${basename} to end in .cjs\x2C change the requiring ` +\n      'code to use dynamic import() which is available in all CommonJS ' +\n      'modules\x2C or change "type": "module" to "type": "commonjs" in ' +\n      `${packageJsonPath} to treat all .js files as CommonJS (using .mjs for ` +\n      'all ES modules instead).\\n';\n    return msg;\n  }\x2C Error);\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED'\x2C\n  'Script execution was interrupted by `SIGINT`'\x2C Error);\nE('ERR_SERVER_ALREADY_LISTEN'\x2C\n  'Listen method has been called more than once without closing.'\x2C Error);\nE('ERR_SERVER_NOT_RUNNING'\x2C 'Server is not running.'\x2C Error);\nE('ERR_SOCKET_ALREADY_BOUND'\x2C 'Socket is already bound'\x2C Error);\nE('ERR_SOCKET_BAD_BUFFER_SIZE'\x2C\n  'Buffer size must be a positive integer'\x2C TypeError);\nE('ERR_SOCKET_BAD_PORT'\x2C (name\x2C port\x2C allowZero = true) => {\n  assert(typeof allowZero === 'boolean'\x2C\n         "The 'allowZero' argument must be of type boolean.");\n  const operator = allowZero ? '>=' : '>';\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\n}\x2C RangeError);\nE('ERR_SOCKET_BAD_TYPE'\x2C\n  'Bad socket type specified. Valid types are: udp4\x2C udp6'\x2C TypeError);\nE('ERR_SOCKET_BUFFER_SIZE'\x2C\n  'Could not get or set buffer size'\x2C\n  SystemError);\nE('ERR_SOCKET_CLOSED'\x2C 'Socket is closed'\x2C Error);\nE('ERR_SOCKET_DGRAM_IS_CONNECTED'\x2C 'Already connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED'\x2C 'Not connected'\x2C Error);\nE('ERR_SOCKET_DGRAM_NOT_RUNNING'\x2C 'Not running'\x2C Error);\nE('ERR_SRI_PARSE'\x2C\n  'Subresource Integrity string %j had an unexpected %j at position %d'\x2C\n  SyntaxError);\nE('ERR_STREAM_ALREADY_FINISHED'\x2C\n  'Cannot call %s after a stream was finished'\x2C\n  Error);\nE('ERR_STREAM_CANNOT_PIPE'\x2C 'Cannot pipe\x2C not readable'\x2C Error);\nE('ERR_STREAM_DESTROYED'\x2C 'Cannot call %s after a stream was destroyed'\x2C Error);\nE('ERR_STREAM_NULL_VALUES'\x2C 'May not write null values to stream'\x2C TypeError);\nE('ERR_STREAM_PREMATURE_CLOSE'\x2C 'Premature close'\x2C Error);\nE('ERR_STREAM_PUSH_AFTER_EOF'\x2C 'stream.push() after EOF'\x2C Error);\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT'\x2C\n  'stream.unshift() after end event'\x2C Error);\nE('ERR_STREAM_WRAP'\x2C 'Stream has StringDecoder set or is in objectMode'\x2C Error);\nE('ERR_STREAM_WRITE_AFTER_END'\x2C 'write after end'\x2C Error);\nE('ERR_SYNTHETIC'\x2C 'JavaScript Callstack'\x2C Error);\nE('ERR_SYSTEM_ERROR'\x2C 'A system error occurred'\x2C SystemError);\nE('ERR_TEST_FAILURE'\x2C function(error\x2C failureType) {\n  hideInternalStackFrames(this);\n  assert(typeof failureType === 'string'\x2C\n         "The 'failureType' argument must be of type string.");\n\n  let msg = error?.message ?? error;\n\n  if (typeof msg !== 'string') {\n    msg = inspectWithNoCustomRetry(msg);\n  }\n\n  this.failureType = failureType;\n  this.cause = error;\n  return msg;\n}\x2C Error);\nE('ERR_TLS_CERT_ALTNAME_FORMAT'\x2C 'Invalid subject alternative name string'\x2C\n  SyntaxError);\nE('ERR_TLS_CERT_ALTNAME_INVALID'\x2C function(reason\x2C host\x2C cert) {\n  this.reason = reason;\n  this.host = host;\n  this.cert = cert;\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\n}\x2C Error);\nE('ERR_TLS_DH_PARAM_SIZE'\x2C 'DH parameter size %s is less than 2048'\x2C Error);\nE('ERR_TLS_HANDSHAKE_TIMEOUT'\x2C 'TLS handshake timeout'\x2C Error);\nE('ERR_TLS_INVALID_CONTEXT'\x2C '%s must be a SecureContext'\x2C TypeError);\nE('ERR_TLS_INVALID_PROTOCOL_VERSION'\x2C\n  '%j is not a valid %s TLS protocol version'\x2C TypeError);\nE('ERR_TLS_INVALID_STATE'\x2C 'TLS socket connection must be securely established'\x2C\n  Error);\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT'\x2C\n  'TLS protocol version %j conflicts with secureProtocol %j'\x2C TypeError);\nE('ERR_TLS_RENEGOTIATION_DISABLED'\x2C\n  'TLS session renegotiation disabled for this socket'\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_TLS_REQUIRED_SERVER_NAME'\x2C\n  '"servername" is required parameter for Server.addContext'\x2C Error);\nE('ERR_TLS_SESSION_ATTACK'\x2C 'TLS session renegotiation attack detected'\x2C Error);\nE('ERR_TLS_SNI_FROM_SERVER'\x2C\n  'Cannot issue SNI from a TLS server-side socket'\x2C Error);\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED'\x2C\n  'At least one category is required'\x2C TypeError);\nE('ERR_TRACE_EVENTS_UNAVAILABLE'\x2C 'Trace events are unavailable'\x2C Error);\n\n// This should probably be a `RangeError`.\nE('ERR_TTY_INIT_FAILED'\x2C 'TTY initialization failed'\x2C SystemError);\nE('ERR_UNAVAILABLE_DURING_EXIT'\x2C 'Cannot call function in process exit ' +\n  'handler'\x2C Error);\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET'\x2C\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\n    'callback was already active'\x2C\n  Error);\nE('ERR_UNESCAPED_CHARACTERS'\x2C '%s contains unescaped characters'\x2C TypeError);\nE('ERR_UNHANDLED_ERROR'\x2C\n  // Using a default argument here is important so the argument is not counted\n  // towards `Function#length`.\n  (err = undefined) => {\n    const msg = 'Unhandled error.';\n    if (err === undefined) return msg;\n    return `${msg} (${err})`;\n  }\x2C Error);\nE('ERR_UNKNOWN_BUILTIN_MODULE'\x2C 'No such built-in module: %s'\x2C Error);\nE('ERR_UNKNOWN_CREDENTIAL'\x2C '%s identifier does not exist: %s'\x2C Error);\nE('ERR_UNKNOWN_ENCODING'\x2C 'Unknown encoding: %s'\x2C TypeError);\nE('ERR_UNKNOWN_FILE_EXTENSION'\x2C (ext\x2C path\x2C suggestion) => {\n  let msg = `Unknown file extension "${ext}" for ${path}`;\n  if (suggestion) {\n    msg += `. ${suggestion}`;\n  }\n  return msg;\n}\x2C TypeError);\nE('ERR_UNKNOWN_MODULE_FORMAT'\x2C 'Unknown module format: %s for URL %s'\x2C\n  RangeError);\nE('ERR_UNKNOWN_SIGNAL'\x2C 'Unknown signal: %s'\x2C TypeError);\nE('ERR_UNSUPPORTED_DIR_IMPORT'\x2C "Directory import '%s' is not supported " +\n'resolving ES modules imported from %s'\x2C Error);\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME'\x2C (url\x2C supported) => {\n  let msg = `Only URLs with a scheme in: ${ArrayPrototypeJoin(supported\x2C '\x2C ')} are supported by the default ESM loader`;\n  if (isWindows && url.protocol.length === 2) {\n    msg +=\n      '. On Windows\x2C absolute paths must be valid file:// URLs';\n  }\n  msg += `. Received protocol '${url.protocol}'`;\n  return msg;\n}\x2C Error);\nE('ERR_USE_AFTER_CLOSE'\x2C '%s was closed'\x2C Error);\n\n// This should probably be a `TypeError`.\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE'\x2C\n  'At least one valid performance entry type is required'\x2C Error);\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'\x2C\n  'A dynamic import callback was not specified.'\x2C TypeError);\nE('ERR_VM_MODULE_ALREADY_LINKED'\x2C 'Module has already been linked'\x2C Error);\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA'\x2C\n  'Cached data cannot be created for a module which has been evaluated'\x2C Error);\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT'\x2C\n  'Linked modules must use the same context'\x2C Error);\nE('ERR_VM_MODULE_LINK_FAILURE'\x2C function(message\x2C cause) {\n  this.cause = cause;\n  return message;\n}\x2C Error);\nE('ERR_VM_MODULE_NOT_MODULE'\x2C\n  'Provided module is not an instance of Module'\x2C Error);\nE('ERR_VM_MODULE_STATUS'\x2C 'Module status %s'\x2C Error);\nE('ERR_WASI_ALREADY_STARTED'\x2C 'WASI instance has already started'\x2C Error);\nE('ERR_WEBASSEMBLY_RESPONSE'\x2C 'WebAssembly response %s'\x2C TypeError);\nE('ERR_WORKER_INIT_FAILED'\x2C 'Worker initialization failure: %s'\x2C Error);\nE('ERR_WORKER_INVALID_EXEC_ARGV'\x2C (errors\x2C msg = 'invalid execArgv flags') =>\n  `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors\x2C '\x2C ')}`\x2C\n  Error);\nE('ERR_WORKER_NOT_RUNNING'\x2C 'Worker instance not running'\x2C Error);\nE('ERR_WORKER_OUT_OF_MEMORY'\x2C\n  'Worker terminated due to reaching memory limit: %s'\x2C Error);\nE('ERR_WORKER_PATH'\x2C (filename) =>\n  'The worker script or module filename must be an absolute path or a ' +\n  'relative path starting with \\'./\\' or \\'../\\'.' +\n  (StringPrototypeStartsWith(filename\x2C 'file://') ?\n    ' Wrap file:// URLs with `new URL`.' : ''\n  ) +\n  (StringPrototypeStartsWith(filename\x2C 'data:text/javascript') ?\n    ' Wrap data: URLs with `new URL`.' : ''\n  ) +\n  ` Received "${filename}"`\x2C\n  TypeError);\nE('ERR_WORKER_UNSERIALIZABLE_ERROR'\x2C\n  'Serializing an uncaught exception failed'\x2C Error);\nE('ERR_WORKER_UNSUPPORTED_OPERATION'\x2C\n  '%s is not supported in workers'\x2C TypeError);\nE('ERR_ZLIB_INITIALIZATION_FAILED'\x2C 'Initialization failed'\x2C Error);\n
code-source-info,0xb4611f1bff8,17,9925,10909,C0O9925C3O9955C10O9961C15O9982C20O9986C25O10020C33O10042C37O10065C40O10065C46O10135C51O10139C56O10173C65O10195C69O10224C83O10224C89O10258C96O10281C105O10297C109O10312C121O10464C128O10506C142O10619C147O10654C162O10258C167O10834C174O10834C178O10870C180O10881C184O10892C186O10905,,
tick,0x7ff805e2d810,237231,0,0x0,3,0x102d6ee20,0xb4611f1bd3f,0x1026af2d0,0xb4611f02d89,0xb4611f06c6f,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f1bbe6,0x1025e2730,0xb4611f145b4,0x10311893f
tick,0x7ff805e4dd6d,237246,0,0x0,3,0x102d6ee20,0xb4611f1bd3f,0x1026af2d0,0xb4611f02d89,0xb4611f06c6f,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f1bbe6,0x1025e2730,0xb4611f145b4,0x10311893f
tick,0x7ff805edeb48,237255,0,0x0,3,0x102d6ee20,0xb4611f1bd3f,0x1026af2d0,0xb4611f02d89,0xb4611f06c6f,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f1bbe6,0x1025e2730,0xb4611f145b4,0x10311893f
tick,0x7ff805ea4dea,237264,0,0x0,3,0x102d6ee20,0xb4611f1bd3f,0x1026af2d0,0xb4611f02d89,0xb4611f06c6f,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f1bbe6,0x1025e2730,0xb4611f145b4,0x10311893f
tick,0x7ff805ea76fa,237274,0,0x0,3,0x102d6ee20,0xb4611f1bd3f,0x1026af2d0,0xb4611f02d89,0xb4611f06c6f,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f1bbe6,0x1025e2730,0xb4611f145b4,0x10311893f
tick,0x7ff805ea4dea,237283,0,0x0,3,0x102d6ee20,0xb4611f1bd3f,0x1026af2d0,0xb4611f02d89,0xb4611f06c6f,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f1bbe6,0x1025e2730,0xb4611f145b4,0x10311893f
code-creation,LazyCompile,10,237295,0xb4611f1f7e8,64,isErrorStackTraceLimitWritable node:internal/errors:193:40,0xb4665160068,~
code-source-info,0xb4611f1f7e8,17,5450,5707,C0O5470C7O5501C13O5470C19O5530C21O5560C28O5586C31O5567C35O5593C36O5601C44O5608C51O5667C57O5687C62O5691C63O5705,,
code-creation,LazyCompile,10,237404,0xb4611f1fa98,291,getMessage node:internal/errors:426:20,0xb4665160608,~
code-source-info,0xb4611f1fa98,17,11963,12815,C0O11997C5O12006C10O12006C16O12019C30O12030C37O12026C43O12061C49O12098C54O12116C59O12131C63O12123C72O12187C83O12231C101O12293C115O12251C119O12098C124O12315C138O12322C143O12352C144O12374C149O12412C151O12456C156O12424C163O12466C168O12417C171O12486C176O12522C180O12513C189O12543C200O12587C220O12643C230O12607C234O12486C239O12678C245O12685C250O12696C252O12707C253O12711C258O12711C263O12747C271O12767C275O12792C285O12754C290O12813,,
code-creation,LazyCompile,10,237470,0xb4611f1fd40,9, node:internal/errors:1360:30,0xb46651610f8,~
code-source-info,0xb4611f1fd40,17,47527,47672,C0O47539C2O47550C6O47649C8O47670,,
code-creation,LazyCompile,10,237533,0xb4611f1fe88,68,captureLargerStackTrace node:internal/errors:471:35,0xb46651606f8,~
code-source-info,0xb4611f1fe88,17,13207,13577,C0O13253C3O13253C7O13291C9O13330C14O13358C21O13350C27O13381C32O13405C35O13403C39O13425C44O13425C48O13481C52O13512C59O13536C61O13534C65O13562C67O13573,,
tick,0x102a5cb01,237797,0,0x0,3,0x102d5e910,0xb4611f0a2f7,0xb4611f06d86,0xb4611f064a0,0xb4611f05819,0xb4611f0507a,0xb4611f1bbe6,0x1025e2730,0xb4611f145b4,0x10311893f
code-creation,LazyCompile,10,237836,0xb4611f20168,440,packageResolve node:internal/modules/esm/resolve:853:24,0xb469fbeb2f8,~
code-source-info,0xb4611f20168,403,27558,29624,C0O27592C5O27609C10O27609C19O27650C22O27663C27O27663C34O27708C44O27731C50O27715C55O27744C56O27806C59O27806C65O27760C70O27773C75O27789C80O27883C83O27883C88O27932C94O27969C99O27997C104O27969C109O28031C116O28036C121O28077C127O28116C133O28142C151O28149C156O28245C157O28284C167O28310C173O28324C182O28284C188O28374C193O28374C198O28411C200O28445C207O28457C212O28564C216O28571C223O28457C229O28445C234O28593C239O28593C245O28616C248O28650C255O28676C266O28751C272O28773C281O28667C287O28815C292O28833C297O28870C299O28935C311O28935C317O29009C323O29048C329O29074C347O29081C352O29177C353O29188C355O29207C360O29224C372O29231C377O29318C378O29330C391O29337C396O29377C397O29439C402O29459C406O29446C411O28423C414O29557C421O29601C424O29601C434O29563C439O29557,,
code-creation,LazyCompile,10,237981,0xb4611f204f8,3,node: node:internal/modules/esm/get_format:33:10,0xb469fbef698,~
code-source-info,0xb4611f204f8,404,1131,1155,C0O1136C2O1153,,
code-creation,LazyCompile,10,238309,0xb4611f20768,33,primordials.SafePromiseAll node:internal/per_context/primordials:452:30,0xb46651464f8,~
code-source-info,0xb4611f20768,12,13302,13529,C0O13302C13O13428C27O13428C32O13529,,
code-creation,LazyCompile,10,238342,0xb4611f208b0,49, node:internal/per_context/primordials:455:15,0xb4611f206b8,~
code-source-info,0xb4611f208b0,12,13440,13525,C0O13515C7O13466C16O13470C25O13470C31O13466C37O13514C42O13515C48O13525,,
code-creation,LazyCompile,10,238379,0xb4611f20a40,45,arrayToSafePromiseIterable node:internal/per_context/primordials:438:36,0xb46651464a8,~
code-source-info,0xb4611f20a40,12,12897,13132,C0O12897C9O12920C14O12936C23O12959C26O12984C31O12959C39O12920C44O13132,,
code-creation,LazyCompile,10,238415,0xb4611f20c00,33, node:internal/per_context/primordials:442:7,0xb4611f20988,~
code-source-info,0xb4611f20c00,12,13000,13122,C0O13000C13O13024C27O13024C32O13122,,
code-creation,LazyCompile,10,238448,0xb4611f20d30,47, node:internal/per_context/primordials:443:25,0xb4611f20b50,~
code-source-info,0xb4611f20d30,12,13040,13121,C0O13050C29O13097C41O13050C46O13121,,
code-creation,Function,11,238627,0x11324c200,2448, node:internal/url:699:12,0xb46d10a6630,^
code-source-info,0x11324c200,74,19418,20668,,,
code-creation,Function,11,238655,0x11324cc40,952,URL node:internal/url:636:14,0xb46d10a6458,^
code-source-info,0x11324cc40,74,17618,18011,,,
code-creation,Function,11,238677,0x11324d080,360,get protocol node:internal/url:795:15,0xb46d10a6810,^
code-source-info,0x11324d080,74,21935,22043,,,
code-creation,Function,11,238696,0x11324d280,320,initSearchParams node:internal/url:1082:26,0xb46d10a7170,^
code-source-info,0x11324d280,74,29398,29513,,,
code-creation,Function,11,238716,0x11324d440,652,isErrorStackTraceLimitWritable node:internal/errors:193:40,0xb4665160068,^
code-source-info,0x11324d440,17,5450,5707,,,
code-creation,Function,11,238737,0x11324d780,240,SafePromise node:internal/per_context/primordials:408:16,0xb4665146338,^
code-source-info,0x11324d780,12,11771,11802,,,
tick,0x11324c200,239091,0,0x0,0,0xb4611f10d03,0x10311893f
code-creation,LazyCompile,10,239253,0xb4611f21510,149,builtinStrategy node:internal/modules/esm/translators:254:58,0xb46bbe65bd8,~
code-source-info,0xb4611f21510,416,7550,7902,C6O7550C14O7560C24O7595C29O7560C33O7642C41O7642C47O7689C52O7689C58O7718C66O7723C75O7767C77O7781C84O7787C89O7781C90O7830C100O7861C105O7830C109O7885C114O7885C126O7900,,
code-creation,Eval,10,239458,0xb4611f21b50,5, node:http:1:1,0xb4611f219a8,~
script-source,438,node:http,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ArrayPrototypeSort\x2C\n  ObjectDefineProperty\x2C\n} = primordials;\n\nconst httpAgent = require('_http_agent');\nconst { ClientRequest } = require('_http_client');\nconst { methods } = require('_http_common');\nconst { IncomingMessage } = require('_http_incoming');\nconst {\n  validateHeaderName\x2C\n  validateHeaderValue\x2C\n  OutgoingMessage\n} = require('_http_outgoing');\nconst {\n  _connectionListener\x2C\n  STATUS_CODES\x2C\n  Server\x2C\n  ServerResponse\n} = require('_http_server');\nlet maxHeaderSize;\n\n/**\n * Returns a new instance of `http.Server`.\n * @param {{\n *   IncomingMessage?: IncomingMessage;\n *   ServerResponse?: ServerResponse;\n *   insecureHTTPParser?: boolean;\n *   maxHeaderSize?: number;\n *   }} [opts]\n * @param {Function} [requestListener]\n * @returns {Server}\n */\nfunction createServer(opts\x2C requestListener) {\n  return new Server(opts\x2C requestListener);\n}\n\n/**\n * @typedef {object} HTTPRequestOptions\n * @property {httpAgent.Agent | boolean} [agent]\n * @property {string} [auth]\n * @property {Function} [createConnection]\n * @property {number} [defaultPort]\n * @property {number} [family]\n * @property {object} [headers]\n * @property {number} [hints]\n * @property {string} [host]\n * @property {string} [hostname]\n * @property {boolean} [insecureHTTPParser]\n * @property {string} [localAddress]\n * @property {number} [localPort]\n * @property {Function} [lookup]\n * @property {number} [maxHeaderSize]\n * @property {string} [method]\n * @property {string} [path]\n * @property {number} [port]\n * @property {string} [protocol]\n * @property {boolean} [setHost]\n * @property {string} [socketPath]\n * @property {number} [timeout]\n * @property {AbortSignal} [signal]\n */\n\n/**\n * Makes an HTTP request.\n * @param {string | URL} url\n * @param {HTTPRequestOptions} [options]\n * @param {Function} [cb]\n * @returns {ClientRequest}\n */\nfunction request(url\x2C options\x2C cb) {\n  return new ClientRequest(url\x2C options\x2C cb);\n}\n\n/**\n * Makes a `GET` HTTP request.\n * @param {string | URL} url\n * @param {HTTPRequestOptions} [options]\n * @param {Function} [cb]\n * @returns {ClientRequest}\n */\nfunction get(url\x2C options\x2C cb) {\n  const req = request(url\x2C options\x2C cb);\n  req.end();\n  return req;\n}\n\nmodule.exports = {\n  _connectionListener\x2C\n  METHODS: ArrayPrototypeSort(ArrayPrototypeSlice(methods))\x2C\n  STATUS_CODES\x2C\n  Agent: httpAgent.Agent\x2C\n  ClientRequest\x2C\n  IncomingMessage\x2C\n  OutgoingMessage\x2C\n  Server\x2C\n  ServerResponse\x2C\n  createServer\x2C\n  validateHeaderName\x2C\n  validateHeaderValue\x2C\n  get\x2C\n  request\n};\n\nObjectDefineProperty(module.exports\x2C 'maxHeaderSize'\x2C {\n  __proto__: null\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  get() {\n    if (maxHeaderSize === undefined) {\n      const { getOptionValue } = require('internal/options');\n      maxHeaderSize = getOptionValue('--max-http-header-size');\n    }\n\n    return maxHeaderSize;\n  }\n});\n\nObjectDefineProperty(module.exports\x2C 'globalAgent'\x2C {\n  __proto__: null\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  get() {\n    return httpAgent.globalAgent;\n  }\x2C\n  set(value) {\n    httpAgent.globalAgent = value;\n  }\n});\n
code-source-info,0xb4611f21b50,438,0,4220,C0O0C4O4220,,
code-creation,Function,10,239934,0xb4611f22070,349, node:http:1:1,0xb4611f21ac8,~
code-source-info,0xb4611f22070,438,0,4220,C0O0C37O1159C42O1182C47O1204C52O1262C58O1262C62O1262C64O1312C70O1312C75O1294C81O1357C87O1357C92O1345C97O1410C103O1410C108O1390C113O1512C119O1512C124O1447C129O1469C134O1492C139O1617C145O1617C150O1549C155O1572C160O1588C166O1598C171O1646C172O1646C174O3354C181O3375C185O3426C191O3407C201O3459C209O3492C219O3501C225O3518C231O3537C237O3556C243O3566C249O3584C255O3600C261O3622C267O3645C273O3652C279O3369C283O3692C298O3783C306O3664C311O4026C326O4115C334O4164C342O3998C348O4219,,
tick,0x102ce0f6c,240310,1,0x10266e4e0,2,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f220aa,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,Eval,10,240600,0xb4611f23218,5, node:_http_agent:1:1,0xb4611f22e70,~
script-source,439,node:_http_agent,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeIncludes\x2C\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeShift\x2C\n  ArrayPrototypeSome\x2C\n  ArrayPrototypeSplice\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsNaN\x2C\n  ObjectCreate\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  ObjectValues\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeStartsWith\x2C\n  StringPrototypeSubstr\x2C\n  Symbol\x2C\n} = primordials;\n\nconst net = require('net');\nconst EventEmitter = require('events');\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\nconst { AsyncResource } = require('async_hooks');\nconst { async_id_symbol } = require('internal/async_hooks').symbols;\nconst {\n  codes: {\n    ERR_OUT_OF_RANGE\x2C\n  }\x2C\n} = require('internal/errors');\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst {\n  validateNumber\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst kOnKeylog = Symbol('onkeylog');\nconst kRequestOptions = Symbol('requestOptions');\nconst kRequestAsyncResource = Symbol('requestAsyncResource');\n// New Agent code.\n\n// The largest departure from the previous implementation is that\n// an Agent instance holds connections for a variable number of host:ports.\n// Surprisingly\x2C this is still API compatible as far as third parties are\n// concerned. The only code that really notices the difference is the\n// request object.\n\n// Another departure is that all code related to HTTP parsing is in\n// ClientRequest.onSocket(). The Agent is now *strictly*\n// concerned with managing a connection pool.\n\nclass ReusedHandle {\n  constructor(type\x2C handle) {\n    this.type = type;\n    this.handle = handle;\n  }\n}\n\nfunction freeSocketErrorListener(err) {\n  const socket = this;\n  debug('SOCKET ERROR on FREE socket:'\x2C err.message\x2C err.stack);\n  socket.destroy();\n  socket.emit('agentRemove');\n}\n\nfunction Agent(options) {\n  if (!(this instanceof Agent))\n    return new Agent(options);\n\n  FunctionPrototypeCall(EventEmitter\x2C this);\n\n  this.defaultPort = 80;\n  this.protocol = 'http:';\n\n  this.options = { __proto__: null\x2C ...options };\n\n  if (this.options.noDelay === undefined)\n    this.options.noDelay = true;\n\n  // Don't confuse net and make it think that we're connecting to a pipe\n  this.options.path = null;\n  this.requests = ObjectCreate(null);\n  this.sockets = ObjectCreate(null);\n  this.freeSockets = ObjectCreate(null);\n  this.keepAliveMsecs = this.options.keepAliveMsecs || 1000;\n  this.keepAlive = this.options.keepAlive || false;\n  this.maxSockets = this.options.maxSockets || Agent.defaultMaxSockets;\n  this.maxFreeSockets = this.options.maxFreeSockets || 256;\n  this.scheduling = this.options.scheduling || 'lifo';\n  this.maxTotalSockets = this.options.maxTotalSockets;\n  this.totalSocketCount = 0;\n\n  validateOneOf(this.scheduling\x2C 'scheduling'\x2C ['fifo'\x2C 'lifo']);\n\n  if (this.maxTotalSockets !== undefined) {\n    validateNumber(this.maxTotalSockets\x2C 'maxTotalSockets');\n    if (this.maxTotalSockets <= 0 || NumberIsNaN(this.maxTotalSockets))\n      throw new ERR_OUT_OF_RANGE('maxTotalSockets'\x2C '> 0'\x2C\n                                 this.maxTotalSockets);\n  } else {\n    this.maxTotalSockets = Infinity;\n  }\n\n  this.on('free'\x2C (socket\x2C options) => {\n    const name = this.getName(options);\n    debug('agent.on(free)'\x2C name);\n\n    // TODO(ronag): socket.destroy(err) might have been called\n    // before coming here and have an 'error' scheduled. In the\n    // case of socket.destroy() below this 'error' has no handler\n    // and could cause unhandled exception.\n\n    if (!socket.writable) {\n      socket.destroy();\n      return;\n    }\n\n    const requests = this.requests[name];\n    if (requests && requests.length) {\n      const req = ArrayPrototypeShift(requests);\n      const reqAsyncRes = req[kRequestAsyncResource];\n      if (reqAsyncRes) {\n        // Run request within the original async context.\n        reqAsyncRes.runInAsyncScope(() => {\n          asyncResetHandle(socket);\n          setRequestSocket(this\x2C req\x2C socket);\n        });\n        req[kRequestAsyncResource] = null;\n      } else {\n        setRequestSocket(this\x2C req\x2C socket);\n      }\n      if (requests.length === 0) {\n        delete this.requests[name];\n      }\n      return;\n    }\n\n    // If there are no pending requests\x2C then put it in\n    // the freeSockets pool\x2C but only if we're allowed to do so.\n    const req = socket._httpMessage;\n    if (!req || !req.shouldKeepAlive || !this.keepAlive) {\n      socket.destroy();\n      return;\n    }\n\n    const freeSockets = this.freeSockets[name] || [];\n    const freeLen = freeSockets.length;\n    let count = freeLen;\n    if (this.sockets[name])\n      count += this.sockets[name].length;\n\n    if (this.totalSocketCount > this.maxTotalSockets ||\n        count > this.maxSockets ||\n        freeLen >= this.maxFreeSockets ||\n        !this.keepSocketAlive(socket)) {\n      socket.destroy();\n      return;\n    }\n\n    this.freeSockets[name] = freeSockets;\n    socket[async_id_symbol] = -1;\n    socket._httpMessage = null;\n    this.removeSocket(socket\x2C options);\n\n    socket.once('error'\x2C freeSocketErrorListener);\n    ArrayPrototypePush(freeSockets\x2C socket);\n  });\n\n  // Don't emit keylog events unless there is a listener for them.\n  this.on('newListener'\x2C maybeEnableKeylog);\n}\nObjectSetPrototypeOf(Agent.prototype\x2C EventEmitter.prototype);\nObjectSetPrototypeOf(Agent\x2C EventEmitter);\n\nfunction maybeEnableKeylog(eventName) {\n  if (eventName === 'keylog') {\n    this.removeListener('newListener'\x2C maybeEnableKeylog);\n    // Future sockets will listen on keylog at creation.\n    const agent = this;\n    this[kOnKeylog] = function onkeylog(keylog) {\n      agent.emit('keylog'\x2C keylog\x2C this);\n    };\n    // Existing sockets will start listening on keylog now.\n    const sockets = ObjectValues(this.sockets);\n    for (let i = 0; i < sockets.length; i++) {\n      sockets[i].on('keylog'\x2C this[kOnKeylog]);\n    }\n  }\n}\n\nAgent.defaultMaxSockets = Infinity;\n\nAgent.prototype.createConnection = net.createConnection;\n\n// Get the key for a given set of request options\nAgent.prototype.getName = function getName(options = kEmptyObject) {\n  let name = options.host || 'localhost';\n\n  name += ':';\n  if (options.port)\n    name += options.port;\n\n  name += ':';\n  if (options.localAddress)\n    name += options.localAddress;\n\n  // Pacify parallel/test-http-agent-getname by only appending\n  // the ':' when options.family is set.\n  if (options.family === 4 || options.family === 6)\n    name += `:${options.family}`;\n\n  if (options.socketPath)\n    name += `:${options.socketPath}`;\n\n  return name;\n};\n\nAgent.prototype.addRequest = function addRequest(req\x2C options\x2C port/* legacy */\x2C\n                                                 localAddress/* legacy */) {\n  // Legacy API: addRequest(req\x2C host\x2C port\x2C localAddress)\n  if (typeof options === 'string') {\n    options = {\n      __proto__: null\x2C\n      host: options\x2C\n      port\x2C\n      localAddress\n    };\n  }\n\n  options = { __proto__: null\x2C ...options\x2C ...this.options };\n  if (options.socketPath)\n    options.path = options.socketPath;\n\n  if (!options.servername && options.servername !== '')\n    options.servername = calculateServerName(options\x2C req);\n\n  const name = this.getName(options);\n  if (!this.sockets[name]) {\n    this.sockets[name] = [];\n  }\n\n  const freeSockets = this.freeSockets[name];\n  let socket;\n  if (freeSockets) {\n    while (freeSockets.length && freeSockets[0].destroyed) {\n      ArrayPrototypeShift(freeSockets);\n    }\n    socket = this.scheduling === 'fifo' ?\n      ArrayPrototypeShift(freeSockets) :\n      ArrayPrototypePop(freeSockets);\n    if (!freeSockets.length)\n      delete this.freeSockets[name];\n  }\n\n  const freeLen = freeSockets ? freeSockets.length : 0;\n  const sockLen = freeLen + this.sockets[name].length;\n\n  if (socket) {\n    asyncResetHandle(socket);\n    this.reuseSocket(socket\x2C req);\n    setRequestSocket(this\x2C req\x2C socket);\n    ArrayPrototypePush(this.sockets[name]\x2C socket);\n  } else if (sockLen < this.maxSockets &&\n             this.totalSocketCount < this.maxTotalSockets) {\n    debug('call onSocket'\x2C sockLen\x2C freeLen);\n    // If we are under maxSockets create a new one.\n    this.createSocket(req\x2C options\x2C (err\x2C socket) => {\n      if (err)\n        req.onSocket(socket\x2C err);\n      else\n        setRequestSocket(this\x2C req\x2C socket);\n    });\n  } else {\n    debug('wait for socket');\n    // We are over limit so we'll add it to the queue.\n    if (!this.requests[name]) {\n      this.requests[name] = [];\n    }\n\n    // Used to create sockets for pending requests from different origin\n    req[kRequestOptions] = options;\n    // Used to capture the original async context.\n    req[kRequestAsyncResource] = new AsyncResource('QueuedRequest');\n\n    ArrayPrototypePush(this.requests[name]\x2C req);\n  }\n};\n\nAgent.prototype.createSocket = function createSocket(req\x2C options\x2C cb) {\n  options = { __proto__: null\x2C ...options\x2C ...this.options };\n  if (options.socketPath)\n    options.path = options.socketPath;\n\n  if (!options.servername && options.servername !== '')\n    options.servername = calculateServerName(options\x2C req);\n\n  const name = this.getName(options);\n  options._agentKey = name;\n\n  debug('createConnection'\x2C name\x2C options);\n  options.encoding = null;\n\n  const oncreate = once((err\x2C s) => {\n    if (err)\n      return cb(err);\n    if (!this.sockets[name]) {\n      this.sockets[name] = [];\n    }\n    ArrayPrototypePush(this.sockets[name]\x2C s);\n    this.totalSocketCount++;\n    debug('sockets'\x2C name\x2C this.sockets[name].length\x2C this.totalSocketCount);\n    installListeners(this\x2C s\x2C options);\n    cb(null\x2C s);\n  });\n  // When keepAlive is true\x2C pass the related options to createConnection\n  if (this.keepAlive) {\n    options.keepAlive = this.keepAlive;\n    options.keepAliveInitialDelay = this.keepAliveMsecs;\n  }\n  const newSocket = this.createConnection(options\x2C oncreate);\n  if (newSocket)\n    oncreate(null\x2C newSocket);\n};\n\nfunction calculateServerName(options\x2C req) {\n  let servername = options.host;\n  const hostHeader = req.getHeader('host');\n  if (hostHeader) {\n    validateString(hostHeader\x2C 'options.headers.host');\n\n    // abc => abc\n    // abc:123 => abc\n    // [::1] => ::1\n    // [::1]:123 => ::1\n    if (StringPrototypeStartsWith(hostHeader\x2C '[')) {\n      const index = StringPrototypeIndexOf(hostHeader\x2C ']');\n      if (index === -1) {\n        // Leading '['\x2C but no ']'. Need to do something...\n        servername = hostHeader;\n      } else {\n        servername = StringPrototypeSubstr(hostHeader\x2C 1\x2C index - 1);\n      }\n    } else {\n      servername = StringPrototypeSplit(hostHeader\x2C ':'\x2C 1)[0];\n    }\n  }\n  // Don't implicitly set invalid (IP) servernames.\n  if (net.isIP(servername))\n    servername = '';\n  return servername;\n}\n\nfunction installListeners(agent\x2C s\x2C options) {\n  function onFree() {\n    debug('CLIENT socket onFree');\n    agent.emit('free'\x2C s\x2C options);\n  }\n  s.on('free'\x2C onFree);\n\n  function onClose(err) {\n    debug('CLIENT socket onClose');\n    // This is the only place where sockets get removed from the Agent.\n    // If you want to remove a socket from the pool\x2C just close it.\n    // All socket errors end in a close event anyway.\n    agent.totalSocketCount--;\n    agent.removeSocket(s\x2C options);\n  }\n  s.on('close'\x2C onClose);\n\n  function onTimeout() {\n    debug('CLIENT socket onTimeout');\n\n    // Destroy if in free list.\n    // TODO(ronag): Always destroy\x2C even if not in free list.\n    const sockets = agent.freeSockets;\n    if (ArrayPrototypeSome(ObjectKeys(sockets)\x2C (name) =>\n      ArrayPrototypeIncludes(sockets[name]\x2C s)\n    )) {\n      return s.destroy();\n    }\n  }\n  s.on('timeout'\x2C onTimeout);\n\n  function onRemove() {\n    // We need this function for cases like HTTP 'upgrade'\n    // (defined by WebSockets) where we need to remove a socket from the\n    // pool because it'll be locked up indefinitely\n    debug('CLIENT socket onRemove');\n    agent.totalSocketCount--;\n    agent.removeSocket(s\x2C options);\n    s.removeListener('close'\x2C onClose);\n    s.removeListener('free'\x2C onFree);\n    s.removeListener('timeout'\x2C onTimeout);\n    s.removeListener('agentRemove'\x2C onRemove);\n  }\n  s.on('agentRemove'\x2C onRemove);\n\n  if (agent[kOnKeylog]) {\n    s.on('keylog'\x2C agent[kOnKeylog]);\n  }\n}\n\nAgent.prototype.removeSocket = function removeSocket(s\x2C options) {\n  const name = this.getName(options);\n  debug('removeSocket'\x2C name\x2C 'writable:'\x2C s.writable);\n  const sets = [this.sockets];\n\n  // If the socket was destroyed\x2C remove it from the free buffers too.\n  if (!s.writable)\n    ArrayPrototypePush(sets\x2C this.freeSockets);\n\n  for (let sk = 0; sk < sets.length; sk++) {\n    const sockets = sets[sk];\n\n    if (sockets[name]) {\n      const index = ArrayPrototypeIndexOf(sockets[name]\x2C s);\n      if (index !== -1) {\n        ArrayPrototypeSplice(sockets[name]\x2C index\x2C 1);\n        // Don't leak\n        if (sockets[name].length === 0)\n          delete sockets[name];\n      }\n    }\n  }\n\n  let req;\n  if (this.requests[name] && this.requests[name].length) {\n    debug('removeSocket\x2C have a request\x2C make a socket');\n    req = this.requests[name][0];\n  } else {\n    // TODO(rickyes): this logic will not be FIFO across origins.\n    // There might be older requests in a different origin\x2C but\n    // if the origin which releases the socket has pending requests\n    // that will be prioritized.\n    const keys = ObjectKeys(this.requests);\n    for (let i = 0; i < keys.length; i++) {\n      const prop = keys[i];\n      // Check whether this specific origin is already at maxSockets\n      if (this.sockets[prop] && this.sockets[prop].length) break;\n      debug('removeSocket\x2C have a request with different origin\x2C' +\n        ' make a socket');\n      req = this.requests[prop][0];\n      options = req[kRequestOptions];\n      break;\n    }\n  }\n\n  if (req && options) {\n    req[kRequestOptions] = undefined;\n    // If we have pending requests and a socket gets closed make a new one\n    this.createSocket(req\x2C options\x2C (err\x2C socket) => {\n      if (err)\n        req.onSocket(socket\x2C err);\n      else\n        socket.emit('free');\n    });\n  }\n\n};\n\nAgent.prototype.keepSocketAlive = function keepSocketAlive(socket) {\n  socket.setKeepAlive(true\x2C this.keepAliveMsecs);\n  socket.unref();\n\n  const agentTimeout = this.options.timeout || 0;\n  if (socket.timeout !== agentTimeout) {\n    socket.setTimeout(agentTimeout);\n  }\n\n  return true;\n};\n\nAgent.prototype.reuseSocket = function reuseSocket(socket\x2C req) {\n  debug('have free socket');\n  socket.removeListener('error'\x2C freeSocketErrorListener);\n  req.reusedSocket = true;\n  socket.ref();\n};\n\nAgent.prototype.destroy = function destroy() {\n  const sets = [this.freeSockets\x2C this.sockets];\n  for (let s = 0; s < sets.length; s++) {\n    const set = sets[s];\n    const keys = ObjectKeys(set);\n    for (let v = 0; v < keys.length; v++) {\n      const setName = set[keys[v]];\n      for (let n = 0; n < setName.length; n++) {\n        setName[n].destroy();\n      }\n    }\n  }\n};\n\nfunction setRequestSocket(agent\x2C req\x2C socket) {\n  req.onSocket(socket);\n  const agentTimeout = agent.options.timeout || 0;\n  if (req.timeout === undefined || req.timeout === agentTimeout) {\n    return;\n  }\n  socket.setTimeout(req.timeout);\n}\n\nfunction asyncResetHandle(socket) {\n  // Guard against an uninitialized or user supplied Socket.\n  const handle = socket._handle;\n  if (handle && typeof handle.asyncReset === 'function') {\n    // Assign the handle a new asyncId and run any destroy()/init() hooks.\n    handle.asyncReset(new ReusedHandle(handle.getProviderType()\x2C handle));\n    socket[async_id_symbol] = handle.getAsyncId();\n  }\n}\n\nmodule.exports = {\n  Agent\x2C\n  globalAgent: new Agent()\n};\n
code-source-info,0xb4611f23218,439,0,16766,C0O0C4O16766,,
code-creation,Function,10,242474,0xb4611f23bb0,645, node:_http_agent:1:1,0xb4611f23190,~
code-source-info,0xb4611f23bb0,439,0,16766,C0O0C140O1159C146O1185C152O1210C158O1231C164O1253C170O1276C176O1298C182O1322C188O1347C194O1362C200O1378C206O1392C211O1416C217O1432C223O1458C229O1482C235O1511C241O1536C246O1574C249O1574C253O1574C255O1611C258O1611C262O1611C264O1642C267O1642C272O1675C285O1676C291O1642C293O1747C296O1747C301O1729C307O1799C310O1799C315O1830C320O1779C326O1890C329O1890C334O1890C339O1863C345O1954C348O1954C353O1928C359O1944C365O2045C368O2045C373O1990C379O2008C385O2025C391O2096C394O2096C398O2096C400O2140C403O2140C407O2140C409O2196C412O2196C416O2196C439O2726C441O6425C444O6452C452O6476C457O6425C462O6488C468O6488C473O7059C476O7085C479O7083C483O7096C486O7102C494O7135C498O7129C502O7204C505O7210C514O7228C518O7731C521O7737C530O7758C534O9925C537O9931C546O9954C550O13364C553O13370C562O13393C566O15199C569O15205C578O15231C582O15489C585O15495C594O15517C598O15690C601O15696C610O15714C614O16708C621O16729C628O16751C639O16723C644O16765,,
tick,0x7ff805edeb89,242560,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f220aa,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,242803,0xb4611f258e8,532,Agent node:_http_agent:96:15,0xb4611f23298,~
code-source-info,0xb4611f258e8,439,3027,6424,C0O3027C9O3041C16O3052C21O3075C28O3082C33O3101C34O3105C45O3127C51O3105C56O3151C61O3168C65O3176C70O3190C74O3204C88O3241C94O3217C98O3255C101O3264C106O3272C112O3299C115O3304C121O3320C125O3404C128O3409C134O3422C138O3432C145O3448C150O3448C154O3446C158O3470C165O3485C170O3485C174O3483C178O3507C185O3526C190O3526C194O3524C198O3548C204O3575C209O3583C219O3568C223O3609C229O3631C234O3639C241O3624C245O3661C251O3684C256O3692C267O3712C271O3677C275O3733C281O3760C286O3768C296O3753C300O3793C306O3816C311O3824C319O3809C323O3848C329O3876C334O3884C338O3869C342O3903C346O3925C350O3933C360O3952C373O3933C378O4000C381O4009C387O4046C397O4066C405O4046C410O4107C413O4116C419O4132C428O4140C434O4157C439O4140C445O4181C461O4272C468O4187C473O4181C476O4305C479O4328C482O4326C486O4345C489O4350C502O4350C508O6380C511O6385C524O6385C531O6423,,
tick,0x7ff805db1a96,243161,0,0x0,3,0x102d6ee20,0xb4611f23e24,0x113244eeb,0x1132442e1,0xb4611f220aa,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,243211,0xb4611f26f50,75, node:internal/validators:132:39,0xb466517a6b0,~
code-source-info,0xb4611f26f50,22,3847,4180,C0O3875C5O3880C12O3940C19O3966C22O3984C27O3966C36O3940C42O4087C47O4106C51O4121C67O4127C72O4121C74O4179,,
code-creation,Eval,10,243766,0xb4611f28640,5, node:_http_client:1:1,0xb4611f27a48,~
script-source,440,node:_http_client,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Boolean\x2C\n  Error\x2C\n  FunctionPrototypeCall\x2C\n  NumberIsFinite\x2C\n  ObjectAssign\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectApply\x2C\n  RegExpPrototypeExec\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeIndexOf\x2C\n  StringPrototypeToUpperCase\x2C\n  Symbol\x2C\n  TypedArrayPrototypeSlice\x2C\n} = primordials;\n\nconst net = require('net');\nconst assert = require('internal/assert');\nconst {\n  kEmptyObject\x2C\n  once\x2C\n} = require('internal/util');\nconst {\n  _checkIsHttpToken: checkIsHttpToken\x2C\n  freeParser\x2C\n  parsers\x2C\n  HTTPParser\x2C\n  isLenient\x2C\n  prepareError\x2C\n} = require('_http_common');\nconst {\n  kUniqueHeaders\x2C\n  parseUniqueHeadersOption\x2C\n  OutgoingMessage\n} = require('_http_outgoing');\nconst Agent = require('_http_agent');\nconst { Buffer } = require('buffer');\nconst { defaultTriggerAsyncIdScope } = require('internal/async_hooks');\nconst { URL\x2C urlToHttpOptions\x2C searchParamsSymbol } = require('internal/url');\nconst { kOutHeaders\x2C kNeedDrain } = require('internal/http');\nconst { connResetException\x2C codes } = require('internal/errors');\nconst {\n  ERR_HTTP_HEADERS_SENT\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_HTTP_TOKEN\x2C\n  ERR_INVALID_PROTOCOL\x2C\n  ERR_UNESCAPED_CHARACTERS\n} = codes;\nconst {\n  validateInteger\x2C\n} = require('internal/validators');\nconst { getTimerDuration } = require('internal/timers');\nconst {\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\n  DTRACE_HTTP_CLIENT_RESPONSE\n} = require('internal/dtrace');\n\nconst {\n  hasObserver\x2C\n  startPerf\x2C\n  stopPerf\x2C\n} = require('internal/perf/observe');\n\nconst kClientRequestStatistics = Symbol('ClientRequestStatistics');\n\nconst dc = require('diagnostics_channel');\nconst onClientRequestStartChannel = dc.channel('http.client.request.start');\nconst onClientResponseFinishChannel = dc.channel('http.client.response.finish');\n\nconst { addAbortSignal\x2C finished } = require('stream');\n\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\n\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nconst kError = Symbol('kError');\n\nconst kLenientAll = HTTPParser.kLenientAll | 0;\nconst kLenientNone = HTTPParser.kLenientNone | 0;\n\nfunction validateHost(host\x2C name) {\n  if (host !== null && host !== undefined && typeof host !== 'string') {\n    throw new ERR_INVALID_ARG_TYPE(`options.${name}`\x2C\n                                   ['string'\x2C 'undefined'\x2C 'null']\x2C\n                                   host);\n  }\n  return host;\n}\n\nclass HTTPClientAsyncResource {\n  constructor(type\x2C req) {\n    this.type = type;\n    this.req = req;\n  }\n}\n\nfunction ClientRequest(input\x2C options\x2C cb) {\n  FunctionPrototypeCall(OutgoingMessage\x2C this);\n\n  if (typeof input === 'string') {\n    const urlStr = input;\n    input = urlToHttpOptions(new URL(urlStr));\n  } else if (input && input[searchParamsSymbol] &&\n             input[searchParamsSymbol][searchParamsSymbol]) {\n    // url.URL instance\n    input = urlToHttpOptions(input);\n  } else {\n    cb = options;\n    options = input;\n    input = null;\n  }\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = input || kEmptyObject;\n  } else {\n    options = ObjectAssign(input || {}\x2C options);\n  }\n\n  let agent = options.agent;\n  const defaultAgent = options._defaultAgent || Agent.globalAgent;\n  if (agent === false) {\n    agent = new defaultAgent.constructor();\n  } else if (agent === null || agent === undefined) {\n    if (typeof options.createConnection !== 'function') {\n      agent = defaultAgent;\n    }\n    // Explicitly pass through this statement as agent will not be used\n    // when createConnection is provided.\n  } else if (typeof agent.addRequest !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('options.agent'\x2C\n                                   ['Agent-like Object'\x2C 'undefined'\x2C 'false']\x2C\n                                   agent);\n  }\n  this.agent = agent;\n\n  const protocol = options.protocol || defaultAgent.protocol;\n  let expectedProtocol = defaultAgent.protocol;\n  if (this.agent && this.agent.protocol)\n    expectedProtocol = this.agent.protocol;\n\n  if (options.path) {\n    const path = String(options.path);\n    if (RegExpPrototypeExec(INVALID_PATH_REGEX\x2C path) !== null)\n      throw new ERR_UNESCAPED_CHARACTERS('Request path');\n  }\n\n  if (protocol !== expectedProtocol) {\n    throw new ERR_INVALID_PROTOCOL(protocol\x2C expectedProtocol);\n  }\n\n  const defaultPort = options.defaultPort ||\n                    (this.agent && this.agent.defaultPort);\n\n  const port = options.port = options.port || defaultPort || 80;\n  const host = options.host = validateHost(options.hostname\x2C 'hostname') ||\n                            validateHost(options.host\x2C 'host') || 'localhost';\n\n  const setHost = (options.setHost === undefined || Boolean(options.setHost));\n\n  this.socketPath = options.socketPath;\n\n  if (options.timeout !== undefined)\n    this.timeout = getTimerDuration(options.timeout\x2C 'timeout');\n\n  const signal = options.signal;\n  if (signal) {\n    addAbortSignal(signal\x2C this);\n  }\n  let method = options.method;\n  const methodIsString = (typeof method === 'string');\n  if (method !== null && method !== undefined && !methodIsString) {\n    throw new ERR_INVALID_ARG_TYPE('options.method'\x2C 'string'\x2C method);\n  }\n\n  if (methodIsString && method) {\n    if (!checkIsHttpToken(method)) {\n      throw new ERR_INVALID_HTTP_TOKEN('Method'\x2C method);\n    }\n    method = this.method = StringPrototypeToUpperCase(method);\n  } else {\n    method = this.method = 'GET';\n  }\n\n  const maxHeaderSize = options.maxHeaderSize;\n  if (maxHeaderSize !== undefined)\n    validateInteger(maxHeaderSize\x2C 'maxHeaderSize'\x2C 0);\n  this.maxHeaderSize = maxHeaderSize;\n\n  const insecureHTTPParser = options.insecureHTTPParser;\n  if (insecureHTTPParser !== undefined &&\n      typeof insecureHTTPParser !== 'boolean') {\n    throw new ERR_INVALID_ARG_TYPE(\n      'options.insecureHTTPParser'\x2C 'boolean'\x2C insecureHTTPParser);\n  }\n  this.insecureHTTPParser = insecureHTTPParser;\n\n  this.path = options.path || '/';\n  if (cb) {\n    this.once('response'\x2C cb);\n  }\n\n  if (method === 'GET' ||\n      method === 'HEAD' ||\n      method === 'DELETE' ||\n      method === 'OPTIONS' ||\n      method === 'TRACE' ||\n      method === 'CONNECT') {\n    this.useChunkedEncodingByDefault = false;\n  } else {\n    this.useChunkedEncodingByDefault = true;\n  }\n\n  this._ended = false;\n  this.res = null;\n  this.aborted = false;\n  this.timeoutCb = null;\n  this.upgradeOrConnect = false;\n  this.parser = null;\n  this.maxHeadersCount = null;\n  this.reusedSocket = false;\n  this.host = host;\n  this.protocol = protocol;\n\n  if (this.agent) {\n    // If there is an agent we should default to Connection:keep-alive\x2C\n    // but only if the Agent will actually reuse the connection!\n    // If it's not a keepAlive agent\x2C and the maxSockets==Infinity\x2C then\n    // there's never a case where this socket will actually be reused\n    if (!this.agent.keepAlive && !NumberIsFinite(this.agent.maxSockets)) {\n      this._last = true;\n      this.shouldKeepAlive = false;\n    } else {\n      this._last = false;\n      this.shouldKeepAlive = true;\n    }\n  }\n\n  const headersArray = ArrayIsArray(options.headers);\n  if (!headersArray) {\n    if (options.headers) {\n      const keys = ObjectKeys(options.headers);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        this.setHeader(key\x2C options.headers[key]);\n      }\n    }\n\n    if (host && !this.getHeader('host') && setHost) {\n      let hostHeader = host;\n\n      // For the Host header\x2C ensure that IPv6 addresses are enclosed\n      // in square brackets\x2C as defined by URI formatting\n      // https://tools.ietf.org/html/rfc3986#section-3.2.2\n      const posColon = StringPrototypeIndexOf(hostHeader\x2C ':');\n      if (posColon !== -1 &&\n          StringPrototypeIncludes(hostHeader\x2C ':'\x2C posColon + 1) &&\n          StringPrototypeCharCodeAt(hostHeader\x2C 0) !== 91/* '[' */) {\n        hostHeader = `[${hostHeader}]`;\n      }\n\n      if (port && +port !== defaultPort) {\n        hostHeader += ':' + port;\n      }\n      this.setHeader('Host'\x2C hostHeader);\n    }\n\n    if (options.auth && !this.getHeader('Authorization')) {\n      this.setHeader('Authorization'\x2C 'Basic ' +\n                     Buffer.from(options.auth).toString('base64'));\n    }\n\n    if (this.getHeader('expect')) {\n      if (this._header) {\n        throw new ERR_HTTP_HEADERS_SENT('render');\n      }\n\n      this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n'\x2C\n                        this[kOutHeaders]);\n    }\n  } else {\n    this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n'\x2C\n                      options.headers);\n  }\n\n  this[kUniqueHeaders] = parseUniqueHeadersOption(options.uniqueHeaders);\n\n  let optsWithoutSignal = options;\n  if (optsWithoutSignal.signal) {\n    optsWithoutSignal = ObjectAssign({}\x2C options);\n    delete optsWithoutSignal.signal;\n  }\n\n  // initiate connection\n  if (this.agent) {\n    this.agent.addRequest(this\x2C optsWithoutSignal);\n  } else {\n    // No agent\x2C default to Connection:close.\n    this._last = true;\n    this.shouldKeepAlive = false;\n    if (typeof optsWithoutSignal.createConnection === 'function') {\n      const oncreate = once((err\x2C socket) => {\n        if (err) {\n          process.nextTick(() => this.emit('error'\x2C err));\n        } else {\n          this.onSocket(socket);\n        }\n      });\n\n      try {\n        const newSocket = optsWithoutSignal.createConnection(optsWithoutSignal\x2C\n                                                             oncreate);\n        if (newSocket) {\n          oncreate(null\x2C newSocket);\n        }\n      } catch (err) {\n        oncreate(err);\n      }\n    } else {\n      debug('CLIENT use net.createConnection'\x2C optsWithoutSignal);\n      this.onSocket(net.createConnection(optsWithoutSignal));\n    }\n  }\n}\nObjectSetPrototypeOf(ClientRequest.prototype\x2C OutgoingMessage.prototype);\nObjectSetPrototypeOf(ClientRequest\x2C OutgoingMessage);\n\nClientRequest.prototype._finish = function _finish() {\n  DTRACE_HTTP_CLIENT_REQUEST(this\x2C this.socket);\n  FunctionPrototypeCall(OutgoingMessage.prototype._finish\x2C this);\n  if (hasObserver('http')) {\n    startPerf(this\x2C kClientRequestStatistics\x2C {\n      type: 'http'\x2C\n      name: 'HttpClient'\x2C\n      detail: {\n        req: {\n          method: this.method\x2C\n          url: `${this.protocol}//${this.host}${this.path}`\x2C\n          headers: typeof this.getHeaders === 'function' ? this.getHeaders() : {}\x2C\n        }\x2C\n      }\x2C\n    });\n  }\n  if (onClientRequestStartChannel.hasSubscribers) {\n    onClientRequestStartChannel.publish({\n      request: this\x2C\n    });\n  }\n};\n\nClientRequest.prototype._implicitHeader = function _implicitHeader() {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('render');\n  }\n  this._storeHeader(this.method + ' ' + this.path + ' HTTP/1.1\\r\\n'\x2C\n                    this[kOutHeaders]);\n};\n\nClientRequest.prototype.abort = function abort() {\n  if (this.aborted) {\n    return;\n  }\n  this.aborted = true;\n  process.nextTick(emitAbortNT\x2C this);\n  this.destroy();\n};\n\nClientRequest.prototype.destroy = function destroy(err) {\n  if (this.destroyed) {\n    return this;\n  }\n  this.destroyed = true;\n\n  // If we're aborting\x2C we don't care about any more response data.\n  if (this.res) {\n    this.res._dump();\n  }\n\n  this[kError] = err;\n  this.socket?.destroy(err);\n\n  return this;\n};\n\nfunction emitAbortNT(req) {\n  req.emit('abort');\n}\n\nfunction ondrain() {\n  const msg = this._httpMessage;\n  if (msg && !msg.finished && msg[kNeedDrain]) {\n    msg[kNeedDrain] = false;\n    msg.emit('drain');\n  }\n}\n\nfunction socketCloseListener() {\n  const socket = this;\n  const req = socket._httpMessage;\n  debug('HTTP socket close');\n\n  // NOTE: It's important to get parser here\x2C because it could be freed by\n  // the `socketOnData`.\n  const parser = socket.parser;\n  const res = req.res;\n\n  req.destroyed = true;\n  if (res) {\n    // Socket closed before we emitted 'end' below.\n    if (!res.complete) {\n      res.destroy(connResetException('aborted'));\n    }\n    req._closed = true;\n    req.emit('close');\n    if (!res.aborted && res.readable) {\n      res.push(null);\n    }\n  } else {\n    if (!req.socket._hadError) {\n      // This socket error fired before we started to\n      // receive a response. The error needs to\n      // fire on the request.\n      req.socket._hadError = true;\n      req.emit('error'\x2C connResetException('socket hang up'));\n    }\n    req._closed = true;\n    req.emit('close');\n  }\n\n  // Too bad.  That output wasn't getting written.\n  // This is pretty terrible that it doesn't raise an error.\n  // Fixed better in v0.10\n  if (req.outputData)\n    req.outputData.length = 0;\n\n  if (parser) {\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n  }\n}\n\nfunction socketErrorListener(err) {\n  const socket = this;\n  const req = socket._httpMessage;\n  debug('SOCKET ERROR:'\x2C err.message\x2C err.stack);\n\n  if (req) {\n    // For Safety. Some additional errors might fire later on\n    // and we need to make sure we don't double-fire the error event.\n    req.socket._hadError = true;\n    req.emit('error'\x2C err);\n  }\n\n  const parser = socket.parser;\n  if (parser) {\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n  }\n\n  // Ensure that no further data will come out of the socket\n  socket.removeListener('data'\x2C socketOnData);\n  socket.removeListener('end'\x2C socketOnEnd);\n  socket.destroy();\n}\n\nfunction socketOnEnd() {\n  const socket = this;\n  const req = this._httpMessage;\n  const parser = this.parser;\n\n  if (!req.res && !req.socket._hadError) {\n    // If we don't have a response then we know that the socket\n    // ended prematurely and we need to emit an error on the request.\n    req.socket._hadError = true;\n    req.emit('error'\x2C connResetException('socket hang up'));\n  }\n  if (parser) {\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n  }\n  socket.destroy();\n}\n\nfunction socketOnData(d) {\n  const socket = this;\n  const req = this._httpMessage;\n  const parser = this.parser;\n\n  assert(parser && parser.socket === socket);\n\n  const ret = parser.execute(d);\n  if (ret instanceof Error) {\n    prepareError(ret\x2C parser\x2C d);\n    debug('parse error'\x2C ret);\n    freeParser(parser\x2C req\x2C socket);\n    socket.removeListener('data'\x2C socketOnData);\n    socket.removeListener('end'\x2C socketOnEnd);\n    socket.destroy();\n    req.socket._hadError = true;\n    req.emit('error'\x2C ret);\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade (if status code 101) or CONNECT\n    const bytesParsed = ret;\n    const res = parser.incoming;\n    req.res = res;\n\n    socket.removeListener('data'\x2C socketOnData);\n    socket.removeListener('end'\x2C socketOnEnd);\n    socket.removeListener('drain'\x2C ondrain);\n\n    if (req.timeoutCb) socket.removeListener('timeout'\x2C req.timeoutCb);\n    socket.removeListener('timeout'\x2C responseOnTimeout);\n\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n\n    const bodyHead = TypedArrayPrototypeSlice(d\x2C bytesParsed\x2C d.length);\n\n    const eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (req.listenerCount(eventName) > 0) {\n      req.upgradeOrConnect = true;\n\n      // detach the socket\n      socket.emit('agentRemove');\n      socket.removeListener('close'\x2C socketCloseListener);\n      socket.removeListener('error'\x2C socketErrorListener);\n\n      socket._httpMessage = null;\n      socket.readableFlowing = null;\n\n      req.emit(eventName\x2C res\x2C socket\x2C bodyHead);\n      req.destroyed = true;\n      req._closed = true;\n      req.emit('close');\n    } else {\n      // Requested Upgrade or used CONNECT method\x2C but have no handler.\n      socket.destroy();\n    }\n  } else if (parser.incoming && parser.incoming.complete &&\n             // When the status code is informational (100\x2C 102-199)\x2C\n             // the server will send a final response after this client\n             // sends a request body\x2C so we must not free the parser.\n             // 101 (Switching Protocols) and all other status codes\n             // should be processed normally.\n             !statusIsInformational(parser.incoming.statusCode)) {\n    socket.removeListener('data'\x2C socketOnData);\n    socket.removeListener('end'\x2C socketOnEnd);\n    socket.removeListener('drain'\x2C ondrain);\n    freeParser(parser\x2C req\x2C socket);\n  }\n}\n\nfunction statusIsInformational(status) {\n  // 100 (Continue)    RFC7231 Section 6.2.1\n  // 102 (Processing)  RFC2518\n  // 103 (Early Hints) RFC8297\n  // 104-199 (Unassigned)\n  return (status < 200 && status >= 100 && status !== 101);\n}\n\n// client\nfunction parserOnIncomingClient(res\x2C shouldKeepAlive) {\n  const socket = this.socket;\n  const req = socket._httpMessage;\n\n  debug('AGENT incoming response!');\n\n  if (req.res) {\n    // We already have a response object\x2C this means the server\n    // sent a double response.\n    socket.destroy();\n    return 0;  // No special treatment.\n  }\n  req.res = res;\n\n  // Skip body and treat as Upgrade.\n  if (res.upgrade)\n    return 2;\n\n  // Responses to CONNECT request is handled as Upgrade.\n  const method = req.method;\n  if (method === 'CONNECT') {\n    res.upgrade = true;\n    return 2;  // Skip body and treat as Upgrade.\n  }\n\n  if (statusIsInformational(res.statusCode)) {\n    // Restart the parser\x2C as this is a 1xx informational message.\n    req.res = null; // Clear res so that we don't hit double-responses.\n    // Maintain compatibility by sending 100-specific events\n    if (res.statusCode === 100) {\n      req.emit('continue');\n    }\n    // Send information events to all 1xx responses except 101 Upgrade.\n    req.emit('information'\x2C {\n      statusCode: res.statusCode\x2C\n      statusMessage: res.statusMessage\x2C\n      httpVersion: res.httpVersion\x2C\n      httpVersionMajor: res.httpVersionMajor\x2C\n      httpVersionMinor: res.httpVersionMinor\x2C\n      headers: res.headers\x2C\n      rawHeaders: res.rawHeaders\n    });\n\n    return 1;  // Skip body but don't treat as Upgrade.\n  }\n\n  if (req.shouldKeepAlive && !shouldKeepAlive && !req.upgradeOrConnect) {\n    // Server MUST respond with Connection:keep-alive for us to enable it.\n    // If we've been upgraded (via WebSockets) we also shouldn't try to\n    // keep the connection open.\n    req.shouldKeepAlive = false;\n  }\n\n  DTRACE_HTTP_CLIENT_RESPONSE(socket\x2C req);\n  if (req[kClientRequestStatistics] && hasObserver('http')) {\n    stopPerf(req\x2C kClientRequestStatistics\x2C {\n      detail: {\n        res: {\n          statusCode: res.statusCode\x2C\n          statusMessage: res.statusMessage\x2C\n          headers: res.headers\x2C\n        }\x2C\n      }\x2C\n    });\n  }\n  if (onClientResponseFinishChannel.hasSubscribers) {\n    onClientResponseFinishChannel.publish({\n      request: req\x2C\n      response: res\x2C\n    });\n  }\n  req.res = res;\n  res.req = req;\n\n  // Add our listener first\x2C so that we guarantee socket cleanup\n  res.on('end'\x2C responseOnEnd);\n  req.on('prefinish'\x2C requestOnPrefinish);\n  socket.on('timeout'\x2C responseOnTimeout);\n\n  // If the user did not listen for the 'response' event\x2C then they\n  // can't possibly read the data\x2C so we ._dump() it into the void\n  // so that the socket doesn't hang there in a paused state.\n  if (req.aborted || !req.emit('response'\x2C res))\n    res._dump();\n\n  if (method === 'HEAD')\n    return 1;  // Skip body but don't treat as Upgrade.\n\n  if (res.statusCode === 304) {\n    res.complete = true;\n    return 1; // Skip body as there won't be any\n  }\n\n  return 0;  // No special treatment.\n}\n\n// client\nfunction responseKeepAlive(req) {\n  const socket = req.socket;\n\n  debug('AGENT socket keep-alive');\n  if (req.timeoutCb) {\n    socket.setTimeout(0\x2C req.timeoutCb);\n    req.timeoutCb = null;\n  }\n  socket.removeListener('close'\x2C socketCloseListener);\n  socket.removeListener('error'\x2C socketErrorListener);\n  socket.removeListener('data'\x2C socketOnData);\n  socket.removeListener('end'\x2C socketOnEnd);\n\n  // TODO(ronag): Between here and emitFreeNT the socket\n  // has no 'error' handler.\n\n  // There are cases where _handle === null. Avoid those. Passing undefined to\n  // nextTick() will call getDefaultTriggerAsyncId() to retrieve the id.\n  const asyncId = socket._handle ? socket._handle.getAsyncId() : undefined;\n  // Mark this socket as available\x2C AFTER user-added end\n  // handlers have a chance to run.\n  defaultTriggerAsyncIdScope(asyncId\x2C process.nextTick\x2C emitFreeNT\x2C req);\n\n  req.destroyed = true;\n  if (req.res) {\n    // Detach socket from IncomingMessage to avoid destroying the freed\n    // socket in IncomingMessage.destroy().\n    req.res.socket = null;\n  }\n}\n\nfunction responseOnEnd() {\n  const req = this.req;\n  const socket = req.socket;\n\n  if (socket) {\n    if (req.timeoutCb) socket.removeListener('timeout'\x2C emitRequestTimeout);\n    socket.removeListener('timeout'\x2C responseOnTimeout);\n  }\n\n  req._ended = true;\n\n  if (!req.shouldKeepAlive) {\n    if (socket.writable) {\n      debug('AGENT socket.destroySoon()');\n      if (typeof socket.destroySoon === 'function')\n        socket.destroySoon();\n      else\n        socket.end();\n    }\n    assert(!socket.writable);\n  } else if (req.finished && !this.aborted) {\n    // We can assume `req.finished` means all data has been written since:\n    // - `'responseOnEnd'` means we have been assigned a socket.\n    // - when we have a socket we write directly to it without buffering.\n    // - `req.finished` means `end()` has been called and no further data.\n    //   can be written\n    responseKeepAlive(req);\n  }\n}\n\nfunction responseOnTimeout() {\n  const req = this._httpMessage;\n  if (!req) return;\n  const res = req.res;\n  if (!res) return;\n  res.emit('timeout');\n}\n\nfunction requestOnPrefinish() {\n  const req = this;\n\n  if (req.shouldKeepAlive && req._ended)\n    responseKeepAlive(req);\n}\n\nfunction emitFreeNT(req) {\n  req._closed = true;\n  req.emit('close');\n  if (req.socket) {\n    req.socket.emit('free');\n  }\n}\n\nfunction tickOnSocket(req\x2C socket) {\n  const parser = parsers.alloc();\n  req.socket = socket;\n  const lenient = req.insecureHTTPParser === undefined ?\n    isLenient() : req.insecureHTTPParser;\n  parser.initialize(HTTPParser.RESPONSE\x2C\n                    new HTTPClientAsyncResource('HTTPINCOMINGMESSAGE'\x2C req)\x2C\n                    req.maxHeaderSize || 0\x2C\n                    lenient ? kLenientAll : kLenientNone);\n  parser.socket = socket;\n  parser.outgoing = req;\n  req.parser = parser;\n\n  socket.parser = parser;\n  socket._httpMessage = req;\n\n  // Propagate headers limit from request object to parser\n  if (typeof req.maxHeadersCount === 'number') {\n    parser.maxHeaderPairs = req.maxHeadersCount << 1;\n  }\n\n  parser.onIncoming = parserOnIncomingClient;\n  socket.on('error'\x2C socketErrorListener);\n  socket.on('data'\x2C socketOnData);\n  socket.on('end'\x2C socketOnEnd);\n  socket.on('close'\x2C socketCloseListener);\n  socket.on('drain'\x2C ondrain);\n\n  if (\n    req.timeout !== undefined ||\n    (req.agent && req.agent.options && req.agent.options.timeout)\n  ) {\n    listenSocketTimeout(req);\n  }\n  req.emit('socket'\x2C socket);\n}\n\nfunction emitRequestTimeout() {\n  const req = this._httpMessage;\n  if (req) {\n    req.emit('timeout');\n  }\n}\n\nfunction listenSocketTimeout(req) {\n  if (req.timeoutCb) {\n    return;\n  }\n  // Set timeoutCb so it will get cleaned up on request end.\n  req.timeoutCb = emitRequestTimeout;\n  // Delegate socket timeout event.\n  if (req.socket) {\n    req.socket.once('timeout'\x2C emitRequestTimeout);\n  } else {\n    req.on('socket'\x2C (socket) => {\n      socket.once('timeout'\x2C emitRequestTimeout);\n    });\n  }\n}\n\nClientRequest.prototype.onSocket = function onSocket(socket\x2C err) {\n  // TODO(ronag): Between here and onSocketNT the socket\n  // has no 'error' handler.\n  process.nextTick(onSocketNT\x2C this\x2C socket\x2C err);\n};\n\nfunction onSocketNT(req\x2C socket\x2C err) {\n  if (req.destroyed || err) {\n    req.destroyed = true;\n\n    function _destroy(req\x2C err) {\n      if (!req.aborted && !err) {\n        err = connResetException('socket hang up');\n      }\n      if (err) {\n        req.emit('error'\x2C err);\n      }\n      req._closed = true;\n      req.emit('close');\n    }\n\n    if (socket) {\n      if (!err && req.agent && !socket.destroyed) {\n        socket.emit('free');\n      } else {\n        finished(socket.destroy(err || req[kError])\x2C (er) => {\n          if (er?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n            er = null;\n          }\n          _destroy(req\x2C er || err);\n        });\n        return;\n      }\n    }\n\n    _destroy(req\x2C err || req[kError]);\n  } else {\n    tickOnSocket(req\x2C socket);\n    req._flush();\n  }\n}\n\nClientRequest.prototype._deferToConnect = _deferToConnect;\nfunction _deferToConnect(method\x2C arguments_) {\n  // This function is for calls that need to happen once the socket is\n  // assigned to this request and writable. It's an important promisy\n  // thing for all the socket calls that happen either now\n  // (when a socket is assigned) or in the future (when a socket gets\n  // assigned out of the pool and is eventually writable).\n\n  const callSocketMethod = () => {\n    if (method)\n      ReflectApply(this.socket[method]\x2C this.socket\x2C arguments_);\n  };\n\n  const onSocket = () => {\n    if (this.socket.writable) {\n      callSocketMethod();\n    } else {\n      this.socket.once('connect'\x2C callSocketMethod);\n    }\n  };\n\n  if (!this.socket) {\n    this.once('socket'\x2C onSocket);\n  } else {\n    onSocket();\n  }\n}\n\nClientRequest.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n  if (this._ended) {\n    return this;\n  }\n\n  listenSocketTimeout(this);\n  msecs = getTimerDuration(msecs\x2C 'msecs');\n  if (callback) this.once('timeout'\x2C callback);\n\n  if (this.socket) {\n    setSocketTimeout(this.socket\x2C msecs);\n  } else {\n    this.once('socket'\x2C (sock) => setSocketTimeout(sock\x2C msecs));\n  }\n\n  return this;\n};\n\nfunction setSocketTimeout(sock\x2C msecs) {\n  if (sock.connecting) {\n    sock.once('connect'\x2C function() {\n      sock.setTimeout(msecs);\n    });\n  } else {\n    sock.setTimeout(msecs);\n  }\n}\n\nClientRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  this._deferToConnect('setNoDelay'\x2C [noDelay]);\n};\n\nClientRequest.prototype.setSocketKeepAlive =\n    function setSocketKeepAlive(enable\x2C initialDelay) {\n      this._deferToConnect('setKeepAlive'\x2C [enable\x2C initialDelay]);\n    };\n\nClientRequest.prototype.clearTimeout = function clearTimeout(cb) {\n  this.setTimeout(0\x2C cb);\n};\n\nmodule.exports = {\n  ClientRequest\n};\n
code-source-info,0xb4611f28640,440,0,27414,C0O0C4O27414,,
code-creation,Function,10,247012,0xb4611f29660,1058, node:_http_client:1:1,0xb4611f285b8,~
code-source-info,0xb4611f29660,440,0,27414,C0O0C313O1159C319O1175C325O1186C331O1195C337O1220C343O1238C349O1254C355O1268C360O1292C366O1308C372O1331C378O1341C384O1370C390O1397C396O1423C402O1453C407O1463C413O1519C416O1519C420O1519C422O1550C425O1550C429O1550C431O1614C434O1614C439O1588C445O1604C451O1759C454O1759C459O1669C465O1689C471O1703C477O1714C483O1728C489O1741C495O1860C498O1860C503O1794C509O1812C515O1840C521O1901C524O1901C528O1901C530O1944C533O1944C538O1933C544O2002C547O2002C552O1971C558O2089C561O2089C566O2043C572O2048C578O2066C584O2150C587O2150C592O2122C598O2135C604O2214C607O2214C612O2184C618O2204C623O2252C629O2277C635O2301C641O2327C647O2351C653O2418C656O2418C661O2397C667O2479C670O2479C675O2458C681O2579C684O2579C689O2517C695O2547C701O2660C704O2660C709O2618C715O2633C721O2646C727O2728C730O2728C734O2728C736O2775C739O2775C744O2846C752O2846C757O2843C759O2925C767O2925C772O2922C774O3003C777O3003C782O2974C788O2990C794O3035C797O3035C802O3068C815O3069C821O3035C823O3142C827O3142C829O3177C832O3177C836O3177C838O3216C841O3227C845O3239C848O3216C850O3265C853O3276C857O3289C860O3265C883O3590C885O11050C893O11077C898O11015C903O11089C906O11089C911O11158C920O11176C924O11820C933O11846C937O12077C946O12093C950O12250C959O12268C963O24584C972O24603C976O25589C983O25615C987O26402C996O26423C1000O26995C1009O27016C1013O27116C1022O27145C1026O27293C1035O27316C1039O27376C1046O27397C1052O27391C1057O27413,,
tick,0x7ff805e4dd2c,247131,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x7ff805e4dde4,247143,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x7ff805f105d0,247152,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,Eval,10,247661,0xb4611f2c7d0,5, node:_http_common:1:1,0xb4611f2c4b8,~
script-source,441,node:_http_common,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  MathMin\x2C\n  Symbol\x2C\n  RegExpPrototypeExec\x2C\n} = primordials;\nconst { setImmediate } = require('timers');\n\nconst { methods\x2C HTTPParser } = internalBinding('http_parser');\nconst { getOptionValue } = require('internal/options');\nconst insecureHTTPParser = getOptionValue('--insecure-http-parser');\n\nconst FreeList = require('internal/freelist');\nconst incoming = require('_http_incoming');\nconst {\n  IncomingMessage\x2C\n  readStart\x2C\n  readStop\n} = incoming;\n\nconst kIncomingMessage = Symbol('IncomingMessage');\nconst kOnMessageBegin = HTTPParser.kOnMessageBegin | 0;\nconst kOnHeaders = HTTPParser.kOnHeaders | 0;\nconst kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;\nconst kOnBody = HTTPParser.kOnBody | 0;\nconst kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;\nconst kOnExecute = HTTPParser.kOnExecute | 0;\nconst kOnTimeout = HTTPParser.kOnTimeout | 0;\n\nconst MAX_HEADER_PAIRS = 2000;\n\n// Only called in the slow case where slow means\n// that the request headers were either fragmented\n// across multiple TCP packets or too large to be\n// processed in a single run. This method is also\n// called to process trailing HTTP headers.\nfunction parserOnHeaders(headers\x2C url) {\n  // Once we exceeded headers limit - stop collecting them\n  if (this.maxHeaderPairs <= 0 ||\n      this._headers.length < this.maxHeaderPairs) {\n    this._headers.push(...headers);\n  }\n  this._url += url;\n}\n\n// `headers` and `url` are set only if .onHeaders() has not been called for\n// this request.\n// `url` is not set for response parsers but that's not applicable here since\n// all our parsers are request parsers.\nfunction parserOnHeadersComplete(versionMajor\x2C versionMinor\x2C headers\x2C method\x2C\n                                 url\x2C statusCode\x2C statusMessage\x2C upgrade\x2C\n                                 shouldKeepAlive) {\n  const parser = this;\n  const { socket } = parser;\n\n  if (headers === undefined) {\n    headers = parser._headers;\n    parser._headers = [];\n  }\n\n  if (url === undefined) {\n    url = parser._url;\n    parser._url = '';\n  }\n\n  // Parser is also used by http client\n  const ParserIncomingMessage = (socket && socket.server &&\n                                 socket.server[kIncomingMessage]) ||\n                                 IncomingMessage;\n\n  const incoming = parser.incoming = new ParserIncomingMessage(socket);\n  incoming.httpVersionMajor = versionMajor;\n  incoming.httpVersionMinor = versionMinor;\n  incoming.httpVersion = `${versionMajor}.${versionMinor}`;\n  incoming.url = url;\n  incoming.upgrade = upgrade;\n\n  let n = headers.length;\n\n  // If parser.maxHeaderPairs <= 0 assume that there's no limit.\n  if (parser.maxHeaderPairs > 0)\n    n = MathMin(n\x2C parser.maxHeaderPairs);\n\n  incoming._addHeaderLines(headers\x2C n);\n\n  if (typeof method === 'number') {\n    // server only\n    incoming.method = methods[method];\n  } else {\n    // client only\n    incoming.statusCode = statusCode;\n    incoming.statusMessage = statusMessage;\n  }\n\n  return parser.onIncoming(incoming\x2C shouldKeepAlive);\n}\n\nfunction parserOnBody(b) {\n  const stream = this.incoming;\n\n  // If the stream has already been removed\x2C then drop it.\n  if (stream === null)\n    return;\n\n  // Pretend this was the result of a stream._read call.\n  if (!stream._dumped) {\n    const ret = stream.push(b);\n    if (!ret)\n      readStop(this.socket);\n  }\n}\n\nfunction parserOnMessageComplete() {\n  const parser = this;\n  const stream = parser.incoming;\n\n  if (stream !== null) {\n    stream.complete = true;\n    // Emit any trailing headers.\n    const headers = parser._headers;\n    if (headers.length) {\n      stream._addHeaderLines(headers\x2C headers.length);\n      parser._headers = [];\n      parser._url = '';\n    }\n\n    // For emit end event\n    stream.push(null);\n  }\n\n  // Force to read the next incoming message\n  readStart(parser.socket);\n}\n\n\nconst parsers = new FreeList('parsers'\x2C 1000\x2C function parsersCb() {\n  const parser = new HTTPParser();\n\n  cleanParser(parser);\n\n  parser[kOnHeaders] = parserOnHeaders;\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\n  parser[kOnBody] = parserOnBody;\n  parser[kOnMessageComplete] = parserOnMessageComplete;\n\n  return parser;\n});\n\nfunction closeParserInstance(parser) { parser.close(); }\n\n// Free the parser and also break any links that it\n// might have to any other things.\n// TODO: All parser data should be attached to a\n// single object\x2C so that it can be easily cleaned\n// up by doing `parser.data = {}`\x2C which should\n// be done in FreeList.free.  `parsers.free(parser)`\n// should be all that is needed.\nfunction freeParser(parser\x2C req\x2C socket) {\n  if (parser) {\n    if (parser._consumed)\n      parser.unconsume();\n    cleanParser(parser);\n    parser.remove();\n    if (parsers.free(parser) === false) {\n      // Make sure the parser's stack has unwound before deleting the\n      // corresponding C++ object through .close().\n      setImmediate(closeParserInstance\x2C parser);\n    } else {\n      // Since the Parser destructor isn't going to run the destroy() callbacks\n      // it needs to be triggered manually.\n      parser.free();\n    }\n  }\n  if (req) {\n    req.parser = null;\n  }\n  if (socket) {\n    socket.parser = null;\n  }\n}\n\nconst tokenRegExp = /^[\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]+$/;\n/**\n * Verifies that the given val is a valid HTTP token\n * per the rules defined in RFC 7230\n * See https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nfunction checkIsHttpToken(val) {\n  return RegExpPrototypeExec(tokenRegExp\x2C val) !== null;\n}\n\nconst headerCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n/**\n * True if val contains an invalid field-vchar\n *  field-value    = *( field-content / obs-fold )\n *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n *  field-vchar    = VCHAR / obs-text\n */\nfunction checkInvalidHeaderChar(val) {\n  return RegExpPrototypeExec(headerCharRegex\x2C val) !== null;\n}\n\nfunction cleanParser(parser) {\n  parser._headers = [];\n  parser._url = '';\n  parser.socket = null;\n  parser.incoming = null;\n  parser.outgoing = null;\n  parser.maxHeaderPairs = MAX_HEADER_PAIRS;\n  parser[kOnMessageBegin] = null;\n  parser[kOnExecute] = null;\n  parser[kOnTimeout] = null;\n  parser._consumed = false;\n  parser.onIncoming = null;\n}\n\nfunction prepareError(err\x2C parser\x2C rawPacket) {\n  err.rawPacket = rawPacket || parser.getCurrentBuffer();\n  if (typeof err.reason === 'string')\n    err.message = `Parse Error: ${err.reason}`;\n}\n\nlet warnedLenient = false;\n\nfunction isLenient() {\n  if (insecureHTTPParser && !warnedLenient) {\n    warnedLenient = true;\n    process.emitWarning('Using insecure HTTP parsing');\n  }\n  return insecureHTTPParser;\n}\n\nmodule.exports = {\n  _checkInvalidHeaderChar: checkInvalidHeaderChar\x2C\n  _checkIsHttpToken: checkIsHttpToken\x2C\n  chunkExpression: /(?:^|\\W)chunked(?:$|\\W)/i\x2C\n  continueExpression: /(?:^|\\W)100-continue(?:$|\\W)/i\x2C\n  CRLF: '\\r\\n'\x2C // TODO: Deprecate this.\n  freeParser\x2C\n  methods\x2C\n  parsers\x2C\n  kIncomingMessage\x2C\n  HTTPParser\x2C\n  isLenient\x2C\n  prepareError\x2C\n};\n
code-source-info,0xb4611f2c7d0,441,0,8085,C0O0C4O8085,,
code-creation,Function,10,248593,0xb4611f2ce78,462, node:_http_common:1:1,0xb4611f2c748,~
code-source-info,0xb4611f2ce78,441,0,8085,C0O0C136O1159C142O1170C147O1180C153O1243C156O1243C161O1226C167O1295C170O1295C175O1271C181O1280C187O1354C190O1354C195O1335C200O1410C203O1410C207O1410C209O1470C212O1470C217O1517C220O1517C225O1554C231O1573C237O1586C243O1635C246O1635C250O1635C252O1686C255O1697C259O1713C262O1686C264O1737C267O1748C271O1759C274O1737C276O1791C279O1802C283O1821C286O1791C288O1842C291O1853C295O1861C298O1842C300O1893C303O1904C307O1923C310O1893C312O1947C315O1958C319O1969C322O1947C324O1993C327O2004C331O2015C334O1993C336O2046C340O2046C342O4981C357O4981C362O4981C364O6329C368O6329C370O6636C374O6636C376O7536C377O7536C379O7731C386O7777C392O7822C396O7859C404O7909C414O7985C420O7999C426O8010C432O8021C438O8041C444O8055C450O8068C456O7746C461O8084,,
tick,0x7ff805e4dde4,248666,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f29826,0x113244eeb,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,Eval,10,248972,0xb4611f2f478,5, node:internal/freelist:1:1,0xb4611f2f320,~
script-source,442,node:internal/freelist,'use strict';\n\nconst {\n  ReflectApply\x2C\n} = primordials;\n\nclass FreeList {\n  constructor(name\x2C max\x2C ctor) {\n    this.name = name;\n    this.ctor = ctor;\n    this.max = max;\n    this.list = [];\n  }\n\n  alloc() {\n    return this.list.length > 0 ?\n      this.list.pop() :\n      ReflectApply(this.ctor\x2C this\x2C arguments);\n  }\n\n  free(obj) {\n    if (this.list.length < this.max) {\n      this.list.push(obj);\n      return true;\n    }\n    return false;\n  }\n}\n\nmodule.exports = FreeList;\n
code-source-info,0xb4611f2f478,442,0,476,C0O0C4O476,,
code-creation,Function,10,249055,0xb4611f2f780,54, node:internal/freelist:1:1,0xb4611f2f3f0,~
code-source-info,0xb4611f2f780,442,0,476,C0O0C8O25C46O449C48O464C53O475,,
tick,0x102cbd7f0,249299,1,0x10266e4e0,2,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f2cf54,0x113244eeb,0x1132442e1,0xb4611f29826,0x113244eeb,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,Eval,10,249524,0xb4611f2ff80,5, node:_http_incoming:1:1,0xb4611f2fd48,~
script-source,443,node:_http_incoming,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\n} = primordials;\n\nconst { Readable\x2C finished } = require('stream');\n\nconst kHeaders = Symbol('kHeaders');\nconst kHeadersDistinct = Symbol('kHeadersDistinct');\nconst kHeadersCount = Symbol('kHeadersCount');\nconst kTrailers = Symbol('kTrailers');\nconst kTrailersDistinct = Symbol('kTrailersDistinct');\nconst kTrailersCount = Symbol('kTrailersCount');\n\nfunction readStart(socket) {\n  if (socket && !socket._paused && socket.readable)\n    socket.resume();\n}\n\nfunction readStop(socket) {\n  if (socket)\n    socket.pause();\n}\n\n/* Abstract base class for ServerRequest and ClientResponse. */\nfunction IncomingMessage(socket) {\n  let streamOptions;\n\n  if (socket) {\n    streamOptions = {\n      highWaterMark: socket.readableHighWaterMark\n    };\n  }\n\n  Readable.call(this\x2C streamOptions);\n\n  this._readableState.readingMore = true;\n\n  this.socket = socket;\n\n  this.httpVersionMajor = null;\n  this.httpVersionMinor = null;\n  this.httpVersion = null;\n  this.complete = false;\n  this[kHeaders] = null;\n  this[kHeadersCount] = 0;\n  this.rawHeaders = [];\n  this[kTrailers] = null;\n  this[kTrailersCount] = 0;\n  this.rawTrailers = [];\n\n  this.aborted = false;\n\n  this.upgrade = null;\n\n  // request (server) only\n  this.url = '';\n  this.method = null;\n\n  // response (client) only\n  this.statusCode = null;\n  this.statusMessage = null;\n  this.client = socket;\n\n  this._consuming = false;\n  // Flag for when we decide that this message cannot possibly be\n  // read by the user\x2C so there's no point continuing to handle it.\n  this._dumped = false;\n}\nObjectSetPrototypeOf(IncomingMessage.prototype\x2C Readable.prototype);\nObjectSetPrototypeOf(IncomingMessage\x2C Readable);\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'connection'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this.socket;\n  }\x2C\n  set: function(val) {\n    this.socket = val;\n  }\n});\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'headers'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (!this[kHeaders]) {\n      this[kHeaders] = {};\n\n      const src = this.rawHeaders;\n      const dst = this[kHeaders];\n\n      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n        this._addHeaderLine(src[n + 0]\x2C src[n + 1]\x2C dst);\n      }\n    }\n    return this[kHeaders];\n  }\x2C\n  set: function(val) {\n    this[kHeaders] = val;\n  }\n});\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'headersDistinct'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (!this[kHeadersDistinct]) {\n      this[kHeadersDistinct] = {};\n\n      const src = this.rawHeaders;\n      const dst = this[kHeadersDistinct];\n\n      for (let n = 0; n < this[kHeadersCount]; n += 2) {\n        this._addHeaderLineDistinct(src[n + 0]\x2C src[n + 1]\x2C dst);\n      }\n    }\n    return this[kHeadersDistinct];\n  }\x2C\n  set: function(val) {\n    this[kHeadersDistinct] = val;\n  }\n});\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'trailers'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (!this[kTrailers]) {\n      this[kTrailers] = {};\n\n      const src = this.rawTrailers;\n      const dst = this[kTrailers];\n\n      for (let n = 0; n < this[kTrailersCount]; n += 2) {\n        this._addHeaderLine(src[n + 0]\x2C src[n + 1]\x2C dst);\n      }\n    }\n    return this[kTrailers];\n  }\x2C\n  set: function(val) {\n    this[kTrailers] = val;\n  }\n});\n\nObjectDefineProperty(IncomingMessage.prototype\x2C 'trailersDistinct'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    if (!this[kTrailersDistinct]) {\n      this[kTrailersDistinct] = {};\n\n      const src = this.rawTrailers;\n      const dst = this[kTrailersDistinct];\n\n      for (let n = 0; n < this[kTrailersCount]; n += 2) {\n        this._addHeaderLineDistinct(src[n + 0]\x2C src[n + 1]\x2C dst);\n      }\n    }\n    return this[kTrailersDistinct];\n  }\x2C\n  set: function(val) {\n    this[kTrailersDistinct] = val;\n  }\n});\n\nIncomingMessage.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n  if (callback)\n    this.on('timeout'\x2C callback);\n  this.socket.setTimeout(msecs);\n  return this;\n};\n\n// Argument n cannot be factored out due to the overhead of\n// argument adaptor frame creation inside V8 in case that number of actual\n// arguments is different from expected arguments.\n// Ref: https://bugs.chromium.org/p/v8/issues/detail?id=10201\n// NOTE: Argument adapt frame issue might be solved in V8 engine v8.9.\n// Refactoring `n` out might be possible when V8 is upgraded to that\n// version.\n// Ref: https://v8.dev/blog/v8-release-89\nIncomingMessage.prototype._read = function _read(n) {\n  if (!this._consuming) {\n    this._readableState.readingMore = false;\n    this._consuming = true;\n  }\n\n  // We actually do almost nothing here\x2C because the parserOnBody\n  // function fills up our internal buffer directly.  However\x2C we\n  // do need to unpause the underlying socket so that it flows.\n  if (this.socket.readable)\n    readStart(this.socket);\n};\n\n// It's possible that the socket will be destroyed\x2C and removed from\n// any messages\x2C before ever calling this.  In that case\x2C just skip\n// it\x2C since something else is destroying this connection anyway.\nIncomingMessage.prototype._destroy = function _destroy(err\x2C cb) {\n  if (!this.readableEnded || !this.complete) {\n    this.aborted = true;\n    this.emit('aborted');\n  }\n\n  // If aborted and the underlying socket is not already destroyed\x2C\n  // destroy it.\n  // We have to check if the socket is already destroyed because finished\n  // does not call the callback when this method is invoked from `_http_client`\n  // in `test/parallel/test-http-client-spurious-aborted.js`\n  if (this.socket && !this.socket.destroyed && this.aborted) {\n    this.socket.destroy(err);\n    const cleanup = finished(this.socket\x2C (e) => {\n      if (e?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\n        e = null;\n      }\n      cleanup();\n      process.nextTick(onError\x2C this\x2C e || err\x2C cb);\n    });\n  } else {\n    process.nextTick(onError\x2C this\x2C err\x2C cb);\n  }\n};\n\nIncomingMessage.prototype._addHeaderLines = _addHeaderLines;\nfunction _addHeaderLines(headers\x2C n) {\n  if (headers && headers.length) {\n    let dest;\n    if (this.complete) {\n      this.rawTrailers = headers;\n      this[kTrailersCount] = n;\n      dest = this[kTrailers];\n    } else {\n      this.rawHeaders = headers;\n      this[kHeadersCount] = n;\n      dest = this[kHeaders];\n    }\n\n    if (dest) {\n      for (let i = 0; i < n; i += 2) {\n        this._addHeaderLine(headers[i]\x2C headers[i + 1]\x2C dest);\n      }\n    }\n  }\n}\n\n\n// This function is used to help avoid the lowercasing of a field name if it\n// matches a 'traditional cased' version of a field name. It then returns the\n// lowercased name to both avoid calling toLowerCase() a second time and to\n// indicate whether the field was a 'no duplicates' field. If a field is not a\n// 'no duplicates' field\x2C a `0` byte is prepended as a flag. The one exception\n// to this is the Set-Cookie header which is indicated by a `1` byte flag\x2C since\n// it is an 'array' field and thus is treated differently in _addHeaderLines().\n// TODO: perhaps http_parser could be returning both raw and lowercased versions\n// of known header names to avoid us having to call toLowerCase() for those\n// headers.\nfunction matchKnownFields(field\x2C lowercased) {\n  switch (field.length) {\n    case 3:\n      if (field === 'Age' || field === 'age') return 'age';\n      break;\n    case 4:\n      if (field === 'Host' || field === 'host') return 'host';\n      if (field === 'From' || field === 'from') return 'from';\n      if (field === 'ETag' || field === 'etag') return 'etag';\n      if (field === 'Date' || field === 'date') return '\\u0000date';\n      if (field === 'Vary' || field === 'vary') return '\\u0000vary';\n      break;\n    case 6:\n      if (field === 'Server' || field === 'server') return 'server';\n      if (field === 'Cookie' || field === 'cookie') return '\\u0002cookie';\n      if (field === 'Origin' || field === 'origin') return '\\u0000origin';\n      if (field === 'Expect' || field === 'expect') return '\\u0000expect';\n      if (field === 'Accept' || field === 'accept') return '\\u0000accept';\n      break;\n    case 7:\n      if (field === 'Referer' || field === 'referer') return 'referer';\n      if (field === 'Expires' || field === 'expires') return 'expires';\n      if (field === 'Upgrade' || field === 'upgrade') return '\\u0000upgrade';\n      break;\n    case 8:\n      if (field === 'Location' || field === 'location')\n        return 'location';\n      if (field === 'If-Match' || field === 'if-match')\n        return '\\u0000if-match';\n      break;\n    case 10:\n      if (field === 'User-Agent' || field === 'user-agent')\n        return 'user-agent';\n      if (field === 'Set-Cookie' || field === 'set-cookie')\n        return '\\u0001';\n      if (field === 'Connection' || field === 'connection')\n        return '\\u0000connection';\n      break;\n    case 11:\n      if (field === 'Retry-After' || field === 'retry-after')\n        return 'retry-after';\n      break;\n    case 12:\n      if (field === 'Content-Type' || field === 'content-type')\n        return 'content-type';\n      if (field === 'Max-Forwards' || field === 'max-forwards')\n        return 'max-forwards';\n      break;\n    case 13:\n      if (field === 'Authorization' || field === 'authorization')\n        return 'authorization';\n      if (field === 'Last-Modified' || field === 'last-modified')\n        return 'last-modified';\n      if (field === 'Cache-Control' || field === 'cache-control')\n        return '\\u0000cache-control';\n      if (field === 'If-None-Match' || field === 'if-none-match')\n        return '\\u0000if-none-match';\n      break;\n    case 14:\n      if (field === 'Content-Length' || field === 'content-length')\n        return 'content-length';\n      break;\n    case 15:\n      if (field === 'Accept-Encoding' || field === 'accept-encoding')\n        return '\\u0000accept-encoding';\n      if (field === 'Accept-Language' || field === 'accept-language')\n        return '\\u0000accept-language';\n      if (field === 'X-Forwarded-For' || field === 'x-forwarded-for')\n        return '\\u0000x-forwarded-for';\n      break;\n    case 16:\n      if (field === 'Content-Encoding' || field === 'content-encoding')\n        return '\\u0000content-encoding';\n      if (field === 'X-Forwarded-Host' || field === 'x-forwarded-host')\n        return '\\u0000x-forwarded-host';\n      break;\n    case 17:\n      if (field === 'If-Modified-Since' || field === 'if-modified-since')\n        return 'if-modified-since';\n      if (field === 'Transfer-Encoding' || field === 'transfer-encoding')\n        return '\\u0000transfer-encoding';\n      if (field === 'X-Forwarded-Proto' || field === 'x-forwarded-proto')\n        return '\\u0000x-forwarded-proto';\n      break;\n    case 19:\n      if (field === 'Proxy-Authorization' || field === 'proxy-authorization')\n        return 'proxy-authorization';\n      if (field === 'If-Unmodified-Since' || field === 'if-unmodified-since')\n        return 'if-unmodified-since';\n      break;\n  }\n  if (lowercased) {\n    return '\\u0000' + field;\n  }\n  return matchKnownFields(StringPrototypeToLowerCase(field)\x2C true);\n}\n// Add the given (field\x2C value) pair to the message\n//\n// Per RFC2616\x2C section 4.2 it is acceptable to join multiple instances of the\n// same header with a '\x2C ' if the header in question supports specification of\n// multiple values this way. The one exception to this is the Cookie header\x2C\n// which has multiple values joined with a '; ' instead. If a header's values\n// cannot be joined in either of these ways\x2C we declare the first instance the\n// winner and drop the second. Extended header fields (those beginning with\n// 'x-') are always joined.\nIncomingMessage.prototype._addHeaderLine = _addHeaderLine;\nfunction _addHeaderLine(field\x2C value\x2C dest) {\n  field = matchKnownFields(field);\n  const flag = StringPrototypeCharCodeAt(field\x2C 0);\n  if (flag === 0 || flag === 2) {\n    field = StringPrototypeSlice(field\x2C 1);\n    // Make a delimited list\n    if (typeof dest[field] === 'string') {\n      dest[field] += (flag === 0 ? '\x2C ' : '; ') + value;\n    } else {\n      dest[field] = value;\n    }\n  } else if (flag === 1) {\n    // Array header -- only Set-Cookie at the moment\n    if (dest['set-cookie'] !== undefined) {\n      dest['set-cookie'].push(value);\n    } else {\n      dest['set-cookie'] = [value];\n    }\n  } else if (dest[field] === undefined) {\n    // Drop duplicates\n    dest[field] = value;\n  }\n}\n\nIncomingMessage.prototype._addHeaderLineDistinct = _addHeaderLineDistinct;\nfunction _addHeaderLineDistinct(field\x2C value\x2C dest) {\n  field = StringPrototypeToLowerCase(field);\n  if (!dest[field]) {\n    dest[field] = [value];\n  } else {\n    dest[field].push(value);\n  }\n}\n\n\n// Call this instead of resume() if we want to just\n// dump all the data to /dev/null\nIncomingMessage.prototype._dump = function _dump() {\n  if (!this._dumped) {\n    this._dumped = true;\n    // If there is buffered data\x2C it may trigger 'data' events.\n    // Remove 'data' event listeners explicitly.\n    this.removeAllListeners('data');\n    this.resume();\n  }\n};\n\nfunction onError(self\x2C error\x2C cb) {\n  // This is to keep backward compatible behavior.\n  // An error is emitted only if there are listeners attached to the event.\n  if (self.listenerCount('error') === 0) {\n    cb();\n  } else {\n    cb(error);\n  }\n}\n\nmodule.exports = {\n  IncomingMessage\x2C\n  readStart\x2C\n  readStop\n};\n
code-source-info,0xb4611f2ff80,443,0,14509,C0O0C4O14509,,
code-creation,Function,10,251113,0xb4611f30c60,504, node:_http_incoming:1:1,0xb4611f2fef8,~
code-source-info,0xb4611f30c60,443,0,14509,C0O0C85O1159C90O1183C95O1207C101O1236C107O1260C113O1290C118O1346C121O1346C126O1323C132O1333C138O1383C141O1383C145O1383C147O1428C150O1428C154O1428C156O1478C159O1478C163O1478C165O1521C168O1521C172O1521C174O1568C177O1568C181O1568C183O1620C186O1620C190O1620C192O2865C200O2885C205O2828C210O2897C213O2897C218O2984C231O3037C239O3086C247O2947C252O3171C265O3221C273O3527C281O3134C286O3615C299O3673C307O4019C315O3578C320O4115C333O4166C341O4478C349O4078C354O4567C367O4626C375O4978C383O4530C388O5054C397O5075C401O5676C410O5692C414O6293C423O6312C427O7129C434O7155C438O12817C445O12842C449O13576C456O13609C460O13933C469O13949C473O14444C480O14465C486O14484C492O14497C498O14459C503O14508,,
tick,0x7ff805f105d0,251182,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f2cf54,0x113244eeb,0x1132442e1,0xb4611f29826,0x113244eeb,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,251296,0xb4611f32348,26,FreeList node:internal/freelist:8:14,0xb4611f2f4a8,~
code-source-info,0xb4611f32348,442,87,194,C0O111C2O121C6O133C8O143C12O155C14O164C18O175C20O185C25O193,,
tick,0x102ce0f6c,251686,1,0x10266e4e0,2,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f29852,0x113244eeb,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,Eval,10,251932,0xb4611f33370,5, node:_http_outgoing:1:1,0xb4611f32e98,~
script-source,444,node:_http_outgoing,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeJoin\x2C\n  MathFloor\x2C\n  NumberPrototypeToString\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectKeys\x2C\n  ObjectValues\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeExec\x2C\n  SafeSet\x2C\n  StringPrototypeToLowerCase\x2C\n  Symbol\x2C\n} = primordials;\n\nconst { getDefaultHighWaterMark } = require('internal/streams/state');\nconst assert = require('internal/assert');\nconst EE = require('events');\nconst Stream = require('stream');\nconst internalUtil = require('internal/util');\nconst { kOutHeaders\x2C utcDate\x2C kNeedDrain } = require('internal/http');\nconst { Buffer } = require('buffer');\nconst {\n  _checkIsHttpToken: checkIsHttpToken\x2C\n  _checkInvalidHeaderChar: checkInvalidHeaderChar\x2C\n  chunkExpression: RE_TE_CHUNKED\x2C\n} = require('_http_common');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  symbols: { async_id_symbol }\n} = require('internal/async_hooks');\nconst {\n  codes: {\n    ERR_HTTP_HEADERS_SENT\x2C\n    ERR_HTTP_INVALID_HEADER_VALUE\x2C\n    ERR_HTTP_TRAILER_INVALID\x2C\n    ERR_INVALID_HTTP_TOKEN\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_ARG_VALUE\x2C\n    ERR_INVALID_CHAR\x2C\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\n    ERR_STREAM_CANNOT_PIPE\x2C\n    ERR_STREAM_ALREADY_FINISHED\x2C\n    ERR_STREAM_WRITE_AFTER_END\x2C\n    ERR_STREAM_NULL_VALUES\x2C\n    ERR_STREAM_DESTROYED\n  }\x2C\n  hideStackFrames\n} = require('internal/errors');\nconst { validateString } = require('internal/validators');\nconst { isUint8Array } = require('internal/util/types');\n\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\n\nconst HIGH_WATER_MARK = getDefaultHighWaterMark();\n\nconst kCorked = Symbol('corked');\nconst kUniqueHeaders = Symbol('kUniqueHeaders');\n\nconst nop = () => {};\n\nconst RE_CONN_CLOSE = /(?:^|\\W)close(?:$|\\W)/i;\n\n// isCookieField performs a case-insensitive comparison of a provided string\n// against the word "cookie." As of V8 6.6 this is faster than handrolling or\n// using a case-insensitive RegExp.\nfunction isCookieField(s) {\n  return s.length === 6 && StringPrototypeToLowerCase(s) === 'cookie';\n}\n\nfunction OutgoingMessage() {\n  Stream.call(this);\n\n  // Queue that holds all currently pending data\x2C until the response will be\n  // assigned to the socket (until it will its turn in the HTTP pipeline).\n  this.outputData = [];\n\n  // `outputSize` is an approximate measure of how much data is queued on this\n  // response. `_onPendingData` will be invoked to update similar global\n  // per-connection counter. That counter will be used to pause/unpause the\n  // TCP socket and HTTP Parser and thus handle the backpressure.\n  this.outputSize = 0;\n\n  this.writable = true;\n  this.destroyed = false;\n\n  this._last = false;\n  this.chunkedEncoding = false;\n  this.shouldKeepAlive = true;\n  this.maxRequestsOnConnectionReached = false;\n  this._defaultKeepAlive = true;\n  this.useChunkedEncodingByDefault = true;\n  this.sendDate = false;\n  this._removedConnection = false;\n  this._removedContLen = false;\n  this._removedTE = false;\n\n  this._contentLength = null;\n  this._hasBody = true;\n  this._trailer = '';\n  this[kNeedDrain] = false;\n\n  this.finished = false;\n  this._headerSent = false;\n  this[kCorked] = 0;\n  this._closed = false;\n\n  this.socket = null;\n  this._header = null;\n  this[kOutHeaders] = null;\n\n  this._keepAliveTimeout = 0;\n\n  this._onPendingData = nop;\n}\nObjectSetPrototypeOf(OutgoingMessage.prototype\x2C Stream.prototype);\nObjectSetPrototypeOf(OutgoingMessage\x2C Stream);\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableFinished'\x2C {\n  __proto__: null\x2C\n  get() {\n    return (\n      this.finished &&\n      this.outputSize === 0 &&\n      (!this.socket || this.socket.writableLength === 0)\n    );\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableObjectMode'\x2C {\n  __proto__: null\x2C\n  get() {\n    return false;\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableLength'\x2C {\n  __proto__: null\x2C\n  get() {\n    return this.outputSize + (this.socket ? this.socket.writableLength : 0);\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableHighWaterMark'\x2C {\n  __proto__: null\x2C\n  get() {\n    return this.socket ? this.socket.writableHighWaterMark : HIGH_WATER_MARK;\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableCorked'\x2C {\n  __proto__: null\x2C\n  get() {\n    const corked = this.socket ? this.socket.writableCorked : 0;\n    return corked + this[kCorked];\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C '_headers'\x2C {\n  __proto__: null\x2C\n  get: internalUtil.deprecate(function() {\n    return this.getHeaders();\n  }\x2C 'OutgoingMessage.prototype._headers is deprecated'\x2C 'DEP0066')\x2C\n  set: internalUtil.deprecate(function(val) {\n    if (val == null) {\n      this[kOutHeaders] = null;\n    } else if (typeof val === 'object') {\n      const headers = this[kOutHeaders] = ObjectCreate(null);\n      const keys = ObjectKeys(val);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; ++i) {\n        const name = keys[i];\n        headers[StringPrototypeToLowerCase(name)] = [name\x2C val[name]];\n      }\n    }\n  }\x2C 'OutgoingMessage.prototype._headers is deprecated'\x2C 'DEP0066')\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'connection'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return this.socket;\n  }\x2C\n  set: function(val) {\n    this.socket = val;\n  }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C '_headerNames'\x2C {\n  __proto__: null\x2C\n  get: internalUtil.deprecate(function() {\n    const headers = this[kOutHeaders];\n    if (headers !== null) {\n      const out = ObjectCreate(null);\n      const keys = ObjectKeys(headers);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; ++i) {\n        const key = keys[i];\n        const val = headers[key][0];\n        out[key] = val;\n      }\n      return out;\n    }\n    return null;\n  }\x2C 'OutgoingMessage.prototype._headerNames is deprecated'\x2C 'DEP0066')\x2C\n  set: internalUtil.deprecate(function(val) {\n    if (typeof val === 'object' && val !== null) {\n      const headers = this[kOutHeaders];\n      if (!headers)\n        return;\n      const keys = ObjectKeys(val);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; ++i) {\n        const header = headers[keys[i]];\n        if (header)\n          header[0] = val[keys[i]];\n      }\n    }\n  }\x2C 'OutgoingMessage.prototype._headerNames is deprecated'\x2C 'DEP0066')\n});\n\n\nOutgoingMessage.prototype._renderHeaders = function _renderHeaders() {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('render');\n  }\n\n  const headersMap = this[kOutHeaders];\n  const headers = {};\n\n  if (headersMap !== null) {\n    const keys = ObjectKeys(headersMap);\n    // Retain for(;;) loop for performance reasons\n    // Refs: https://github.com/nodejs/node/pull/30958\n    for (let i = 0\x2C l = keys.length; i < l; i++) {\n      const key = keys[i];\n      headers[headersMap[key][0]] = headersMap[key][1];\n    }\n  }\n  return headers;\n};\n\nOutgoingMessage.prototype.cork = function() {\n  if (this.socket) {\n    this.socket.cork();\n  } else {\n    this[kCorked]++;\n  }\n};\n\nOutgoingMessage.prototype.uncork = function() {\n  if (this.socket) {\n    this.socket.uncork();\n  } else if (this[kCorked]) {\n    this[kCorked]--;\n  }\n};\n\nOutgoingMessage.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n\n  if (callback) {\n    this.on('timeout'\x2C callback);\n  }\n\n  if (!this.socket) {\n    this.once('socket'\x2C function socketSetTimeoutOnConnect(socket) {\n      socket.setTimeout(msecs);\n    });\n  } else {\n    this.socket.setTimeout(msecs);\n  }\n  return this;\n};\n\n\n// It's possible that the socket will be destroyed\x2C and removed from\n// any messages\x2C before ever calling this.  In that case\x2C just skip\n// it\x2C since something else is destroying this connection anyway.\nOutgoingMessage.prototype.destroy = function destroy(error) {\n  if (this.destroyed) {\n    return this;\n  }\n  this.destroyed = true;\n\n  if (this.socket) {\n    this.socket.destroy(error);\n  } else {\n    this.once('socket'\x2C function socketDestroyOnConnect(socket) {\n      socket.destroy(error);\n    });\n  }\n\n  return this;\n};\n\n\n// This abstract either writing directly to the socket or buffering it.\nOutgoingMessage.prototype._send = function _send(data\x2C encoding\x2C callback) {\n  // This is a shameful hack to get the headers and first body chunk onto\n  // the same packet. Future versions of Node are going to take care of\n  // this at a lower level and in a more general way.\n  if (!this._headerSent) {\n    if (typeof data === 'string' &&\n        (encoding === 'utf8' || encoding === 'latin1' || !encoding)) {\n      data = this._header + data;\n    } else {\n      const header = this._header;\n      this.outputData.unshift({\n        data: header\x2C\n        encoding: 'latin1'\x2C\n        callback: null\n      });\n      this.outputSize += header.length;\n      this._onPendingData(header.length);\n    }\n    this._headerSent = true;\n  }\n  return this._writeRaw(data\x2C encoding\x2C callback);\n};\n\n\nOutgoingMessage.prototype._writeRaw = _writeRaw;\nfunction _writeRaw(data\x2C encoding\x2C callback) {\n  const conn = this.socket;\n  if (conn && conn.destroyed) {\n    // The socket was destroyed. If we're still trying to write to it\x2C\n    // then we haven't gotten the 'close' event yet.\n    return false;\n  }\n\n  if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (conn && conn._httpMessage === this && conn.writable) {\n    // There might be pending data in the this.output buffer.\n    if (this.outputData.length) {\n      this._flushOutput(conn);\n    }\n    // Directly write to socket.\n    return conn.write(data\x2C encoding\x2C callback);\n  }\n  // Buffer\x2C as long as we're not destroyed.\n  this.outputData.push({ data\x2C encoding\x2C callback });\n  this.outputSize += data.length;\n  this._onPendingData(data.length);\n  return this.outputSize < HIGH_WATER_MARK;\n}\n\n\nOutgoingMessage.prototype._storeHeader = _storeHeader;\nfunction _storeHeader(firstLine\x2C headers) {\n  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\\r\\n'\n  // in the case of response it is: 'HTTP/1.1 200 OK\\r\\n'\n  const state = {\n    connection: false\x2C\n    contLen: false\x2C\n    te: false\x2C\n    date: false\x2C\n    expect: false\x2C\n    trailer: false\x2C\n    header: firstLine\n  };\n\n  if (headers) {\n    if (headers === this[kOutHeaders]) {\n      for (const key in headers) {\n        const entry = headers[key];\n        processHeader(this\x2C state\x2C entry[0]\x2C entry[1]\x2C false);\n      }\n    } else if (ArrayIsArray(headers)) {\n      if (headers.length && ArrayIsArray(headers[0])) {\n        for (let i = 0; i < headers.length; i++) {\n          const entry = headers[i];\n          processHeader(this\x2C state\x2C entry[0]\x2C entry[1]\x2C true);\n        }\n      } else {\n        if (headers.length % 2 !== 0) {\n          throw new ERR_INVALID_ARG_VALUE('headers'\x2C headers);\n        }\n\n        for (let n = 0; n < headers.length; n += 2) {\n          processHeader(this\x2C state\x2C headers[n + 0]\x2C headers[n + 1]\x2C true);\n        }\n      }\n    } else {\n      for (const key in headers) {\n        if (ObjectPrototypeHasOwnProperty(headers\x2C key)) {\n          processHeader(this\x2C state\x2C key\x2C headers[key]\x2C true);\n        }\n      }\n    }\n  }\n\n  let { header } = state;\n\n  // Date header\n  if (this.sendDate && !state.date) {\n    header += 'Date: ' + utcDate() + '\\r\\n';\n  }\n\n  // Force the connection to close when the response is a 204 No Content or\n  // a 304 Not Modified and the user has set a "Transfer-Encoding: chunked"\n  // header.\n  //\n  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but\n  // node.js used to send out a zero chunk anyway to accommodate clients\n  // that don't have special handling for those responses.\n  //\n  // It was pointed out that this might confuse reverse proxies to the point\n  // of creating security liabilities\x2C so suppress the zero chunk and force\n  // the connection to close.\n  if (this.chunkedEncoding && (this.statusCode === 204 ||\n                               this.statusCode === 304)) {\n    debug(this.statusCode + ' response should not use chunked encoding\x2C' +\n          ' closing connection.');\n    this.chunkedEncoding = false;\n    this.shouldKeepAlive = false;\n  }\n\n  // keep-alive logic\n  if (this._removedConnection) {\n    this._last = true;\n    this.shouldKeepAlive = false;\n  } else if (!state.connection) {\n    const shouldSendKeepAlive = this.shouldKeepAlive &&\n        (state.contLen || this.useChunkedEncodingByDefault || this.agent);\n    if (shouldSendKeepAlive && this.maxRequestsOnConnectionReached) {\n      header += 'Connection: close\\r\\n';\n    } else if (shouldSendKeepAlive) {\n      header += 'Connection: keep-alive\\r\\n';\n      if (this._keepAliveTimeout && this._defaultKeepAlive) {\n        const timeoutSeconds = MathFloor(this._keepAliveTimeout / 1000);\n        header += `Keep-Alive: timeout=${timeoutSeconds}\\r\\n`;\n      }\n    } else {\n      this._last = true;\n      header += 'Connection: close\\r\\n';\n    }\n  }\n\n  if (!state.contLen && !state.te) {\n    if (!this._hasBody) {\n      // Make sure we don't end the 0\\r\\n\\r\\n at the end of the message.\n      this.chunkedEncoding = false;\n    } else if (!this.useChunkedEncodingByDefault) {\n      this._last = true;\n    } else if (!state.trailer &&\n               !this._removedContLen &&\n               typeof this._contentLength === 'number') {\n      header += 'Content-Length: ' + this._contentLength + '\\r\\n';\n    } else if (!this._removedTE) {\n      header += 'Transfer-Encoding: chunked\\r\\n';\n      this.chunkedEncoding = true;\n    } else {\n      // We should only be able to get here if both Content-Length and\n      // Transfer-Encoding are removed by the user.\n      // See: test/parallel/test-http-remove-header-stays-removed.js\n      debug('Both Content-Length and Transfer-Encoding are removed');\n    }\n  }\n\n  // Test non-chunked message does not have trailer header set\x2C\n  // message will be terminated by the first empty line after the\n  // header fields\x2C regardless of the header fields present in the\n  // message\x2C and thus cannot contain a message body or 'trailers'.\n  if (this.chunkedEncoding !== true && state.trailer) {\n    throw new ERR_HTTP_TRAILER_INVALID();\n  }\n\n  this._header = header + '\\r\\n';\n  this._headerSent = false;\n\n  // Wait until the first body chunk\x2C or close()\x2C is sent to flush\x2C\n  // UNLESS we're sending Expect: 100-continue.\n  if (state.expect) this._send('');\n}\n\nfunction processHeader(self\x2C state\x2C key\x2C value\x2C validate) {\n  if (validate)\n    validateHeaderName(key);\n  if (ArrayIsArray(value)) {\n    if (\n      (value.length < 2 || !isCookieField(key)) &&\n      (!self[kUniqueHeaders] || !self[kUniqueHeaders].has(StringPrototypeToLowerCase(key)))\n    ) {\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < value.length; i++)\n        storeHeader(self\x2C state\x2C key\x2C value[i]\x2C validate);\n      return;\n    }\n    value = ArrayPrototypeJoin(value\x2C '; ');\n  }\n  storeHeader(self\x2C state\x2C key\x2C value\x2C validate);\n}\n\nfunction storeHeader(self\x2C state\x2C key\x2C value\x2C validate) {\n  if (validate)\n    validateHeaderValue(key\x2C value);\n  state.header += key + ': ' + value + '\\r\\n';\n  matchHeader(self\x2C state\x2C key\x2C value);\n}\n\nfunction matchHeader(self\x2C state\x2C field\x2C value) {\n  if (field.length < 4 || field.length > 17)\n    return;\n  field = StringPrototypeToLowerCase(field);\n  switch (field) {\n    case 'connection':\n      state.connection = true;\n      self._removedConnection = false;\n      if (RegExpPrototypeExec(RE_CONN_CLOSE\x2C value) !== null)\n        self._last = true;\n      else\n        self.shouldKeepAlive = true;\n      break;\n    case 'transfer-encoding':\n      state.te = true;\n      self._removedTE = false;\n      if (RegExpPrototypeExec(RE_TE_CHUNKED\x2C value) !== null)\n        self.chunkedEncoding = true;\n      break;\n    case 'content-length':\n      state.contLen = true;\n      self._removedContLen = false;\n      break;\n    case 'date':\n    case 'expect':\n    case 'trailer':\n      state[field] = true;\n      break;\n    case 'keep-alive':\n      self._defaultKeepAlive = false;\n      break;\n  }\n}\n\nconst validateHeaderName = hideStackFrames((name) => {\n  if (typeof name !== 'string' || !name || !checkIsHttpToken(name)) {\n    throw new ERR_INVALID_HTTP_TOKEN('Header name'\x2C name);\n  }\n});\n\nconst validateHeaderValue = hideStackFrames((name\x2C value) => {\n  if (value === undefined) {\n    throw new ERR_HTTP_INVALID_HEADER_VALUE(value\x2C name);\n  }\n  if (checkInvalidHeaderChar(value)) {\n    debug('Header "%s" contains invalid characters'\x2C name);\n    throw new ERR_INVALID_CHAR('header content'\x2C name);\n  }\n});\n\nfunction parseUniqueHeadersOption(headers) {\n  if (!ArrayIsArray(headers)) {\n    return null;\n  }\n\n  const unique = new SafeSet();\n  const l = headers.length;\n  for (let i = 0; i < l; i++) {\n    unique.add(StringPrototypeToLowerCase(headers[i]));\n  }\n\n  return unique;\n}\n\nOutgoingMessage.prototype.setHeader = function setHeader(name\x2C value) {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('set');\n  }\n  validateHeaderName(name);\n  validateHeaderValue(name\x2C value);\n\n  let headers = this[kOutHeaders];\n  if (headers === null)\n    this[kOutHeaders] = headers = ObjectCreate(null);\n\n  headers[StringPrototypeToLowerCase(name)] = [name\x2C value];\n  return this;\n};\n\nOutgoingMessage.prototype.appendHeader = function appendHeader(name\x2C value) {\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('append');\n  }\n  validateHeaderName(name);\n  validateHeaderValue(name\x2C value);\n\n  const field = StringPrototypeToLowerCase(name);\n  const headers = this[kOutHeaders];\n  if (headers === null || !headers[field]) {\n    return this.setHeader(name\x2C value);\n  }\n\n  // Prepare the field for appending\x2C if required\n  if (!ArrayIsArray(headers[field][1])) {\n    headers[field][1] = [headers[field][1]];\n  }\n\n  const existingValues = headers[field][1];\n  if (ArrayIsArray(value)) {\n    for (let i = 0\x2C length = value.length; i < length; i++) {\n      existingValues.push(value[i]);\n    }\n  } else {\n    existingValues.push(value);\n  }\n\n  return this;\n};\n\n\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  validateString(name\x2C 'name');\n\n  const headers = this[kOutHeaders];\n  if (headers === null)\n    return;\n\n  const entry = headers[StringPrototypeToLowerCase(name)];\n  return entry && entry[1];\n};\n\n\n// Returns an array of the names of the current outgoing headers.\nOutgoingMessage.prototype.getHeaderNames = function getHeaderNames() {\n  return this[kOutHeaders] !== null ? ObjectKeys(this[kOutHeaders]) : [];\n};\n\n\n// Returns an array of the names of the current outgoing raw headers.\nOutgoingMessage.prototype.getRawHeaderNames = function getRawHeaderNames() {\n  const headersMap = this[kOutHeaders];\n  if (headersMap === null) return [];\n\n  const values = ObjectValues(headersMap);\n  const headers = Array(values.length);\n  // Retain for(;;) loop for performance reasons\n  // Refs: https://github.com/nodejs/node/pull/30958\n  for (let i = 0\x2C l = values.length; i < l; i++) {\n    headers[i] = values[i][0];\n  }\n\n  return headers;\n};\n\n\n// Returns a shallow copy of the current outgoing headers.\nOutgoingMessage.prototype.getHeaders = function getHeaders() {\n  const headers = this[kOutHeaders];\n  const ret = ObjectCreate(null);\n  if (headers) {\n    const keys = ObjectKeys(headers);\n    // Retain for(;;) loop for performance reasons\n    // Refs: https://github.com/nodejs/node/pull/30958\n    for (let i = 0; i < keys.length; ++i) {\n      const key = keys[i];\n      const val = headers[key][1];\n      ret[key] = val;\n    }\n  }\n  return ret;\n};\n\n\nOutgoingMessage.prototype.hasHeader = function hasHeader(name) {\n  validateString(name\x2C 'name');\n  return this[kOutHeaders] !== null &&\n    !!this[kOutHeaders][StringPrototypeToLowerCase(name)];\n};\n\n\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  validateString(name\x2C 'name');\n\n  if (this._header) {\n    throw new ERR_HTTP_HEADERS_SENT('remove');\n  }\n\n  const key = StringPrototypeToLowerCase(name);\n\n  switch (key) {\n    case 'connection':\n      this._removedConnection = true;\n      break;\n    case 'content-length':\n      this._removedContLen = true;\n      break;\n    case 'transfer-encoding':\n      this._removedTE = true;\n      break;\n    case 'date':\n      this.sendDate = false;\n      break;\n  }\n\n  if (this[kOutHeaders] !== null) {\n    delete this[kOutHeaders][key];\n  }\n};\n\n\nOutgoingMessage.prototype._implicitHeader = function _implicitHeader() {\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_implicitHeader()');\n};\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'headersSent'\x2C {\n  __proto__: null\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n  get: function() { return !!this._header; }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableEnded'\x2C {\n  __proto__: null\x2C\n  get: function() { return this.finished; }\n});\n\nObjectDefineProperty(OutgoingMessage.prototype\x2C 'writableNeedDrain'\x2C {\n  __proto__: null\x2C\n  get: function() {\n    return !this.destroyed && !this.finished && this[kNeedDrain];\n  }\n});\n\nconst crlf_buf = Buffer.from('\\r\\n');\nOutgoingMessage.prototype.write = function write(chunk\x2C encoding\x2C callback) {\n  if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  const ret = write_(this\x2C chunk\x2C encoding\x2C callback\x2C false);\n  if (!ret)\n    this[kNeedDrain] = true;\n  return ret;\n};\n\nfunction onError(msg\x2C err\x2C callback) {\n  const triggerAsyncId = msg.socket ? msg.socket[async_id_symbol] : undefined;\n  defaultTriggerAsyncIdScope(triggerAsyncId\x2C\n                             process.nextTick\x2C\n                             emitErrorNt\x2C\n                             msg\x2C\n                             err\x2C\n                             callback);\n}\n\nfunction emitErrorNt(msg\x2C err\x2C callback) {\n  callback(err);\n  if (typeof msg.emit === 'function' && !msg._closed) {\n    msg.emit('error'\x2C err);\n  }\n}\n\nfunction write_(msg\x2C chunk\x2C encoding\x2C callback\x2C fromEnd) {\n  if (typeof callback !== 'function')\n    callback = nop;\n\n  let len;\n  if (chunk === null) {\n    throw new ERR_STREAM_NULL_VALUES();\n  } else if (typeof chunk === 'string') {\n    len = Buffer.byteLength(chunk\x2C encoding);\n  } else if (isUint8Array(chunk)) {\n    len = chunk.length;\n  } else {\n    throw new ERR_INVALID_ARG_TYPE(\n      'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\n  }\n\n  let err;\n  if (msg.finished) {\n    err = new ERR_STREAM_WRITE_AFTER_END();\n  } else if (msg.destroyed) {\n    err = new ERR_STREAM_DESTROYED('write');\n  }\n\n  if (err) {\n    if (!msg.destroyed) {\n      onError(msg\x2C err\x2C callback);\n    } else {\n      process.nextTick(callback\x2C err);\n    }\n    return false;\n  }\n\n  if (!msg._header) {\n    if (fromEnd) {\n      msg._contentLength = len;\n    }\n    msg._implicitHeader();\n  }\n\n  if (!msg._hasBody) {\n    debug('This type of response MUST NOT have a body. ' +\n          'Ignoring write() calls.');\n    process.nextTick(callback);\n    return true;\n  }\n\n  if (!fromEnd && msg.socket && !msg.socket.writableCorked) {\n    msg.socket.cork();\n    process.nextTick(connectionCorkNT\x2C msg.socket);\n  }\n\n  let ret;\n  if (msg.chunkedEncoding && chunk.length !== 0) {\n    msg._send(NumberPrototypeToString(len\x2C 16)\x2C 'latin1'\x2C null);\n    msg._send(crlf_buf\x2C null\x2C null);\n    msg._send(chunk\x2C encoding\x2C null);\n    ret = msg._send(crlf_buf\x2C null\x2C callback);\n  } else {\n    ret = msg._send(chunk\x2C encoding\x2C callback);\n  }\n\n  debug('write ret = ' + ret);\n  return ret;\n}\n\n\nfunction connectionCorkNT(conn) {\n  conn.uncork();\n}\n\nOutgoingMessage.prototype.addTrailers = function addTrailers(headers) {\n  this._trailer = '';\n  const keys = ObjectKeys(headers);\n  const isArray = ArrayIsArray(headers);\n  // Retain for(;;) loop for performance reasons\n  // Refs: https://github.com/nodejs/node/pull/30958\n  for (let i = 0\x2C l = keys.length; i < l; i++) {\n    let field\x2C value;\n    const key = keys[i];\n    if (isArray) {\n      field = headers[key][0];\n      value = headers[key][1];\n    } else {\n      field = key;\n      value = headers[key];\n    }\n    if (typeof field !== 'string' || !field || !checkIsHttpToken(field)) {\n      throw new ERR_INVALID_HTTP_TOKEN('Trailer name'\x2C field);\n    }\n\n    // Check if the field must be sent several times\n    const isArrayValue = ArrayIsArray(value);\n    if (\n      isArrayValue && value.length > 1 &&\n      (!this[kUniqueHeaders] || !this[kUniqueHeaders].has(StringPrototypeToLowerCase(field)))\n    ) {\n      for (let j = 0\x2C l = value.length; j < l; j++) {\n        if (checkInvalidHeaderChar(value[j])) {\n          debug('Trailer "%s"[%d] contains invalid characters'\x2C field\x2C j);\n          throw new ERR_INVALID_CHAR('trailer content'\x2C field);\n        }\n        this._trailer += field + ': ' + value[j] + '\\r\\n';\n      }\n    } else {\n      if (isArrayValue) {\n        value = ArrayPrototypeJoin(value\x2C '; ');\n      }\n\n      if (checkInvalidHeaderChar(value)) {\n        debug('Trailer "%s" contains invalid characters'\x2C field);\n        throw new ERR_INVALID_CHAR('trailer content'\x2C field);\n      }\n      this._trailer += field + ': ' + value + '\\r\\n';\n    }\n  }\n};\n\nfunction onFinish(outmsg) {\n  if (outmsg && outmsg.socket && outmsg.socket._hadError) return;\n  outmsg.emit('finish');\n}\n\nOutgoingMessage.prototype.end = function end(chunk\x2C encoding\x2C callback) {\n  if (typeof chunk === 'function') {\n    callback = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    callback = encoding;\n    encoding = null;\n  }\n\n  if (chunk) {\n    if (this.finished) {\n      onError(this\x2C\n              new ERR_STREAM_WRITE_AFTER_END()\x2C\n              typeof callback !== 'function' ? nop : callback);\n      return this;\n    }\n\n    if (this.socket) {\n      this.socket.cork();\n    }\n\n    write_(this\x2C chunk\x2C encoding\x2C null\x2C true);\n  } else if (this.finished) {\n    if (typeof callback === 'function') {\n      if (!this.writableFinished) {\n        this.on('finish'\x2C callback);\n      } else {\n        callback(new ERR_STREAM_ALREADY_FINISHED('end'));\n      }\n    }\n    return this;\n  } else if (!this._header) {\n    if (this.socket) {\n      this.socket.cork();\n    }\n\n    this._contentLength = 0;\n    this._implicitHeader();\n  }\n\n  if (typeof callback === 'function')\n    this.once('finish'\x2C callback);\n\n  const finish = onFinish.bind(undefined\x2C this);\n\n  if (this._hasBody && this.chunkedEncoding) {\n    this._send('0\\r\\n' + this._trailer + '\\r\\n'\x2C 'latin1'\x2C finish);\n  } else if (!this._headerSent || this.writableLength || chunk) {\n    this._send(''\x2C 'latin1'\x2C finish);\n  } else {\n    process.nextTick(finish);\n  }\n\n  if (this.socket) {\n    // Fully uncork connection on end().\n    this.socket._writableState.corked = 1;\n    this.socket.uncork();\n  }\n  this[kCorked] = 0;\n\n  this.finished = true;\n\n  // There is the first message on the outgoing queue\x2C and we've sent\n  // everything to the socket.\n  debug('outgoing message end.');\n  if (this.outputData.length === 0 &&\n      this.socket &&\n      this.socket._httpMessage === this) {\n    this._finish();\n  }\n\n  return this;\n};\n\n\nOutgoingMessage.prototype._finish = function _finish() {\n  assert(this.socket);\n  this.emit('prefinish');\n};\n\n\n// This logic is probably a bit confusing. Let me explain a bit:\n//\n// In both HTTP servers and clients it is possible to queue up several\n// outgoing messages. This is easiest to imagine in the case of a client.\n// Take the following situation:\n//\n//    req1 = client.request('GET'\x2C '/');\n//    req2 = client.request('POST'\x2C '/');\n//\n// When the user does\n//\n//   req2.write('hello world\\n');\n//\n// it's possible that the first request has not been completely flushed to\n// the socket yet. Thus the outgoing messages need to be prepared to queue\n// up data internally before sending it on further to the socket's queue.\n//\n// This function\x2C outgoingFlush()\x2C is called by both the Server and Client\n// to attempt to flush any pending messages out to the socket.\nOutgoingMessage.prototype._flush = function _flush() {\n  const socket = this.socket;\n\n  if (socket && socket.writable) {\n    // There might be remaining data in this.output; write it out\n    const ret = this._flushOutput(socket);\n\n    if (this.finished) {\n      // This is a queue to the server or client to bring in the next this.\n      this._finish();\n    } else if (ret && this[kNeedDrain]) {\n      this[kNeedDrain] = false;\n      this.emit('drain');\n    }\n  }\n};\n\nOutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {\n  while (this[kCorked]) {\n    this[kCorked]--;\n    socket.cork();\n  }\n\n  const outputLength = this.outputData.length;\n  if (outputLength <= 0)\n    return undefined;\n\n  const outputData = this.outputData;\n  socket.cork();\n  let ret;\n  // Retain for(;;) loop for performance reasons\n  // Refs: https://github.com/nodejs/node/pull/30958\n  for (let i = 0; i < outputLength; i++) {\n    const { data\x2C encoding\x2C callback } = outputData[i];\n    ret = socket.write(data\x2C encoding\x2C callback);\n  }\n  socket.uncork();\n\n  this.outputData = [];\n  this._onPendingData(-this.outputSize);\n  this.outputSize = 0;\n\n  return ret;\n};\n\n\nOutgoingMessage.prototype.flushHeaders = function flushHeaders() {\n  if (!this._header) {\n    this._implicitHeader();\n  }\n\n  // Force-flush the headers.\n  this._send('');\n};\n\nOutgoingMessage.prototype.pipe = function pipe() {\n  // OutgoingMessage should be write-only. Piping from it is disabled.\n  this.emit('error'\x2C new ERR_STREAM_CANNOT_PIPE());\n};\n\nOutgoingMessage.prototype[EE.captureRejectionSymbol] =\nfunction(err\x2C event) {\n  this.destroy(err);\n};\n\nmodule.exports = {\n  kUniqueHeaders\x2C\n  parseUniqueHeadersOption\x2C\n  validateHeaderName\x2C\n  validateHeaderValue\x2C\n  OutgoingMessage\n};\n
code-source-info,0xb4611f33370,444,0,30940,C0O0C4O30940,,
code-creation,Function,10,255293,0xb4611f34f40,1534, node:_http_outgoing:1:1,0xb4611f332e8,~
code-source-info,0xb4611f34f40,444,0,30940,C0O0C224O1159C230O1168C236O1184C242O1206C248O1219C254O1246C260O1262C265O1286C271O1300C277O1316C283O1349C288O1373C294O1396C300O1407C306O1437C311O1499C314O1499C319O1471C324O1549C327O1549C331O1549C333O1588C336O1588C341O1622C344O1622C348O1622C350O1662C353O1662C358O1733C361O1733C366O1696C372O1709C378O1718C384O1778C387O1778C392O1767C398O1933C401O1933C406O1826C412O1871C418O1914C424O2031C427O2031C432O1968C443O2009C449O2483C452O2483C457O2483C462O2087C468O2114C474O2149C480O2179C486O2207C492O2233C498O2260C504O2282C510O2314C516O2342C522O2375C528O2407C534O2435C540O2463C545O2538C548O2538C553O2519C559O2595C562O2595C567O2578C573O2640C576O2640C581O2673C594O2674C600O2640C602O2744C605O2744C607O2788C610O2788C614O2788C616O2829C619O2829C623O2829C625O2868C629O2868C631O2901C635O2901C637O4523C645O4541C650O4486C655O4553C658O4553C663O4638C676O4692C684O4601C689O4877C702O4933C710O4840C715O5005C728O5057C736O4968C741O5188C754O5247C762O5151C767O5379C780O5431C788O5342C793O5585C806O5649C829O5649C838O5791C861O5791C870O5548C875O6393C888O6446C896O6495C904O6356C909O6580C922O6648C945O6648C954O7204C977O7204C986O6543C991O7755C1000O7780C1004O8305C1013O8320C1017O8436C1026O8453C1030O8590C1039O8611C1043O9130C1052O9148C1056O9527C1065O9543C1069O10312C1076O10332C1080O11203C1087O11226C1091O17463C1096O17463C1100O17463C1102O17657C1107O17657C1111O17657C1113O18235C1122O18255C1126O18636C1135O18659C1139O19417C1148O19437C1152O19747C1161O19772C1165O19967C1174O19995C1178O20477C1187O20498C1191O20929C1200O20949C1204O21129C1213O21152C1217O21739C1226O21765C1230O21898C1243O21994C1251O21861C1256O22074C1269O22130C1277O22037C1282O22209C1295O22269C1303O22172C1308O22374C1311O22381C1319O22381C1324O22374C1326O22411C1335O22427C1339O24822C1348O24844C1352O26519C1361O26533C1365O28340C1374O28358C1378O29213C1387O29230C1391O29681C1400O29704C1404O30369C1413O30392C1421O30544C1430O30559C1438O30722C1443O30735C1456O30759C1464O30809C1474O30830C1484O30848C1494O30876C1504O30898C1514O30921C1524O30824C1533O30939,,
tick,0x1025893f0,255447,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f29852,0x113244eeb,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x7ff805f12098,255460,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f29852,0x113244eeb,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x102db043d,255510,1,0x10266e4e0,6,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f29852,0x113244eeb,0x1132442e1,0xb4611f220b6,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,Eval,10,255654,0xb4611f383f0,5, node:internal/http:1:1,0xb4611f38238,~
script-source,445,node:internal/http,'use strict';\n\nconst {\n  Symbol\x2C\n  Date\x2C\n  DatePrototypeGetMilliseconds\x2C\n  DatePrototypeToUTCString\x2C\n} = primordials;\n\nconst { setUnrefTimeout } = require('internal/timers');\n\nlet utcCache;\n\nfunction utcDate() {\n  if (!utcCache) cache();\n  return utcCache;\n}\n\nfunction cache() {\n  const d = new Date();\n  utcCache = DatePrototypeToUTCString(d);\n  setUnrefTimeout(resetCache\x2C 1000 - DatePrototypeGetMilliseconds(d));\n}\n\nfunction resetCache() {\n  utcCache = undefined;\n}\n\nmodule.exports = {\n  kOutHeaders: Symbol('kOutHeaders')\x2C\n  kNeedDrain: Symbol('kNeedDrain')\x2C\n  utcDate\x2C\n};\n
code-source-info,0xb4611f383f0,445,0,577,C0O0C4O577,,
code-creation,Function,10,255745,0xb4611f38618,118, node:internal/http:1:1,0xb4611f38368,~
code-source-info,0xb4611f38618,445,0,577,C0O0C37O25C42O35C48O43C54O75C60O147C63O147C68O127C74O180C75O180C77O470C85O504C96O541C106O565C112O485C117O576,,
code-creation,LazyCompile,10,255965,0xb4611f38d98,43,hideStackFrames node:internal/errors:398:25,0xb4665160408,~
code-source-info,0xb4611f38d98,17,11081,11322,C0O11206C5O11230C9O11225C13O11238C21O11259C28O11297C35O11238C40O11310C42O11320,,
code-creation,Eval,10,256119,0xb4611f397a8,5, node:diagnostics_channel:1:1,0xb4611f39538,~
script-source,446,node:diagnostics_channel,'use strict';\n\nconst {\n  ArrayPrototypeIndexOf\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypeSplice\x2C\n  ObjectCreate\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectSetPrototypeOf\x2C\n  SymbolHasInstance\x2C\n} = primordials;\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n  }\n} = require('internal/errors');\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { triggerUncaughtException } = internalBinding('errors');\n\nconst { WeakReference } = internalBinding('util');\n\n// TODO(qard): should there be a C++ channel interface?\nclass ActiveChannel {\n  subscribe(subscription) {\n    validateFunction(subscription\x2C 'subscription');\n    ArrayPrototypePush(this._subscribers\x2C subscription);\n  }\n\n  unsubscribe(subscription) {\n    const index = ArrayPrototypeIndexOf(this._subscribers\x2C subscription);\n    if (index === -1) return false;\n\n    ArrayPrototypeSplice(this._subscribers\x2C index\x2C 1);\n\n    // When there are no more active subscribers\x2C restore to fast prototype.\n    if (!this._subscribers.length) {\n      // eslint-disable-next-line no-use-before-define\n      ObjectSetPrototypeOf(this\x2C Channel.prototype);\n    }\n\n    return true;\n  }\n\n  get hasSubscribers() {\n    return true;\n  }\n\n  publish(data) {\n    for (let i = 0; i < this._subscribers.length; i++) {\n      try {\n        const onMessage = this._subscribers[i];\n        onMessage(data\x2C this.name);\n      } catch (err) {\n        process.nextTick(() => {\n          triggerUncaughtException(err\x2C false);\n        });\n      }\n    }\n  }\n}\n\nclass Channel {\n  constructor(name) {\n    this._subscribers = undefined;\n    this.name = name;\n  }\n\n  static [SymbolHasInstance](instance) {\n    const prototype = ObjectGetPrototypeOf(instance);\n    return prototype === Channel.prototype ||\n           prototype === ActiveChannel.prototype;\n  }\n\n  subscribe(subscription) {\n    ObjectSetPrototypeOf(this\x2C ActiveChannel.prototype);\n    this._subscribers = [];\n    this.subscribe(subscription);\n  }\n\n  unsubscribe() {\n    return false;\n  }\n\n  get hasSubscribers() {\n    return false;\n  }\n\n  publish() {}\n}\n\nconst channels = ObjectCreate(null);\n\nfunction channel(name) {\n  let channel;\n  const ref = channels[name];\n  if (ref) channel = ref.get();\n  if (channel) return channel;\n\n  if (typeof name !== 'string' && typeof name !== 'symbol') {\n    throw new ERR_INVALID_ARG_TYPE('channel'\x2C ['string'\x2C 'symbol']\x2C name);\n  }\n\n  channel = new Channel(name);\n  channels[name] = new WeakReference(channel);\n  return channel;\n}\n\nfunction subscribe(name\x2C subscription) {\n  const chan = channel(name);\n  channels[name].incRef();\n  chan.subscribe(subscription);\n}\n\nfunction unsubscribe(name\x2C subscription) {\n  const chan = channel(name);\n  if (!chan.unsubscribe(subscription)) {\n    return false;\n  }\n\n  channels[name].decRef();\n  return true;\n}\n\nfunction hasSubscribers(name) {\n  let channel;\n  const ref = channels[name];\n  if (ref) channel = ref.get();\n  if (!channel) {\n    return false;\n  }\n\n  return channel.hasSubscribers;\n}\n\nmodule.exports = {\n  channel\x2C\n  hasSubscribers\x2C\n  subscribe\x2C\n  unsubscribe\x2C\n  Channel\n};\n
code-source-info,0xb4611f397a8,446,0,3040,C0O0C4O3040,,
code-creation,Function,10,256467,0xb4611f3a3f8,337, node:diagnostics_channel:1:1,0xb4611f39720,~
code-source-info,0xb4611f3a3f8,446,0,3040,C0O0C66O25C72O50C78O72C84O96C89O112C95O136C101O160C106O250C109O250C114O250C119O220C125O310C128O310C133O288C139O380C142O380C147O351C153O434C156O434C161O416C208O516C226O1592C284O1482C286O2054C288O2054C292O2054C294O2951C301O2972C307O2983C313O3001C319O3014C325O3029C331O2966C336O3039,,
code-creation,LazyCompile,10,256590,0xb4611f3adc8,105,channel node:diagnostics_channel:97:17,0xb4611f397d8,~
code-source-info,0xb4611f3adc8,446,2091,2448,C0O2106C2O2129C9O2137C13O2147C15O2170C20O2170C25O2179C29O2192C31O2207C32O2211C44O2275C62O2281C67O2275C68O2353C75O2363C81O2384C88O2405C93O2401C98O2399C102O2431C104O2446,,
code-creation,LazyCompile,10,256634,0xb4611f3b400,13,Channel node:diagnostics_channel:67:14,0xb4611f39ad0,~
code-source-info,0xb4611f3b400,446,1511,1580,C0O1524C1O1542C5O1559C7O1569C12O1579,,
tick,0x1027cbd2c,256767,1,0x10266e4e0,2,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f22101,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
new,MemoryChunk,0xb46da640000,262144
code-creation,Eval,10,257435,0xb4611f3e550,5, node:_http_server:1:1,0xb4611f3d0f8,~
script-source,447,node:_http_server,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayIsArray\x2C\n  Error\x2C\n  ObjectKeys\x2C\n  ObjectSetPrototypeOf\x2C\n  RegExpPrototypeExec\x2C\n  ReflectApply\x2C\n  Symbol\x2C\n  SymbolFor\x2C\n} = primordials;\n\nconst net = require('net');\nconst EE = require('events');\nconst assert = require('internal/assert');\nconst {\n  parsers\x2C\n  freeParser\x2C\n  continueExpression\x2C\n  chunkExpression\x2C\n  kIncomingMessage\x2C\n  HTTPParser\x2C\n  isLenient\x2C\n  _checkInvalidHeaderChar: checkInvalidHeaderChar\x2C\n  prepareError\x2C\n} = require('_http_common');\nconst { ConnectionsList } = internalBinding('http_parser');\nconst {\n  kUniqueHeaders\x2C\n  parseUniqueHeadersOption\x2C\n  OutgoingMessage\n} = require('_http_outgoing');\nconst {\n  kOutHeaders\x2C\n  kNeedDrain\x2C\n} = require('internal/http');\nconst {\n  defaultTriggerAsyncIdScope\x2C\n  getOrSetAsyncId\n} = require('internal/async_hooks');\nconst { IncomingMessage } = require('_http_incoming');\nconst {\n  connResetException\x2C\n  codes\n} = require('internal/errors');\nconst {\n  ERR_HTTP_REQUEST_TIMEOUT\x2C\n  ERR_HTTP_HEADERS_SENT\x2C\n  ERR_HTTP_INVALID_STATUS_CODE\x2C\n  ERR_HTTP_SOCKET_ENCODING\x2C\n  ERR_INVALID_ARG_TYPE\x2C\n  ERR_INVALID_ARG_VALUE\x2C\n  ERR_INVALID_CHAR\n} = codes;\nconst {\n  validateInteger\x2C\n  validateBoolean\n} = require('internal/validators');\nconst Buffer = require('buffer').Buffer;\nconst {\n  DTRACE_HTTP_SERVER_REQUEST\x2C\n  DTRACE_HTTP_SERVER_RESPONSE\n} = require('internal/dtrace');\nconst { setInterval\x2C clearInterval } = require('timers');\nlet debug = require('internal/util/debuglog').debuglog('http'\x2C (fn) => {\n  debug = fn;\n});\n\nconst dc = require('diagnostics_channel');\nconst onRequestStartChannel = dc.channel('http.server.request.start');\nconst onResponseFinishChannel = dc.channel('http.server.response.finish');\n\nconst kServerResponse = Symbol('ServerResponse');\nconst kServerResponseStatistics = Symbol('ServerResponseStatistics');\n\nconst {\n  hasObserver\x2C\n  startPerf\x2C\n  stopPerf\x2C\n} = require('internal/perf/observe');\n\nconst STATUS_CODES = {\n  100: 'Continue'\x2C                   // RFC 7231 6.2.1\n  101: 'Switching Protocols'\x2C        // RFC 7231 6.2.2\n  102: 'Processing'\x2C                 // RFC 2518 10.1 (obsoleted by RFC 4918)\n  103: 'Early Hints'\x2C                // RFC 8297 2\n  200: 'OK'\x2C                         // RFC 7231 6.3.1\n  201: 'Created'\x2C                    // RFC 7231 6.3.2\n  202: 'Accepted'\x2C                   // RFC 7231 6.3.3\n  203: 'Non-Authoritative Information'\x2C // RFC 7231 6.3.4\n  204: 'No Content'\x2C                 // RFC 7231 6.3.5\n  205: 'Reset Content'\x2C              // RFC 7231 6.3.6\n  206: 'Partial Content'\x2C            // RFC 7233 4.1\n  207: 'Multi-Status'\x2C               // RFC 4918 11.1\n  208: 'Already Reported'\x2C           // RFC 5842 7.1\n  226: 'IM Used'\x2C                    // RFC 3229 10.4.1\n  300: 'Multiple Choices'\x2C           // RFC 7231 6.4.1\n  301: 'Moved Permanently'\x2C          // RFC 7231 6.4.2\n  302: 'Found'\x2C                      // RFC 7231 6.4.3\n  303: 'See Other'\x2C                  // RFC 7231 6.4.4\n  304: 'Not Modified'\x2C               // RFC 7232 4.1\n  305: 'Use Proxy'\x2C                  // RFC 7231 6.4.5\n  307: 'Temporary Redirect'\x2C         // RFC 7231 6.4.7\n  308: 'Permanent Redirect'\x2C         // RFC 7238 3\n  400: 'Bad Request'\x2C                // RFC 7231 6.5.1\n  401: 'Unauthorized'\x2C               // RFC 7235 3.1\n  402: 'Payment Required'\x2C           // RFC 7231 6.5.2\n  403: 'Forbidden'\x2C                  // RFC 7231 6.5.3\n  404: 'Not Found'\x2C                  // RFC 7231 6.5.4\n  405: 'Method Not Allowed'\x2C         // RFC 7231 6.5.5\n  406: 'Not Acceptable'\x2C             // RFC 7231 6.5.6\n  407: 'Proxy Authentication Required'\x2C // RFC 7235 3.2\n  408: 'Request Timeout'\x2C            // RFC 7231 6.5.7\n  409: 'Conflict'\x2C                   // RFC 7231 6.5.8\n  410: 'Gone'\x2C                       // RFC 7231 6.5.9\n  411: 'Length Required'\x2C            // RFC 7231 6.5.10\n  412: 'Precondition Failed'\x2C        // RFC 7232 4.2\n  413: 'Payload Too Large'\x2C          // RFC 7231 6.5.11\n  414: 'URI Too Long'\x2C               // RFC 7231 6.5.12\n  415: 'Unsupported Media Type'\x2C     // RFC 7231 6.5.13\n  416: 'Range Not Satisfiable'\x2C      // RFC 7233 4.4\n  417: 'Expectation Failed'\x2C         // RFC 7231 6.5.14\n  418: 'I\\'m a Teapot'\x2C              // RFC 7168 2.3.3\n  421: 'Misdirected Request'\x2C        // RFC 7540 9.1.2\n  422: 'Unprocessable Entity'\x2C       // RFC 4918 11.2\n  423: 'Locked'\x2C                     // RFC 4918 11.3\n  424: 'Failed Dependency'\x2C          // RFC 4918 11.4\n  425: 'Too Early'\x2C                  // RFC 8470 5.2\n  426: 'Upgrade Required'\x2C           // RFC 2817 and RFC 7231 6.5.15\n  428: 'Precondition Required'\x2C      // RFC 6585 3\n  429: 'Too Many Requests'\x2C          // RFC 6585 4\n  431: 'Request Header Fields Too Large'\x2C // RFC 6585 5\n  451: 'Unavailable For Legal Reasons'\x2C // RFC 7725 3\n  500: 'Internal Server Error'\x2C      // RFC 7231 6.6.1\n  501: 'Not Implemented'\x2C            // RFC 7231 6.6.2\n  502: 'Bad Gateway'\x2C                // RFC 7231 6.6.3\n  503: 'Service Unavailable'\x2C        // RFC 7231 6.6.4\n  504: 'Gateway Timeout'\x2C            // RFC 7231 6.6.5\n  505: 'HTTP Version Not Supported'\x2C // RFC 7231 6.6.6\n  506: 'Variant Also Negotiates'\x2C    // RFC 2295 8.1\n  507: 'Insufficient Storage'\x2C       // RFC 4918 11.5\n  508: 'Loop Detected'\x2C              // RFC 5842 7.2\n  509: 'Bandwidth Limit Exceeded'\x2C\n  510: 'Not Extended'\x2C               // RFC 2774 7\n  511: 'Network Authentication Required' // RFC 6585 6\n};\n\nconst kOnExecute = HTTPParser.kOnExecute | 0;\nconst kOnTimeout = HTTPParser.kOnTimeout | 0;\nconst kLenientAll = HTTPParser.kLenientAll | 0;\nconst kLenientNone = HTTPParser.kLenientNone | 0;\nconst kConnections = Symbol('http.server.connections');\nconst kConnectionsCheckingInterval = Symbol('http.server.connectionsCheckingInterval');\n\nclass HTTPServerAsyncResource {\n  constructor(type\x2C socket) {\n    this.type = type;\n    this.socket = socket;\n  }\n}\n\nfunction ServerResponse(req) {\n  OutgoingMessage.call(this);\n\n  if (req.method === 'HEAD') this._hasBody = false;\n\n  this.req = req;\n  this.sendDate = true;\n  this._sent100 = false;\n  this._expect_continue = false;\n\n  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {\n    this.useChunkedEncodingByDefault = RegExpPrototypeExec(chunkExpression\x2C\n                                                           req.headers.te) !== null;\n    this.shouldKeepAlive = false;\n  }\n\n  if (hasObserver('http')) {\n    startPerf(this\x2C kServerResponseStatistics\x2C {\n      type: 'http'\x2C\n      name: 'HttpRequest'\x2C\n      detail: {\n        req: {\n          method: req.method\x2C\n          url: req.url\x2C\n          headers: req.headers\x2C\n        }\x2C\n      }\x2C\n    });\n  }\n}\nObjectSetPrototypeOf(ServerResponse.prototype\x2C OutgoingMessage.prototype);\nObjectSetPrototypeOf(ServerResponse\x2C OutgoingMessage);\n\nServerResponse.prototype._finish = function _finish() {\n  DTRACE_HTTP_SERVER_RESPONSE(this.socket);\n  if (this[kServerResponseStatistics] && hasObserver('http')) {\n    stopPerf(this\x2C kServerResponseStatistics\x2C {\n      detail: {\n        res: {\n          statusCode: this.statusCode\x2C\n          statusMessage: this.statusMessage\x2C\n          headers: typeof this.getHeaders === 'function' ? this.getHeaders() : {}\x2C\n        }\x2C\n      }\x2C\n    });\n  }\n  OutgoingMessage.prototype._finish.call(this);\n};\n\n\nServerResponse.prototype.statusCode = 200;\nServerResponse.prototype.statusMessage = undefined;\n\nfunction onServerResponseClose() {\n  // EventEmitter.emit makes a copy of the 'close' listeners array before\n  // calling the listeners. detachSocket() unregisters onServerResponseClose\n  // but if detachSocket() is called\x2C directly or indirectly\x2C by a 'close'\n  // listener\x2C onServerResponseClose is still in that copy of the listeners\n  // array. That is\x2C in the example below\x2C b still gets called even though\n  // it's been removed by a:\n  //\n  //   var EventEmitter = require('events');\n  //   var obj = new EventEmitter();\n  //   obj.on('event'\x2C a);\n  //   obj.on('event'\x2C b);\n  //   function a() { obj.removeListener('event'\x2C b) }\n  //   function b() { throw "BAM!" }\n  //   obj.emit('event');  // throws\n  //\n  // Ergo\x2C we need to deal with stale 'close' events and handle the case\n  // where the ServerResponse object has already been deconstructed.\n  // Fortunately\x2C that requires only a single if check. :-)\n  if (this._httpMessage) {\n    emitCloseNT(this._httpMessage);\n  }\n}\n\nServerResponse.prototype.assignSocket = function assignSocket(socket) {\n  assert(!socket._httpMessage);\n  socket._httpMessage = this;\n  socket.on('close'\x2C onServerResponseClose);\n  this.socket = socket;\n  this.emit('socket'\x2C socket);\n  this._flush();\n};\n\nServerResponse.prototype.detachSocket = function detachSocket(socket) {\n  assert(socket._httpMessage === this);\n  socket.removeListener('close'\x2C onServerResponseClose);\n  socket._httpMessage = null;\n  this.socket = null;\n};\n\nServerResponse.prototype.writeContinue = function writeContinue(cb) {\n  this._writeRaw('HTTP/1.1 100 Continue\\r\\n\\r\\n'\x2C 'ascii'\x2C cb);\n  this._sent100 = true;\n};\n\nServerResponse.prototype.writeProcessing = function writeProcessing(cb) {\n  this._writeRaw('HTTP/1.1 102 Processing\\r\\n\\r\\n'\x2C 'ascii'\x2C cb);\n};\n\nServerResponse.prototype._implicitHeader = function _implicitHeader() {\n  this.writeHead(this.statusCode);\n};\n\nServerResponse.prototype.writeHead = writeHead;\nfunction writeHead(statusCode\x2C reason\x2C obj) {\n  const originalStatusCode = statusCode;\n\n  statusCode |= 0;\n  if (statusCode < 100 || statusCode > 999) {\n    throw new ERR_HTTP_INVALID_STATUS_CODE(originalStatusCode);\n  }\n\n\n  if (typeof reason === 'string') {\n    // writeHead(statusCode\x2C reasonPhrase[\x2C headers])\n    this.statusMessage = reason;\n  } else {\n    // writeHead(statusCode[\x2C headers])\n    if (!this.statusMessage)\n      this.statusMessage = STATUS_CODES[statusCode] || 'unknown';\n    obj = reason;\n  }\n  this.statusCode = statusCode;\n\n  let headers;\n  if (this[kOutHeaders]) {\n    // Slow-case: when progressive API and header fields are passed.\n    let k;\n    if (ArrayIsArray(obj)) {\n      if (obj.length % 2 !== 0) {\n        throw new ERR_INVALID_ARG_VALUE('headers'\x2C obj);\n      }\n\n      for (let n = 0; n < obj.length; n += 2) {\n        k = obj[n + 0];\n        if (k) this.setHeader(k\x2C obj[n + 1]);\n      }\n    } else if (obj) {\n      const keys = ObjectKeys(obj);\n      // Retain for(;;) loop for performance reasons\n      // Refs: https://github.com/nodejs/node/pull/30958\n      for (let i = 0; i < keys.length; i++) {\n        k = keys[i];\n        if (k) this.setHeader(k\x2C obj[k]);\n      }\n    }\n    if (k === undefined && this._header) {\n      throw new ERR_HTTP_HEADERS_SENT('render');\n    }\n    // Only progressive api is used\n    headers = this[kOutHeaders];\n  } else {\n    // Only writeHead() called\n    headers = obj;\n  }\n\n  if (checkInvalidHeaderChar(this.statusMessage))\n    throw new ERR_INVALID_CHAR('statusMessage');\n\n  const statusLine = `HTTP/1.1 ${statusCode} ${this.statusMessage}\\r\\n`;\n\n  if (statusCode === 204 || statusCode === 304 ||\n      (statusCode >= 100 && statusCode <= 199)) {\n    // RFC 2616\x2C 10.2.5:\n    // The 204 response MUST NOT include a message-body\x2C and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616\x2C 10.3.5:\n    // The 304 response MUST NOT contain a message-body\x2C and thus is always\n    // terminated by the first empty line after the header fields.\n    // RFC 2616\x2C 10.1 Informational 1xx:\n    // This class of status code indicates a provisional response\x2C\n    // consisting only of the Status-Line and optional headers\x2C and is\n    // terminated by an empty line.\n    this._hasBody = false;\n  }\n\n  // Don't keep alive connections where the client expects 100 Continue\n  // but we sent a final status; they may put extra bytes on the wire.\n  if (this._expect_continue && !this._sent100) {\n    this.shouldKeepAlive = false;\n  }\n\n  this._storeHeader(statusLine\x2C headers);\n\n  return this;\n}\n\n// Docs-only deprecated: DEP0063\nServerResponse.prototype.writeHeader = ServerResponse.prototype.writeHead;\n\nfunction storeHTTPOptions(options) {\n  this[kIncomingMessage] = options.IncomingMessage || IncomingMessage;\n  this[kServerResponse] = options.ServerResponse || ServerResponse;\n\n  const maxHeaderSize = options.maxHeaderSize;\n  if (maxHeaderSize !== undefined)\n    validateInteger(maxHeaderSize\x2C 'maxHeaderSize'\x2C 0);\n  this.maxHeaderSize = maxHeaderSize;\n\n  const insecureHTTPParser = options.insecureHTTPParser;\n  if (insecureHTTPParser !== undefined)\n    validateBoolean(insecureHTTPParser\x2C 'options.insecureHTTPParser');\n  this.insecureHTTPParser = insecureHTTPParser;\n\n  if (options.noDelay === undefined)\n    options.noDelay = true;\n\n  const requestTimeout = options.requestTimeout;\n  if (requestTimeout !== undefined) {\n    validateInteger(requestTimeout\x2C 'requestTimeout'\x2C 0);\n    this.requestTimeout = requestTimeout;\n  } else {\n    this.requestTimeout = 300_000; // 5 minutes\n  }\n\n  const headersTimeout = options.headersTimeout;\n  if (headersTimeout !== undefined) {\n    validateInteger(headersTimeout\x2C 'headersTimeout'\x2C 0);\n    this.headersTimeout = headersTimeout;\n  } else {\n    this.headersTimeout = 60_000; // 60 seconds\n  }\n\n  if (this.requestTimeout > 0 && this.headersTimeout > 0 && this.headersTimeout >= this.requestTimeout) {\n    throw new codes.ERR_OUT_OF_RANGE('headersTimeout'\x2C '>= requestTimeout'\x2C headersTimeout);\n  }\n\n  const keepAliveTimeout = options.keepAliveTimeout;\n  if (keepAliveTimeout !== undefined) {\n    validateInteger(keepAliveTimeout\x2C 'keepAliveTimeout'\x2C 0);\n    this.keepAliveTimeout = keepAliveTimeout;\n  } else {\n    this.keepAliveTimeout = 5_000; // 5 seconds;\n  }\n\n  const connectionsCheckingInterval = options.connectionsCheckingInterval;\n  if (connectionsCheckingInterval !== undefined) {\n    validateInteger(connectionsCheckingInterval\x2C 'connectionsCheckingInterval'\x2C 0);\n    this.connectionsCheckingInterval = connectionsCheckingInterval;\n  } else {\n    this.connectionsCheckingInterval = 30_000; // 30 seconds\n  }\n}\n\nfunction setupConnectionsTracking(server) {\n  // Start connection handling\n  server[kConnections] = new ConnectionsList();\n\n  // This checker is started without checking whether any headersTimeout or requestTimeout is non zero\n  // otherwise it would not be started if such timeouts are modified after createServer.\n  server[kConnectionsCheckingInterval] =\n    setInterval(checkConnections.bind(server)\x2C server.connectionsCheckingInterval).unref();\n}\n\nfunction Server(options\x2C requestListener) {\n  if (!(this instanceof Server)) return new Server(options\x2C requestListener);\n\n  if (typeof options === 'function') {\n    requestListener = options;\n    options = {};\n  } else if (options == null || typeof options === 'object') {\n    options = { ...options };\n  } else {\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'object'\x2C options);\n  }\n\n  storeHTTPOptions.call(this\x2C options);\n  net.Server.call(\n    this\x2C\n    { allowHalfOpen: true\x2C noDelay: options.noDelay\x2C\n      keepAlive: options.keepAlive\x2C\n      keepAliveInitialDelay: options.keepAliveInitialDelay });\n\n  if (requestListener) {\n    this.on('request'\x2C requestListener);\n  }\n\n  // Similar option to this. Too lazy to write my own docs.\n  // http://www.squid-cache.org/Doc/config/half_closed_clients/\n  // https://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F\n  this.httpAllowHalfOpen = false;\n\n  this.on('connection'\x2C connectionListener);\n\n  this.timeout = 0;\n  this.maxHeadersCount = null;\n  this.maxRequestsPerSocket = 0;\n  setupConnectionsTracking(this);\n  this[kUniqueHeaders] = parseUniqueHeadersOption(options.uniqueHeaders);\n}\nObjectSetPrototypeOf(Server.prototype\x2C net.Server.prototype);\nObjectSetPrototypeOf(Server\x2C net.Server);\n\nServer.prototype.close = function() {\n  clearInterval(this[kConnectionsCheckingInterval]);\n  ReflectApply(net.Server.prototype.close\x2C this\x2C arguments);\n};\n\nServer.prototype.closeAllConnections = function() {\n  const connections = this[kConnections].all();\n\n  for (let i = 0\x2C l = connections.length; i < l; i++) {\n    connections[i].socket.destroy();\n  }\n};\n\nServer.prototype.closeIdleConnections = function() {\n  const connections = this[kConnections].idle();\n\n  for (let i = 0\x2C l = connections.length; i < l; i++) {\n    if (connections[i].socket._httpMessage && !connections[i].socket._httpMessage.finished) {\n      continue;\n    }\n\n    connections[i].socket.destroy();\n  }\n};\n\nServer.prototype.setTimeout = function setTimeout(msecs\x2C callback) {\n  this.timeout = msecs;\n  if (callback)\n    this.on('timeout'\x2C callback);\n  return this;\n};\n\nServer.prototype[EE.captureRejectionSymbol] = function(err\x2C event\x2C ...args) {\n  switch (event) {\n    case 'request': {\n      const { 1: res } = args;\n      if (!res.headersSent && !res.writableEnded) {\n        // Don't leak headers.\n        const names = res.getHeaderNames();\n        for (let i = 0; i < names.length; i++) {\n          res.removeHeader(names[i]);\n        }\n        res.statusCode = 500;\n        res.end(STATUS_CODES[500]);\n      } else {\n        res.destroy();\n      }\n      break;\n    }\n    default:\n      net.Server.prototype[SymbolFor('nodejs.rejection')]\n        .apply(this\x2C arguments);\n  }\n};\n\nfunction checkConnections() {\n  if (this.headersTimeout === 0 && this.requestTimeout === 0) {\n    return;\n  }\n\n  const expired = this[kConnections].expired(this.headersTimeout\x2C this.requestTimeout);\n\n  for (let i = 0; i < expired.length; i++) {\n    const socket = expired[i].socket;\n\n    if (socket) {\n      onRequestTimeout(socket);\n    }\n  }\n}\n\nfunction connectionListener(socket) {\n  defaultTriggerAsyncIdScope(\n    getOrSetAsyncId(socket)\x2C connectionListenerInternal\x2C this\x2C socket\n  );\n}\n\nfunction connectionListenerInternal(server\x2C socket) {\n  debug('SERVER new http connection');\n\n  // Ensure that the server property of the socket is correctly set.\n  // See https://github.com/nodejs/node/issues/13435\n  socket.server = server;\n\n  // If the user has added a listener to the server\x2C\n  // request\x2C or response\x2C then it's their responsibility.\n  // otherwise\x2C destroy on timeout by default\n  if (server.timeout && typeof socket.setTimeout === 'function')\n    socket.setTimeout(server.timeout);\n  socket.on('timeout'\x2C socketOnTimeout);\n\n  const parser = parsers.alloc();\n\n  const lenient = server.insecureHTTPParser === undefined ?\n    isLenient() : server.insecureHTTPParser;\n\n  // TODO(addaleax): This doesn't play well with the\n  // `async_hooks.currentResource()` proposal\x2C see\n  // https://github.com/nodejs/node/pull/21313\n  parser.initialize(\n    HTTPParser.REQUEST\x2C\n    new HTTPServerAsyncResource('HTTPINCOMINGMESSAGE'\x2C socket)\x2C\n    server.maxHeaderSize || 0\x2C\n    lenient ? kLenientAll : kLenientNone\x2C\n    server[kConnections]\x2C\n  );\n  parser.socket = socket;\n  socket.parser = parser;\n\n  // Propagate headers limit from server instance to parser\n  if (typeof server.maxHeadersCount === 'number') {\n    parser.maxHeaderPairs = server.maxHeadersCount << 1;\n  }\n\n  const state = {\n    onData: null\x2C\n    onEnd: null\x2C\n    onClose: null\x2C\n    onDrain: null\x2C\n    outgoing: []\x2C\n    incoming: []\x2C\n    // `outgoingData` is an approximate amount of bytes queued through all\n    // inactive responses. If more data than the high watermark is queued - we\n    // need to pause TCP socket/HTTP parser\x2C and wait until the data will be\n    // sent to the client.\n    outgoingData: 0\x2C\n    requestsCount: 0\x2C\n    keepAliveTimeoutSet: false\n  };\n  state.onData = socketOnData.bind(undefined\x2C\n                                   server\x2C socket\x2C parser\x2C state);\n  state.onEnd = socketOnEnd.bind(undefined\x2C\n                                 server\x2C socket\x2C parser\x2C state);\n  state.onClose = socketOnClose.bind(undefined\x2C\n                                     socket\x2C state);\n  state.onDrain = socketOnDrain.bind(undefined\x2C\n                                     socket\x2C state);\n  socket.on('data'\x2C state.onData);\n  socket.on('error'\x2C socketOnError);\n  socket.on('end'\x2C state.onEnd);\n  socket.on('close'\x2C state.onClose);\n  socket.on('drain'\x2C state.onDrain);\n  parser.onIncoming = parserOnIncoming.bind(undefined\x2C\n                                            server\x2C socket\x2C state);\n\n  // We are consuming socket\x2C so it won't get any actual data\n  socket.on('resume'\x2C onSocketResume);\n  socket.on('pause'\x2C onSocketPause);\n\n  // Overrides to unconsume on `data`\x2C `readable` listeners\n  socket.on = generateSocketListenerWrapper('on');\n  socket.addListener = generateSocketListenerWrapper('addListener');\n  socket.prependListener = generateSocketListenerWrapper('prependListener');\n  socket.setEncoding = socketSetEncoding;\n\n  // We only consume the socket if it has never been consumed before.\n  if (socket._handle && socket._handle.isStreamBase &&\n      !socket._handle._consumed) {\n    parser._consumed = true;\n    socket._handle._consumed = true;\n    parser.consume(socket._handle);\n  }\n  parser[kOnExecute] =\n    onParserExecute.bind(undefined\x2C\n                         server\x2C socket\x2C parser\x2C state);\n\n  parser[kOnTimeout] =\n    onParserTimeout.bind(undefined\x2C\n                         server\x2C socket);\n\n  socket._paused = false;\n}\n\nfunction socketSetEncoding() {\n  throw new ERR_HTTP_SOCKET_ENCODING();\n}\n\nfunction updateOutgoingData(socket\x2C state\x2C delta) {\n  state.outgoingData += delta;\n  socketOnDrain(socket\x2C state);\n}\n\nfunction socketOnDrain(socket\x2C state) {\n  const needPause = state.outgoingData > socket.writableHighWaterMark;\n\n  // If we previously paused\x2C then start reading again.\n  if (socket._paused && !needPause) {\n    socket._paused = false;\n    if (socket.parser)\n      socket.parser.resume();\n    socket.resume();\n  }\n\n  const msg = socket._httpMessage;\n  if (msg && !msg.finished && msg[kNeedDrain]) {\n    msg[kNeedDrain] = false;\n    msg.emit('drain');\n  }\n}\n\nfunction socketOnTimeout() {\n  const req = this.parser && this.parser.incoming;\n  const reqTimeout = req && !req.complete && req.emit('timeout'\x2C this);\n  const res = this._httpMessage;\n  const resTimeout = res && res.emit('timeout'\x2C this);\n  const serverTimeout = this.server.emit('timeout'\x2C this);\n\n  if (!reqTimeout && !resTimeout && !serverTimeout)\n    this.destroy();\n}\n\nfunction socketOnClose(socket\x2C state) {\n  debug('server socket close');\n  freeParser(socket.parser\x2C null\x2C socket);\n  abortIncoming(state.incoming);\n}\n\nfunction abortIncoming(incoming) {\n  while (incoming.length) {\n    const req = incoming.shift();\n    req.destroy(connResetException('aborted'));\n  }\n  // Abort socket._httpMessage ?\n}\n\nfunction socketOnEnd(server\x2C socket\x2C parser\x2C state) {\n  const ret = parser.finish();\n\n  if (ret instanceof Error) {\n    debug('parse error');\n    // socketOnError has additional logic and will call socket.destroy(err).\n    socketOnError.call(socket\x2C ret);\n  } else if (!server.httpAllowHalfOpen) {\n    socket.end();\n  } else if (state.outgoing.length) {\n    state.outgoing[state.outgoing.length - 1]._last = true;\n  } else if (socket._httpMessage) {\n    socket._httpMessage._last = true;\n  } else {\n    socket.end();\n  }\n}\n\nfunction socketOnData(server\x2C socket\x2C parser\x2C state\x2C d) {\n  assert(!socket._paused);\n  debug('SERVER socketOnData %d'\x2C d.length);\n\n  const ret = parser.execute(d);\n  onParserExecuteCommon(server\x2C socket\x2C parser\x2C state\x2C ret\x2C d);\n}\n\nfunction onRequestTimeout(socket) {\n  // socketOnError has additional logic and will call socket.destroy(err).\n  socketOnError.call(socket\x2C new ERR_HTTP_REQUEST_TIMEOUT());\n}\n\nfunction onParserExecute(server\x2C socket\x2C parser\x2C state\x2C ret) {\n  // When underlying `net.Socket` instance is consumed - no\n  // `data` events are emitted\x2C and thus `socket.setTimeout` fires the\n  // callback even if the data is constantly flowing into the socket.\n  // See\x2C https://github.com/nodejs/node/commit/ec2822adaad76b126b5cccdeaa1addf2376c9aa6\n  socket._unrefTimer();\n  debug('SERVER socketOnParserExecute %d'\x2C ret);\n  onParserExecuteCommon(server\x2C socket\x2C parser\x2C state\x2C ret\x2C undefined);\n}\n\nfunction onParserTimeout(server\x2C socket) {\n  const serverTimeout = server.emit('timeout'\x2C socket);\n\n  if (!serverTimeout)\n    socket.destroy();\n}\n\nconst noop = () => {};\nconst badRequestResponse = Buffer.from(\n  `HTTP/1.1 400 ${STATUS_CODES[400]}\\r\\n` +\n  'Connection: close\\r\\n\\r\\n'\x2C 'ascii'\n);\nconst requestTimeoutResponse = Buffer.from(\n  `HTTP/1.1 408 ${STATUS_CODES[408]}\\r\\n` +\n  'Connection: close\\r\\n\\r\\n'\x2C 'ascii'\n);\nconst requestHeaderFieldsTooLargeResponse = Buffer.from(\n  `HTTP/1.1 431 ${STATUS_CODES[431]}\\r\\n` +\n  'Connection: close\\r\\n\\r\\n'\x2C 'ascii'\n);\nfunction socketOnError(e) {\n  // Ignore further errors\n  this.removeListener('error'\x2C socketOnError);\n  this.on('error'\x2C noop);\n\n  if (!this.server.emit('clientError'\x2C e\x2C this)) {\n    if (this.writable && this.bytesWritten === 0) {\n      let response;\n\n      switch (e.code) {\n        case 'HPE_HEADER_OVERFLOW':\n          response = requestHeaderFieldsTooLargeResponse;\n          break;\n        case 'ERR_HTTP_REQUEST_TIMEOUT':\n          response = requestTimeoutResponse;\n          break;\n        default:\n          response = badRequestResponse;\n          break;\n      }\n\n      this.write(response);\n    }\n    this.destroy(e);\n  }\n}\n\nfunction onParserExecuteCommon(server\x2C socket\x2C parser\x2C state\x2C ret\x2C d) {\n  resetSocketTimeout(server\x2C socket\x2C state);\n\n  if (ret instanceof Error) {\n    prepareError(ret\x2C parser\x2C d);\n    debug('parse error'\x2C ret);\n    socketOnError.call(socket\x2C ret);\n  } else if (parser.incoming && parser.incoming.upgrade) {\n    // Upgrade or CONNECT\n    const req = parser.incoming;\n    debug('SERVER upgrade or connect'\x2C req.method);\n\n    if (!d)\n      d = parser.getCurrentBuffer();\n\n    socket.removeListener('data'\x2C state.onData);\n    socket.removeListener('end'\x2C state.onEnd);\n    socket.removeListener('close'\x2C state.onClose);\n    socket.removeListener('drain'\x2C state.onDrain);\n    socket.removeListener('error'\x2C socketOnError);\n    socket.removeListener('timeout'\x2C socketOnTimeout);\n    unconsume(parser\x2C socket);\n    parser.finish();\n    freeParser(parser\x2C req\x2C socket);\n    parser = null;\n\n    const eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';\n    if (eventName === 'upgrade' || server.listenerCount(eventName) > 0) {\n      debug('SERVER have listener for %s'\x2C eventName);\n      const bodyHead = d.slice(ret\x2C d.length);\n\n      socket.readableFlowing = null;\n\n      server.emit(eventName\x2C req\x2C socket\x2C bodyHead);\n    } else {\n      // Got CONNECT method\x2C but have no handler.\n      socket.destroy();\n    }\n  } else if (parser.incoming && parser.incoming.method === 'PRI') {\n    debug('SERVER got PRI request');\n    socket.destroy();\n  }\n\n  if (socket._paused && socket.parser) {\n    // onIncoming paused the socket\x2C we should pause the parser as well\n    debug('pause parser');\n    socket.parser.pause();\n  }\n}\n\nfunction clearIncoming(req) {\n  req = req || this;\n  const parser = req.socket && req.socket.parser;\n  // Reset the .incoming property so that the request object can be gc'ed.\n  if (parser && parser.incoming === req) {\n    if (req.readableEnded) {\n      parser.incoming = null;\n    } else {\n      req.on('end'\x2C clearIncoming);\n    }\n  }\n}\n\nfunction resOnFinish(req\x2C res\x2C socket\x2C state\x2C server) {\n  if (onResponseFinishChannel.hasSubscribers) {\n    onResponseFinishChannel.publish({\n      request: req\x2C\n      response: res\x2C\n      socket\x2C\n      server\n    });\n  }\n\n  // Usually the first incoming element should be our request.  it may\n  // be that in the case abortIncoming() was called that the incoming\n  // array will be empty.\n  assert(state.incoming.length === 0 || state.incoming[0] === req);\n\n  state.incoming.shift();\n\n  // If the user never called req.read()\x2C and didn't pipe() or\n  // .resume() or .on('data')\x2C then we call req._dump() so that the\n  // bytes will be pulled off the wire.\n  if (!req._consuming && !req._readableState.resumeScheduled)\n    req._dump();\n\n  res.detachSocket(socket);\n  clearIncoming(req);\n  process.nextTick(emitCloseNT\x2C res);\n\n  if (res._last) {\n    if (typeof socket.destroySoon === 'function') {\n      socket.destroySoon();\n    } else {\n      socket.end();\n    }\n  } else if (state.outgoing.length === 0) {\n    if (server.keepAliveTimeout && typeof socket.setTimeout === 'function') {\n      socket.setTimeout(server.keepAliveTimeout);\n      state.keepAliveTimeoutSet = true;\n    }\n  } else {\n    // Start sending the next message\n    const m = state.outgoing.shift();\n    if (m) {\n      m.assignSocket(socket);\n    }\n  }\n}\n\nfunction emitCloseNT(self) {\n  if (!self._closed) {\n    self.destroyed = true;\n    self._closed = true;\n    self.emit('close');\n  }\n}\n\n// The following callback is issued after the headers have been read on a\n// new message. In this callback we setup the response object and pass it\n// to the user.\nfunction parserOnIncoming(server\x2C socket\x2C state\x2C req\x2C keepAlive) {\n  resetSocketTimeout(server\x2C socket\x2C state);\n\n  if (req.upgrade) {\n    req.upgrade = req.method === 'CONNECT' ||\n                  server.listenerCount('upgrade') > 0;\n    if (req.upgrade)\n      return 2;\n  }\n\n  state.incoming.push(req);\n\n  // If the writable end isn't consuming\x2C then stop reading\n  // so that we don't become overwhelmed by a flood of\n  // pipelined requests that may never be resolved.\n  if (!socket._paused) {\n    const ws = socket._writableState;\n    if (ws.needDrain || state.outgoingData >= socket.writableHighWaterMark) {\n      socket._paused = true;\n      // We also need to pause the parser\x2C but don't do that until after\n      // the call to execute\x2C because we may still be processing the last\n      // chunk.\n      socket.pause();\n    }\n  }\n\n  const res = new server[kServerResponse](req);\n  res._keepAliveTimeout = server.keepAliveTimeout;\n  res._onPendingData = updateOutgoingData.bind(undefined\x2C\n                                               socket\x2C state);\n\n  res.shouldKeepAlive = keepAlive;\n  res[kUniqueHeaders] = server[kUniqueHeaders];\n  DTRACE_HTTP_SERVER_REQUEST(req\x2C socket);\n\n  if (onRequestStartChannel.hasSubscribers) {\n    onRequestStartChannel.publish({\n      request: req\x2C\n      response: res\x2C\n      socket\x2C\n      server\n    });\n  }\n\n  if (socket._httpMessage) {\n    // There are already pending outgoing res\x2C append.\n    state.outgoing.push(res);\n  } else {\n    res.assignSocket(socket);\n  }\n\n  // When we're finished writing the response\x2C check if this is the last\n  // response\x2C if so destroy the socket.\n  res.on('finish'\x2C\n         resOnFinish.bind(undefined\x2C\n                          req\x2C res\x2C socket\x2C state\x2C server));\n\n  let handled = false;\n\n  if (req.httpVersionMajor === 1 && req.httpVersionMinor === 1) {\n    const isRequestsLimitSet = (\n      typeof server.maxRequestsPerSocket === 'number' &&\n      server.maxRequestsPerSocket > 0\n    );\n\n    if (isRequestsLimitSet) {\n      state.requestsCount++;\n      res.maxRequestsOnConnectionReached = (\n        server.maxRequestsPerSocket <= state.requestsCount);\n    }\n\n    if (isRequestsLimitSet &&\n      (server.maxRequestsPerSocket < state.requestsCount)) {\n      handled = true;\n      server.emit('dropRequest'\x2C req\x2C socket);\n      res.writeHead(503);\n      res.end();\n    } else if (req.headers.expect !== undefined) {\n      handled = true;\n\n      if (RegExpPrototypeExec(continueExpression\x2C req.headers.expect) !== null) {\n        res._expect_continue = true;\n\n        if (server.listenerCount('checkContinue') > 0) {\n          server.emit('checkContinue'\x2C req\x2C res);\n        } else {\n          res.writeContinue();\n          server.emit('request'\x2C req\x2C res);\n        }\n      } else if (server.listenerCount('checkExpectation') > 0) {\n        server.emit('checkExpectation'\x2C req\x2C res);\n      } else {\n        res.writeHead(417);\n        res.end();\n      }\n    }\n  }\n\n  if (!handled) {\n    server.emit('request'\x2C req\x2C res);\n  }\n\n  return 0;  // No special treatment.\n}\n\nfunction resetSocketTimeout(server\x2C socket\x2C state) {\n  if (!state.keepAliveTimeoutSet)\n    return;\n\n  socket.setTimeout(server.timeout || 0);\n  state.keepAliveTimeoutSet = false;\n}\n\nfunction onSocketResume() {\n  // It may seem that the socket is resumed\x2C but this is an enemy's trick to\n  // deceive us! `resume` is emitted asynchronously\x2C and may be called from\n  // `incoming.readStart()`. Stop the socket again here\x2C just to preserve the\n  // state.\n  //\n  // We don't care about stream semantics for the consumed socket anyway.\n  if (this._paused) {\n    this.pause();\n    return;\n  }\n\n  if (this._handle && !this._handle.reading) {\n    this._handle.reading = true;\n    this._handle.readStart();\n  }\n}\n\nfunction onSocketPause() {\n  if (this._handle && this._handle.reading) {\n    this._handle.reading = false;\n    this._handle.readStop();\n  }\n}\n\nfunction unconsume(parser\x2C socket) {\n  if (socket._handle) {\n    if (parser._consumed)\n      parser.unconsume();\n    parser._consumed = false;\n    socket.removeListener('pause'\x2C onSocketPause);\n    socket.removeListener('resume'\x2C onSocketResume);\n  }\n}\n\nfunction generateSocketListenerWrapper(originalFnName) {\n  return function socketListenerWrap(ev\x2C fn) {\n    const res = net.Socket.prototype[originalFnName].call(this\x2C\n                                                          ev\x2C fn);\n    if (!this.parser) {\n      this.on = net.Socket.prototype.on;\n      this.addListener = net.Socket.prototype.addListener;\n      this.prependListener = net.Socket.prototype.prependListener;\n      return res;\n    }\n\n    if (ev === 'data' || ev === 'readable')\n      unconsume(this.parser\x2C this);\n\n    return res;\n  };\n}\n\nmodule.exports = {\n  STATUS_CODES\x2C\n  Server\x2C\n  ServerResponse\x2C\n  setupConnectionsTracking\x2C\n  storeHTTPOptions\x2C\n  _connectionListener: connectionListener\x2C\n  kServerResponse\n};\n
code-source-info,0xb4611f3e550,447,0,34614,C0O0C4O34614,,
code-creation,Function,10,261247,0xb46da641168,1470, node:_http_server:1:1,0xb4611f3e4c8,~
code-source-info,0xb46da641168,447,0,34614,C0O0C377O1159C383O1175C389O1184C395O1198C400O1222C406O1245C412O1261C417O1271C423O1312C426O1312C430O1312C432O1339C435O1339C440O1373C443O1373C447O1373C449O1593C452O1593C457O1411C463O1422C469O1436C475O1458C481O1477C487O1497C493O1511C499O1549C505O1575C511O1646C514O1646C519O1626C525O1754C528O1754C533O1688C539O1706C545O1734C551O1822C554O1822C559O1791C565O1806C571O1908C574O1908C579O1858C585O1888C591O1969C594O1969C599O1949C605O2038C608O2038C613O2006C619O2028C625O2259C628O2076C634O2104C640O2129C646O2161C652O2189C658O2213C664O2238C670O2315C673O2315C678O2276C684O2295C690O2362C693O2362C698O2379C703O2460C706O2460C711O2398C717O2428C723O2527C726O2527C731O2496C737O2509C743O2558C746O2558C751O2591C764O2592C770O2558C772O2649C775O2649C780O2714C788O2714C793O2711C795O2787C803O2787C808O2784C810O2852C813O2852C817O2852C819O2912C822O2912C826O2912C828O3001C831O3001C836O2959C842O2974C848O2987C854O3057C858O3057C860O6531C863O6542C867O6553C870O6531C872O6577C875O6588C879O6599C882O6577C884O6624C887O6635C891O6647C894O6624C896O6673C899O6684C903O6697C906O6673C908O6723C911O6723C915O6723C917O6795C920O6795C924O6795C947O6847C949O7718C952O7754C960O7781C965O7718C970O7793C976O7793C981O7849C984O7864C993O7882C997O8344C1000O8359C1009O8380C1013O8387C1016O8402C1022O8426C1026O9428C1029O9443C1038O9466C1042O9683C1045O9698C1054O9721C1058O9908C1061O9923C1070O9947C1074O10070C1077O10085C1086O10111C1090O10214C1093O10229C1102O10255C1106O10325C1109O10340C1116O10360C1120O13003C1123O13018C1131O13057C1136O13067C1140O13040C1144O16672C1147O16700C1155O16715C1160O16722C1165O16672C1170O16734C1176O16767C1181O16734C1186O16777C1189O16784C1198O16800C1202O16933C1205O16940C1214O16970C1218O17135C1221O17142C1230O17173C1234O17456C1237O17463C1246O17484C1250O17618C1253O17625C1258O17638C1267O17662C1271O25102C1275O25102C1277O25146C1292O25182C1308O25194C1315O25146C1321O25139C1323O25276C1338O25312C1354O25324C1361O25276C1367O25269C1369O25419C1384O25455C1400O25467C1407O25419C1413O25412C1415O34439C1422O34460C1428O34476C1434O34486C1440O34504C1446O34532C1452O34573C1458O34595C1464O34454C1469O34613,,
tick,0x7ff805ede983,261407,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f22101,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x7ff805e4dd52,261419,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f22101,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x103b69f66,261428,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb4611f22101,0x113244eeb,0xb46b969288c,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,261647,0xb46da6445a8,5,byteLength node:buffer:633:17,0xb469fcef978,~
code-source-info,0xb46da6445a8,30,18115,18140,C0O18134C4O18140,,
code-creation,LazyCompile,10,261680,0xb46da644680,23,write node:buffer:634:12,0xb469fcefa48,~
code-source-info,0xb46da644680,30,18153,18218,C0O18187C17O18187C22O18218,,
tick,0x113247cc0,261873,0,0x0,0,0x1025e38e0,0xb46b96af834,0xb46b96928cf,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,261924,0xb46da6449d8,43,get node:http:133:6,0xb4611f21c70,~
code-source-info,0xb46da6449d8,438,3786,3992,C0O3795C6O3863C12O3863C17O3844C22O3898C25O3914C32O3912C38O3967C42O3988,,
code-creation,LazyCompile,10,261964,0xb46da644fd0,10,get node:http:147:6,0xb4611f21cc0,~
code-source-info,0xb46da644fd0,438,4118,4160,C0O4127C5O4144C9O4156,,
code-creation,LazyCompile,10,262339,0xb46da645550,12,get node:crypto:369:8,0xb462a843db0,~
script-source,89,node:crypto,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Note: In 0.8 and before\x2C crypto functions all defaulted to using\n// binary-encoded strings rather than buffers.\n\n'use strict';\n\nconst {\n  ObjectDefineProperty\x2C\n  ObjectDefineProperties\x2C\n} = primordials;\n\nconst {\n  assertCrypto\x2C\n  deprecate\n} = require('internal/util');\nassertCrypto();\n\nconst {\n  ERR_CRYPTO_FIPS_FORCED\x2C\n} = require('internal/errors').codes;\nconst constants = internalBinding('constants').crypto;\nconst { getOptionValue } = require('internal/options');\nconst {\n  getFipsCrypto\x2C\n  setFipsCrypto\x2C\n  timingSafeEqual\x2C\n} = internalBinding('crypto');\nconst {\n  checkPrime\x2C\n  checkPrimeSync\x2C\n  generatePrime\x2C\n  generatePrimeSync\x2C\n  randomBytes\x2C\n  randomFill\x2C\n  randomFillSync\x2C\n  randomInt\x2C\n  randomUUID\x2C\n} = require('internal/crypto/random');\nconst {\n  pbkdf2\x2C\n  pbkdf2Sync\n} = require('internal/crypto/pbkdf2');\nconst {\n  scrypt\x2C\n  scryptSync\n} = require('internal/crypto/scrypt');\nconst {\n  hkdf\x2C\n  hkdfSync\n} = require('internal/crypto/hkdf');\nconst {\n  generateKeyPair\x2C\n  generateKeyPairSync\x2C\n  generateKey\x2C\n  generateKeySync\x2C\n} = require('internal/crypto/keygen');\nconst {\n  createSecretKey\x2C\n  createPublicKey\x2C\n  createPrivateKey\x2C\n  KeyObject\x2C\n} = require('internal/crypto/keys');\nconst {\n  DiffieHellman\x2C\n  DiffieHellmanGroup\x2C\n  ECDH\x2C\n  diffieHellman\n} = require('internal/crypto/diffiehellman');\nconst {\n  Cipher\x2C\n  Cipheriv\x2C\n  Decipher\x2C\n  Decipheriv\x2C\n  privateDecrypt\x2C\n  privateEncrypt\x2C\n  publicDecrypt\x2C\n  publicEncrypt\x2C\n  getCipherInfo\x2C\n} = require('internal/crypto/cipher');\nconst {\n  Sign\x2C\n  signOneShot\x2C\n  Verify\x2C\n  verifyOneShot\n} = require('internal/crypto/sig');\nconst {\n  Hash\x2C\n  Hmac\n} = require('internal/crypto/hash');\nconst {\n  X509Certificate\n} = require('internal/crypto/x509');\nconst {\n  getCiphers\x2C\n  getCurves\x2C\n  getDefaultEncoding\x2C\n  getHashes\x2C\n  setDefaultEncoding\x2C\n  setEngine\x2C\n  secureHeapUsed\x2C\n} = require('internal/crypto/util');\nconst Certificate = require('internal/crypto/certificate');\n\nlet webcrypto;\nfunction lazyWebCrypto() {\n  webcrypto ??= require('internal/crypto/webcrypto');\n  return webcrypto;\n}\n\n// These helper functions are needed because the constructors can\n// use new\x2C in which case V8 cannot inline the recursive constructor call\nfunction createHash(algorithm\x2C options) {\n  return new Hash(algorithm\x2C options);\n}\n\nfunction createCipher(cipher\x2C password\x2C options) {\n  return new Cipher(cipher\x2C password\x2C options);\n}\n\nfunction createCipheriv(cipher\x2C key\x2C iv\x2C options) {\n  return new Cipheriv(cipher\x2C key\x2C iv\x2C options);\n}\n\nfunction createDecipher(cipher\x2C password\x2C options) {\n  return new Decipher(cipher\x2C password\x2C options);\n}\n\nfunction createDecipheriv(cipher\x2C key\x2C iv\x2C options) {\n  return new Decipheriv(cipher\x2C key\x2C iv\x2C options);\n}\n\nfunction createDiffieHellman(sizeOrKey\x2C keyEncoding\x2C generator\x2C genEncoding) {\n  return new DiffieHellman(sizeOrKey\x2C keyEncoding\x2C generator\x2C genEncoding);\n}\n\nfunction createDiffieHellmanGroup(name) {\n  return new DiffieHellmanGroup(name);\n}\n\nfunction createECDH(curve) {\n  return new ECDH(curve);\n}\n\nfunction createHmac(hmac\x2C key\x2C options) {\n  return new Hmac(hmac\x2C key\x2C options);\n}\n\nfunction createSign(algorithm\x2C options) {\n  return new Sign(algorithm\x2C options);\n}\n\nfunction createVerify(algorithm\x2C options) {\n  return new Verify(algorithm\x2C options);\n}\n\nmodule.exports = {\n  // Methods\n  checkPrime\x2C\n  checkPrimeSync\x2C\n  createCipheriv\x2C\n  createDecipheriv\x2C\n  createDiffieHellman\x2C\n  createDiffieHellmanGroup\x2C\n  createECDH\x2C\n  createHash\x2C\n  createHmac\x2C\n  createPrivateKey\x2C\n  createPublicKey\x2C\n  createSecretKey\x2C\n  createSign\x2C\n  createVerify\x2C\n  diffieHellman\x2C\n  generatePrime\x2C\n  generatePrimeSync\x2C\n  getCiphers\x2C\n  getCipherInfo\x2C\n  getCurves\x2C\n  getDiffieHellman: createDiffieHellmanGroup\x2C\n  getHashes\x2C\n  hkdf\x2C\n  hkdfSync\x2C\n  pbkdf2\x2C\n  pbkdf2Sync\x2C\n  generateKeyPair\x2C\n  generateKeyPairSync\x2C\n  generateKey\x2C\n  generateKeySync\x2C\n  privateDecrypt\x2C\n  privateEncrypt\x2C\n  publicDecrypt\x2C\n  publicEncrypt\x2C\n  randomBytes\x2C\n  randomFill\x2C\n  randomFillSync\x2C\n  randomInt\x2C\n  randomUUID\x2C\n  scrypt\x2C\n  scryptSync\x2C\n  sign: signOneShot\x2C\n  setEngine\x2C\n  timingSafeEqual\x2C\n  getFips\x2C\n  setFips\x2C\n  verify: verifyOneShot\x2C\n\n  // Classes\n  Certificate\x2C\n  Cipher\x2C\n  Cipheriv\x2C\n  Decipher\x2C\n  Decipheriv\x2C\n  DiffieHellman\x2C\n  DiffieHellmanGroup\x2C\n  ECDH\x2C\n  Hash\x2C\n  Hmac\x2C\n  KeyObject\x2C\n  Sign\x2C\n  Verify\x2C\n  X509Certificate\x2C\n  secureHeapUsed\x2C\n};\n\nfunction getFips() {\n  return getOptionValue('--force-fips') ? 1 : getFipsCrypto();\n}\n\nfunction setFips(val) {\n  if (getOptionValue('--force-fips')) {\n    if (val) return;\n    throw new ERR_CRYPTO_FIPS_FORCED();\n  } else {\n    setFipsCrypto(val);\n  }\n}\n\nfunction getRandomValues(array) {\n  return lazyWebCrypto().crypto.getRandomValues(array);\n}\n\nObjectDefineProperty(constants\x2C 'defaultCipherList'\x2C {\n  __proto__: null\x2C\n  get() {\n    const value = getOptionValue('--tls-cipher-list');\n    ObjectDefineProperty(this\x2C 'defaultCipherList'\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      value\n    });\n    return value;\n  }\x2C\n  set(val) {\n    ObjectDefineProperty(this\x2C 'defaultCipherList'\x2C {\n      __proto__: null\x2C\n      writable: true\x2C\n      configurable: true\x2C\n      enumerable: true\x2C\n      value: val\n    });\n  }\x2C\n  configurable: true\x2C\n  enumerable: true\x2C\n});\n\nfunction getRandomBytesAlias(key) {\n  return {\n    enumerable: false\x2C\n    configurable: true\x2C\n    get() {\n      let value;\n      if (getOptionValue('--pending-deprecation')) {\n        value = deprecate(\n          randomBytes\x2C\n          `crypto.${key} is deprecated.`\x2C\n          'DEP0115');\n      } else {\n        value = randomBytes;\n      }\n      ObjectDefineProperty(\n        this\x2C\n        key\x2C\n        {\n          __proto__: null\x2C\n          enumerable: false\x2C\n          configurable: true\x2C\n          writable: true\x2C\n          value: value\n        }\n      );\n      return value;\n    }\x2C\n    set(value) {\n      ObjectDefineProperty(\n        this\x2C\n        key\x2C\n        {\n          __proto__: null\x2C\n          enumerable: true\x2C\n          configurable: true\x2C\n          writable: true\x2C\n          value\n        }\n      );\n    }\n  };\n}\n\nObjectDefineProperties(module.exports\x2C {\n  createCipher: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    value: deprecate(createCipher\x2C\n                     'crypto.createCipher is deprecated.'\x2C 'DEP0106')\n  }\x2C\n  createDecipher: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    value: deprecate(createDecipher\x2C\n                     'crypto.createDecipher is deprecated.'\x2C 'DEP0106')\n  }\x2C\n  // crypto.fips is deprecated. DEP0093. Use crypto.getFips()/crypto.setFips()\n  fips: {\n    __proto__: null\x2C\n    get: getFips\x2C\n    set: setFips\x2C\n  }\x2C\n  DEFAULT_ENCODING: {\n    __proto__: null\x2C\n    enumerable: false\x2C\n    configurable: true\x2C\n    get: deprecate(getDefaultEncoding\x2C\n                   'crypto.DEFAULT_ENCODING is deprecated.'\x2C 'DEP0091')\x2C\n    set: deprecate(setDefaultEncoding\x2C\n                   'crypto.DEFAULT_ENCODING is deprecated.'\x2C 'DEP0091')\n  }\x2C\n  constants: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    value: constants\n  }\x2C\n\n  webcrypto: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    get() { return lazyWebCrypto().crypto; }\x2C\n    set: undefined\x2C\n  }\x2C\n\n  subtle: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    get() { return lazyWebCrypto().crypto.subtle; }\x2C\n    set: undefined\x2C\n  }\x2C\n\n  getRandomValues: {\n    __proto__: null\x2C\n    configurable: false\x2C\n    enumerable: true\x2C\n    get: () => getRandomValues\x2C\n    set: undefined\x2C\n  }\x2C\n\n  // Aliases for randomBytes are deprecated.\n  // The ecosystem needs those to exist for backwards compatibility.\n  prng: getRandomBytesAlias('prng')\x2C\n  pseudoRandomBytes: getRandomBytesAlias('pseudoRandomBytes')\x2C\n  rng: getRandomBytesAlias('rng')\n});\n
code-source-info,0xb46da645550,89,8236,8273,C0O8241C3O8248C7O8263C11O8271,,
tick,0x7ff805f12098,263426,0,0x0,3,0x102d5e910,0x1031b6710,0x113247bfe,0x113247ea8,0xb46b96afb92,0x1025e38e0,0xb46b96af834,0xb46b96928cf,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,263441,0xb46da6462a8,32,lazyWebCrypto node:crypto:125:23,0xb462a8435b8,~
code-source-info,0xb46da6462a8,89,3106,3186,C0O3113C14O3127C21O3123C27O3167C31O3184,,
code-creation,Eval,10,263978,0xb46da646d00,5, node:internal/crypto/webcrypto:1:1,0xb46da646898,~
script-source,448,node:internal/crypto/webcrypto,'use strict';\n\nconst {\n  ArrayPrototypeIncludes\x2C\n  JSONParse\x2C\n  JSONStringify\x2C\n  ObjectDefineProperties\x2C\n  ReflectApply\x2C\n  ReflectConstruct\x2C\n  SafeSet\x2C\n  SymbolToStringTag\x2C\n  StringPrototypeRepeat\x2C\n} = primordials;\n\nconst {\n  kWebCryptoKeyFormatRaw\x2C\n  kWebCryptoKeyFormatPKCS8\x2C\n  kWebCryptoKeyFormatSPKI\x2C\n  kWebCryptoCipherEncrypt\x2C\n  kWebCryptoCipherDecrypt\x2C\n} = internalBinding('crypto');\n\nconst {\n  validateArray\x2C\n  validateBoolean\x2C\n  validateObject\x2C\n  validateOneOf\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nconst { TextDecoder\x2C TextEncoder } = require('internal/encoding');\n\nconst {\n  codes: {\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_INVALID_THIS\x2C\n  }\n} = require('internal/errors');\n\nconst {\n  CryptoKey\x2C\n  InternalCryptoKey\x2C\n  createSecretKey\x2C\n  isCryptoKey\x2C\n} = require('internal/crypto/keys');\n\nconst {\n  asyncDigest\x2C\n} = require('internal/crypto/hash');\n\nconst {\n  getArrayBufferOrView\x2C\n  hasAnyNotIn\x2C\n  lazyRequire\x2C\n  normalizeAlgorithm\x2C\n  normalizeHashName\x2C\n  validateMaxBufferLength\x2C\n  kExportFormats\x2C\n  kHandle\x2C\n  kKeyObject\x2C\n} = require('internal/crypto/util');\n\nconst {\n  kEnumerableProperty\x2C\n  lazyDOMException\x2C\n} = require('internal/util');\n\nconst {\n  getRandomValues: _getRandomValues\x2C\n  randomUUID: _randomUUID\x2C\n} = require('internal/crypto/random');\n\nasync function digest(algorithm\x2C data) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  return ReflectApply(asyncDigest\x2C this\x2C arguments);\n}\n\nfunction randomUUID() {\n  if (this !== crypto) throw new ERR_INVALID_THIS('Crypto');\n  return _randomUUID();\n}\n\nasync function generateKey(\n  algorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  algorithm = normalizeAlgorithm(algorithm);\n  validateBoolean(extractable\x2C 'extractable');\n  validateArray(keyUsages\x2C 'keyUsages');\n  let result;\n  let resultType;\n  switch (algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      resultType = 'CryptoKeyPair';\n      result = await lazyRequire('internal/crypto/rsa')\n        .rsaKeyGenerate(algorithm\x2C extractable\x2C keyUsages);\n      break;\n    case 'Ed25519':\n      // Fall through\n    case 'Ed448':\n      // Fall through\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      resultType = 'CryptoKeyPair';\n      result = await lazyRequire('internal/crypto/cfrg')\n        .cfrgGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n      break;\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      resultType = 'CryptoKeyPair';\n      result = await lazyRequire('internal/crypto/ec')\n        .ecGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n      break;\n    case 'HMAC':\n      resultType = 'CryptoKey';\n      result = await lazyRequire('internal/crypto/mac')\n        .hmacGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n      break;\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      resultType = 'CryptoKey';\n      result = await lazyRequire('internal/crypto/aes')\n        .aesGenerateKey(algorithm\x2C extractable\x2C keyUsages);\n      break;\n    default:\n      throw lazyDOMException('Unrecognized name.');\n  }\n\n  if (\n    (resultType === 'CryptoKey' &&\n      (result.type === 'secret' || result.type === 'private') &&\n      result.usages.length === 0) ||\n    (resultType === 'CryptoKeyPair' && result.privateKey.usages.length === 0)\n  ) {\n    throw lazyDOMException(\n      'Usages cannot be empty when creating a key.'\x2C\n      'SyntaxError');\n  }\n\n  return result;\n}\n\nasync function deriveBits(algorithm\x2C baseKey\x2C length) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  algorithm = normalizeAlgorithm(algorithm);\n  if (!isCryptoKey(baseKey))\n    throw new ERR_INVALID_ARG_TYPE('baseKey'\x2C 'CryptoKey'\x2C baseKey);\n  if (!ArrayPrototypeIncludes(baseKey.usages\x2C 'deriveBits')) {\n    throw lazyDOMException(\n      'baseKey does not have deriveBits usage'\x2C\n      'InvalidAccessError');\n  }\n  if (baseKey.algorithm.name !== algorithm.name)\n    throw lazyDOMException('Key algorithm mismatch'\x2C 'InvalidAccessError');\n  switch (algorithm.name) {\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      // Fall through\n    case 'ECDH':\n      return lazyRequire('internal/crypto/diffiehellman')\n        .asyncDeriveBitsECDH(algorithm\x2C baseKey\x2C length);\n    case 'HKDF':\n      return lazyRequire('internal/crypto/hkdf')\n        .hkdfDeriveBits(algorithm\x2C baseKey\x2C length);\n    case 'PBKDF2':\n      return lazyRequire('internal/crypto/pbkdf2')\n        .pbkdf2DeriveBits(algorithm\x2C baseKey\x2C length);\n  }\n  throw lazyDOMException('Unrecognized name.');\n}\n\nfunction getKeyLength({ name\x2C length\x2C hash }) {\n  switch (name) {\n    case 'AES-CTR':\n    case 'AES-CBC':\n    case 'AES-GCM':\n    case 'AES-KW':\n      if (length !== 128 && length !== 192 && length !== 256)\n        throw lazyDOMException('Invalid key length'\x2C 'OperationError');\n\n      return length;\n    case 'HMAC':\n      if (length === undefined) {\n        switch (hash?.name) {\n          case 'SHA-1':\n            return 160;\n          case 'SHA-256':\n            return 256;\n          case 'SHA-384':\n            return 384;\n          case 'SHA-512':\n            return 512;\n        }\n      }\n\n      if (typeof length === 'number' && length !== 0) {\n        return length;\n      }\n\n      throw lazyDOMException('Invalid key length'\x2C 'OperationError');\n    case 'HKDF':\n    case 'PBKDF2':\n      return null;\n  }\n}\n\nasync function deriveKey(\n  algorithm\x2C\n  baseKey\x2C\n  derivedKeyAlgorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  algorithm = normalizeAlgorithm(algorithm);\n  derivedKeyAlgorithm = normalizeAlgorithm(derivedKeyAlgorithm);\n  if (!isCryptoKey(baseKey))\n    throw new ERR_INVALID_ARG_TYPE('baseKey'\x2C 'CryptoKey'\x2C baseKey);\n  if (!ArrayPrototypeIncludes(baseKey.usages\x2C 'deriveKey')) {\n    throw lazyDOMException(\n      'baseKey does not have deriveKey usage'\x2C\n      'InvalidAccessError');\n  }\n  if (baseKey.algorithm.name !== algorithm.name)\n    throw lazyDOMException('Key algorithm mismatch'\x2C 'InvalidAccessError');\n  validateObject(derivedKeyAlgorithm\x2C 'derivedKeyAlgorithm'\x2C {\n    allowArray: true\x2C allowFunction: true\x2C\n  });\n  validateBoolean(extractable\x2C 'extractable');\n  validateArray(keyUsages\x2C 'keyUsages');\n\n  const length = getKeyLength(derivedKeyAlgorithm);\n  let bits;\n  switch (algorithm.name) {\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      // Fall through\n    case 'ECDH':\n      bits = await lazyRequire('internal/crypto/diffiehellman')\n        .asyncDeriveBitsECDH(algorithm\x2C baseKey\x2C length);\n      break;\n    case 'HKDF':\n      bits = await lazyRequire('internal/crypto/hkdf')\n        .hkdfDeriveBits(algorithm\x2C baseKey\x2C length);\n      break;\n    case 'PBKDF2':\n      bits = await lazyRequire('internal/crypto/pbkdf2')\n        .pbkdf2DeriveBits(algorithm\x2C baseKey\x2C length);\n      break;\n    default:\n      throw lazyDOMException('Unrecognized name.');\n  }\n\n  return ReflectApply(\n    importKey\x2C\n    this\x2C\n    ['raw'\x2C bits\x2C derivedKeyAlgorithm\x2C extractable\x2C keyUsages]\x2C\n  );\n}\n\nasync function exportKeySpki(key) {\n  switch (key.algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/rsa')\n          .rsaExportKey(key\x2C kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/ec')\n          .ecExportKey(key\x2C kWebCryptoKeyFormatSPKI);\n      }\n      break;\n    case 'Ed25519':\n      // Fall through\n    case 'Ed448':\n      // Fall through\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/cfrg')\n          .cfrgExportKey(key\x2C kWebCryptoKeyFormatSPKI);\n      }\n      break;\n  }\n\n  throw lazyDOMException(\n    `Unable to export a raw ${key.algorithm.name} ${key.type} key`\x2C\n    'InvalidAccessError');\n}\n\nasync function exportKeyPkcs8(key) {\n  switch (key.algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      if (key.type === 'private') {\n        return lazyRequire('internal/crypto/rsa')\n          .rsaExportKey(key\x2C kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      if (key.type === 'private') {\n        return lazyRequire('internal/crypto/ec')\n          .ecExportKey(key\x2C kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n    case 'Ed25519':\n      // Fall through\n    case 'Ed448':\n      // Fall through\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      if (key.type === 'private') {\n        return lazyRequire('internal/crypto/cfrg')\n          .cfrgExportKey(key\x2C kWebCryptoKeyFormatPKCS8);\n      }\n      break;\n  }\n\n  throw lazyDOMException(\n    `Unable to export a pkcs8 ${key.algorithm.name} ${key.type} key`\x2C\n    'InvalidAccessError');\n}\n\nasync function exportKeyRaw(key) {\n  switch (key.algorithm.name) {\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/ec')\n          .ecExportKey(key\x2C kWebCryptoKeyFormatRaw);\n      }\n      break;\n    case 'Ed25519':\n      // Fall through\n    case 'Ed448':\n      // Fall through\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      if (key.type === 'public') {\n        return lazyRequire('internal/crypto/cfrg')\n          .cfrgExportKey(key\x2C kWebCryptoKeyFormatRaw);\n      }\n      break;\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      // Fall through\n    case 'HMAC':\n      return key[kKeyObject].export().buffer;\n  }\n\n  throw lazyDOMException(\n    `Unable to export a raw ${key.algorithm.name} ${key.type} key`\x2C\n    'InvalidAccessError');\n}\n\nasync function exportKeyJWK(key) {\n  const jwk = key[kKeyObject][kHandle].exportJwk({\n    key_ops: key.usages\x2C\n    ext: key.extractable\x2C\n  }\x2C true);\n  switch (key.algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkRsa);\n      return jwk;\n    case 'RSA-PSS':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkRsaPss);\n      return jwk;\n    case 'RSA-OAEP':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkRsaOaep);\n      return jwk;\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      jwk.crv ||= key.algorithm.namedCurve;\n      return jwk;\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      jwk.crv ||= key.algorithm.name;\n      return jwk;\n    case 'Ed25519':\n      // Fall through\n    case 'Ed448':\n      jwk.crv ||= key.algorithm.name;\n      jwk.alg = 'EdDSA';\n      return jwk;\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      jwk.alg = lazyRequire('internal/crypto/aes')\n        .getAlgorithmName(key.algorithm.name\x2C key.algorithm.length);\n      return jwk;\n    case 'HMAC':\n      jwk.alg = normalizeHashName(\n        key.algorithm.hash.name\x2C\n        normalizeHashName.kContextJwkHmac);\n      return jwk;\n    default:\n      // Fall through\n  }\n\n  throw lazyDOMException('Not yet supported'\x2C 'NotSupportedError');\n}\n\nasync function exportKey(format\x2C key) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  validateString(format\x2C 'format');\n  validateOneOf(format\x2C 'format'\x2C kExportFormats);\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('key'\x2C 'CryptoKey'\x2C key);\n\n  if (!key.extractable)\n    throw lazyDOMException('key is not extractable'\x2C 'InvalidAccessException');\n\n  switch (format) {\n    case 'spki': return exportKeySpki(key);\n    case 'pkcs8': return exportKeyPkcs8(key);\n    case 'jwk': return exportKeyJWK(key);\n    case 'raw': return exportKeyRaw(key);\n  }\n  throw lazyDOMException(\n    'Export format is unsupported'\x2C 'NotSupportedError');\n}\n\nasync function importGenericSecretKey(\n  { name\x2C length }\x2C\n  format\x2C\n  keyData\x2C\n  extractable\x2C\n  keyUsages) {\n  const usagesSet = new SafeSet(keyUsages);\n  if (extractable)\n    throw lazyDOMException(`${name} keys are not extractable`\x2C 'SyntaxError');\n\n  if (hasAnyNotIn(usagesSet\x2C ['deriveKey'\x2C 'deriveBits'])) {\n    throw lazyDOMException(\n      `Unsupported key usage for a ${name} key`\x2C\n      'SyntaxError');\n  }\n\n  switch (format) {\n    case 'raw': {\n      if (hasAnyNotIn(usagesSet\x2C ['deriveKey'\x2C 'deriveBits'])) {\n        throw lazyDOMException(\n          `Unsupported key usage for a ${name} key`\x2C\n          'SyntaxError');\n      }\n\n      const checkLength = keyData.byteLength * 8;\n\n      if (checkLength === 0 || length === 0)\n        throw lazyDOMException('Zero-length key is not supported'\x2C 'DataError');\n\n      // The Web Crypto spec allows for key lengths that are not multiples of\n      // 8. We don't. Our check here is stricter than that defined by the spec\n      // in that we require that algorithm.length match keyData.length * 8 if\n      // algorithm.length is specified.\n      if (length !== undefined && length !== checkLength) {\n        throw lazyDOMException('Invalid key length'\x2C 'DataError');\n      }\n\n      const keyObject = createSecretKey(keyData);\n      return new InternalCryptoKey(keyObject\x2C { name }\x2C keyUsages\x2C false);\n    }\n  }\n\n  throw lazyDOMException(\n    `Unable to import ${name} key with format ${format}`\x2C\n    'NotSupportedError');\n}\n\nasync function importKey(\n  format\x2C\n  keyData\x2C\n  algorithm\x2C\n  extractable\x2C\n  keyUsages) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  validateString(format\x2C 'format');\n  validateOneOf(format\x2C 'format'\x2C kExportFormats);\n  if (format !== 'jwk')\n    keyData = getArrayBufferOrView(keyData\x2C 'keyData');\n  algorithm = normalizeAlgorithm(algorithm);\n  validateBoolean(extractable\x2C 'extractable');\n  validateArray(keyUsages\x2C 'keyUsages');\n  switch (algorithm.name) {\n    case 'RSASSA-PKCS1-v1_5':\n      // Fall through\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSA-OAEP':\n      return lazyRequire('internal/crypto/rsa')\n        .rsaImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'ECDSA':\n      // Fall through\n    case 'ECDH':\n      return lazyRequire('internal/crypto/ec')\n        .ecImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'Ed25519':\n      // Fall through\n    case 'Ed448':\n      // Fall through\n    case 'X25519':\n      // Fall through\n    case 'X448':\n      return lazyRequire('internal/crypto/cfrg')\n        .cfrgImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'HMAC':\n      return lazyRequire('internal/crypto/mac')\n        .hmacImportKey(format\x2C keyData\x2C algorithm\x2C extractable\x2C keyUsages);\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      // Fall through\n    case 'AES-KW':\n      return lazyRequire('internal/crypto/aes')\n        .aesImportKey(algorithm\x2C format\x2C keyData\x2C extractable\x2C keyUsages);\n    case 'HKDF':\n      // Fall through\n    case 'PBKDF2':\n      return importGenericSecretKey(\n        algorithm\x2C\n        format\x2C\n        keyData\x2C\n        extractable\x2C\n        keyUsages);\n  }\n\n  throw lazyDOMException('Unrecognized name.'\x2C 'NotSupportedError');\n}\n\n// subtle.wrapKey() is essentially a subtle.exportKey() followed\n// by a subtle.encrypt().\nasync function wrapKey(format\x2C key\x2C wrappingKey\x2C algorithm) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  algorithm = normalizeAlgorithm(algorithm);\n  let keyData = await ReflectApply(exportKey\x2C this\x2C [format\x2C key]);\n\n  if (format === 'jwk') {\n    if (keyData == null || typeof keyData !== 'object')\n      throw lazyDOMException('Invalid exported JWK key'\x2C 'DataError');\n    const ec = new TextEncoder();\n    const raw = JSONStringify(keyData);\n    keyData = ec.encode(raw + StringPrototypeRepeat(' '\x2C 8 - (raw.length % 8)));\n  }\n\n  return cipherOrWrap(\n    kWebCryptoCipherEncrypt\x2C\n    algorithm\x2C\n    wrappingKey\x2C\n    keyData\x2C\n    'wrapKey');\n}\n\n// subtle.unwrapKey() is essentially a subtle.decrypt() followed\n// by a subtle.importKey().\nasync function unwrapKey(\n  format\x2C\n  wrappedKey\x2C\n  unwrappingKey\x2C\n  unwrapAlgo\x2C\n  unwrappedKeyAlgo\x2C\n  extractable\x2C\n  keyUsages) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  wrappedKey = getArrayBufferOrView(wrappedKey\x2C 'wrappedKey');\n  unwrapAlgo = normalizeAlgorithm(unwrapAlgo);\n  let keyData = await cipherOrWrap(\n    kWebCryptoCipherDecrypt\x2C\n    unwrapAlgo\x2C\n    unwrappingKey\x2C\n    wrappedKey\x2C\n    'unwrapKey');\n\n  if (format === 'jwk') {\n    // The fatal: true option is only supported in builds that have ICU.\n    const options = process.versions.icu !== undefined ?\n      { fatal: true } : undefined;\n    const dec = new TextDecoder('utf-8'\x2C options);\n    try {\n      keyData = JSONParse(dec.decode(keyData));\n    } catch {\n      throw lazyDOMException('Invalid imported JWK key'\x2C 'DataError');\n    }\n  }\n\n  return ReflectApply(\n    importKey\x2C\n    this\x2C\n    [format\x2C keyData\x2C unwrappedKeyAlgo\x2C extractable\x2C keyUsages]\x2C\n  );\n}\n\nfunction signVerify(algorithm\x2C key\x2C data\x2C signature) {\n  algorithm = normalizeAlgorithm(algorithm);\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('key'\x2C 'CryptoKey'\x2C key);\n  data = getArrayBufferOrView(data\x2C 'data');\n  let usage = 'sign';\n  if (signature !== undefined) {\n    signature = getArrayBufferOrView(signature\x2C 'signature');\n    usage = 'verify';\n  }\n\n  if (!ArrayPrototypeIncludes(key.usages\x2C usage) ||\n      algorithm.name !== key.algorithm.name) {\n    throw lazyDOMException(\n      `Unable to use this key to ${usage}`\x2C\n      'InvalidAccessError');\n  }\n\n  switch (algorithm.name) {\n    case 'RSA-PSS':\n      // Fall through\n    case 'RSASSA-PKCS1-v1_5':\n      return lazyRequire('internal/crypto/rsa')\n        .rsaSignVerify(key\x2C data\x2C algorithm\x2C signature);\n    case 'ECDSA':\n      return lazyRequire('internal/crypto/ec')\n        .ecdsaSignVerify(key\x2C data\x2C algorithm\x2C signature);\n    case 'Ed25519':\n      // Fall through\n    case 'Ed448':\n      // Fall through\n      return lazyRequire('internal/crypto/cfrg')\n        .eddsaSignVerify(key\x2C data\x2C algorithm\x2C signature);\n    case 'HMAC':\n      return lazyRequire('internal/crypto/mac')\n        .hmacSignVerify(key\x2C data\x2C algorithm\x2C signature);\n  }\n  throw lazyDOMException('Unrecognized named.'\x2C 'NotSupportedError');\n}\n\nasync function sign(algorithm\x2C key\x2C data) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  return signVerify(algorithm\x2C key\x2C data);\n}\n\nasync function verify(algorithm\x2C key\x2C signature\x2C data) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  return signVerify(algorithm\x2C key\x2C data\x2C signature);\n}\n\nasync function cipherOrWrap(mode\x2C algorithm\x2C key\x2C data\x2C op) {\n  algorithm = normalizeAlgorithm(algorithm);\n  // We use a Node.js style error here instead of a DOMException because\n  // the WebCrypto spec is not specific what kind of error is to be thrown\n  // in this case. Both Firefox and Chrome throw simple TypeErrors here.\n  if (!isCryptoKey(key))\n    throw new ERR_INVALID_ARG_TYPE('key'\x2C 'CryptoKey'\x2C key);\n  // The key algorithm and cipher algorithm must match\x2C and the\n  // key must have the proper usage.\n  if (key.algorithm.name !== algorithm.name ||\n      !ArrayPrototypeIncludes(key.usages\x2C op)) {\n    throw lazyDOMException(\n      'The requested operation is not valid for the provided key'\x2C\n      'InvalidAccessError');\n  }\n\n  // For the Web Crypto API\x2C the input data can be any ArrayBuffer\x2C\n  // TypedArray\x2C or DataView.\n  data = getArrayBufferOrView(data\x2C 'data');\n\n  // While WebCrypto allows for larger input buffer sizes\x2C we limit\n  // those to sizes that can fit within uint32_t because of limitations\n  // in the OpenSSL API.\n  validateMaxBufferLength(data\x2C 'data');\n\n  switch (algorithm.name) {\n    case 'RSA-OAEP':\n      return lazyRequire('internal/crypto/rsa')\n        .rsaCipher(mode\x2C key\x2C data\x2C algorithm);\n    case 'AES-CTR':\n      // Fall through\n    case 'AES-CBC':\n      // Fall through\n    case 'AES-GCM':\n      return lazyRequire('internal/crypto/aes')\n        .aesCipher(mode\x2C key\x2C data\x2C algorithm);\n    case 'AES-KW':\n      if (op === 'wrapKey' || op === 'unwrapKey') {\n        return lazyRequire('internal/crypto/aes')\n          .aesCipher(mode\x2C key\x2C data\x2C algorithm);\n      }\n  }\n  throw lazyDOMException('Unrecognized name.'\x2C 'NotSupportedError');\n}\n\nasync function encrypt(algorithm\x2C key\x2C data) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  return cipherOrWrap(kWebCryptoCipherEncrypt\x2C algorithm\x2C key\x2C data\x2C 'encrypt');\n}\n\nasync function decrypt(algorithm\x2C key\x2C data) {\n  if (this !== subtle) throw new ERR_INVALID_THIS('SubtleCrypto');\n  return cipherOrWrap(kWebCryptoCipherDecrypt\x2C algorithm\x2C key\x2C data\x2C 'decrypt');\n}\n\n// The SubtleCrypto and Crypto classes are defined as part of the\n// Web Crypto API standard: https://www.w3.org/TR/WebCryptoAPI/\n\nclass SubtleCrypto {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n}\nconst subtle = ReflectConstruct(function() {}\x2C []\x2C SubtleCrypto);\n\nclass Crypto {\n  constructor() {\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\n  }\n\n  get subtle() {\n    if (this !== crypto) throw new ERR_INVALID_THIS('Crypto');\n    return subtle;\n  }\n}\nconst crypto = ReflectConstruct(function() {}\x2C []\x2C Crypto);\n\nfunction getRandomValues(array) {\n  if (this !== crypto) throw new ERR_INVALID_THIS('Crypto');\n  return ReflectApply(_getRandomValues\x2C this\x2C arguments);\n}\n\nObjectDefineProperties(\n  Crypto.prototype\x2C {\n    [SymbolToStringTag]: {\n      __proto__: null\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      writable: false\x2C\n      value: 'Crypto'\x2C\n    }\x2C\n    subtle: kEnumerableProperty\x2C\n    getRandomValues: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: getRandomValues\x2C\n    }\x2C\n    randomUUID: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: randomUUID\x2C\n    }\x2C\n    CryptoKey: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: CryptoKey\x2C\n    }\n  });\n\nObjectDefineProperties(\n  SubtleCrypto.prototype\x2C {\n    [SymbolToStringTag]: {\n      __proto__: null\x2C\n      enumerable: false\x2C\n      configurable: true\x2C\n      writable: false\x2C\n      value: 'SubtleCrypto'\x2C\n    }\x2C\n    encrypt: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: encrypt\x2C\n    }\x2C\n    decrypt: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: decrypt\x2C\n    }\x2C\n    sign: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: sign\x2C\n    }\x2C\n    verify: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: verify\x2C\n    }\x2C\n    digest: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: digest\x2C\n    }\x2C\n    generateKey: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: generateKey\x2C\n    }\x2C\n    deriveKey: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: deriveKey\x2C\n    }\x2C\n    deriveBits: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: deriveBits\x2C\n    }\x2C\n    importKey: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: importKey\x2C\n    }\x2C\n    exportKey: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: exportKey\x2C\n    }\x2C\n    wrapKey: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: wrapKey\x2C\n    }\x2C\n    unwrapKey: {\n      __proto__: null\x2C\n      enumerable: true\x2C\n      configurable: true\x2C\n      writable: true\x2C\n      value: unwrapKey\x2C\n    }\n  });\n\nmodule.exports = {\n  Crypto\x2C\n  CryptoKey\x2C\n  SubtleCrypto\x2C\n  crypto\x2C\n};\n
code-source-info,0xb46da646d00,448,0,24596,C0O0C4O24596,,
code-creation,Function,10,266768,0xb46da648290,1142, node:internal/crypto/webcrypto:1:1,0xb46da646c78,~
code-source-info,0xb46da648290,448,0,24596,C0O0C247O25C253O51C259O64C265O81C270O107C276O123C281O143C287O154C292O175C298O363C302O363C308O226C314O252C320O280C326O307C332O334C338O492C342O492C348O401C354O418C360O437C366O455C372O472C378O562C382O562C388O533C394O546C400O697C404O697C410O697C416O616C422O645C428O671C434O806C438O806C444O736C449O749C455O770C461O789C467O867C471O867C477O850C483O1080C487O1080C493O911C499O935C505O950C511O965C517O987C523O1008C529O1035C535O1053C541O1064C547O1169C551O1169C557O1124C562O1147C568O1272C572O1272C578O1223C584O1255C616O21484C629O21484C634O21484C668O21735C681O21735C686O21735C688O21970C702O21988C704O22008C719O22149C728O22191C736O22301C751O22341C759O22451C774O22485C782O22595C793O21937C798O22658C812O22676C814O22696C827O22844C835O22954C850O22983C858O23093C873O23119C881O23229C896O23254C904O23364C919O23391C927O23501C942O23533C950O23643C965O23678C973O23788C988O23822C996O23932C1011O23966C1019O24076C1034O24109C1042O24219C1057O24250C1065O24360C1080O24391C1088O24501C1099O22619C1104O24525C1112O24546C1118O24556C1124O24569C1130O24585C1136O24540C1141O24595,,
tick,0x1025894ea,266863,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46da6462b6,0xb46da645553,0x1031b6710,0x113247bfe,0x113247ea8,0xb46b96afb92,0x1025e38e0,0xb46b96af834,0xb46b96928cf,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x7ff805e2d43e,266876,1,0x10266e4e0,3,0x1027fed10,0x113244e26,0x1132442e1,0xb46da6462b6,0xb46da645553,0x1031b6710,0x113247bfe,0x113247ea8,0xb46b96afb92,0x1025e38e0,0xb46b96af834,0xb46b96928cf,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
tick,0x102daee15,266941,1,0x10266e4e0,6,0x1027fed10,0x113244e26,0x1132442e1,0xb46da6462b6,0xb46da645553,0x1031b6710,0x113247bfe,0x113247ea8,0xb46b96afb92,0x1025e38e0,0xb46b96af834,0xb46b96928cf,0xb46b968764d,0xb4611f21544,0xb4611f1063e,0x10311893f
code-creation,LazyCompile,10,267054,0xb46da64a958,2, node:internal/crypto/webcrypto:755:41,0xb46da647460,~
code-source-info,0xb46da64a958,448,21509,21514,C1O21513,,
code-creation,LazyCompile,10,267087,0xb46da64c688,11,SubtleCrypto node:internal/crypto/webcrypto:751:14,0xb46da647410,~
code-source-info,0xb46da64c688,448,21417,21466,C0O21426C5O21432C10O21426,,
code-creation,LazyCompile,10,267116,0xb46da64c770,2, node:internal/crypto/webcrypto:767:41,0xb46da647570,~
code-source-info,0xb46da64c770,448,21760,21765,C1O21764,,
code-creation,LazyCompile,10,267144,0xb46da64c830,11,Crypto node:internal/crypto/webcrypto:758:14,0xb46da6474b0,~
code-source-info,0xb46da64c830,448,21564,21613,C0O21573C5O21579C10O21573,,
code-creation,LazyCompile,10,267258,0xb46da64c978,17,get node:crypto:377:8,0xb462a843e00,~
code-source-info,0xb46da64c978,89,8388,8432,C0O8393C3O8400C7O8415C12O8422C16O8430,,
code-creation,LazyCompile,10,267290,0xb46da64caa0,30,get subtle node:internal/crypto/webcrypto:762:13,0xb46da647520,~
code-source-info,0xb46da64caa0,448,21627,21717,C0O21636C2O21649C4O21645C9O21657C19O21663C24O21657C25O21699C29O21713,,
code-creation,LazyCompile,10,267320,0xb46da64cb88,3,get node:crypto:385:10,0xb462a843e50,~
code-source-info,0xb46da64cb88,89,8558,8579,C0O8564C2O8579,,
code-creation,LazyCompile,10,267385,0xb46da64cd98,16,get node:events:227:6,0xb469fce27a8,~
code-source-info,0xb46da64cd98,29,6747,6800,C0O6756C3O6776C10O6786C12O6785C15O6796,,
code-creation,LazyCompile,10,267467,0xb46da64d708,181,lazyEventEmitterAsyncResource node:events:95:39,0xb469fce2250,~
code-source-info,0xb46da64d708,29,2886,6158,C0O2893C6O2923C19O2980C27O2980C32O2958C37O3031C47O3031C51O3031C53O3083C63O3083C67O3083C69O3164C96O3113C102O3755C110O3829C166O3781C176O6123C180O6156,,
code-creation,LazyCompile,10,267511,0xb46da64da98,5,get node:events:272:16,0xb469fce28e8,~
code-source-info,0xb46da64da98,29,7902,7942,C0O7911C4O7938,,
code-creation,LazyCompile,10,267678,0xb46da64df78,19,createServer node:http:58:22,0xb4611f21b80,~
code-source-info,0xb46da64df78,438,1965,2036,C0O1993C13O2000C18O2034,,
code-creation,LazyCompile,10,267770,0xb46da64e1e8,230,Server node:_http_server:441:16,0xb4611f3e710,~
code-source-info,0xb46da64e1e8,447,15512,16671,C0O15543C2O15554C7O15574C18O15581C23O15618C24O15622C30O15663C33O15694C38O15717C49O15775C57O15816C73O15822C78O15816C79O15885C82O15902C87O15902C93O15925C98O15929C103O15936C113O15996C121O16030C129O16078C137O15936C143O16107C147O16139C155O16139C161O16399C162O16422C166O16439C177O16439C183O16480C184O16493C188O16500C189O16521C193O16531C194O16557C198O16564C201O16564C205O16598C207O16603C212O16621C215O16654C220O16621C224O16619C229O16670,,
code-creation,LazyCompile,10,267862,0xb46da650770,287,Server node:net:1277:16,0xb469fbf4920,~
code-source-info,0xb46da650770,406,33589,34835,C0O33623C2O33634C7O33658C18O33665C23O33705C24O33709C29O33722C34O33722C39O33737C45O33778C48O33812C51O33835C59O33835C67O33882C78O33940C84O33971C90O34030C98O34030C106O34089C122O34095C127O34089C128O34176C136O34221C141O34251C149O34221C154O34330C160O34352C165O34365C166O34395C170O34413C171O34431C175O34439C177O34444C182O34461C186O34469C187O34482C191O34492C192O34511C196O34522C198O34536C202O34544C203O34556C207O34597C217O34587C221O34655C227O34643C231O34673C233O34688C236O34704C241O34688C245O34686C249O34716C251O34733C254O34749C259O34733C263O34731C267O34803C271O34825C277O34793C279O34792C281O34790C286O34834,,
code-creation,LazyCompile,10,267963,0xb46da650ae8,343,storeHTTPOptions node:_http_server:377:26,0xb4611f3e670,~
code-source-info,0xb46da650ae8,447,13104,15043,C0O13118C2O13123C5O13151C16O13170C18O13141C22O13189C24O13194C27O13221C38O13211C42O13288C47O13305C49O13342C62O13342C67O13396C69O13415C73O13470C78O13492C80O13534C88O13534C93O13603C95O13627C99O13664C105O13691C106O13707C110O13749C115O13767C117O13807C130O13807C135O13865C137O13885C143O13918C149O13938C153O14000C158O14018C160O14058C173O14058C178O14116C180O14136C186O14169C192O14189C196O14229C202O14244C207O14256C213O14271C218O14283C223O14306C227O14298C232O14328C237O14344C253O14334C258O14328C259O14457C264O14477C266O14519C279O14519C284O14581C286O14603C292O14638C296O14660C300O14734C305O14765C307O14818C320O14818C325O14902C327O14935C333O14981C337O15014C342O15042,,
code-creation,LazyCompile,10,268081,0xb46da650e98,69,setupConnectionsTracking node:_http_server:431:34,0xb4611f3e6c0,~
code-source-info,0xb46da650e98,447,15078,15495,C0O15122C2O15129C7O15149C10O15145C15O15143C19O15363C21O15370C26O15406C32O15435C37O15435C43O15456C48O15406C54O15484C59O15485C63O15400C68O15494,,
code-creation,LazyCompile,10,268164,0xb46da651130,220,setInterval node:timers:210:21,0xb46d2cb3930,~
script-source,51,node:timers,// Copyright Joyent\x2C Inc. and other Node contributors.\n//\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software")\x2C to deal in the Software without restriction\x2C including\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\n// persons to whom the Software is furnished to do so\x2C subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nconst {\n  MathTrunc\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  SymbolToPrimitive\n} = primordials;\n\nconst {\n  immediateInfo\x2C\n  toggleImmediateRef\n} = internalBinding('timers');\nconst L = require('internal/linkedlist');\nconst {\n  async_id_symbol\x2C\n  Timeout\x2C\n  Immediate\x2C\n  decRefCount\x2C\n  immediateInfoFields: {\n    kCount\x2C\n    kRefCount\n  }\x2C\n  kRefed\x2C\n  kHasPrimitive\x2C\n  getTimerDuration\x2C\n  timerListMap\x2C\n  timerListQueue\x2C\n  immediateQueue\x2C\n  active\x2C\n  unrefActive\x2C\n  insert\n} = require('internal/timers');\nconst {\n  promisify: { custom: customPromisify }\x2C\n  deprecate\n} = require('internal/util');\nlet debug = require('internal/util/debuglog').debuglog('timer'\x2C (fn) => {\n  debug = fn;\n});\nconst { validateFunction } = require('internal/validators');\n\nlet timersPromises;\n\nconst {\n  destroyHooksExist\x2C\n  // The needed emit*() functions.\n  emitDestroy\n} = require('internal/async_hooks');\n\n// This stores all the known timer async ids to allow users to clearTimeout and\n// clearInterval using those ids\x2C to match the spec and the rest of the web\n// platform.\nconst knownTimersById = ObjectCreate(null);\n\n// Remove a timer. Cancels the timeout and resets the relevant timer properties.\nfunction unenroll(item) {\n  if (item._destroyed)\n    return;\n\n  item._destroyed = true;\n\n  if (item[kHasPrimitive])\n    delete knownTimersById[item[async_id_symbol]];\n\n  // Fewer checks may be possible\x2C but these cover everything.\n  if (destroyHooksExist() && item[async_id_symbol] !== undefined)\n    emitDestroy(item[async_id_symbol]);\n\n  L.remove(item);\n\n  // We only delete refed lists because unrefed ones are incredibly likely\n  // to come from http and be recreated shortly after.\n  // TODO: Long-term this could instead be handled by creating an internal\n  // clearTimeout that makes it clear that the list should not be deleted.\n  // That function could then be used by http and other similar modules.\n  if (item[kRefed]) {\n    // Compliment truncation during insert().\n    const msecs = MathTrunc(item._idleTimeout);\n    const list = timerListMap[msecs];\n    if (list !== undefined && L.isEmpty(list)) {\n      debug('unenroll: list empty');\n      timerListQueue.removeAt(list.priorityQueuePosition);\n      delete timerListMap[list.msecs];\n    }\n\n    decRefCount();\n  }\n\n  // If active is called later\x2C then we want to make sure not to insert again\n  item._idleTimeout = -1;\n}\n\n// Make a regular object able to act as a timer by setting some properties.\n// This function does not start the timer\x2C see `active()`.\n// Using existing objects as timers slightly reduces object overhead.\nfunction enroll(item\x2C msecs) {\n  msecs = getTimerDuration(msecs\x2C 'msecs');\n\n  // If this item was already in a list somewhere\n  // then we should unenroll it from that\n  if (item._idleNext) unenroll(item);\n\n  L.init(item);\n  item._idleTimeout = msecs;\n}\n\n\n/**\n * Schedules the execution of a one-time `callback`\n * after `after` milliseconds.\n * @param {Function} callback\n * @param {number} [after]\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Timeout}\n */\nfunction setTimeout(callback\x2C after\x2C arg1\x2C arg2\x2C arg3) {\n  validateFunction(callback\x2C 'callback');\n\n  let i\x2C args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1\x2C arg2];\n      break;\n    default:\n      args = [arg1\x2C arg2\x2C arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically\x2C makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback\x2C after\x2C args\x2C false\x2C true);\n  insert(timeout\x2C timeout._idleTimeout);\n\n  return timeout;\n}\n\nObjectDefineProperty(setTimeout\x2C customPromisify\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!timersPromises)\n      timersPromises = require('timers/promises');\n    return timersPromises.setTimeout;\n  }\n});\n\n/**\n * Cancels a timeout.\n * @param {Timeout | string | number} timer\n * @returns {void}\n */\nfunction clearTimeout(timer) {\n  if (timer && timer._onTimeout) {\n    timer._onTimeout = null;\n    unenroll(timer);\n    return;\n  }\n  if (typeof timer === 'number' || typeof timer === 'string') {\n    const timerInstance = knownTimersById[timer];\n    if (timerInstance !== undefined) {\n      timerInstance._onTimeout = null;\n      unenroll(timerInstance);\n    }\n  }\n}\n\n/**\n * Schedules repeated execution of `callback`\n * every `repeat` milliseconds.\n * @param {Function} callback\n * @param {number} [repeat]\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Timeout}\n */\nfunction setInterval(callback\x2C repeat\x2C arg1\x2C arg2\x2C arg3) {\n  validateFunction(callback\x2C 'callback');\n\n  let i\x2C args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n    case 2:\n      break;\n    case 3:\n      args = [arg1];\n      break;\n    case 4:\n      args = [arg1\x2C arg2];\n      break;\n    default:\n      args = [arg1\x2C arg2\x2C arg3];\n      for (i = 5; i < arguments.length; i++) {\n        // Extend array dynamically\x2C makes .apply run much faster in v6.0.0\n        args[i - 2] = arguments[i];\n      }\n      break;\n  }\n\n  const timeout = new Timeout(callback\x2C repeat\x2C args\x2C true\x2C true);\n  insert(timeout\x2C timeout._idleTimeout);\n\n  return timeout;\n}\n\n/**\n * Cancels an interval.\n * @param {Timeout | string | number} timer\n * @returns {void}\n */\nfunction clearInterval(timer) {\n  // clearTimeout and clearInterval can be used to clear timers created from\n  // both setTimeout and setInterval\x2C as specified by HTML Living Standard:\n  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval\n  clearTimeout(timer);\n}\n\nTimeout.prototype.close = function() {\n  clearTimeout(this);\n  return this;\n};\n\n/**\n * Coerces a `Timeout` to a primitive.\n * @returns {number}\n */\nTimeout.prototype[SymbolToPrimitive] = function() {\n  const id = this[async_id_symbol];\n  if (!this[kHasPrimitive]) {\n    this[kHasPrimitive] = true;\n    knownTimersById[id] = this;\n  }\n  return id;\n};\n\n/**\n * Schedules the immediate execution of `callback`\n * after I/O events' callbacks.\n * @param {Function} callback\n * @param {any} [arg1]\n * @param {any} [arg2]\n * @param {any} [arg3]\n * @returns {Immediate}\n */\nfunction setImmediate(callback\x2C arg1\x2C arg2\x2C arg3) {\n  validateFunction(callback\x2C 'callback');\n\n  let i\x2C args;\n  switch (arguments.length) {\n    // fast cases\n    case 1:\n      break;\n    case 2:\n      args = [arg1];\n      break;\n    case 3:\n      args = [arg1\x2C arg2];\n      break;\n    default:\n      args = [arg1\x2C arg2\x2C arg3];\n      for (i = 4; i < arguments.length; i++) {\n        // Extend array dynamically\x2C makes .apply run much faster in v6.0.0\n        args[i - 1] = arguments[i];\n      }\n      break;\n  }\n\n  return new Immediate(callback\x2C args);\n}\n\nObjectDefineProperty(setImmediate\x2C customPromisify\x2C {\n  __proto__: null\x2C\n  enumerable: true\x2C\n  get() {\n    if (!timersPromises)\n      timersPromises = require('timers/promises');\n    return timersPromises.setImmediate;\n  }\n});\n\n/**\n * Cancels an immediate.\n * @param {Immediate} immediate\n * @returns {void}\n */\nfunction clearImmediate(immediate) {\n  if (!immediate || immediate._destroyed)\n    return;\n\n  immediateInfo[kCount]--;\n  immediate._destroyed = true;\n\n  if (immediate[kRefed] && --immediateInfo[kRefCount] === 0)\n    toggleImmediateRef(false);\n  immediate[kRefed] = null;\n\n  if (destroyHooksExist() && immediate[async_id_symbol] !== undefined) {\n    emitDestroy(immediate[async_id_symbol]);\n  }\n\n  immediate._onImmediate = null;\n\n  immediateQueue.remove(immediate);\n}\n\nmodule.exports = {\n  setTimeout\x2C\n  clearTimeout\x2C\n  setImmediate\x2C\n  clearImmediate\x2C\n  setInterval\x2C\n  clearInterval\x2C\n  _unrefActive: deprecate(\n    unrefActive\x2C\n    'timers._unrefActive() is deprecated.' +\n    ' Please use timeout.refresh() instead.'\x2C\n    'DEP0127')\x2C\n  active: deprecate(\n    active\x2C\n    'timers.active() is deprecated. Please use timeout.refresh() instead.'\x2C\n    'DEP0126')\x2C\n  unenroll: deprecate(\n    unenroll\x2C\n    'timers.unenroll() is deprecated. Please use clearTimeout instead.'\x2C\n    'DEP0096')\x2C\n  enroll: deprecate(\n    enroll\x2C\n    'timers.enroll() is deprecated. Please use setTimeout instead.'\x2C\n    'DEP0095')\n};\n
code-source-info,0xb46da651130,51,5817,6456,C0O5817C2O5858C10O5858C15O5905C17O5908C19O5934C54O5992C56O6017C65O6025C74O6038C76O6063C85O6071C94O6077C103O6090C105O6116C114O6124C123O6130C132O6136C139O6154C142O6175C146O6163C151O6274C153O6281C159O6297C162O6286C166O6184C171O6149C174O6316C176O6346C196O6346C202O6397C207O6421C212O6397C217O6439C219O6454,,
tick,0x7ff805f107bf,269275,0,0x0,3,0x102d5e910,0xb46da650ec8,0xb46da64e2b1,0xb46da64df85,0xb4611f1b8b0,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
code-creation,LazyCompile,10,269344,0xb46da6520d0,180,Timeout node:internal/timers:164:14,0xb466516b088,~
script-source,18,node:internal/timers,'use strict';\n\n// HOW and WHY the timers implementation works the way it does.\n//\n// Timers are crucial to Node.js. Internally\x2C any TCP I/O connection creates a\n// timer so that we can time out of connections. Additionally\x2C many user\n// libraries and applications also use timers. As such there may be a\n// significantly large amount of timeouts scheduled at any given time.\n// Therefore\x2C it is very important that the timers implementation is performant\n// and efficient.\n//\n// Note: It is suggested you first read through the lib/internal/linkedlist.js\n// linked list implementation\x2C since timers depend on it extensively. It can be\n// somewhat counter-intuitive at first\x2C as it is not actually a class. Instead\x2C\n// it is a set of helpers that operate on an existing object.\n//\n// In order to be as performant as possible\x2C the architecture and data\n// structures are designed so that they are optimized to handle the following\n// use cases as efficiently as possible:\n\n// - Adding a new timer. (insert)\n// - Removing an existing timer. (remove)\n// - Handling a timer timing out. (timeout)\n//\n// Whenever possible\x2C the implementation tries to make the complexity of these\n// operations as close to constant-time as possible.\n// (So that performance is not impacted by the number of scheduled timers.)\n//\n// Object maps are kept which contain linked lists keyed by their duration in\n// milliseconds.\n//\n/* eslint-disable node-core/non-ascii-character */\n//\n// \u2554\u2550\u2550\u2550\u2550 > Object Map\n// \u2551\n// \u2560\u2550\u2550\n// \u2551 lists: { '40': { }\x2C '320': { etc } } (keys of millisecond duration)\n// \u255a\u2550\u2550          \u250c\u2500\u2500\u2500\u2500\u2518\n//              \u2502\n// \u2554\u2550\u2550          \u2502\n// \u2551 TimersList { _idleNext: { }\x2C _idlePrev: (self) }\n// \u2551         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n// \u2551    \u2554\u2550\u2550  \u2502                              ^\n// \u2551    \u2551    { _idleNext: { }\x2C  _idlePrev: { }\x2C _onTimeout: (callback) }\n// \u2551    \u2551      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n// \u2551    \u2551      \u2502                                  ^\n// \u2551    \u2551      { _idleNext: { etc }\x2C  _idlePrev: { }\x2C _onTimeout: (callback) }\n// \u2560\u2550\u2550  \u2560\u2550\u2550\n// \u2551    \u2551\n// \u2551    \u255a\u2550\u2550\u2550\u2550 >  Actual JavaScript timeouts\n// \u2551\n// \u255a\u2550\u2550\u2550\u2550 > Linked List\n//\n/* eslint-enable node-core/non-ascii-character */\n//\n// With this\x2C virtually constant-time insertion (append)\x2C removal\x2C and timeout\n// is possible in the JavaScript layer. Any one list of timers is able to be\n// sorted by just appending to it because all timers within share the same\n// duration. Therefore\x2C any timer added later will always have been scheduled to\n// timeout later\x2C thus only needing to be appended.\n// Removal from an object-property linked list is also virtually constant-time\n// as can be seen in the lib/internal/linkedlist.js implementation.\n// Timeouts only need to process any timers currently due to expire\x2C which will\n// always be at the beginning of the list for reasons stated above. Any timers\n// after the first one encountered that does not yet need to timeout will also\n// always be due to timeout at a later time.\n//\n// Less-than constant time operations are thus contained in two places:\n// The PriorityQueue \u2014 an efficient binary heap implementation that does all\n// operations in worst-case O(log n) time \u2014 which manages the order of expiring\n// Timeout lists and the object map lookup of a specific list by the duration of\n// timers within (or creation of a new list). However\x2C these operations combined\n// have shown to be trivial in comparison to other timers architectures.\n\nconst {\n  MathMax\x2C\n  MathTrunc\x2C\n  NumberIsFinite\x2C\n  NumberMIN_SAFE_INTEGER\x2C\n  ObjectCreate\x2C\n  ReflectApply\x2C\n  Symbol\x2C\n} = primordials;\n\nconst {\n  scheduleTimer\x2C\n  toggleTimerRef\x2C\n  getLibuvNow\x2C\n  immediateInfo\x2C\n  toggleImmediateRef\n} = internalBinding('timers');\n\nconst {\n  getDefaultTriggerAsyncId\x2C\n  newAsyncId\x2C\n  initHooksExist\x2C\n  destroyHooksExist\x2C\n  // The needed emit*() functions.\n  emitInit\x2C\n  emitBefore\x2C\n  emitAfter\x2C\n  emitDestroy\x2C\n} = require('internal/async_hooks');\n\n// Symbols for storing async id state.\nconst async_id_symbol = Symbol('asyncId');\nconst trigger_async_id_symbol = Symbol('triggerId');\n\nconst kHasPrimitive = Symbol('kHasPrimitive');\n\nconst {\n  ERR_OUT_OF_RANGE\n} = require('internal/errors').codes;\nconst {\n  validateFunction\x2C\n  validateNumber\x2C\n} = require('internal/validators');\n\nconst L = require('internal/linkedlist');\nconst PriorityQueue = require('internal/priority_queue');\n\nconst { inspect } = require('internal/util/inspect');\nlet debug = require('internal/util/debuglog').debuglog('timer'\x2C (fn) => {\n  debug = fn;\n});\n\n// *Must* match Environment::ImmediateInfo::Fields in src/env.h.\nconst kCount = 0;\nconst kRefCount = 1;\nconst kHasOutstanding = 2;\n\n// Timeout values > TIMEOUT_MAX are set to 1.\nconst TIMEOUT_MAX = 2 ** 31 - 1;\n\nlet timerListId = NumberMIN_SAFE_INTEGER;\n\nconst kRefed = Symbol('refed');\n\nlet nextExpiry = Infinity;\nlet refCount = 0;\n\n// This is a priority queue with a custom sorting function that first compares\n// the expiry times of two lists and if they're the same then compares their\n// individual IDs to determine which list was created first.\nconst timerListQueue = new PriorityQueue(compareTimersLists\x2C setPosition);\n\n// Object map containing linked lists of timers\x2C keyed and sorted by their\n// duration in milliseconds.\n//\n// - key = time in milliseconds\n// - value = linked list\nconst timerListMap = ObjectCreate(null);\n\nfunction initAsyncResource(resource\x2C type) {\n  const asyncId = resource[async_id_symbol] = newAsyncId();\n  const triggerAsyncId =\n    resource[trigger_async_id_symbol] = getDefaultTriggerAsyncId();\n  if (initHooksExist())\n    emitInit(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\nclass Timeout {\n  // Timer constructor function.\n  // The entire prototype is defined in lib/timers.js\n  constructor(callback\x2C after\x2C args\x2C isRepeat\x2C isRefed) {\n    after *= 1; // Coalesce to number or NaN\n    if (!(after >= 1 && after <= TIMEOUT_MAX)) {\n      if (after > TIMEOUT_MAX) {\n        process.emitWarning(`${after} does not fit into` +\n                            ' a 32-bit signed integer.' +\n                            '\\nTimeout duration was set to 1.'\x2C\n                            'TimeoutOverflowWarning');\n      }\n      after = 1; // Schedule on next tick\x2C follows browser behavior\n    }\n\n    this._idleTimeout = after;\n    this._idlePrev = this;\n    this._idleNext = this;\n    this._idleStart = null;\n    // This must be set to null first to avoid function tracking\n    // on the hidden class\x2C revisit in V8 versions after 6.2\n    this._onTimeout = null;\n    this._onTimeout = callback;\n    this._timerArgs = args;\n    this._repeat = isRepeat ? after : null;\n    this._destroyed = false;\n\n    if (isRefed)\n      incRefCount();\n    this[kRefed] = isRefed;\n    this[kHasPrimitive] = false;\n\n    initAsyncResource(this\x2C 'Timeout');\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_\x2C options) {\n    return inspect(this\x2C {\n      ...options\x2C\n      // Only inspect one level.\n      depth: 0\x2C\n      // It should not recurse.\n      customInspect: false\n    });\n  }\n\n  refresh() {\n    if (this[kRefed])\n      active(this);\n    else\n      unrefActive(this);\n\n    return this;\n  }\n\n  unref() {\n    if (this[kRefed]) {\n      this[kRefed] = false;\n      if (!this._destroyed)\n        decRefCount();\n    }\n    return this;\n  }\n\n  ref() {\n    if (!this[kRefed]) {\n      this[kRefed] = true;\n      if (!this._destroyed)\n        incRefCount();\n    }\n    return this;\n  }\n\n  hasRef() {\n    return this[kRefed];\n  }\n}\n\nclass TimersList {\n  constructor(expiry\x2C msecs) {\n    this._idleNext = this; // Create the list with the linkedlist properties to\n    this._idlePrev = this; // Prevent any unnecessary hidden class changes.\n    this.expiry = expiry;\n    this.id = timerListId++;\n    this.msecs = msecs;\n    this.priorityQueuePosition = null;\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [inspect.custom](_\x2C options) {\n    return inspect(this\x2C {\n      ...options\x2C\n      // Only inspect one level.\n      depth: 0\x2C\n      // It should not recurse.\n      customInspect: false\n    });\n  }\n}\n\n// A linked list for storing `setImmediate()` requests\nclass ImmediateList {\n  constructor() {\n    this.head = null;\n    this.tail = null;\n  }\n\n  // Appends an item to the end of the linked list\x2C adjusting the current tail's\n  // next pointer and the item's previous pointer where applicable\n  append(item) {\n    if (this.tail !== null) {\n      this.tail._idleNext = item;\n      item._idlePrev = this.tail;\n    } else {\n      this.head = item;\n    }\n    this.tail = item;\n  }\n\n  // Removes an item from the linked list\x2C adjusting the pointers of adjacent\n  // items and the linked list's head or tail pointers as necessary\n  remove(item) {\n    if (item._idleNext) {\n      item._idleNext._idlePrev = item._idlePrev;\n    }\n\n    if (item._idlePrev) {\n      item._idlePrev._idleNext = item._idleNext;\n    }\n\n    if (item === this.head)\n      this.head = item._idleNext;\n    if (item === this.tail)\n      this.tail = item._idlePrev;\n\n    item._idleNext = null;\n    item._idlePrev = null;\n  }\n}\n\n// Create a single linked list instance only once at startup\nconst immediateQueue = new ImmediateList();\n\nfunction incRefCount() {\n  if (refCount++ === 0)\n    toggleTimerRef(true);\n}\n\nfunction decRefCount() {\n  if (--refCount === 0)\n    toggleTimerRef(false);\n}\n\n// Schedule or re-schedule a timer.\n// The item must have been enroll()'d first.\nfunction active(item) {\n  insertGuarded(item\x2C true);\n}\n\n// Internal APIs that need timeouts should use `unrefActive()` instead of\n// `active()` so that they do not unnecessarily keep the process open.\nfunction unrefActive(item) {\n  insertGuarded(item\x2C false);\n}\n\n// The underlying logic for scheduling or re-scheduling a timer.\n//\n// Appends a timer onto the end of an existing timers list\x2C or creates a new\n// list if one does not already exist for the specified timeout duration.\nfunction insertGuarded(item\x2C refed\x2C start) {\n  const msecs = item._idleTimeout;\n  if (msecs < 0 || msecs === undefined)\n    return;\n\n  insert(item\x2C msecs\x2C start);\n\n  const isDestroyed = item._destroyed;\n  if (isDestroyed || !item[async_id_symbol]) {\n    item._destroyed = false;\n    initAsyncResource(item\x2C 'Timeout');\n  }\n\n  if (isDestroyed) {\n    if (refed)\n      incRefCount();\n  } else if (refed === !item[kRefed]) {\n    if (refed)\n      incRefCount();\n    else\n      decRefCount();\n  }\n  item[kRefed] = refed;\n}\n\nfunction insert(item\x2C msecs\x2C start = getLibuvNow()) {\n  // Truncate so that accuracy of sub-millisecond timers is not assumed.\n  msecs = MathTrunc(msecs);\n  item._idleStart = start;\n\n  // Use an existing list if there is one\x2C otherwise we need to make a new one.\n  let list = timerListMap[msecs];\n  if (list === undefined) {\n    debug('no %d list was found in insert\x2C creating a new one'\x2C msecs);\n    const expiry = start + msecs;\n    timerListMap[msecs] = list = new TimersList(expiry\x2C msecs);\n    timerListQueue.insert(list);\n\n    if (nextExpiry > expiry) {\n      scheduleTimer(msecs);\n      nextExpiry = expiry;\n    }\n  }\n\n  L.append(list\x2C item);\n}\n\nfunction setUnrefTimeout(callback\x2C after) {\n  // Type checking identical to setTimeout()\n  validateFunction(callback\x2C 'callback');\n\n  const timer = new Timeout(callback\x2C after\x2C undefined\x2C false\x2C false);\n  insert(timer\x2C timer._idleTimeout);\n\n  return timer;\n}\n\n// Type checking used by timers.enroll() and Socket#setTimeout()\nfunction getTimerDuration(msecs\x2C name) {\n  validateNumber(msecs\x2C name);\n  if (msecs < 0 || !NumberIsFinite(msecs)) {\n    throw new ERR_OUT_OF_RANGE(name\x2C 'a non-negative finite number'\x2C msecs);\n  }\n\n  // Ensure that msecs fits into signed int32\n  if (msecs > TIMEOUT_MAX) {\n    process.emitWarning(`${msecs} does not fit into a 32-bit signed integer.` +\n                        `\\nTimer duration was truncated to ${TIMEOUT_MAX}.`\x2C\n                        'TimeoutOverflowWarning');\n    return TIMEOUT_MAX;\n  }\n\n  return msecs;\n}\n\nfunction compareTimersLists(a\x2C b) {\n  const expiryDiff = a.expiry - b.expiry;\n  if (expiryDiff === 0) {\n    if (a.id < b.id)\n      return -1;\n    if (a.id > b.id)\n      return 1;\n  }\n  return expiryDiff;\n}\n\nfunction setPosition(node\x2C pos) {\n  node.priorityQueuePosition = pos;\n}\n\nfunction getTimerCallbacks(runNextTicks) {\n  // If an uncaught exception was thrown during execution of immediateQueue\x2C\n  // this queue will store all remaining Immediates that need to run upon\n  // resolution of all error handling (if process is still alive).\n  const outstandingQueue = new ImmediateList();\n\n  function processImmediate() {\n    const queue = outstandingQueue.head !== null ?\n      outstandingQueue : immediateQueue;\n    let immediate = queue.head;\n\n    // Clear the linked list early in case new `setImmediate()`\n    // calls occur while immediate callbacks are executed\n    if (queue !== outstandingQueue) {\n      queue.head = queue.tail = null;\n      immediateInfo[kHasOutstanding] = 1;\n    }\n\n    let prevImmediate;\n    let ranAtLeastOneImmediate = false;\n    while (immediate !== null) {\n      if (ranAtLeastOneImmediate)\n        runNextTicks();\n      else\n        ranAtLeastOneImmediate = true;\n\n      // It's possible for this current Immediate to be cleared while executing\n      // the next tick queue above\x2C which means we need to use the previous\n      // Immediate's _idleNext which is guaranteed to not have been cleared.\n      if (immediate._destroyed) {\n        outstandingQueue.head = immediate = prevImmediate._idleNext;\n        continue;\n      }\n\n      // TODO(RaisinTen): Destroy and unref the Immediate after _onImmediate()\n      // gets executed\x2C just like how Timeouts work.\n      immediate._destroyed = true;\n\n      immediateInfo[kCount]--;\n      if (immediate[kRefed])\n        immediateInfo[kRefCount]--;\n      immediate[kRefed] = null;\n\n      prevImmediate = immediate;\n\n      const asyncId = immediate[async_id_symbol];\n      emitBefore(asyncId\x2C immediate[trigger_async_id_symbol]\x2C immediate);\n\n      try {\n        const argv = immediate._argv;\n        if (!argv)\n          immediate._onImmediate();\n        else\n          immediate._onImmediate(...argv);\n      } finally {\n        immediate._onImmediate = null;\n\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n\n        outstandingQueue.head = immediate = immediate._idleNext;\n      }\n\n      emitAfter(asyncId);\n    }\n\n    if (queue === outstandingQueue)\n      outstandingQueue.head = null;\n    immediateInfo[kHasOutstanding] = 0;\n  }\n\n\n  function processTimers(now) {\n    debug('process timer lists %d'\x2C now);\n    nextExpiry = Infinity;\n\n    let list;\n    let ranAtLeastOneList = false;\n    while ((list = timerListQueue.peek()) != null) {\n      if (list.expiry > now) {\n        nextExpiry = list.expiry;\n        return refCount > 0 ? nextExpiry : -nextExpiry;\n      }\n      if (ranAtLeastOneList)\n        runNextTicks();\n      else\n        ranAtLeastOneList = true;\n      listOnTimeout(list\x2C now);\n    }\n    return 0;\n  }\n\n  function listOnTimeout(list\x2C now) {\n    const msecs = list.msecs;\n\n    debug('timeout callback %d'\x2C msecs);\n\n    let ranAtLeastOneTimer = false;\n    let timer;\n    while ((timer = L.peek(list)) != null) {\n      const diff = now - timer._idleStart;\n\n      // Check if this loop iteration is too early for the next timer.\n      // This happens if there are more timers scheduled for later in the list.\n      if (diff < msecs) {\n        list.expiry = MathMax(timer._idleStart + msecs\x2C now + 1);\n        list.id = timerListId++;\n        timerListQueue.percolateDown(1);\n        debug('%d list wait because diff is %d'\x2C msecs\x2C diff);\n        return;\n      }\n\n      if (ranAtLeastOneTimer)\n        runNextTicks();\n      else\n        ranAtLeastOneTimer = true;\n\n      // The actual logic for when a timeout happens.\n      L.remove(timer);\n\n      const asyncId = timer[async_id_symbol];\n\n      if (!timer._onTimeout) {\n        if (!timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            refCount--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n        continue;\n      }\n\n      emitBefore(asyncId\x2C timer[trigger_async_id_symbol]\x2C timer);\n\n      let start;\n      if (timer._repeat)\n        start = getLibuvNow();\n\n      try {\n        const args = timer._timerArgs;\n        if (args === undefined)\n          timer._onTimeout();\n        else\n          ReflectApply(timer._onTimeout\x2C timer\x2C args);\n      } finally {\n        if (timer._repeat && timer._idleTimeout !== -1) {\n          timer._idleTimeout = timer._repeat;\n          insert(timer\x2C timer._idleTimeout\x2C start);\n        } else if (!timer._idleNext && !timer._idlePrev && !timer._destroyed) {\n          timer._destroyed = true;\n\n          if (timer[kRefed])\n            refCount--;\n\n          if (destroyHooksExist())\n            emitDestroy(asyncId);\n        }\n      }\n\n      emitAfter(asyncId);\n    }\n\n    // If `L.peek(list)` returned nothing\x2C the list was either empty or we have\n    // called all of the timer timeouts.\n    // As such\x2C we can remove the list from the object map and\n    // the PriorityQueue.\n    debug('%d list empty'\x2C msecs);\n\n    // The current list may have been removed and recreated since the reference\n    // to `list` was created. Make sure they're the same instance of the list\n    // before destroying.\n    if (list === timerListMap[msecs]) {\n      delete timerListMap[msecs];\n      timerListQueue.shift();\n    }\n  }\n\n  return {\n    processImmediate\x2C\n    processTimers\n  };\n}\n\nclass Immediate {\n  constructor(callback\x2C args) {\n    this._idleNext = null;\n    this._idlePrev = null;\n    this._onImmediate = callback;\n    this._argv = args;\n    this._destroyed = false;\n    this[kRefed] = false;\n\n    initAsyncResource(this\x2C 'Immediate');\n\n    this.ref();\n    immediateInfo[kCount]++;\n\n    immediateQueue.append(this);\n  }\n\n  ref() {\n    if (this[kRefed] === false) {\n      this[kRefed] = true;\n      if (immediateInfo[kRefCount]++ === 0)\n        toggleImmediateRef(true);\n    }\n    return this;\n  }\n\n  unref() {\n    if (this[kRefed] === true) {\n      this[kRefed] = false;\n      if (--immediateInfo[kRefCount] === 0)\n        toggleImmediateRef(false);\n    }\n    return this;\n  }\n\n  hasRef() {\n    return !!this[kRefed];\n  }\n}\n\nfunction getTimerCounts() {\n  return {\n    timeoutCount: refCount\x2C\n    immediateCount: immediateInfo[kRefCount]\x2C\n  };\n}\n\nmodule.exports = {\n  TIMEOUT_MAX\x2C\n  kTimeout: Symbol('timeout')\x2C // For hiding Timeouts on other internals.\n  async_id_symbol\x2C\n  trigger_async_id_symbol\x2C\n  Timeout\x2C\n  Immediate\x2C\n  kRefed\x2C\n  kHasPrimitive\x2C\n  initAsyncResource\x2C\n  setUnrefTimeout\x2C\n  getTimerDuration\x2C\n  immediateQueue\x2C\n  getTimerCallbacks\x2C\n  immediateInfoFields: {\n    kCount\x2C\n    kRefCount\x2C\n    kHasOutstanding\n  }\x2C\n  active\x2C\n  unrefActive\x2C\n  insert\x2C\n  timerListMap\x2C\n  timerListQueue\x2C\n  decRefCount\x2C\n  incRefCount\x2C\n  getTimerCounts\x2C\n};\n
code-source-info,0xb46da6520d0,18,5688,6723,C0O5737C7O5782C9O5794C16O5811C18O5808C23O5833C25O5845C27O5843C32O5868C35O5876C42O5891C52O5917C58O5975C65O5876C71O6110C75O6183C77O6201C81O6214C83O6229C87O6241C89O6256C93O6268C94O6284C98O6422C99O6438C103O6450C105O6466C109O6482C111O6498C115O6510C120O6525C127O6523C131O6554C132O6570C136O6584C140O6603C143O6603C146O6622C148O6627C153O6635C157O6650C159O6655C163O6670C167O6684C173O6684C179O6722,,
tick,0x7ff805e2d43e,271509,0,0x0,3,0x102d6ee20,0xb46da6511f4,0xb46da650ec8,0xb46da64e2b1,0xb46da64df85,0xb4611f1b8b0,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
tick,0x7ff805e2d43e,271520,0,0x0,3,0x102d6ee20,0xb46da6511f4,0xb46da650ec8,0xb46da64e2b1,0xb46da64df85,0xb4611f1b8b0,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
code-creation,LazyCompile,10,271536,0xb46da653878,37,incRefCount node:internal/timers:304:21,0xb466516b448,~
code-source-info,0xb46da653878,18,9166,9222,C0O9173C12O9185C19O9188C24O9199C31O9199C36O9221,,
code-creation,LazyCompile,10,271581,0xb46da6539a0,76,initAsyncResource node:internal/timers:154:27,0xb466516b038,~
code-source-info,0xb46da6539a0,18,5319,5571,C0O5356C2O5365C7O5384C10O5384C14O5382C21O5427C23O5436C28O5463C31O5463C35O5461C42O5493C47O5497C52O5519C69O5519C75O5570,,
code-creation,LazyCompile,10,271643,0xb46da653ae8,23,newAsyncId node:internal/async_hooks:416:20,0xb46651717f0,~
script-source,19,node:internal/async_hooks,'use strict';\n\nconst {\n  ArrayPrototypeSlice\x2C\n  ErrorCaptureStackTrace\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectDefineProperty\x2C\n  Symbol\x2C\n} = primordials;\n\nconst promiseHooks = require('internal/promise_hooks');\n\nconst async_wrap = internalBinding('async_wrap');\nconst { setCallbackTrampoline } = async_wrap;\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\n * hooks for each type.\n *\n * async_id_fields is a Float64Array wrapping the double array of\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\n * the various asynchronous states of the application. These are:\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\n *    current execution stack.\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\n *    the resource corresponding to the current execution stack.\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\n *    of retrieving the triggerAsyncId value is:\n *    1. the value passed directly to the constructor\n *    2. value set in kDefaultTriggerAsyncId\n *    3. executionAsyncId of the current resource.\n *\n * async_ids_stack is a Float64Array that contains part of the async ID\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\n * popAsyncContext() call removes two doubles from it.\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\n * side are used instead in pushAsyncContext() and popAsyncContext().\n */\nconst {\n  async_hook_fields\x2C\n  async_id_fields\x2C\n  execution_async_resources\n} = async_wrap;\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\n// responsible for the current execution stack. This is unwound as each resource\n// exits. In the case of a fatal exception this stack is emptied after calling\n// each hook's after() callback.\nconst {\n  pushAsyncContext: pushAsyncContext_\x2C\n  popAsyncContext: popAsyncContext_\x2C\n  executionAsyncResource: executionAsyncResource_\x2C\n  clearAsyncIdStack\x2C\n} = async_wrap;\n// Properties in active_hooks are used to keep track of the set of hooks being\n// executed in case another hook is enabled/disabled. The new set of hooks is\n// then restored once the active set of hooks is finished executing.\nconst active_hooks = {\n  // Array of all AsyncHooks that will be iterated whenever an async event\n  // fires. Using var instead of (preferably const) in order to assign\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\n  // execution.\n  array: []\x2C\n  // Use a counter to track nested calls of async hook callbacks and make sure\n  // the active_hooks.array isn't altered mid execution.\n  call_depth: 0\x2C\n  // Use to temporarily store and updated active_hooks.array if the user\n  // enables or disables a hook while hooks are being processed. If a hook is\n  // enabled() or disabled() during hook execution then the current set of\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\n  // subsequent changes are on the duplicated array. When all hooks have\n  // completed executing active_hooks.tmp_array is assigned to\n  // active_hooks.array.\n  tmp_array: null\x2C\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\n  // is written back to async_hook_fields when active_hooks.array is restored.\n  tmp_fields: null\n};\n\nconst { registerDestroyHook } = async_wrap;\nconst { enqueueMicrotask } = internalBinding('task_queue');\nconst { resource_symbol\x2C owner_symbol } = internalBinding('symbols');\n\n// Each constant tracks how many callbacks there are for any given step of\n// async execution. These are tracked so if the user didn't include callbacks\n// for a given step\x2C that step can bail out early.\nconst {\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\n} = async_wrap.constants;\n\nconst { async_id_symbol\x2C\n        trigger_async_id_symbol } = internalBinding('symbols');\n\n// Lazy load of internal/util/inspect;\nlet inspect;\n\n// Used in AsyncHook and AsyncResource.\nconst init_symbol = Symbol('init');\nconst before_symbol = Symbol('before');\nconst after_symbol = Symbol('after');\nconst destroy_symbol = Symbol('destroy');\nconst promise_resolve_symbol = Symbol('promiseResolve');\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\nconst emitPromiseResolveNative =\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\n\nlet domain_cb;\nfunction useDomainTrampoline(fn) {\n  domain_cb = fn;\n}\n\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\n  const index = async_hook_fields[kStackLength] - 1;\n  execution_async_resources[index] = resource;\n\n  if (asyncId !== 0 && hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n\n  let result;\n  if (asyncId === 0 && typeof domain_cb === 'function') {\n    args.unshift(cb);\n    result = domain_cb.apply(this\x2C args);\n  } else {\n    result = cb.apply(this\x2C args);\n  }\n\n  if (asyncId !== 0 && hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  execution_async_resources.pop();\n  return result;\n}\n\nconst topLevelResource = {};\n\nfunction executionAsyncResource() {\n  // Indicate to the native layer that this function is likely to be used\x2C\n  // in which case it will inform JS about the current async resource via\n  // the trampoline above.\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\n\n  const index = async_hook_fields[kStackLength] - 1;\n  if (index === -1) return topLevelResource;\n  const resource = execution_async_resources[index] ||\n    executionAsyncResource_(index);\n  return lookupPublicResource(resource);\n}\n\nfunction inspectExceptionValue(e) {\n  inspect ??= require('internal/util/inspect').inspect;\n  return { message: inspect(e) };\n}\n\n// Used to fatally abort the process if a callback throws.\nfunction fatalError(e) {\n  if (typeof e?.stack === 'string') {\n    process._rawDebug(e.stack);\n  } else {\n    const o = inspectExceptionValue(e);\n    ErrorCaptureStackTrace(o\x2C fatalError);\n    process._rawDebug(o.stack);\n  }\n\n  const { getOptionValue } = require('internal/options');\n  if (getOptionValue('--abort-on-uncaught-exception')) {\n    process.abort();\n  }\n  process.exit(1);\n}\n\nfunction lookupPublicResource(resource) {\n  if (typeof resource !== 'object' || resource === null) return resource;\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\n  // AsyncWrap instances.\n  const publicResource = resource[resource_symbol];\n  if (publicResource !== undefined)\n    return publicResource;\n  return resource;\n}\n\n// Emit From Native //\n\n// Used by C++ to call all init() callbacks. Because some state can be setup\n// from C++ there's no need to perform all the same operations as in\n// emitInitScript.\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  active_hooks.call_depth += 1;\n  resource = lookupPublicResource(resource);\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\n        active_hooks.array[i][init_symbol](\n          asyncId\x2C type\x2C triggerAsyncId\x2C\n          resource\n        );\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\n  // will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\n// Called from native. The asyncId stack handling is taken care of there\n// before this is called.\nfunction emitHook(symbol\x2C asyncId) {\n  active_hooks.call_depth += 1;\n  // Use a single try/catch for all hook to avoid setting up one per\n  // iteration.\n  try {\n    // Using var here instead of let because "for (var ...)" is faster than let.\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\n    // eslint-disable-next-line no-var\n    for (var i = 0; i < active_hooks.array.length; i++) {\n      if (typeof active_hooks.array[i][symbol] === 'function') {\n        active_hooks.array[i][symbol](asyncId);\n      }\n    }\n  } catch (e) {\n    fatalError(e);\n  } finally {\n    active_hooks.call_depth -= 1;\n  }\n\n  // Hooks can only be restored if there have been no recursive hook calls.\n  // Also the active hooks do not need to be restored if enable()/disable()\n  // weren't called during hook execution\x2C in which case\n  // active_hooks.tmp_array will be null.\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\n    restoreActiveHooks();\n  }\n}\n\nfunction emitHookFactory(symbol\x2C name) {\n  const fn = emitHook.bind(undefined\x2C symbol);\n\n  // Set the name property of the function as it looks good in the stack trace.\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\n    __proto__: null\x2C\n    value: name\n  });\n  return fn;\n}\n\n// Manage Active Hooks //\n\nfunction getHookArrays() {\n  if (active_hooks.call_depth === 0)\n    return [active_hooks.array\x2C async_hook_fields];\n  // If this hook is being enabled while in the middle of processing the array\n  // of currently active hooks then duplicate the current set of active hooks\n  // and store this there. This shouldn't fire until the next time hooks are\n  // processed.\n  if (active_hooks.tmp_array === null)\n    storeActiveHooks();\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\n}\n\n\nfunction storeActiveHooks() {\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\n  // 4. So do this the long way.\n  active_hooks.tmp_fields = [];\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\n}\n\nfunction copyHooks(destination\x2C source) {\n  destination[kInit] = source[kInit];\n  destination[kBefore] = source[kBefore];\n  destination[kAfter] = source[kAfter];\n  destination[kDestroy] = source[kDestroy];\n  destination[kPromiseResolve] = source[kPromiseResolve];\n}\n\n\n// Then restore the correct hooks array in case any hooks were added/removed\n// during hook callback execution.\nfunction restoreActiveHooks() {\n  active_hooks.array = active_hooks.tmp_array;\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\n\n  active_hooks.tmp_array = null;\n  active_hooks.tmp_fields = null;\n}\n\nfunction trackPromise(promise\x2C parent) {\n  if (promise[async_id_symbol]) {\n    return;\n  }\n\n  // Get trigger id from parent async id before making the async id of the\n  // child so if a new one must be made it will be lower than the child.\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\n    getDefaultTriggerAsyncId();\n\n  promise[async_id_symbol] = newAsyncId();\n  promise[trigger_async_id_symbol] = triggerAsyncId;\n}\n\nfunction promiseInitHook(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  const triggerAsyncId = promise[trigger_async_id_symbol];\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\n}\n\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\n  promiseInitHook(promise\x2C parent);\n  destroyTracking(promise\x2C parent);\n}\n\nfunction destroyTracking(promise\x2C parent) {\n  trackPromise(promise\x2C parent);\n  const asyncId = promise[async_id_symbol];\n  registerDestroyHook(promise\x2C asyncId);\n}\n\nfunction promiseBeforeHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  const triggerId = promise[trigger_async_id_symbol];\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\n}\n\nfunction promiseAfterHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  if (hasHooks(kAfter)) {\n    emitAfterNative(asyncId);\n  }\n  if (asyncId === executionAsyncId()) {\n    // This condition might not be true if async_hooks was enabled during\n    // the promise callback execution.\n    // Popping it off the stack can be skipped in that case\x2C because it is\n    // known that it would correspond to exactly one call with\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\n    popAsyncContext(asyncId);\n  }\n}\n\nfunction promiseResolveHook(promise) {\n  trackPromise(promise);\n  const asyncId = promise[async_id_symbol];\n  emitPromiseResolveNative(asyncId);\n}\n\nlet wantPromiseHook = false;\nfunction enableHooks() {\n  async_hook_fields[kCheck] += 1;\n\n  setCallbackTrampoline(callbackTrampoline);\n}\n\nlet stopPromiseHook;\nfunction updatePromiseHookMode() {\n  wantPromiseHook = true;\n  let initHook;\n  if (initHooksExist()) {\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\n      promiseInitHook;\n  } else if (destroyHooksExist()) {\n    initHook = destroyTracking;\n  }\n  if (stopPromiseHook) stopPromiseHook();\n  stopPromiseHook = promiseHooks.createHook({\n    init: initHook\x2C\n    before: promiseBeforeHook\x2C\n    after: promiseAfterHook\x2C\n    settled: promiseResolveHooksExist() ? promiseResolveHook : undefined\n  });\n}\n\nfunction disableHooks() {\n  async_hook_fields[kCheck] -= 1;\n\n  wantPromiseHook = false;\n\n  setCallbackTrampoline();\n\n  // Delay the call to `disablePromiseHook()` because we might currently be\n  // between the `before` and `after` calls of a Promise.\n  enqueueMicrotask(disablePromiseHookIfNecessary);\n}\n\nfunction disablePromiseHookIfNecessary() {\n  if (!wantPromiseHook && stopPromiseHook) {\n    stopPromiseHook();\n  }\n}\n\n// Internal Embedder API //\n\n// Increment the internal id counter and return the value. Important that the\n// counter increment first. Since it's done the same way in\n// Environment::new_async_uid()\nfunction newAsyncId() {\n  return ++async_id_fields[kAsyncIdCounter];\n}\n\nfunction getOrSetAsyncId(object) {\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\n    return object[async_id_symbol];\n  }\n\n  return object[async_id_symbol] = newAsyncId();\n}\n\n\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\n// the user to safeguard this call and make sure it's zero'd out when the\n// constructor is complete.\nfunction getDefaultTriggerAsyncId() {\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\n  if (defaultTriggerAsyncId < 0)\n    return async_id_fields[kExecutionAsyncId];\n  return defaultTriggerAsyncId;\n}\n\n\nfunction clearDefaultTriggerAsyncId() {\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\n}\n\n/**\n * Sets a default top level trigger ID to be used\n *\n * @template {Array<unknown>} T\n * @template {unknown} R\n * @param {number} triggerAsyncId\n * @param { (...T: args) => R } block\n * @param  {T} args\n * @returns {R}\n */\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\n  if (triggerAsyncId === undefined)\n    return block.apply(null\x2C args);\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\n  // CHECK(triggerAsyncId > 0)\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\n\n  try {\n    return block.apply(null\x2C args);\n  } finally {\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\n  }\n}\n\nfunction hasHooks(key) {\n  return async_hook_fields[key] > 0;\n}\n\nfunction enabledHooksExist() {\n  return hasHooks(kCheck);\n}\n\nfunction initHooksExist() {\n  return hasHooks(kInit);\n}\n\nfunction afterHooksExist() {\n  return hasHooks(kAfter);\n}\n\nfunction destroyHooksExist() {\n  return hasHooks(kDestroy);\n}\n\nfunction promiseResolveHooksExist() {\n  return hasHooks(kPromiseResolve);\n}\n\n\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\n  // Short circuit all checks for the common case. Which is that no hooks have\n  // been set. Do this to remove performance impact for embedders (and core).\n  if (!hasHooks(kInit))\n    return;\n\n  if (triggerAsyncId === null) {\n    triggerAsyncId = getDefaultTriggerAsyncId();\n  }\n\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\n}\n\n\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\n\n  if (hasHooks(kBefore))\n    emitBeforeNative(asyncId);\n}\n\n\nfunction emitAfterScript(asyncId) {\n  if (hasHooks(kAfter))\n    emitAfterNative(asyncId);\n\n  popAsyncContext(asyncId);\n}\n\n\nfunction emitDestroyScript(asyncId) {\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\n  if (!hasHooks(kDestroy) || asyncId <= 0)\n    return;\n  async_wrap.queueDestroyAsyncId(asyncId);\n}\n\n\nfunction hasAsyncIdStack() {\n  return hasHooks(kStackLength);\n}\n\n\n// This is the equivalent of the native push_async_ids() call.\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\n  const offset = async_hook_fields[kStackLength];\n  execution_async_resources[offset] = resource;\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\n  async_hook_fields[kStackLength]++;\n  async_id_fields[kExecutionAsyncId] = asyncId;\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\n}\n\n\n// This is the equivalent of the native pop_async_ids() call.\nfunction popAsyncContext(asyncId) {\n  const stackLength = async_hook_fields[kStackLength];\n  if (stackLength === 0) return false;\n\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\n    // Do the same thing as the native code (i.e. crash hard).\n    return popAsyncContext_(asyncId);\n  }\n\n  const offset = stackLength - 1;\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\n  execution_async_resources.pop();\n  async_hook_fields[kStackLength] = offset;\n  return offset > 0;\n}\n\n\nfunction executionAsyncId() {\n  return async_id_fields[kExecutionAsyncId];\n}\n\nfunction triggerAsyncId() {\n  return async_id_fields[kTriggerAsyncId];\n}\n\n\nmodule.exports = {\n  executionAsyncId\x2C\n  triggerAsyncId\x2C\n  // Private API\n  getHookArrays\x2C\n  symbols: {\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\n    promise_resolve_symbol\x2C owner_symbol\n  }\x2C\n  constants: {\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\n  }\x2C\n  enableHooks\x2C\n  disableHooks\x2C\n  updatePromiseHookMode\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  executionAsyncResource\x2C\n  // Internal Embedder API\n  newAsyncId\x2C\n  getOrSetAsyncId\x2C\n  getDefaultTriggerAsyncId\x2C\n  defaultTriggerAsyncIdScope\x2C\n  enabledHooksExist\x2C\n  initHooksExist\x2C\n  afterHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit: emitInitScript\x2C\n  emitBefore: emitBeforeScript\x2C\n  emitAfter: emitAfterScript\x2C\n  emitDestroy: emitDestroyScript\x2C\n  pushAsyncContext\x2C\n  popAsyncContext\x2C\n  registerDestroyHook\x2C\n  useDomainTrampoline\x2C\n  nativeHooks: {\n    init: emitInitNative\x2C\n    before: emitBeforeNative\x2C\n    after: emitAfterNative\x2C\n    destroy: emitDestroyNative\x2C\n    promise_resolve: emitPromiseResolveNative\n  }\x2C\n  asyncWrap: {\n    Providers: async_wrap.Providers\x2C\n  }\n};\n
code-source-info,0xb46da653ae8,19,14473,14524,C0O14480C7O14505C16O14520C22O14522,,
tick,0x7ff805f105d0,273863,0,0x0,3,0x102d5e910,0xb46da6539aa,0xb46da65217d,0xb46da6511f4,0xb46da650ec8,0xb46da64e2b1,0xb46da64df85,0xb4611f1b8b0,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
tick,0x102a93ab4,273876,0,0x0,3,0x102d5e910,0xb46da6539aa,0xb46da65217d,0xb46da6511f4,0xb46da650ec8,0xb46da64e2b1,0xb46da64df85,0xb4611f1b8b0,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
code-creation,LazyCompile,10,273887,0xb46da654fc0,35,getDefaultTriggerAsyncId node:internal/async_hooks:432:34,0xb4665171890,~
code-source-info,0xb46da654fc0,19,14932,15189,C0O14969C7O14985C9O14984C13O15078C14O15104C19O15113C26O15136C28O15135C31O15155C32O15158C34O15187,,
code-creation,LazyCompile,10,273924,0xb46da6550d0,13,initHooksExist node:internal/async_hooks:478:24,0xb4665171a20,~
code-source-info,0xb46da6550d0,19,16153,16185,C0O16160C5O16176C8O16167C12O16183,,
code-creation,LazyCompile,10,273957,0xb46da6551b8,16,hasHooks node:internal/async_hooks:470:18,0xb4665171980,~
code-source-info,0xb46da6551b8,19,16021,16067,C0O16031C7O16055C12O16061C15O16065,,
code-creation,LazyCompile,10,274011,0xb46da655378,161,insert node:internal/timers:355:16,0xb466516b5d8,~
code-source-info,0xb46da655378,18,10399,11035,C12O10421C15O10421C23O10513C28O10521C33O10541C35O10557C39O10660C46O10672C50O10683C52O10713C60O10713C65O10800C67O10806C71O10819C78O10852C89O10848C95O10839C99O10883C104O10898C109O10898C114O10917C121O10932C126O10950C131O10950C135O10978C137O10989C143O11012C148O11014C153O11014C160O11034,,
code-creation,LazyCompile,10,274069,0xb46da655558,10, node:internal/timers:123:65,0xb466516aca0,~
code-source-info,0xb46da655558,18,4431,4456,C0O4443C2O4449C9O4455,,
code-creation,LazyCompile,10,274103,0xb46da655680,55,TimersList node:internal/timers:240:14,0xb466516b268,~
code-source-info,0xb46da655680,18,7475,7770,C0O7497C2O7512C6O7577C8O7592C12O7653C14O7665C18O7679C30O7700C38O7687C42O7708C44O7719C48O7732C49O7759C54O7769,,
code-creation,LazyCompile,10,274161,0xb46da655818,63,insert node:internal/priority_queue:26:9,0xb466517d300,~
script-source,25,node:internal/priority_queue,'use strict';\n\nconst {\n  Array\x2C\n} = primordials;\n\n// The PriorityQueue is a basic implementation of a binary heap that accepts\n// a custom sorting function via its constructor. This function is passed\n// the two nodes to compare\x2C similar to the native Array#sort. Crucially\n// this enables priority queues that are based on a comparison of more than\n// just a single criteria.\n\nmodule.exports = class PriorityQueue {\n  #compare = (a\x2C b) => a - b;\n  #heap = new Array(64);\n  #setPosition;\n  #size = 0;\n\n  constructor(comparator\x2C setPosition) {\n    if (comparator !== undefined)\n      this.#compare = comparator;\n    if (setPosition !== undefined)\n      this.#setPosition = setPosition;\n  }\n\n  insert(value) {\n    const heap = this.#heap;\n    const pos = ++this.#size;\n    heap[pos] = value;\n\n    if (heap.length === pos)\n      heap.length *= 2;\n\n    this.percolateUp(pos);\n  }\n\n  peek() {\n    return this.#heap[1];\n  }\n\n  percolateDown(pos) {\n    const compare = this.#compare;\n    const setPosition = this.#setPosition;\n    const heap = this.#heap;\n    const size = this.#size;\n    const item = heap[pos];\n\n    while (pos * 2 <= size) {\n      let childIndex = pos * 2 + 1;\n      if (childIndex > size || compare(heap[pos * 2]\x2C heap[childIndex]) < 0)\n        childIndex = pos * 2;\n      const child = heap[childIndex];\n      if (compare(item\x2C child) <= 0)\n        break;\n      if (setPosition !== undefined)\n        setPosition(child\x2C pos);\n      heap[pos] = child;\n      pos = childIndex;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item\x2C pos);\n  }\n\n  percolateUp(pos) {\n    const heap = this.#heap;\n    const compare = this.#compare;\n    const setPosition = this.#setPosition;\n    const item = heap[pos];\n\n    while (pos > 1) {\n      const parent = heap[pos / 2 | 0];\n      if (compare(parent\x2C item) <= 0)\n        break;\n      heap[pos] = parent;\n      if (setPosition !== undefined)\n        setPosition(parent\x2C pos);\n      pos = pos / 2 | 0;\n    }\n    heap[pos] = item;\n    if (setPosition !== undefined)\n      setPosition(item\x2C pos);\n  }\n\n  removeAt(pos) {\n    const heap = this.#heap;\n    const size = --this.#size;\n    heap[pos] = heap[size + 1];\n    heap[size + 1] = undefined;\n\n    if (size > 0 && pos <= size) {\n      if (pos > 1 && this.#compare(heap[pos / 2 | 0]\x2C heap[pos]) > 0)\n        this.percolateUp(pos);\n      else\n        this.percolateDown(pos);\n    }\n  }\n\n  shift() {\n    const heap = this.#heap;\n    const value = heap[1];\n    if (value === undefined)\n      return;\n\n    this.removeAt(1);\n\n    return value;\n  }\n};\n
code-source-info,0xb46da655818,25,698,875,C0O725C2O730C6O753C9O759C15O760C22O771C24O781C28O804C35O811C40O826C47O838C51O854C56O854C62O874,,
code-creation,LazyCompile,10,274497,0xb46da655cb0,102,percolateUp node:internal/priority_queue:65:14,0xb466517d3f0,~
code-source-info,0xb46da655cb0,25,1600,2077,C0O1625C2O1630C6O1657C8O1662C12O1696C14O1701C18O1732C20O1736C24O1759C26O1759C31O1787C33O1796C36O1800C39O1791C43O1816C50O1838C55O1852C57O1865C59O1875C63O1891C67O1930C72O1962C74O1972C77O1976C82O1748C85O1991C87O2001C91O2013C95O2050C101O2076,,
code-creation,LazyCompile,10,274544,0xb46da655e38,8,setPosition node:internal/timers:416:21,0xb466516b718,~
code-source-info,0xb46da655e38,18,12119,12170,C0O12135C2O12162C7O12169,,
tick,0x102cdf904,274598,0,0x0,2,0x102d5e910,0xb46da655411,0xb46da651204,0xb46da650ec8,0xb46da64e2b1,0xb46da64df85,0xb4611f1b8b0,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
code-creation,LazyCompile,10,274719,0xb46da655f20,52,append node:internal/linkedlist:30:16,0xb466517c3c8,~
script-source,24,node:internal/linkedlist,'use strict';\n\nfunction init(list) {\n  list._idleNext = list;\n  list._idlePrev = list;\n  return list;\n}\n\n// Show the most idle item.\nfunction peek(list) {\n  if (list._idlePrev === list) return null;\n  return list._idlePrev;\n}\n\n// Remove an item from its list.\nfunction remove(item) {\n  if (item._idleNext) {\n    item._idleNext._idlePrev = item._idlePrev;\n  }\n\n  if (item._idlePrev) {\n    item._idlePrev._idleNext = item._idleNext;\n  }\n\n  item._idleNext = null;\n  item._idlePrev = null;\n}\n\n// Remove an item from its list and place at the end.\nfunction append(list\x2C item) {\n  if (item._idleNext || item._idlePrev) {\n    remove(item);\n  }\n\n  // Items are linked  with _idleNext -> (older) and _idlePrev -> (newer).\n  // Note: This linkage (next being older) may seem counter-intuitive at first.\n  item._idleNext = list._idleNext;\n  item._idlePrev = list;\n\n  // The list _idleNext points to tail (newest) and _idlePrev to head (oldest).\n  list._idleNext._idlePrev = item;\n  list._idleNext = item;\n}\n\nfunction isEmpty(list) {\n  return list._idleNext === list;\n}\n\nmodule.exports = {\n  init\x2C\n  peek\x2C\n  remove\x2C\n  append\x2C\n  isEmpty\n};\n
code-source-info,0xb46da655f20,24,558,995,C0O584C6O602C12O619C15O619C19O817C23O810C27O830C29O845C33O941C40O961C44O971C46O986C51O994,,
code-creation,LazyCompile,10,274890,0xb46da656220,50,remove node:internal/linkedlist:16:16,0xb466517c378,~
code-source-info,0xb46da656220,24,275,487,C0O295C6O317C11O344C15O337C19O371C25O393C30O420C34O413C38O438C39O453C43O463C44O478C49O486,,
code-creation,LazyCompile,10,274934,0xb46da656348,34,unref node:internal/timers:216:8,0xb466516b178,~
code-source-info,0xb46da656348,18,7121,7255,C0O7130C2O7139C4O7138C9O7156C11O7161C15O7169C19O7194C25O7214C28O7214C31O7239C33O7251,,
code-creation,LazyCompile,10,274970,0xb46da656460,34,decRefCount node:internal/timers:309:21,0xb466516b498,~
code-source-info,0xb46da656460,18,9244,9301,C0O9251C9O9257C16O9266C21O9277C28O9277C33O9300,,
code-creation,LazyCompile,10,275045,0xb46da656580,75,parseUniqueHeadersOption node:_http_outgoing:587:34,0xb4611f335d0,~
code-source-info,0xb46da656580,444,17980,18217,C0O17994C5O17999C11O18028C12O18040C13O18063C18O18063C24O18098C29O18121C31O18126C33O18126C38O18149C45O18153C50O18187C54O18153C59O18149C64O18132C69O18108C72O18201C74O18215,,
code-creation,LazyCompile,10,275170,0xb46da658a70,717,Server.listen node:net:1513:35,0xb469fbf5f20,~
code-source-info,0xb46da658a70,406,40431,44249,C0O40431C3O40464C6O40464C11O40501C12O40511C16O40529C18O40539C22O40556C28O40571C33O40577C38O40571C39O40617C43O40645C51O40645C57O40765C60O40779C67O40786C74O40797C78O40765C87O40823C94O40830C101O40841C105O40809C110O40894C116O40913C125O40948C128O40965C133O40948C138O41049C140O41072C142O41061C147O41083C149O41096C153O41111C155O41116C158O41140C163O41148C168O41148C172O41133C176O41166C193O41166C198O41224C200O41236C201O41243C204O41243C209O41368C217O41395C223O41398C228O41410C237O41475C249O41410C254O41484C256O41496C257O41766C263O41773C269O41793C276O41837C289O41868C294O41897C300O41918C301O41931C305O42115C307O42145C315O42181C323O42206C328O42227C336O42206C341O42272C350O42363C356O42377C359O42407C363O42412C367O42425C372O42470C387O42377C394O42631C399O42667C403O42672C413O42730C425O42631C430O42752C432O42764C433O42904C442O42931C447O42912C453O42986C458O42976C465O43014C474O43046C486O43234C495O43265C501O43341C509O43397C526O43046C531O43449C537O43570C539O43582C540O43605C542O43624C548O43636C553O43652C555O43660C558O43674C569O43703C575O43715C580O43731C582O43739C585O43753C596O43770C597O43779C602O43811C607O43819C612O43819C618O43839C620O43863C625O43871C630O43871C634O43888C635O43901C639O43917C647O43923C652O43917C653O43979C655O43991C656O43999C661O44013C671O44036C676O44056C692O44062C697O44056C698O44195C711O44201C716O44195,,
code-creation,LazyCompile,10,275304,0xb46da659088,183,normalizeArgs node:net:226:23,0xb469fbf4470,~
code-source-info,0xb46da659088,406,5739,6443,C0O5754C2O5771C8O5778C13O5791C18O5813C20O5817C24O5839C28O5851C30O5862C31O5883C32O5887C36O5908C38O5914C48O5995C55O6020C58O6024C64O6073C66O6086C72O6144C74O6157C78O6178C85O6185C92O6203C99O6229C101O6248C104O6242C108O6287C112O6294C115O6281C119O6302C123O6336C132O6343C143O6370C152O6377C161O6386C170O6394C172O6398C176O6420C180O6430C182O6441,,
code-creation,LazyCompile,10,275355,0xb46da659260,19,isPipeName node:net:171:20,0xb469fbf4380,~
code-source-info,0xb46da659260,406,4339,4403,C0O4347C9O4379C15O4391C18O4401,,
code-creation,LazyCompile,10,275390,0xb46da659360,39,once node:events:646:44,0xb469fce3060,~
code-source-info,0xb46da659360,29,18886,18999,C0O18907C3O18907C7O18940C24O18949C30O18940C36O18985C38O18997,,
code-creation,LazyCompile,10,275426,0xb46da659510,60,_onceWrap node:events:632:19,0xb469fce3010,~
code-source-info,0xb46da659510,29,18459,18682,C0O18502C6O18526C12O18537C18O18545C24O18551C31O18581C34O18593C39O18593C45O18608C47O18625C51O18639C53O18652C57O18665C59O18680,,
code-creation,LazyCompile,10,275471,0xb46da6597d8,23,toNumber node:net:1324:18,0xb469fbf4970,~
code-source-info,0xb46da6597d8,406,34963,35011,C0O34969C5O34981C12O34992C22O35009,,
code-creation,LazyCompile,10,275505,0xb46da6598d0,19,getFlags node:net:142:18,0xb469fbf4290,~
code-source-info,0xb46da6598d0,406,3716,3793,C0O3731C1O3747C8O3758C11O3771C18O3791,,
code-creation,LazyCompile,10,275547,0xb46da659ae8,138,addAbortSignalOption node:net:1260:30,0xb469fbf48d0,~
code-source-info,0xb46da659ae8,406,33161,33572,C0O33161C15O33181C22O33192C31O33222C32O33229C33O33236C40O33264C48O33236C53O33301C59O33341C63O33341C65O33374C68O33385C74O33400C79O33408C87O33408C94O33444C97O33451C108O33451C114O33493C117O33498C130O33498C137O33571,,
code-creation,LazyCompile,10,275609,0xb46da659e90,209,listenInCluster node:net:1470:25,0xb469fbf4b00,~
code-source-info,0xb46da659e90,406,39158,40394,C0O39158C38O39264C44O39292C52O39319C60O39329C69O39327C77O39352C84O39364C92O39377C94O39552C97O39559C120O39559C125O39621C126O39628C127O39656C134O39671C140O39690C146O39713C152O39734C158O39742C164O39753C174O39769C181O39840C188O39848C202O39848C208O40393,,
code-creation,LazyCompile,10,275697,0xb46da65a1d0,443,setupListenHandle node:net:1385:27,0xb469fbf4a10,~
code-source-info,0xb46da65a1d0,406,36559,38884,C0O36612C23O36612C28O36829C34O36844C42O36844C48O36910C56O36910C60O36971C62O37059C72O37107C77O37133C92O37114C98O37180C102O37220C104O37241C110O37278C116O37318C122O37355C126O37391C130O37416C148O37423C154O37487C160O37539C177O37539C183O37601C186O37609C200O37609C205O37651C206O37658C207O37669C209O37682C213O37697C215O37702C221O37740C226O37721C230O37719C234O37757C241O37778C245O37801C252O37809C257O37823C261O38055C266O38063C273O38070C280O38063C286O38090C288O38116C305O38116C311O38180C316O38188C321O38188C325O38201C326O38214C330O38226C337O38258C339O38257C346O38315C360O38226C365O38446C366O38453C367O38531C369O38565C375O38571C381O38581C387O38587C390O38551C394O38675C400O38692C405O38692C409O38704C416O38736C418O38735C425O38791C436O38704C442O38883,,
code-creation,LazyCompile,10,275776,0xb46da65a558,10, node:net:39:63,0xb469fbf4c90,~
code-source-info,0xb46da65a558,406,1480,1505,C0O1492C2O1498C9O1504,,
code-creation,LazyCompile,10,275848,0xb46da65a7d8,379,createServerHandle node:net:1327:28,0xb469fbf49c0,~
code-source-info,0xb46da65a7d8,406,35106,36531,C0O35160C2O35236C4O35259C6O35268C13O35301C21O35325C26O35334C35O35332C45O35447C58O35484C66O35447C71O35500C77O35517C78O35542C83O35542C89O35556C91O35571C93O35582C94O35588C101O35596C106O35608C108O35588C114O35624C116O35633C123O35655C128O35669C135O35687C138O35701C145O35678C151O35714C157O35755C165O35778C170O35782C175O35755C180O35818C185O35823C191O35864C196O35864C203O35925C210O35942C213O35955C220O35934C226O35968C228O35989C234O36004C238O36012C240O36025C250O36042C255O36025C260O36065C264O36135C271O36141C283O36135C289O36180C291O36206C296O36206C300O36251C305O36277C308O36258C313O36302C316O36322C318O36338C323O36366C340O36366C348O36427C353O36427C360O36461C364O36483C369O36483C373O36496C375O36507C376O36515C378O36529,,
tick,0x7ff805ede9fe,275957,0,0x0,3,0x102d5e910,0xb46da65a22c,0xb46da659f08,0xb46da658c19,0xb4611f1b8c4,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
code-creation,LazyCompile,10,276080,0xb46da65abb8,224,uvExceptionWithHostPort node:internal/errors:549:35,0xb4665160798,~
code-source-info,0xb46da65abb8,17,15546,16503,C0O15612C3O15612C11O15632C14O15593C20O15602C27O15669C39O15683C52O15692C57O15719C60O15728C65O15745C70O15758C75O15772C88O15783C95O15802C99O15823C104O15837C109O16052C114O16058C119O16079C122O16083C127O16117C133O16139C137O16212C144O16225C148O16235C155O16212C161O16251C164O16255C169O16289C176O16311C180O16327C182O16335C186O16347C188O16356C192O16367C194O16378C198O16393C200O16404C204O16419C208O16437C210O16445C214O16464C219O16471C223O16499,,
code-creation,LazyCompile,10,276141,0xb46da65ae08,67,uvErrmapGet node:internal/errors:464:21,0xb46651606a8,~
code-source-info,0xb46da65ae08,17,12990,13122,C0O13001C3O13013C9O13011C15O13025C30O13046C33O13056C38O13056C42O13042C46O13073C53O13096C56O13106C61O13080C66O13120,,
code-creation,LazyCompile,10,276176,0xb46da65af48,32,lazyUv node:internal/errors:457:16,0xb4665160658,~
code-source-info,0xb46da65af48,17,12848,12913,C0O12855C14O12869C21O12865C27O12894C31O12911,,
code-creation,LazyCompile,10,276373,0xb46da65b0e8,121,defaultTriggerAsyncIdScope node:internal/async_hooks:455:36,0xb4665171930,~
code-source-info,0xb46da65b0e8,19,15544,16002,C0O15544C11O15581C15O15632C22O15632C28O15650C29O15765C36O15781C38O15780C42O15808C49O15824C54O15848C61O15892C68O15892C86O15929C93O15945C98O15969C120O16001,,
code-creation,LazyCompile,10,276450,0xb46da65b3e0,372,nextTick node:internal/process/task_queues:103:18,0xb46d2c8bc50,~
script-source,38,node:internal/process/task_queues,'use strict';\n\nconst {\n  Array\x2C\n  FunctionPrototypeBind\x2C\n} = primordials;\n\nconst {\n  // For easy access to the nextTick state in the C++ land\x2C\n  // and to avoid unnecessary calls into JS land.\n  tickInfo\x2C\n  // Used to run V8's micro task queue.\n  runMicrotasks\x2C\n  setTickCallback\x2C\n  enqueueMicrotask\n} = internalBinding('task_queue');\n\nconst {\n  setHasRejectionToWarn\x2C\n  hasRejectionToWarn\x2C\n  listenForRejections\x2C\n  processPromiseRejections\n} = require('internal/process/promises');\n\nconst {\n  getDefaultTriggerAsyncId\x2C\n  newAsyncId\x2C\n  initHooksExist\x2C\n  destroyHooksExist\x2C\n  emitInit\x2C\n  emitBefore\x2C\n  emitAfter\x2C\n  emitDestroy\x2C\n  symbols: { async_id_symbol\x2C trigger_async_id_symbol }\n} = require('internal/async_hooks');\nconst FixedQueue = require('internal/fixed_queue');\n\nconst {\n  validateFunction\x2C\n} = require('internal/validators');\n\nconst { AsyncResource } = require('async_hooks');\n\n// *Must* match Environment::TickInfo::Fields in src/env.h.\nconst kHasTickScheduled = 0;\n\nfunction hasTickScheduled() {\n  return tickInfo[kHasTickScheduled] === 1;\n}\n\nfunction setHasTickScheduled(value) {\n  tickInfo[kHasTickScheduled] = value ? 1 : 0;\n}\n\nconst queue = new FixedQueue();\n\n// Should be in sync with RunNextTicksNative in node_task_queue.cc\nfunction runNextTicks() {\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    runMicrotasks();\n  if (!hasTickScheduled() && !hasRejectionToWarn())\n    return;\n\n  processTicksAndRejections();\n}\n\nfunction processTicksAndRejections() {\n  let tock;\n  do {\n    while ((tock = queue.shift()) !== null) {\n      const asyncId = tock[async_id_symbol];\n      emitBefore(asyncId\x2C tock[trigger_async_id_symbol]\x2C tock);\n\n      try {\n        const callback = tock.callback;\n        if (tock.args === undefined) {\n          callback();\n        } else {\n          const args = tock.args;\n          switch (args.length) {\n            case 1: callback(args[0]); break;\n            case 2: callback(args[0]\x2C args[1]); break;\n            case 3: callback(args[0]\x2C args[1]\x2C args[2]); break;\n            case 4: callback(args[0]\x2C args[1]\x2C args[2]\x2C args[3]); break;\n            default: callback(...args);\n          }\n        }\n      } finally {\n        if (destroyHooksExist())\n          emitDestroy(asyncId);\n      }\n\n      emitAfter(asyncId);\n    }\n    runMicrotasks();\n  } while (!queue.isEmpty() || processPromiseRejections());\n  setHasTickScheduled(false);\n  setHasRejectionToWarn(false);\n}\n\n// `nextTick()` will not enqueue any callback when the process is about to\n// exit since the callback would not have a chance to be executed.\nfunction nextTick(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  if (process._exiting)\n    return;\n\n  let args;\n  switch (arguments.length) {\n    case 1: break;\n    case 2: args = [arguments[1]]; break;\n    case 3: args = [arguments[1]\x2C arguments[2]]; break;\n    case 4: args = [arguments[1]\x2C arguments[2]\x2C arguments[3]]; break;\n    default:\n      args = new Array(arguments.length - 1);\n      for (let i = 1; i < arguments.length; i++)\n        args[i - 1] = arguments[i];\n  }\n\n  if (queue.isEmpty())\n    setHasTickScheduled(true);\n  const asyncId = newAsyncId();\n  const triggerAsyncId = getDefaultTriggerAsyncId();\n  const tickObject = {\n    [async_id_symbol]: asyncId\x2C\n    [trigger_async_id_symbol]: triggerAsyncId\x2C\n    callback\x2C\n    args\n  };\n  if (initHooksExist())\n    emitInit(asyncId\x2C 'TickObject'\x2C triggerAsyncId\x2C tickObject);\n  queue.push(tickObject);\n}\n\nfunction runMicrotask() {\n  this.runInAsyncScope(() => {\n    const callback = this.callback;\n    try {\n      callback();\n    } finally {\n      this.emitDestroy();\n    }\n  });\n}\n\nconst defaultMicrotaskResourceOpts = { requireManualDestroy: true };\n\nfunction queueMicrotask(callback) {\n  validateFunction(callback\x2C 'callback');\n\n  const asyncResource = new AsyncResource(\n    'Microtask'\x2C\n    defaultMicrotaskResourceOpts\n  );\n  asyncResource.callback = callback;\n\n  enqueueMicrotask(FunctionPrototypeBind(runMicrotask\x2C asyncResource));\n}\n\nmodule.exports = {\n  setupTaskQueue() {\n    // Sets the per-isolate promise rejection callback\n    listenForRejections();\n    // Sets the callback to be run in every tick.\n    setTickCallback(processTicksAndRejections);\n    return {\n      nextTick\x2C\n      runNextTicks\n    };\n  }\x2C\n  queueMicrotask\n};\n
code-source-info,0xb46da65b3e0,38,2582,3438,C0O2582C2O2597C10O2597C15O2640C18O2652C24O2666C25O2673C26O2681C28O2707C63O2729C65O2748C74O2765C86O2771C88O2790C97O2807C109O2821C121O2827C123O2846C132O2863C144O2877C156O2891C168O2897C170O2923C175O2950C179O2957C185O2930C191O2982C194O2999C198O2987C203O3020C205O3027C211O3043C214O3032C218O3008C223O2969C226O3055C231O3065C236O3065C242O3080C247O3080C251O3125C256O3125C260O3164C265O3164C269O3213C276O3220C282O3238C289O3252C295O3278C305O3298C315O3312C323O3324C328O3328C333O3350C350O3350C355O3413C360O3419C365O3419C371O3437,,
code-creation,LazyCompile,10,276981,0xb46da65bc58,15,isEmpty node:internal/fixed_queue:95:10,0xb46d2c90860,~
script-source,40,node:internal/fixed_queue,'use strict';\n\nconst {\n  Array\x2C\n} = primordials;\n\n// Currently optimal queue size\x2C tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or\x2C if there is only one circular buffer\x2C it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one\x2C removing means\n// moving `bottom` forward by one. After reaching the end\x2C the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue\x2C sets the old queue's `.next` to it\x2C\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue\x2C it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n
code-source-info,0xb46da65bc58,40,3637,3677,C0O3658C5O3663C10O3663C14O3673,,
tick,0x7ff805dd2b58,277480,0,0x0,3,0x102d5e910,0xb46da65b4cc,0xb46da65b12c,0xb46da65a338,0xb46da659f08,0xb46da658c19,0xb4611f1b8c4,0x10311b817,0x1025e38e0,0xb4611f150b4,0x10311893f
code-creation,LazyCompile,10,277495,0xb46da65c108,13,isEmpty node:internal/fixed_queue:67:10,0xb46d2c90648,~
code-source-info,0xb46da65c108,40,3084,3129,C0O3105C5O3118C9O3109C12O3125,,
code-creation,LazyCompile,10,277527,0xb46da65c1f8,25,setHasTickScheduled node:internal/process/task_queues:51:29,0xb46d2c8bb60,~
code-source-info,0xb46da65c1f8,38,1084,1142,C0O1096C7O1105C12O1126C19O1124C24O1141,,
code-creation,LazyCompile,10,277574,0xb46da65c7d0,59,push node:internal/fixed_queue:99:7,0xb46d2c908b0,~
code-source-info,0xb46da65c7d0,40,3685,3945,C0O3707C5O3712C10O3712C16O3871C23O3887C26O3883C32O3881C38O3864C42O3925C47O3930C52O3930C58O3944,,
code-creation,LazyCompile,10,277610,0xb46da65c910,24,isFull node:internal/fixed_queue:71:9,0xb46d2c90698,~
code-source-info,0xb46da65c910,40,3139,3200,C0O3162C4O3166C10O3173C12O3171C16O3189C20O3180C23O3196,,
code-creation,LazyCompile,10,277642,0xb46da65ca18,37,push node:internal/fixed_queue:75:7,0xb46d2c906e8,~
code-source-info,0xb46da65ca18,40,3208,3291,C0O3226C5O3236C12O3241C16O3270C20O3274C26O3281C28O3279C31O3262C36O3290,,
code-creation,LazyCompile,10,277807,0xb46da65cd18,15, node:internal/modules/esm/loader:538:15,0xb4611f04af0,~
code-source-info,0xb46da65cd18,399,16155,16192,C0O16158C5O16178C10O16178C14O16192,,
code-creation,LazyCompile,10,277904,0xb46da65ce80,307,removeListener node:events:675:28,0xb469fce3100,~
code-source-info,0xb46da65ce80,29,19632,20903,C0O19657C3O19657C7O19709C12O19724C14O19758C16O19770C17O19791C19O19797C23O19811C25O19843C27O19855C28O19863C30O19872C35O19893C42O19902C47O19926C54O19937C59O19950C64O19967C66O19982C71O19982C75O19980C81O20027C83O20041C85O20069C91O20102C99O20136C114O20102C121O20182C127O20239C130O20270C134O20277C138O20284C139O20284C144O20307C146O20315C152O20319C159O20339C163O20343C170O20352C175O20380C180O20406C182O20291C187O20252C190O20444C191O20457C196O20472C198O20484C199O20494C200O20507C205O20529C210O20529C216O20563C222O20604C228O20616C233O20640C240O20614C246O20662C251O20662C256O20717C263O20724C268O20741C269O20760C272O20754C276O20785C282O20830C299O20830C304O20885C306O20897,,
code-creation,LazyCompile,10,277982,0xb46da65d160,64,stopListeningIfSignal node:internal/process/signal:43:31,0xb46634f9980,~
code-source-info,0xb46da65d160,129,936,1101,C0O960C5O972C10O972C16O985C21O1019C26O1019C33O1039C38O1057C43O1057C47O1070C52O1082C57O1088C63O1100,,
code-creation,LazyCompile,10,278052,0xb46da65d338,318,processTicksAndRejections node:internal/process/task_queues:67:35,0xb46d2c8bc00,~
code-source-info,0xb46da65d338,38,1476,2421,C0O1487C2O1534C7O1525C12O1525C19O1568C21O1573C23O1572C27O1597C34O1622C36O1621C46O1597C54O1698C59O1725C65O1757C70O1814C75O1843C110O1873C111O1886C115O1873C119O1892C121O1919C122O1932C128O1941C132O1919C137O1947C139O1974C140O1987C146O1996C152O2005C156O1974C161O2011C163O2038C164O2051C170O2060C176O2069C182O2078C186O2038C191O2084C193O2112C198O2112C215O2179C220O2183C225O2214C230O2214C245O2251C250O2251C256O2281C261O2281C264O2326C269O2316C274O2316C282O2329C285O2329C290O1495C296O2360C301O2360C305O2390C312O2390C317O2420,,
code-creation,LazyCompile,10,278122,0xb46da65d608,43,shift node:internal/fixed_queue:108:8,0xb46d2c90900,~
code-source-info,0xb46da65d608,40,3954,4180,C0O3981C5O4009C10O4009C15O4031C20O4031C26O4049C32O4148C36O4141C40O4164C42O4176,,
code-creation,LazyCompile,10,278159,0xb46da65d748,54,shift node:internal/fixed_queue:80:8,0xb46d2c90738,~
code-source-info,0xb46da65d748,40,3300,3510,C0O3331C5O3341C9O3335C13O3354C15O3388C16O3400C17O3410C22O3420C28O3428C32O3465C36O3472C42O3479C44O3477C47O3457C51O3490C53O3506,,
code-creation,LazyCompile,10,278199,0xb46da65d880,42,emitBeforeScript node:internal/async_hooks:509:26,0xb4665171bb0,~
code-source-info,0xb46da65d880,19,16823,16974,C0O16863C12O16863C17O16919C22O16932C25O16923C31O16946C36O16946C41O16973,,
code-creation,LazyCompile,10,278242,0xb46da65d9d8,180,pushAsyncContext node:internal/async_hooks:539:26,0xb4665171cf0,~
code-source-info,0xb46da65d9d8,19,17467,18012,C0O17522C7O17540C9O17539C13O17557C20O17591C24O17605C26O17616C32O17623C35O17634C40O17650C44O17620C49O17662C54O17669C59O17712C60O17715C65O17726C72O17749C78O17756C83O17772C85O17771C88O17754C92O17794C97O17805C104O17828C107O17832C113O17839C118O17855C120O17854C123O17837C127O17875C134O17893C142O17906C146O17912C153O17928C158O17947C162O17960C169O17976C174O17993C179O18011,,
code-creation,LazyCompile,10,278303,0xb46da65dbc8,16,emitErrorNT node:net:1458:21,0xb469fbf4a60,~
code-source-info,0xb46da65dbc8,406,38971,39013,C0O38992C8O38992C15O39012,,
code-creation,LazyCompile,10,278351,0xb46da65dcb0,13,destroyHooksExist node:internal/async_hooks:486:27,0xb4665171ac0,~
code-source-info,0xb46da65dcb0,19,16272,16307,C0O16279C5O16295C8O16286C12O16305,,
tick,0x1029290cc,278454,0,0x0,2
code-creation,LazyCompile,10,278488,0xb46da65def0,343, node:internal/process/execution:137:10,0xb46806a0d18,~
script-source,70,node:internal/process/execution,'use strict';\n\nconst {\n  globalThis\x2C\n} = primordials;\n\nconst path = require('path');\n\nconst {\n  codes: {\n    ERR_INVALID_ARG_TYPE\x2C\n    ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET\x2C\n    ERR_EVAL_ESM_CANNOT_PRINT\x2C\n  }\x2C\n} = require('internal/errors');\n\nconst {\n  executionAsyncId\x2C\n  clearDefaultTriggerAsyncId\x2C\n  clearAsyncIdStack\x2C\n  hasAsyncIdStack\x2C\n  afterHooksExist\x2C\n  emitAfter\x2C\n  popAsyncContext\x2C\n} = require('internal/async_hooks');\n\n// shouldAbortOnUncaughtToggle is a typed array for faster\n// communication with JS.\nconst { shouldAbortOnUncaughtToggle } = internalBinding('util');\n\nfunction tryGetCwd() {\n  try {\n    return process.cwd();\n  } catch {\n    // getcwd(3) can fail if the current working directory has been deleted.\n    // Fall back to the directory name of the (absolute) executable path.\n    // It's not really correct but what are the alternatives?\n    return path.dirname(process.execPath);\n  }\n}\n\nfunction evalModule(source\x2C print) {\n  if (print) {\n    throw new ERR_EVAL_ESM_CANNOT_PRINT();\n  }\n  const { loadESM } = require('internal/process/esm_loader');\n  const { handleMainPromise } = require('internal/modules/run_main');\n  return handleMainPromise(loadESM((loader) => loader.eval(source)));\n}\n\nfunction evalScript(name\x2C body\x2C breakFirstLine\x2C print) {\n  const CJSModule = require('internal/modules/cjs/loader').Module;\n  const { kVmBreakFirstLineSymbol } = require('internal/util');\n  const { pathToFileURL } = require('url');\n\n  const cwd = tryGetCwd();\n  const origModule = globalThis.module;  // Set e.g. when called from the REPL.\n\n  const module = new CJSModule(name);\n  module.filename = path.join(cwd\x2C name);\n  module.paths = CJSModule._nodeModulePaths(cwd);\n\n  const asyncESM = require('internal/process/esm_loader');\n  const baseUrl = pathToFileURL(module.filename).href;\n\n  // Create wrapper for cache entry\n  const script = `\n    globalThis.module = module;\n    globalThis.exports = exports;\n    globalThis.__dirname = __dirname;\n    globalThis.require = require;\n    return (main) => main();\n  `;\n  globalThis.__filename = name;\n  const result = module._compile(script\x2C `${name}-wrapper`)(() =>\n    require('vm').runInThisContext(body\x2C {\n      filename: name\x2C\n      displayErrors: true\x2C\n      [kVmBreakFirstLineSymbol]: !!breakFirstLine\x2C\n      importModuleDynamically(specifier\x2C _\x2C importAssertions) {\n        const loader = asyncESM.esmLoader;\n        return loader.import(specifier\x2C baseUrl\x2C importAssertions);\n      }\n    }));\n  if (print) {\n    const { log } = require('internal/console/global');\n    log(result);\n  }\n\n  if (origModule !== undefined)\n    globalThis.module = origModule;\n}\n\nconst exceptionHandlerState = {\n  captureFn: null\x2C\n  reportFlag: false\n};\n\nfunction setUncaughtExceptionCaptureCallback(fn) {\n  if (fn === null) {\n    exceptionHandlerState.captureFn = fn;\n    shouldAbortOnUncaughtToggle[0] = 1;\n    process.report.reportOnUncaughtException = exceptionHandlerState.reportFlag;\n    return;\n  }\n  if (typeof fn !== 'function') {\n    throw new ERR_INVALID_ARG_TYPE('fn'\x2C ['Function'\x2C 'null']\x2C fn);\n  }\n  if (exceptionHandlerState.captureFn !== null) {\n    throw new ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET();\n  }\n  exceptionHandlerState.captureFn = fn;\n  shouldAbortOnUncaughtToggle[0] = 0;\n  exceptionHandlerState.reportFlag =\n    process.report.reportOnUncaughtException === true;\n  process.report.reportOnUncaughtException = false;\n}\n\nfunction hasUncaughtExceptionCaptureCallback() {\n  return exceptionHandlerState.captureFn !== null;\n}\n\nfunction noop() {}\n\n// XXX(joyeecheung): for some reason this cannot be defined at the top-level\n// and exported to be written to process._fatalException\x2C it has to be\n// returned as an *anonymous function* wrapped inside a factory function\x2C\n// otherwise it breaks the test-timers.setInterval async hooks test -\n// this may indicate that node::errors::TriggerUncaughtException() should\n// fix up the callback scope before calling into process._fatalException\x2C\n// or this function should take extra care of the async hooks before it\n// schedules a setImmediate.\nfunction createOnGlobalUncaughtException() {\n  // The C++ land node::errors::TriggerUncaughtException() will\n  // exit the process if it returns false\x2C and continue execution if it\n  // returns true (which indicates that the exception is handled by the user).\n  return (er\x2C fromPromise) => {\n    // It's possible that defaultTriggerAsyncId was set for a constructor\n    // call that threw and was never cleared. So clear it now.\n    clearDefaultTriggerAsyncId();\n\n    // If diagnostic reporting is enabled\x2C call into its handler to see\n    // whether it is interested in handling the situation.\n    // Ignore if the error is scoped inside a domain.\n    // use == in the checks as we want to allow for null and undefined\n    if (er == null || er.domain == null) {\n      try {\n        const report = internalBinding('report');\n        if (report != null && report.shouldReportOnUncaughtException()) {\n          report.writeReport(\n            typeof er?.message === 'string' ?\n              er.message :\n              'Exception'\x2C\n            'Exception'\x2C\n            null\x2C\n            er ?? {});\n        }\n      } catch {\n        // Ignore the exception. Diagnostic reporting is unavailable.\n      }\n    }\n\n    const type = fromPromise ? 'unhandledRejection' : 'uncaughtException';\n    process.emit('uncaughtExceptionMonitor'\x2C er\x2C type);\n    if (exceptionHandlerState.captureFn !== null) {\n      exceptionHandlerState.captureFn(er);\n    } else if (!process.emit('uncaughtException'\x2C er\x2C type)) {\n      // If someone handled it\x2C then great. Otherwise\x2C die in C++ land\n      // since that means that we'll exit the process\x2C emit the 'exit' event.\n      try {\n        if (!process._exiting) {\n          process._exiting = true;\n          process.exitCode = 1;\n          process.emit('exit'\x2C 1);\n        }\n      } catch {\n        // Nothing to be done about it at this point.\n      }\n      return false;\n    }\n\n    // If we handled an error\x2C then make sure any ticks get processed\n    // by ensuring that the next Immediate cycle isn't empty.\n    require('timers').setImmediate(noop);\n\n    // Emit the after() hooks now that the exception has been handled.\n    if (afterHooksExist()) {\n      do {\n        const asyncId = executionAsyncId();\n        if (asyncId === 0)\n          popAsyncContext(0);\n        else\n          emitAfter(asyncId);\n      } while (hasAsyncIdStack());\n    }\n    // And completely empty the id stack\x2C including anything that may be\n    // cached on the native side.\n    clearAsyncIdStack();\n\n    return true;\n  };\n}\n\nfunction readStdin(callback) {\n  process.stdin.setEncoding('utf8');\n\n  let code = '';\n  process.stdin.on('data'\x2C (d) => {\n    code += d;\n  });\n\n  process.stdin.on('end'\x2C () => {\n    callback(code);\n  });\n}\n\nmodule.exports = {\n  readStdin\x2C\n  tryGetCwd\x2C\n  evalModule\x2C\n  evalScript\x2C\n  onGlobalUncaughtException: createOnGlobalUncaughtException()\x2C\n  setUncaughtExceptionCaptureCallback\x2C\n  hasUncaughtExceptionCaptureCallback\n};\n
code-source-info,0xb46da65def0,70,4337,6598,C0O4501C5O4501C8O4792C13O4813C23O4866C29O4866C34O4901C37O4930C42O4930C48O4984C63O5018C74O5060C94O5152C96O4984C107O5291C118O5353C121O5361C135O5361C140O5409C145O5435C151O5463C156O5485C161O5485C168O5511C171O5524C185O5524C195O5732C198O5745C204O5767C208O5784C212O5802C217O5819C221O5834C224O5842C235O5842C247O5953C248O5966C249O6110C255O6110C260O6127C268O6128C273O6224C278O6228C283O6284C288O6284C292O6312C293O6324C298O6341C305O6341C311O6384C316O6384C320O6419C325O6419C330O6255C333O6556C338O6556C341O6582C342O6594,,
code-creation,LazyCompile,10,279290,0xb46da65e8e8,18,clearDefaultTriggerAsyncId node:internal/async_hooks:441:36,0xb46651718e0,~
code-source-info,0xb46da65e8e8,19,15227,15281,C0O15234C7O15250C12O15274C17O15280,,
tick,0x103b487d6,279908,0,0x0,0
code-creation,LazyCompile,10,280599,0xb46da65ea00,46,beforeInspector node:internal/errors:751:18,0xb46651609c8,~
code-source-info,0xb46da65ea00,17,22496,22872,C0O22510C2O22527C4O22526C11O22594C15O22600C19O22706C21O22726C23O22725C27O22755C31O22718C41O22862C45O22868,,
code-creation,LazyCompile,10,280670,0xb46da65ed20,210,enhanceStackTrace node:events:428:27,0xb469fce2d40,~
code-source-info,0xb46da65ed20,29,12386,13119,C0O12416C6O12454C11O12440C16O12471C18O12480C23O12506C28O12524C42O12515C45O12608C50O12634C61O12672C68O12697C71O12722C79O12697C88O12672C94O12759C101O12784C104O12809C112O12784C121O12759C127O12854C132O12854C138O12838C143O12843C148O12900C149O12908C154O12919C161O12957C167O12966C177O12919C182O13068C189O13074C195O13082C201O13082C206O13080C209O13117,,
code-creation,LazyCompile,10,280777,0xb46da65f0c8,343,prepareStackTrace node:internal/errors:90:27,0xb466515f388,~
code-source-info,0xb46da65f0c8,17,2155,3643,C0O2297C5O2320C10O2320C17O2348C22O2367C27O2367C33O2383C38O2402C43O2408C48O2428C53O2444C54O2471C55O2476C61O2479C66O2481C74O2502C78O2520C83O2558C86O2520C93O2604C97O2611C101O2618C102O2618C107O2648C109O2653C115O2656C120O2658C128O2683C132O2693C137O2723C140O2693C147O2754C156O2787C163O2754C168O2801C170O2625C175O2585C178O2986C185O2995C187O2993C192O3022C199O3050C202O3022C207O3106C221O3106C227O3166C229O3189C231O3185C236O3202C238O3224C239O3332C241O3347C248O3364C253O3403C265O3418C280O3434C291O3460C296O3474C301O3521C307O3528C312O3541C314O3560C315O3567C327O3600C333O3600C342O3641,,
code-creation,LazyCompile,10,280872,0xb46da65f3c0,70,maybeOverridePrepareStackTrace node:internal/errors:135:40,0xb466515fed8,~
code-source-info,0xb46da65f3c0,17,3685,4392,C0O3913C7O3918C18O3978C23O3984C28O3984C34O4016C35O4239C40O4267C48O4307C53O4331C58O4331C64O4363C65O4371C69O4390,,
tick,0x102ab5450,281202,0,0x0,0,0x10280b9f0,0x10317b12c,0xb46da65f215,0x1027fe770,0xb46da65ed67,0xb46da65ea1b
code-creation,LazyCompile,10,282184,0xb46da65f5e8,158,identicalSequenceRange node:internal/util/inspect:1197:32,0xb469fcd78f8,~
script-source,26,node:internal/util/inspect,'use strict';\n\nconst {\n  Array\x2C\n  ArrayIsArray\x2C\n  ArrayPrototypeFilter\x2C\n  ArrayPrototypeForEach\x2C\n  ArrayPrototypePop\x2C\n  ArrayPrototypePush\x2C\n  ArrayPrototypePushApply\x2C\n  ArrayPrototypeSort\x2C\n  ArrayPrototypeUnshift\x2C\n  BigIntPrototypeValueOf\x2C\n  BooleanPrototypeValueOf\x2C\n  DatePrototypeGetTime\x2C\n  DatePrototypeToISOString\x2C\n  DatePrototypeToString\x2C\n  ErrorPrototypeToString\x2C\n  FunctionPrototypeCall\x2C\n  FunctionPrototypeToString\x2C\n  JSONStringify\x2C\n  MapPrototypeGetSize\x2C\n  MapPrototypeEntries\x2C\n  MathFloor\x2C\n  MathMax\x2C\n  MathMin\x2C\n  MathRound\x2C\n  MathSqrt\x2C\n  MathTrunc\x2C\n  Number\x2C\n  NumberIsFinite\x2C\n  NumberIsNaN\x2C\n  NumberParseFloat\x2C\n  NumberParseInt\x2C\n  NumberPrototypeValueOf\x2C\n  Object\x2C\n  ObjectAssign\x2C\n  ObjectCreate\x2C\n  ObjectDefineProperty\x2C\n  ObjectGetOwnPropertyDescriptor\x2C\n  ObjectGetOwnPropertyNames\x2C\n  ObjectGetOwnPropertySymbols\x2C\n  ObjectGetPrototypeOf\x2C\n  ObjectIs\x2C\n  ObjectKeys\x2C\n  ObjectPrototypeHasOwnProperty\x2C\n  ObjectPrototypePropertyIsEnumerable\x2C\n  ObjectSeal\x2C\n  ObjectSetPrototypeOf\x2C\n  ReflectOwnKeys\x2C\n  RegExp\x2C\n  RegExpPrototypeExec\x2C\n  RegExpPrototypeSymbolReplace\x2C\n  RegExpPrototypeToString\x2C\n  SafeStringIterator\x2C\n  SafeMap\x2C\n  SafeSet\x2C\n  SetPrototypeGetSize\x2C\n  SetPrototypeValues\x2C\n  String\x2C\n  StringPrototypeCharCodeAt\x2C\n  StringPrototypeCodePointAt\x2C\n  StringPrototypeIncludes\x2C\n  StringPrototypeNormalize\x2C\n  StringPrototypePadEnd\x2C\n  StringPrototypePadStart\x2C\n  StringPrototypeRepeat\x2C\n  StringPrototypeSlice\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n  StringPrototypeTrim\x2C\n  StringPrototypeValueOf\x2C\n  SymbolPrototypeToString\x2C\n  SymbolPrototypeValueOf\x2C\n  SymbolIterator\x2C\n  SymbolToStringTag\x2C\n  TypedArrayPrototypeGetLength\x2C\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\n  Uint8Array\x2C\n  globalThis\x2C\n  uncurryThis\x2C\n} = primordials;\n\nconst {\n  getOwnNonIndexProperties\x2C\n  getPromiseDetails\x2C\n  getProxyDetails\x2C\n  kPending\x2C\n  kRejected\x2C\n  previewEntries\x2C\n  getConstructorName: internalGetConstructorName\x2C\n  getExternalValue\x2C\n  propertyFilter: {\n    ALL_PROPERTIES\x2C\n    ONLY_ENUMERABLE\n  }\n} = internalBinding('util');\n\nconst {\n  customInspectSymbol\x2C\n  isError\x2C\n  join\x2C\n  removeColors\n} = require('internal/util');\n\nconst {\n  isStackOverflowError\n} = require('internal/errors');\n\nconst {\n  isAsyncFunction\x2C\n  isGeneratorFunction\x2C\n  isAnyArrayBuffer\x2C\n  isArrayBuffer\x2C\n  isArgumentsObject\x2C\n  isBoxedPrimitive\x2C\n  isDataView\x2C\n  isExternal\x2C\n  isMap\x2C\n  isMapIterator\x2C\n  isModuleNamespaceObject\x2C\n  isNativeError\x2C\n  isPromise\x2C\n  isSet\x2C\n  isSetIterator\x2C\n  isWeakMap\x2C\n  isWeakSet\x2C\n  isRegExp\x2C\n  isDate\x2C\n  isTypedArray\x2C\n  isStringObject\x2C\n  isNumberObject\x2C\n  isBooleanObject\x2C\n  isBigIntObject\x2C\n} = require('internal/util/types');\n\nconst assert = require('internal/assert');\n\nconst { NativeModule } = require('internal/bootstrap/loaders');\nconst {\n  validateObject\x2C\n  validateString\x2C\n} = require('internal/validators');\n\nlet hexSlice;\nlet internalUrl;\n\nfunction pathToFileUrlHref(filepath) {\n  internalUrl ??= require('internal/url');\n  return internalUrl.pathToFileURL(filepath).href;\n}\n\nconst builtInObjects = new SafeSet(\n  ArrayPrototypeFilter(\n    ObjectGetOwnPropertyNames(globalThis)\x2C\n    (e) => RegExpPrototypeExec(/^[A-Z][a-zA-Z0-9]+$/\x2C e) !== null\n  )\n);\n\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\n\n// These options must stay in sync with `getUserOptions`. So if any option will\n// be added or removed\x2C `getUserOptions` must also be updated accordingly.\nconst inspectDefaultOptions = ObjectSeal({\n  showHidden: false\x2C\n  depth: 2\x2C\n  colors: false\x2C\n  customInspect: true\x2C\n  showProxy: false\x2C\n  maxArrayLength: 100\x2C\n  maxStringLength: 10000\x2C\n  breakLength: 80\x2C\n  compact: 3\x2C\n  sorted: false\x2C\n  getters: false\x2C\n  numericSeparator: false\x2C\n});\n\nconst kObjectType = 0;\nconst kArrayType = 1;\nconst kArrayExtrasType = 2;\n\n/* eslint-disable no-control-regex */\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\n/* eslint-enable no-control-regex */\n\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\n\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\n\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\n\nconst kMinLineLength = 16;\n\n// Constants to map the iterator state.\nconst kWeak = 0;\nconst kIterator = 1;\nconst kMapEntries = 2;\n\n// Escaped control characters (plus the single quote and the backslash). Use\n// empty strings to fill up unused entries.\nconst meta = [\n  '\\\\x00'\x2C '\\\\x01'\x2C '\\\\x02'\x2C '\\\\x03'\x2C '\\\\x04'\x2C '\\\\x05'\x2C '\\\\x06'\x2C '\\\\x07'\x2C // x07\n  '\\\\b'\x2C '\\\\t'\x2C '\\\\n'\x2C '\\\\x0B'\x2C '\\\\f'\x2C '\\\\r'\x2C '\\\\x0E'\x2C '\\\\x0F'\x2C           // x0F\n  '\\\\x10'\x2C '\\\\x11'\x2C '\\\\x12'\x2C '\\\\x13'\x2C '\\\\x14'\x2C '\\\\x15'\x2C '\\\\x16'\x2C '\\\\x17'\x2C // x17\n  '\\\\x18'\x2C '\\\\x19'\x2C '\\\\x1A'\x2C '\\\\x1B'\x2C '\\\\x1C'\x2C '\\\\x1D'\x2C '\\\\x1E'\x2C '\\\\x1F'\x2C // x1F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C "\\\\'"\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C      // x2F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x3F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x4F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\\\\\'\x2C ''\x2C ''\x2C ''\x2C     // x5F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x6F\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\x7F'\x2C    // x7F\n  '\\\\x80'\x2C '\\\\x81'\x2C '\\\\x82'\x2C '\\\\x83'\x2C '\\\\x84'\x2C '\\\\x85'\x2C '\\\\x86'\x2C '\\\\x87'\x2C // x87\n  '\\\\x88'\x2C '\\\\x89'\x2C '\\\\x8A'\x2C '\\\\x8B'\x2C '\\\\x8C'\x2C '\\\\x8D'\x2C '\\\\x8E'\x2C '\\\\x8F'\x2C // x8F\n  '\\\\x90'\x2C '\\\\x91'\x2C '\\\\x92'\x2C '\\\\x93'\x2C '\\\\x94'\x2C '\\\\x95'\x2C '\\\\x96'\x2C '\\\\x97'\x2C // x97\n  '\\\\x98'\x2C '\\\\x99'\x2C '\\\\x9A'\x2C '\\\\x9B'\x2C '\\\\x9C'\x2C '\\\\x9D'\x2C '\\\\x9E'\x2C '\\\\x9F'\x2C // x9F\n];\n\n// Regex used for ansi escape code splitting\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\n// License: MIT\x2C authors: @sindresorhus\x2C Qix-\x2C arjunmehta and LitoMore\n// Matches all ansi escape code sequences in a string\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\n  '|(?:(?:\\\\d{1\x2C4}(?:;\\\\d{0\x2C4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\nconst ansi = new RegExp(ansiPattern\x2C 'g');\n\nlet getStringWidth;\n\nfunction getUserOptions(ctx\x2C isCrossContext) {\n  const ret = {\n    stylize: ctx.stylize\x2C\n    showHidden: ctx.showHidden\x2C\n    depth: ctx.depth\x2C\n    colors: ctx.colors\x2C\n    customInspect: ctx.customInspect\x2C\n    showProxy: ctx.showProxy\x2C\n    maxArrayLength: ctx.maxArrayLength\x2C\n    maxStringLength: ctx.maxStringLength\x2C\n    breakLength: ctx.breakLength\x2C\n    compact: ctx.compact\x2C\n    sorted: ctx.sorted\x2C\n    getters: ctx.getters\x2C\n    numericSeparator: ctx.numericSeparator\x2C\n    ...ctx.userOptions\n  };\n\n  // Typically\x2C the target value will be an instance of `Object`. If that is\n  // *not* the case\x2C the object may come from another vm.Context\x2C and we want\n  // to avoid passing it objects from this Context in that case\x2C so we remove\n  // the prototype from the returned object itself + the `stylize()` function\x2C\n  // and remove all other non-primitives\x2C including non-primitive user options.\n  if (isCrossContext) {\n    ObjectSetPrototypeOf(ret\x2C null);\n    for (const key of ObjectKeys(ret)) {\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\n          ret[key] !== null) {\n        delete ret[key];\n      }\n    }\n    ret.stylize = ObjectSetPrototypeOf((value\x2C flavour) => {\n      let stylized;\n      try {\n        stylized = `${ctx.stylize(value\x2C flavour)}`;\n      } catch {\n        // Continue regardless of error.\n      }\n\n      if (typeof stylized !== 'string') return value;\n      // `stylized` is a string as it should be\x2C which is safe to pass along.\n      return stylized;\n    }\x2C null);\n  }\n\n  return ret;\n}\n\n/**\n * Echos the value of any input. Tries to print the value out\n * in the best way possible given the different types.\n *\n * @param {any} value The value to print out.\n * @param {object} opts Optional options object that alters the output.\n */\n/* Legacy: value\x2C showHidden\x2C depth\x2C colors */\nfunction inspect(value\x2C opts) {\n  // Default options\n  const ctx = {\n    budget: {}\x2C\n    indentationLvl: 0\x2C\n    seen: []\x2C\n    currentDepth: 0\x2C\n    stylize: stylizeNoColor\x2C\n    showHidden: inspectDefaultOptions.showHidden\x2C\n    depth: inspectDefaultOptions.depth\x2C\n    colors: inspectDefaultOptions.colors\x2C\n    customInspect: inspectDefaultOptions.customInspect\x2C\n    showProxy: inspectDefaultOptions.showProxy\x2C\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\x2C\n    maxStringLength: inspectDefaultOptions.maxStringLength\x2C\n    breakLength: inspectDefaultOptions.breakLength\x2C\n    compact: inspectDefaultOptions.compact\x2C\n    sorted: inspectDefaultOptions.sorted\x2C\n    getters: inspectDefaultOptions.getters\x2C\n    numericSeparator: inspectDefaultOptions.numericSeparator\x2C\n  };\n  if (arguments.length > 1) {\n    // Legacy...\n    if (arguments.length > 2) {\n      if (arguments[2] !== undefined) {\n        ctx.depth = arguments[2];\n      }\n      if (arguments.length > 3 && arguments[3] !== undefined) {\n        ctx.colors = arguments[3];\n      }\n    }\n    // Set user-specified options\n    if (typeof opts === 'boolean') {\n      ctx.showHidden = opts;\n    } else if (opts) {\n      const optKeys = ObjectKeys(opts);\n      for (let i = 0; i < optKeys.length; ++i) {\n        const key = optKeys[i];\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\n        // this function public or add a new API with a similar or better\n        // functionality.\n        if (\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\x2C key) ||\n          key === 'stylize') {\n          ctx[key] = opts[key];\n        } else if (ctx.userOptions === undefined) {\n          // This is required to pass through the actual user input.\n          ctx.userOptions = opts;\n        }\n      }\n    }\n  }\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\n  return formatValue(ctx\x2C value\x2C 0);\n}\ninspect.custom = customInspectSymbol;\n\nObjectDefineProperty(inspect\x2C 'defaultOptions'\x2C {\n  __proto__: null\x2C\n  get() {\n    return inspectDefaultOptions;\n  }\x2C\n  set(options) {\n    validateObject(options\x2C 'options');\n    return ObjectAssign(inspectDefaultOptions\x2C options);\n  }\n});\n\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\n// Each color consists of an array with the color code as first entry and the\n// reset code as second entry.\nconst defaultFG = 39;\nconst defaultBG = 49;\ninspect.colors = ObjectAssign(ObjectCreate(null)\x2C {\n  reset: [0\x2C 0]\x2C\n  bold: [1\x2C 22]\x2C\n  dim: [2\x2C 22]\x2C // Alias: faint\n  italic: [3\x2C 23]\x2C\n  underline: [4\x2C 24]\x2C\n  blink: [5\x2C 25]\x2C\n  // Swap foreground and background colors\n  inverse: [7\x2C 27]\x2C // Alias: swapcolors\x2C swapColors\n  hidden: [8\x2C 28]\x2C // Alias: conceal\n  strikethrough: [9\x2C 29]\x2C // Alias: strikeThrough\x2C crossedout\x2C crossedOut\n  doubleunderline: [21\x2C 24]\x2C // Alias: doubleUnderline\n  black: [30\x2C defaultFG]\x2C\n  red: [31\x2C defaultFG]\x2C\n  green: [32\x2C defaultFG]\x2C\n  yellow: [33\x2C defaultFG]\x2C\n  blue: [34\x2C defaultFG]\x2C\n  magenta: [35\x2C defaultFG]\x2C\n  cyan: [36\x2C defaultFG]\x2C\n  white: [37\x2C defaultFG]\x2C\n  bgBlack: [40\x2C defaultBG]\x2C\n  bgRed: [41\x2C defaultBG]\x2C\n  bgGreen: [42\x2C defaultBG]\x2C\n  bgYellow: [43\x2C defaultBG]\x2C\n  bgBlue: [44\x2C defaultBG]\x2C\n  bgMagenta: [45\x2C defaultBG]\x2C\n  bgCyan: [46\x2C defaultBG]\x2C\n  bgWhite: [47\x2C defaultBG]\x2C\n  framed: [51\x2C 54]\x2C\n  overlined: [53\x2C 55]\x2C\n  gray: [90\x2C defaultFG]\x2C // Alias: grey\x2C blackBright\n  redBright: [91\x2C defaultFG]\x2C\n  greenBright: [92\x2C defaultFG]\x2C\n  yellowBright: [93\x2C defaultFG]\x2C\n  blueBright: [94\x2C defaultFG]\x2C\n  magentaBright: [95\x2C defaultFG]\x2C\n  cyanBright: [96\x2C defaultFG]\x2C\n  whiteBright: [97\x2C defaultFG]\x2C\n  bgGray: [100\x2C defaultBG]\x2C // Alias: bgGrey\x2C bgBlackBright\n  bgRedBright: [101\x2C defaultBG]\x2C\n  bgGreenBright: [102\x2C defaultBG]\x2C\n  bgYellowBright: [103\x2C defaultBG]\x2C\n  bgBlueBright: [104\x2C defaultBG]\x2C\n  bgMagentaBright: [105\x2C defaultBG]\x2C\n  bgCyanBright: [106\x2C defaultBG]\x2C\n  bgWhiteBright: [107\x2C defaultBG]\x2C\n});\n\nfunction defineColorAlias(target\x2C alias) {\n  ObjectDefineProperty(inspect.colors\x2C alias\x2C {\n    __proto__: null\x2C\n    get() {\n      return this[target];\n    }\x2C\n    set(value) {\n      this[target] = value;\n    }\x2C\n    configurable: true\x2C\n    enumerable: false\n  });\n}\n\ndefineColorAlias('gray'\x2C 'grey');\ndefineColorAlias('gray'\x2C 'blackBright');\ndefineColorAlias('bgGray'\x2C 'bgGrey');\ndefineColorAlias('bgGray'\x2C 'bgBlackBright');\ndefineColorAlias('dim'\x2C 'faint');\ndefineColorAlias('strikethrough'\x2C 'crossedout');\ndefineColorAlias('strikethrough'\x2C 'strikeThrough');\ndefineColorAlias('strikethrough'\x2C 'crossedOut');\ndefineColorAlias('hidden'\x2C 'conceal');\ndefineColorAlias('inverse'\x2C 'swapColors');\ndefineColorAlias('inverse'\x2C 'swapcolors');\ndefineColorAlias('doubleunderline'\x2C 'doubleUnderline');\n\n// TODO(BridgeAR): Add function style support for more complex styles.\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = ObjectAssign(ObjectCreate(null)\x2C {\n  special: 'cyan'\x2C\n  number: 'yellow'\x2C\n  bigint: 'yellow'\x2C\n  boolean: 'yellow'\x2C\n  undefined: 'grey'\x2C\n  null: 'bold'\x2C\n  string: 'green'\x2C\n  symbol: 'green'\x2C\n  date: 'magenta'\x2C\n  // "name": intentionally not styling\n  // TODO(BridgeAR): Highlight regular expressions properly.\n  regexp: 'red'\x2C\n  module: 'underline'\n});\n\nfunction addQuotes(str\x2C quotes) {\n  if (quotes === -1) {\n    return `"${str}"`;\n  }\n  if (quotes === -2) {\n    return `\\`${str}\\``;\n  }\n  return `'${str}'`;\n}\n\nfunction escapeFn(str) {\n  const charCode = StringPrototypeCharCodeAt(str);\n  return meta.length > charCode ? meta[charCode] : `\\\\u${charCode.toString(16)}`;\n}\n\n// Escape control characters\x2C single quotes and the backslash.\n// This is similar to JSON stringify escaping.\nfunction strEscape(str) {\n  let escapeTest = strEscapeSequencesRegExp;\n  let escapeReplace = strEscapeSequencesReplacer;\n  let singleQuote = 39;\n\n  // Check for double quotes. If not present\x2C do not escape single quotes and\n  // instead wrap the text in double quotes. If double quotes exist\x2C check for\n  // backticks. If they do not exist\x2C use those as fallback instead of the\n  // double quotes.\n  if (StringPrototypeIncludes(str\x2C "'")) {\n    // This invalidates the charCode and therefore can not be matched for\n    // anymore.\n    if (!StringPrototypeIncludes(str\x2C '"')) {\n      singleQuote = -1;\n    } else if (!StringPrototypeIncludes(str\x2C '`') &&\n               !StringPrototypeIncludes(str\x2C '${')) {\n      singleQuote = -2;\n    }\n    if (singleQuote !== 39) {\n      escapeTest = strEscapeSequencesRegExpSingle;\n      escapeReplace = strEscapeSequencesReplacerSingle;\n    }\n  }\n\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\n  if (str.length < 5000 && RegExpPrototypeExec(escapeTest\x2C str) === null)\n    return addQuotes(str\x2C singleQuote);\n  if (str.length > 100) {\n    str = RegExpPrototypeSymbolReplace(escapeReplace\x2C str\x2C escapeFn);\n    return addQuotes(str\x2C singleQuote);\n  }\n\n  let result = '';\n  let last = 0;\n  for (let i = 0; i < str.length; i++) {\n    const point = StringPrototypeCharCodeAt(str\x2C i);\n    if (point === singleQuote ||\n        point === 92 ||\n        point < 32 ||\n        (point > 126 && point < 160)) {\n      if (last === i) {\n        result += meta[point];\n      } else {\n        result += `${StringPrototypeSlice(str\x2C last\x2C i)}${meta[point]}`;\n      }\n      last = i + 1;\n    } else if (point >= 0xd800 && point <= 0xdfff) {\n      if (point <= 0xdbff && i + 1 < str.length) {\n        const point = StringPrototypeCharCodeAt(str\x2C i + 1);\n        if (point >= 0xdc00 && point <= 0xdfff) {\n          i++;\n          continue;\n        }\n      }\n      result += `${StringPrototypeSlice(str\x2C last\x2C i)}\\\\u${point.toString(16)}`;\n      last = i + 1;\n    }\n  }\n\n  if (last !== str.length) {\n    result += StringPrototypeSlice(str\x2C last);\n  }\n  return addQuotes(result\x2C singleQuote);\n}\n\nfunction stylizeWithColor(str\x2C styleType) {\n  const style = inspect.styles[styleType];\n  if (style !== undefined) {\n    const color = inspect.colors[style];\n    if (color !== undefined)\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\n  }\n  return str;\n}\n\nfunction stylizeNoColor(str) {\n  return str;\n}\n\n// Return a new empty array to push in the results of the default formatter.\nfunction getEmptyFormatArray() {\n  return [];\n}\n\nfunction isInstanceof(object\x2C proto) {\n  try {\n    return object instanceof proto;\n  } catch {\n    return false;\n  }\n}\n\nfunction getConstructorName(obj\x2C ctx\x2C recurseTimes\x2C protoProps) {\n  let firstProto;\n  const tmp = obj;\n  while (obj || isUndetectableObject(obj)) {\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n    if (descriptor !== undefined &&\n        typeof descriptor.value === 'function' &&\n        descriptor.value.name !== '' &&\n        isInstanceof(tmp\x2C descriptor.value)) {\n      if (protoProps !== undefined &&\n         (firstProto !== obj ||\n         !builtInObjects.has(descriptor.value.name))) {\n        addPrototypeProperties(\n          ctx\x2C tmp\x2C firstProto || tmp\x2C recurseTimes\x2C protoProps);\n      }\n      return String(descriptor.value.name);\n    }\n\n    obj = ObjectGetPrototypeOf(obj);\n    if (firstProto === undefined) {\n      firstProto = obj;\n    }\n  }\n\n  if (firstProto === null) {\n    return null;\n  }\n\n  const res = internalGetConstructorName(tmp);\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return `${res} <Complex prototype>`;\n  }\n\n  const protoConstr = getConstructorName(\n    firstProto\x2C ctx\x2C recurseTimes + 1\x2C protoProps);\n\n  if (protoConstr === null) {\n    return `${res} <${inspect(firstProto\x2C {\n      ...ctx\x2C\n      customInspect: false\x2C\n      depth: -1\n    })}>`;\n  }\n\n  return `${res} <${protoConstr}>`;\n}\n\n// This function has the side effect of adding prototype properties to the\n// `output` argument (which is an array). This is intended to highlight user\n// defined prototype properties.\nfunction addPrototypeProperties(ctx\x2C main\x2C obj\x2C recurseTimes\x2C output) {\n  let depth = 0;\n  let keys;\n  let keySet;\n  do {\n    if (depth !== 0 || main === obj) {\n      obj = ObjectGetPrototypeOf(obj);\n      // Stop as soon as a null prototype is encountered.\n      if (obj === null) {\n        return;\n      }\n      // Stop as soon as a built-in object type is detected.\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\n      if (descriptor !== undefined &&\n          typeof descriptor.value === 'function' &&\n          builtInObjects.has(descriptor.value.name)) {\n        return;\n      }\n    }\n\n    if (depth === 0) {\n      keySet = new SafeSet();\n    } else {\n      ArrayPrototypeForEach(keys\x2C (key) => keySet.add(key));\n    }\n    // Get all own property names and symbols.\n    keys = ReflectOwnKeys(obj);\n    ArrayPrototypePush(ctx.seen\x2C main);\n    for (const key of keys) {\n      // Ignore the `constructor` property and keys that exist on layers above.\n      if (key === 'constructor' ||\n          ObjectPrototypeHasOwnProperty(main\x2C key) ||\n          (depth !== 0 && keySet.has(key))) {\n        continue;\n      }\n      const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\n      if (typeof desc.value === 'function') {\n        continue;\n      }\n      const value = formatProperty(\n        ctx\x2C obj\x2C recurseTimes\x2C key\x2C kObjectType\x2C desc\x2C main);\n      if (ctx.colors) {\n        // Faint!\n        ArrayPrototypePush(output\x2C `\\u001b[2m${value}\\u001b[22m`);\n      } else {\n        ArrayPrototypePush(output\x2C value);\n      }\n    }\n    ArrayPrototypePop(ctx.seen);\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\n  // is not a good choice here\x2C because it's as if the properties are declared\n  // on the current object from the users perspective.\n  } while (++depth !== 3);\n}\n\nfunction getPrefix(constructor\x2C tag\x2C fallback\x2C size = '') {\n  if (constructor === null) {\n    if (tag !== '' && fallback !== tag) {\n      return `[${fallback}${size}: null prototype] [${tag}] `;\n    }\n    return `[${fallback}${size}: null prototype] `;\n  }\n\n  if (tag !== '' && constructor !== tag) {\n    return `${constructor}${size} [${tag}] `;\n  }\n  return `${constructor}${size} `;\n}\n\n// Look up the keys of the object.\nfunction getKeys(value\x2C showHidden) {\n  let keys;\n  const symbols = ObjectGetOwnPropertySymbols(value);\n  if (showHidden) {\n    keys = ObjectGetOwnPropertyNames(value);\n    if (symbols.length !== 0)\n      ArrayPrototypePushApply(keys\x2C symbols);\n  } else {\n    // This might throw if `value` is a Module Namespace Object from an\n    // unevaluated module\x2C but we don't want to perform the actual type\n    // check because it's expensive.\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\n    // and modify this logic as needed.\n    try {\n      keys = ObjectKeys(value);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\n             isModuleNamespaceObject(value));\n      keys = ObjectGetOwnPropertyNames(value);\n    }\n    if (symbols.length !== 0) {\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\x2C key);\n      ArrayPrototypePushApply(keys\x2C ArrayPrototypeFilter(symbols\x2C filter));\n    }\n  }\n  return keys;\n}\n\nfunction getCtxStyle(value\x2C constructor\x2C tag) {\n  let fallback = '';\n  if (constructor === null) {\n    fallback = internalGetConstructorName(value);\n    if (fallback === tag) {\n      fallback = 'Object';\n    }\n  }\n  return getPrefix(constructor\x2C tag\x2C fallback);\n}\n\nfunction formatProxy(ctx\x2C proxy\x2C recurseTimes) {\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    return ctx.stylize('Proxy [Array]'\x2C 'special');\n  }\n  recurseTimes += 1;\n  ctx.indentationLvl += 2;\n  const res = [\n    formatValue(ctx\x2C proxy[0]\x2C recurseTimes)\x2C\n    formatValue(ctx\x2C proxy[1]\x2C recurseTimes)\x2C\n  ];\n  ctx.indentationLvl -= 2;\n  return reduceToSingleString(\n    ctx\x2C res\x2C ''\x2C ['Proxy ['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n}\n\n// Note: using `formatValue` directly requires the indentation level to be\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\n// value afterwards again.\nfunction formatValue(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  // Primitive types cannot have properties.\n  if (typeof value !== 'object' &&\n      typeof value !== 'function' &&\n      !isUndetectableObject(value)) {\n    return formatPrimitive(ctx.stylize\x2C value\x2C ctx);\n  }\n  if (value === null) {\n    return ctx.stylize('null'\x2C 'null');\n  }\n\n  // Memorize the context for custom inspection on proxies.\n  const context = value;\n  // Always check for proxies to prevent side effects and to prevent triggering\n  // any proxy handlers.\n  const proxy = getProxyDetails(value\x2C !!ctx.showProxy);\n  if (proxy !== undefined) {\n    if (proxy === null || proxy[0] === null) {\n      return ctx.stylize('<Revoked Proxy>'\x2C 'special');\n    }\n    if (ctx.showProxy) {\n      return formatProxy(ctx\x2C proxy\x2C recurseTimes);\n    }\n    value = proxy;\n  }\n\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it.\n  if (ctx.customInspect) {\n    const maybeCustom = value[customInspectSymbol];\n    if (typeof maybeCustom === 'function' &&\n        // Filter out the util module\x2C its inspect function is special.\n        maybeCustom !== inspect &&\n        // Also filter out any prototype objects using the circular check.\n        !(value.constructor && value.constructor.prototype === value)) {\n      // This makes sure the recurseTimes are reported as before while using\n      // a counter internally.\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\n      const isCrossContext =\n        proxy !== undefined || !(context instanceof Object);\n      const ret = FunctionPrototypeCall(\n        maybeCustom\x2C\n        context\x2C\n        depth\x2C\n        getUserOptions(ctx\x2C isCrossContext)\x2C\n        inspect\n      );\n      // If the custom inspection method returned `this`\x2C don't go into\n      // infinite recursion.\n      if (ret !== context) {\n        if (typeof ret !== 'string') {\n          return formatValue(ctx\x2C ret\x2C recurseTimes);\n        }\n        return ret.replace(/\\n/g\x2C `\\n${' '.repeat(ctx.indentationLvl)}`);\n      }\n    }\n  }\n\n  // Using an array here is actually better for the average case than using\n  // a Set. `seen` will only check for the depth and will never grow too large.\n  if (ctx.seen.includes(value)) {\n    let index = 1;\n    if (ctx.circular === undefined) {\n      ctx.circular = new SafeMap();\n      ctx.circular.set(value\x2C index);\n    } else {\n      index = ctx.circular.get(value);\n      if (index === undefined) {\n        index = ctx.circular.size + 1;\n        ctx.circular.set(value\x2C index);\n      }\n    }\n    return ctx.stylize(`[Circular *${index}]`\x2C 'special');\n  }\n\n  return formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray);\n}\n\nfunction formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\n  let keys;\n  let protoProps;\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\n    protoProps = [];\n  }\n\n  const constructor = getConstructorName(value\x2C ctx\x2C recurseTimes\x2C protoProps);\n  // Reset the variable to check for this later on.\n  if (protoProps !== undefined && protoProps.length === 0) {\n    protoProps = undefined;\n  }\n\n  let tag = value[SymbolToStringTag];\n  // Only list the tag in case it's non-enumerable / not an own property.\n  // Otherwise we'd print this twice.\n  if (typeof tag !== 'string' ||\n      (tag !== '' &&\n      (ctx.showHidden ?\n        ObjectPrototypeHasOwnProperty :\n        ObjectPrototypePropertyIsEnumerable)(\n        value\x2C SymbolToStringTag\n      ))) {\n    tag = '';\n  }\n  let base = '';\n  let formatter = getEmptyFormatArray;\n  let braces;\n  let noIterator = true;\n  let i = 0;\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\n\n  let extrasType = kObjectType;\n\n  // Iterators and the rest are split to reduce checks.\n  // We have to check all values in case the constructor is set to null.\n  // Otherwise it would not possible to identify all types properly.\n  if (SymbolIterator in value || constructor === null) {\n    noIterator = false;\n    if (ArrayIsArray(value)) {\n      // Only set the constructor for non ordinary ("Array [...]") arrays.\n      const prefix = (constructor !== 'Array' || tag !== '') ?\n        getPrefix(constructor\x2C tag\x2C 'Array'\x2C `(${value.length})`) :\n        '';\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\n        return `${braces[0]}]`;\n      extrasType = kArrayExtrasType;\n      formatter = formatArray;\n    } else if (isSet(value)) {\n      const size = SetPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Set'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatSet.bind(null\x2C value) :\n        formatSet.bind(null\x2C SetPrototypeValues(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isMap(value)) {\n      const size = MapPrototypeGetSize(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Map'\x2C `(${size})`);\n      keys = getKeys(value\x2C ctx.showHidden);\n      formatter = constructor !== null ?\n        formatMap.bind(null\x2C value) :\n        formatMap.bind(null\x2C MapPrototypeEntries(value));\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\n        return `${prefix}{}`;\n      braces = [`${prefix}{`\x2C '}'];\n    } else if (isTypedArray(value)) {\n      keys = getOwnNonIndexProperties(value\x2C filter);\n      let bound = value;\n      let fallback = '';\n      if (constructor === null) {\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\n        // Reconstruct the array information.\n        bound = new primordials[fallback](value);\n      }\n      const size = TypedArrayPrototypeGetLength(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C fallback\x2C `(${size})`);\n      braces = [`${prefix}[`\x2C ']'];\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\n        return `${braces[0]}]`;\n      // Special handle the value. The original value is required below. The\n      // bound function is required to reconstruct missing information.\n      formatter = formatTypedArray.bind(null\x2C bound\x2C size);\n      extrasType = kArrayExtrasType;\n    } else if (isMapIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Map'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else if (isSetIterator(value)) {\n      keys = getKeys(value\x2C ctx.showHidden);\n      braces = getIteratorBraces('Set'\x2C tag);\n      // Add braces to the formatter parameters.\n      formatter = formatIterator.bind(null\x2C braces);\n    } else {\n      noIterator = true;\n    }\n  }\n  if (noIterator) {\n    keys = getKeys(value\x2C ctx.showHidden);\n    braces = ['{'\x2C '}'];\n    if (constructor === 'Object') {\n      if (isArgumentsObject(value)) {\n        braces[0] = '[Arguments] {';\n      } else if (tag !== '') {\n        braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Object')}{`;\n      }\n      if (keys.length === 0 && protoProps === undefined) {\n        return `${braces[0]}}`;\n      }\n    } else if (typeof value === 'function') {\n      base = getFunctionBase(value\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined)\n        return ctx.stylize(base\x2C 'special');\n    } else if (isRegExp(value)) {\n      // Make RegExps say that they are RegExps\n      base = RegExpPrototypeToString(\n        constructor !== null ? value : new RegExp(value)\n      );\n      const prefix = getPrefix(constructor\x2C tag\x2C 'RegExp');\n      if (prefix !== 'RegExp ')\n        base = `${prefix}${base}`;\n      if ((keys.length === 0 && protoProps === undefined) ||\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\n        return ctx.stylize(base\x2C 'regexp');\n      }\n    } else if (isDate(value)) {\n      // Make dates with properties first say the date\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\n        DatePrototypeToString(value) :\n        DatePrototypeToISOString(value);\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Date');\n      if (prefix !== 'Date ')\n        base = `${prefix}${base}`;\n      if (keys.length === 0 && protoProps === undefined) {\n        return ctx.stylize(base\x2C 'date');\n      }\n    } else if (isError(value)) {\n      base = formatError(value\x2C constructor\x2C tag\x2C ctx\x2C keys);\n      if (keys.length === 0 && protoProps === undefined)\n        return base;\n    } else if (isAnyArrayBuffer(value)) {\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\n      // Can't do the same for DataView because it has a non-primitive\n      // .buffer property that we need to recurse for.\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\n        'SharedArrayBuffer';\n      const prefix = getPrefix(constructor\x2C tag\x2C arrayType);\n      if (typedArray === undefined) {\n        formatter = formatArrayBuffer;\n      } else if (keys.length === 0 && protoProps === undefined) {\n        return prefix +\n              `{ byteLength: ${formatNumber(ctx.stylize\x2C value.byteLength\x2C false)} }`;\n      }\n      braces[0] = `${prefix}{`;\n      ArrayPrototypeUnshift(keys\x2C 'byteLength');\n    } else if (isDataView(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'DataView')}{`;\n      // .buffer goes last\x2C it's not a primitive like the others.\n      ArrayPrototypeUnshift(keys\x2C 'byteLength'\x2C 'byteOffset'\x2C 'buffer');\n    } else if (isPromise(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Promise')}{`;\n      formatter = formatPromise;\n    } else if (isWeakSet(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakSet')}{`;\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\n    } else if (isWeakMap(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakMap')}{`;\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\n    } else if (isModuleNamespaceObject(value)) {\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Module')}{`;\n      // Special handle keys for namespace objects.\n      formatter = formatNamespaceObject.bind(null\x2C keys);\n    } else if (isBoxedPrimitive(value)) {\n      base = getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag);\n      if (keys.length === 0 && protoProps === undefined) {\n        return base;\n      }\n    } else {\n      if (keys.length === 0 && protoProps === undefined) {\n        if (isExternal(value)) {\n          const address = getExternalValue(value).toString(16);\n          return ctx.stylize(`[External: ${address}]`\x2C 'special');\n        }\n        return `${getCtxStyle(value\x2C constructor\x2C tag)}{}`;\n      }\n      braces[0] = `${getCtxStyle(value\x2C constructor\x2C tag)}{`;\n    }\n  }\n\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\n    let constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    if (constructor !== null)\n      constructorName = `[${constructorName}]`;\n    return ctx.stylize(constructorName\x2C 'special');\n  }\n  recurseTimes += 1;\n\n  ctx.seen.push(value);\n  ctx.currentDepth = recurseTimes;\n  let output;\n  const indentationLvl = ctx.indentationLvl;\n  try {\n    output = formatter(ctx\x2C value\x2C recurseTimes);\n    for (i = 0; i < keys.length; i++) {\n      output.push(\n        formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C extrasType));\n    }\n    if (protoProps !== undefined) {\n      output.push(...protoProps);\n    }\n  } catch (err) {\n    const constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\n    return handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl);\n  }\n  if (ctx.circular !== undefined) {\n    const index = ctx.circular.get(value);\n    if (index !== undefined) {\n      const reference = ctx.stylize(`<ref *${index}>`\x2C 'special');\n      // Add reference always to the very beginning of the output.\n      if (ctx.compact !== true) {\n        base = base === '' ? reference : `${reference} ${base}`;\n      } else {\n        braces[0] = `${reference} ${braces[0]}`;\n      }\n    }\n  }\n  ctx.seen.pop();\n\n  if (ctx.sorted) {\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\n    if (extrasType === kObjectType) {\n      output = output.sort(comparator);\n    } else if (keys.length > 1) {\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\n      output.splice(output.length - keys.length\x2C keys.length\x2C ...sorted);\n    }\n  }\n\n  const res = reduceToSingleString(\n    ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value);\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\n  const newLength = budget + res.length;\n  ctx.budget[ctx.indentationLvl] = newLength;\n  // If any indentationLvl exceeds this limit\x2C limit further inspecting to the\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\n  // This limit also makes sure that huge objects don't block the event loop\n  // significantly.\n  if (newLength > 2 ** 27) {\n    ctx.depth = -1;\n  }\n  return res;\n}\n\nfunction getIteratorBraces(type\x2C tag) {\n  if (tag !== `${type} Iterator`) {\n    if (tag !== '')\n      tag += '] [';\n    tag += `${type} Iterator`;\n  }\n  return [`[${tag}] {`\x2C '}'];\n}\n\nfunction getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag) {\n  let fn;\n  let type;\n  if (isNumberObject(value)) {\n    fn = NumberPrototypeValueOf;\n    type = 'Number';\n  } else if (isStringObject(value)) {\n    fn = StringPrototypeValueOf;\n    type = 'String';\n    // For boxed Strings\x2C we have to remove the 0-n indexed entries\x2C\n    // since they just noisy up the output and are redundant\n    // Make boxed primitive Strings look like such\n    keys.splice(0\x2C value.length);\n  } else if (isBooleanObject(value)) {\n    fn = BooleanPrototypeValueOf;\n    type = 'Boolean';\n  } else if (isBigIntObject(value)) {\n    fn = BigIntPrototypeValueOf;\n    type = 'BigInt';\n  } else {\n    fn = SymbolPrototypeValueOf;\n    type = 'Symbol';\n  }\n  let base = `[${type}`;\n  if (type !== constructor) {\n    if (constructor === null) {\n      base += ' (null prototype)';\n    } else {\n      base += ` (${constructor})`;\n    }\n  }\n  base += `: ${formatPrimitive(stylizeNoColor\x2C fn(value)\x2C ctx)}]`;\n  if (tag !== '' && tag !== constructor) {\n    base += ` [${tag}]`;\n  }\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\n    return base;\n  return ctx.stylize(base\x2C StringPrototypeToLowerCase(type));\n}\n\nfunction getClassBase(value\x2C constructor\x2C tag) {\n  const hasName = ObjectPrototypeHasOwnProperty(value\x2C 'name');\n  const name = (hasName && value.name) || '(anonymous)';\n  let base = `class ${name}`;\n  if (constructor !== 'Function' && constructor !== null) {\n    base += ` [${constructor}]`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  if (constructor !== null) {\n    const superName = ObjectGetPrototypeOf(value).name;\n    if (superName) {\n      base += ` extends ${superName}`;\n    }\n  } else {\n    base += ' extends [null prototype]';\n  }\n  return `[${base}]`;\n}\n\nfunction getFunctionBase(value\x2C constructor\x2C tag) {\n  const stringified = FunctionPrototypeToString(value);\n  if (stringified.startsWith('class') && stringified.endsWith('}')) {\n    const slice = stringified.slice(5\x2C -1);\n    const bracketIndex = slice.indexOf('{');\n    if (bracketIndex !== -1 &&\n        (!slice.slice(0\x2C bracketIndex).includes('(') ||\n          // Slow path to guarantee that it's indeed a class.\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\n      return getClassBase(value\x2C constructor\x2C tag);\n    }\n  }\n  let type = 'Function';\n  if (isGeneratorFunction(value)) {\n    type = `Generator${type}`;\n  }\n  if (isAsyncFunction(value)) {\n    type = `Async${type}`;\n  }\n  let base = `[${type}`;\n  if (constructor === null) {\n    base += ' (null prototype)';\n  }\n  if (value.name === '') {\n    base += ' (anonymous)';\n  } else {\n    base += `: ${value.name}`;\n  }\n  base += ']';\n  if (constructor !== type && constructor !== null) {\n    base += ` ${constructor}`;\n  }\n  if (tag !== '' && constructor !== tag) {\n    base += ` [${tag}]`;\n  }\n  return base;\n}\n\nfunction identicalSequenceRange(a\x2C b) {\n  for (let i = 0; i < a.length - 3; i++) {\n    // Find the first entry of b that matches the current entry of a.\n    const pos = b.indexOf(a[i]);\n    if (pos !== -1) {\n      const rest = b.length - pos;\n      if (rest > 3) {\n        let len = 1;\n        const maxLen = MathMin(a.length - i\x2C rest);\n        // Count the number of consecutive entries.\n        while (maxLen > len && a[i + len] === b[pos + len]) {\n          len++;\n        }\n        if (len > 3) {\n          return { len\x2C offset: i };\n        }\n      }\n    }\n  }\n\n  return { len: 0\x2C offset: 0 };\n}\n\nfunction getStackString(error) {\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\n}\n\nfunction getStackFrames(ctx\x2C err\x2C stack) {\n  const frames = stack.split('\\n');\n\n  // Remove stack frames identical to frames in cause.\n  if (err.cause && isError(err.cause)) {\n    const causeStack = getStackString(err.cause);\n    const causeStackStart = causeStack.indexOf('\\n    at');\n    if (causeStackStart !== -1) {\n      const causeFrames = causeStack.slice(causeStackStart + 1).split('\\n');\n      const { len\x2C offset } = identicalSequenceRange(frames\x2C causeFrames);\n      if (len > 0) {\n        const skipped = len - 2;\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\n        frames.splice(offset + 1\x2C skipped\x2C ctx.stylize(msg\x2C 'undefined'));\n      }\n    }\n  }\n  return frames;\n}\n\nfunction improveStack(stack\x2C constructor\x2C name\x2C tag) {\n  // A stack trace may contain arbitrary data. Only manipulate the output\n  // for "regular errors" (errors that "look normal") for now.\n  let len = name.length;\n\n  if (constructor === null ||\n      (name.endsWith('Error') &&\n      stack.startsWith(name) &&\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\n    let fallback = 'Error';\n    if (constructor === null) {\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\n      fallback = (start && start[1]) || '';\n      len = fallback.length;\n      fallback = fallback || 'Error';\n    }\n    const prefix = getPrefix(constructor\x2C tag\x2C fallback).slice(0\x2C -1);\n    if (name !== prefix) {\n      if (prefix.includes(name)) {\n        if (len === 0) {\n          stack = `${prefix}: ${stack}`;\n        } else {\n          stack = `${prefix}${stack.slice(len)}`;\n        }\n      } else {\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\n      }\n    }\n  }\n  return stack;\n}\n\nfunction removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack) {\n  if (!ctx.showHidden && keys.length !== 0) {\n    for (const name of ['name'\x2C 'message'\x2C 'stack']) {\n      const index = keys.indexOf(name);\n      // Only hide the property in case it's part of the original stack\n      if (index !== -1 && stack.includes(err[name])) {\n        keys.splice(index\x2C 1);\n      }\n    }\n  }\n}\n\nfunction markNodeModules(ctx\x2C line) {\n  let tempLine = '';\n  let nodeModule;\n  let pos = 0;\n  while ((nodeModule = nodeModulesRegExp.exec(line)) !== null) {\n    // '/node_modules/'.length === 14\n    tempLine += line.slice(pos\x2C nodeModule.index + 14);\n    tempLine += ctx.stylize(nodeModule[1]\x2C 'module');\n    pos = nodeModule.index + nodeModule[0].length;\n  }\n  if (pos !== 0) {\n    line = tempLine + line.slice(pos);\n  }\n  return line;\n}\n\nfunction markCwd(ctx\x2C line\x2C workingDirectory) {\n  let cwdStartPos = line.indexOf(workingDirectory);\n  let tempLine = '';\n  let cwdLength = workingDirectory.length;\n  if (cwdStartPos !== -1) {\n    if (line.slice(cwdStartPos - 7\x2C cwdStartPos) === 'file://') {\n      cwdLength += 7;\n      cwdStartPos -= 7;\n    }\n    const start = line[cwdStartPos - 1] === '(' ? cwdStartPos - 1 : cwdStartPos;\n    const end = start !== cwdStartPos && line.endsWith(')') ? -1 : line.length;\n    const workingDirectoryEndPos = cwdStartPos + cwdLength + 1;\n    const cwdSlice = line.slice(start\x2C workingDirectoryEndPos);\n\n    tempLine += line.slice(0\x2C start);\n    tempLine += ctx.stylize(cwdSlice\x2C 'undefined');\n    tempLine += line.slice(workingDirectoryEndPos\x2C end);\n    if (end === -1) {\n      tempLine += ctx.stylize(')'\x2C 'undefined');\n    }\n  } else {\n    tempLine += line;\n  }\n  return tempLine;\n}\n\nfunction safeGetCWD() {\n  let workingDirectory;\n  try {\n    workingDirectory = process.cwd();\n  } catch {\n    return;\n  }\n  return workingDirectory;\n}\n\nfunction formatError(err\x2C constructor\x2C tag\x2C ctx\x2C keys) {\n  const name = err.name != null ? String(err.name) : 'Error';\n  let stack = getStackString(err);\n\n  removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack);\n\n  if ('cause' in err &&\n      (keys.length === 0 || !keys.includes('cause'))) {\n    keys.push('cause');\n  }\n\n  // Print errors aggregated into AggregateError\n  if (ArrayIsArray(err.errors) &&\n      (keys.length === 0 || !keys.includes('errors'))) {\n    keys.push('errors');\n  }\n\n  stack = improveStack(stack\x2C constructor\x2C name\x2C tag);\n\n  // Ignore the error message if it's contained in the stack.\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\n  if (pos !== -1)\n    pos += err.message.length;\n  // Wrap the error in brackets in case it has no stack trace.\n  const stackStart = stack.indexOf('\\n    at'\x2C pos);\n  if (stackStart === -1) {\n    stack = `[${stack}]`;\n  } else {\n    let newStack = stack.slice(0\x2C stackStart);\n    const stackFramePart = stack.slice(stackStart + 1);\n    const lines = getStackFrames(ctx\x2C err\x2C stackFramePart);\n    if (ctx.colors) {\n      // Highlight userland code and node modules.\n      const workingDirectory = safeGetCWD();\n      let esmWorkingDirectory;\n      for (let line of lines) {\n        const core = line.match(coreModuleRegExp);\n        if (core !== null && NativeModule.exists(core[1])) {\n          newStack += `\\n${ctx.stylize(line\x2C 'undefined')}`;\n        } else {\n          newStack += '\\n';\n\n          line = markNodeModules(ctx\x2C line);\n          if (workingDirectory !== undefined) {\n            let newLine = markCwd(ctx\x2C line\x2C workingDirectory);\n            if (newLine === line) {\n              esmWorkingDirectory ??= pathToFileUrlHref(workingDirectory);\n              newLine = markCwd(ctx\x2C line\x2C esmWorkingDirectory);\n            }\n            line = newLine;\n          }\n\n          newStack += line;\n        }\n      }\n    } else {\n      newStack += `\\n${lines.join('\\n')}`;\n    }\n    stack = newStack;\n  }\n  // The message and the stack have to be indented as well!\n  if (ctx.indentationLvl !== 0) {\n    const indentation = ' '.repeat(ctx.indentationLvl);\n    stack = stack.replace(/\\n/g\x2C `\\n${indentation}`);\n  }\n  return stack;\n}\n\nfunction groupArrayElements(ctx\x2C output\x2C value) {\n  let totalLength = 0;\n  let maxLength = 0;\n  let i = 0;\n  let outputLength = output.length;\n  if (ctx.maxArrayLength < output.length) {\n    // This makes sure the "... n more items" part is not taken into account.\n    outputLength--;\n  }\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\n  const dataLen = new Array(outputLength);\n  // Calculate the total length of all output entries and the individual max\n  // entries length of all output entries. We have to remove colors first\x2C\n  // otherwise the length would not be calculated properly.\n  for (; i < outputLength; i++) {\n    const len = getStringWidth(output[i]\x2C ctx.colors);\n    dataLen[i] = len;\n    totalLength += len + separatorSpace;\n    if (maxLength < len)\n      maxLength = len;\n  }\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\n  // in-between two entries.\n  const actualMax = maxLength + separatorSpace;\n  // Check if at least three entries fit next to each other and prevent grouping\n  // of arrays that contains entries of very different length (i.e.\x2C if a single\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\n  // space in-between small entries would be enormous.\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\n\n    const approxCharHeights = 2.5;\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\n    const biasedMax = MathMax(actualMax - 3 - averageBias\x2C 1);\n    // Dynamically check how many columns seem possible.\n    const columns = MathMin(\n      // Ideally a square should be drawn. We expect a character to be about 2.5\n      // times as high as wide. This is the area formula to calculate a square\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\n      // Divide that by `actualMax` to receive the correct number of columns.\n      // The added bias increases the columns for short entries.\n      MathRound(\n        MathSqrt(\n          approxCharHeights * biasedMax * outputLength\n        ) / biasedMax\n      )\x2C\n      // Do not exceed the breakLength.\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\x2C\n      // Limit array grouping for small `compact` modes as the user requested\n      // minimal grouping.\n      ctx.compact * 4\x2C\n      // Limit the columns to a maximum of fifteen.\n      15\n    );\n    // Return with the original output if no grouping should happen.\n    if (columns <= 1) {\n      return output;\n    }\n    const tmp = [];\n    const maxLineLength = [];\n    for (let i = 0; i < columns; i++) {\n      let lineMaxLength = 0;\n      for (let j = i; j < output.length; j += columns) {\n        if (dataLen[j] > lineMaxLength)\n          lineMaxLength = dataLen[j];\n      }\n      lineMaxLength += separatorSpace;\n      maxLineLength[i] = lineMaxLength;\n    }\n    let order = StringPrototypePadStart;\n    if (value !== undefined) {\n      for (let i = 0; i < output.length; i++) {\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\n          order = StringPrototypePadEnd;\n          break;\n        }\n      }\n    }\n    // Each iteration creates a single line of grouped entries.\n    for (let i = 0; i < outputLength; i += columns) {\n      // The last lines may contain less entries than columns.\n      const max = MathMin(i + columns\x2C outputLength);\n      let str = '';\n      let j = i;\n      for (; j < max - 1; j++) {\n        // Calculate extra color padding in case it's active. This has to be\n        // done line by line as some lines might contain more colors than\n        // others.\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\n        str += order(`${output[j]}\x2C `\x2C padding\x2C ' ');\n      }\n      if (order === StringPrototypePadStart) {\n        const padding = maxLineLength[j - i] +\n                        output[j].length -\n                        dataLen[j] -\n                        separatorSpace;\n        str += StringPrototypePadStart(output[j]\x2C padding\x2C ' ');\n      } else {\n        str += output[j];\n      }\n      ArrayPrototypePush(tmp\x2C str);\n    }\n    if (ctx.maxArrayLength < output.length) {\n      ArrayPrototypePush(tmp\x2C output[outputLength]);\n    }\n    output = tmp;\n  }\n  return output;\n}\n\nfunction handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl) {\n  if (isStackOverflowError(err)) {\n    ctx.seen.pop();\n    ctx.indentationLvl = indentationLvl;\n    return ctx.stylize(\n      `[${constructorName}: Inspection interrupted ` +\n        'prematurely. Maximum call stack size exceeded.]'\x2C\n      'special'\n    );\n  }\n  /* c8 ignore next */\n  assert.fail(err.stack);\n}\n\nfunction addNumericSeparator(integerString) {\n  let result = '';\n  let i = integerString.length;\n  const start = integerString.startsWith('-') ? 1 : 0;\n  for (; i >= start + 4; i -= 3) {\n    result = `_${integerString.slice(i - 3\x2C i)}${result}`;\n  }\n  return i === integerString.length ?\n    integerString :\n    `${integerString.slice(0\x2C i)}${result}`;\n}\n\nfunction addNumericSeparatorEnd(integerString) {\n  let result = '';\n  let i = 0;\n  for (; i < integerString.length - 3; i += 3) {\n    result += `${integerString.slice(i\x2C i + 3)}_`;\n  }\n  return i === 0 ?\n    integerString :\n    `${result}${integerString.slice(i)}`;\n}\n\nfunction formatNumber(fn\x2C number\x2C numericSeparator) {\n  if (!numericSeparator) {\n    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.\n    if (ObjectIs(number\x2C -0)) {\n      return fn('-0'\x2C 'number');\n    }\n    return fn(`${number}`\x2C 'number');\n  }\n  const integer = MathTrunc(number);\n  const string = String(integer);\n  if (integer === number) {\n    if (!NumberIsFinite(number) || string.includes('e')) {\n      return fn(string\x2C 'number');\n    }\n    return fn(`${addNumericSeparator(string)}`\x2C 'number');\n  }\n  if (NumberIsNaN(number)) {\n    return fn(string\x2C 'number');\n  }\n  return fn(`${\n    addNumericSeparator(string)\n  }.${\n    addNumericSeparatorEnd(String(number).slice(string.length + 1))\n  }`\x2C 'number');\n}\n\nfunction formatBigInt(fn\x2C bigint\x2C numericSeparator) {\n  const string = String(bigint);\n  if (!numericSeparator) {\n    return fn(`${string}n`\x2C 'bigint');\n  }\n  return fn(`${addNumericSeparator(string)}n`\x2C 'bigint');\n}\n\nfunction formatPrimitive(fn\x2C value\x2C ctx) {\n  if (typeof value === 'string') {\n    let trailer = '';\n    if (value.length > ctx.maxStringLength) {\n      const remaining = value.length - ctx.maxStringLength;\n      value = value.slice(0\x2C ctx.maxStringLength);\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\n    }\n    if (ctx.compact !== true &&\n        // We do not support handling unicode characters width with\n        // the readline getStringWidth function as there are\n        // performance implications.\n        value.length > kMinLineLength &&\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\n      return value\n        .split(/(?<=\\n)/)\n        .map((line) => fn(strEscape(line)\x2C 'string'))\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\n    }\n    return fn(strEscape(value)\x2C 'string') + trailer;\n  }\n  if (typeof value === 'number')\n    return formatNumber(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'bigint')\n    return formatBigInt(fn\x2C value\x2C ctx.numericSeparator);\n  if (typeof value === 'boolean')\n    return fn(`${value}`\x2C 'boolean');\n  if (typeof value === 'undefined')\n    return fn('undefined'\x2C 'undefined');\n  // es6 symbol primitive\n  return fn(SymbolPrototypeToString(value)\x2C 'symbol');\n}\n\nfunction formatNamespaceObject(keys\x2C ctx\x2C value\x2C recurseTimes) {\n  const output = new Array(keys.length);\n  for (let i = 0; i < keys.length; i++) {\n    try {\n      output[i] = formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C\n                                 kObjectType);\n    } catch (err) {\n      assert(isNativeError(err) && err.name === 'ReferenceError');\n      // Use the existing functionality. This makes sure the indentation and\n      // line breaks are always correct. Otherwise it is very difficult to keep\n      // this aligned\x2C even though this is a hacky way of dealing with this.\n      const tmp = { [keys[i]]: '' };\n      output[i] = formatProperty(ctx\x2C tmp\x2C recurseTimes\x2C keys[i]\x2C kObjectType);\n      const pos = output[i].lastIndexOf(' ');\n      // We have to find the last whitespace and have to replace that value as\n      // it will be visualized as a regular string.\n      output[i] = output[i].slice(0\x2C pos + 1) +\n                  ctx.stylize('<uninitialized>'\x2C 'special');\n    }\n  }\n  // Reset the keys to an empty array. This prevents duplicated inspection.\n  keys.length = 0;\n  return output;\n}\n\n// The array is sparse and/or has extra keys\nfunction formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C maxLength\x2C output\x2C i) {\n  const keys = ObjectKeys(value);\n  let index = i;\n  for (; i < keys.length && output.length < maxLength; i++) {\n    const key = keys[i];\n    const tmp = +key;\n    // Arrays can only have up to 2^32 - 1 entries\n    if (tmp > 2 ** 32 - 2) {\n      break;\n    }\n    if (`${index}` !== key) {\n      if (!numberRegExp.test(key)) {\n        break;\n      }\n      const emptyItems = tmp - index;\n      const ending = emptyItems > 1 ? 's' : '';\n      const message = `<${emptyItems} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n      index = tmp;\n      if (output.length === maxLength) {\n        break;\n      }\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C kArrayType));\n    index++;\n  }\n  const remaining = value.length - index;\n  if (output.length !== maxLength) {\n    if (remaining > 0) {\n      const ending = remaining > 1 ? 's' : '';\n      const message = `<${remaining} empty item${ending}>`;\n      output.push(ctx.stylize(message\x2C 'undefined'));\n    }\n  } else if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatArrayBuffer(ctx\x2C value) {\n  let buffer;\n  try {\n    buffer = new Uint8Array(value);\n  } catch {\n    return [ctx.stylize('(detached)'\x2C 'special')];\n  }\n  if (hexSlice === undefined)\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\n  let str = StringPrototypeTrim(RegExpPrototypeSymbolReplace(\n    /(.{2})/g\x2C\n    hexSlice(buffer\x2C 0\x2C MathMin(ctx.maxArrayLength\x2C buffer.length))\x2C\n    '$1 '));\n  const remaining = buffer.length - ctx.maxArrayLength;\n  if (remaining > 0)\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\n  return [`${ctx.stylize('[Uint8Contents]'\x2C 'special')}: <${str}>`];\n}\n\nfunction formatArray(ctx\x2C value\x2C recurseTimes) {\n  const valLen = value.length;\n  const len = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C valLen);\n\n  const remaining = valLen - len;\n  const output = [];\n  for (let i = 0; i < len; i++) {\n    // Special handle sparse arrays.\n    if (!ObjectPrototypeHasOwnProperty(value\x2C i)) {\n      return formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C len\x2C output\x2C i);\n    }\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C i\x2C kArrayType));\n  }\n  if (remaining > 0)\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  return output;\n}\n\nfunction formatTypedArray(value\x2C length\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const maxLength = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C length);\n  const remaining = value.length - maxLength;\n  const output = new Array(maxLength);\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\n    formatNumber :\n    formatBigInt;\n  for (let i = 0; i < maxLength; ++i) {\n    output[i] = elementFormatter(ctx.stylize\x2C value[i]\x2C ctx.numericSeparator);\n  }\n  if (remaining > 0) {\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\n  }\n  if (ctx.showHidden) {\n    // .buffer goes last\x2C it's not a primitive like the others.\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\n    ctx.indentationLvl += 2;\n    for (const key of [\n      'BYTES_PER_ELEMENT'\x2C\n      'length'\x2C\n      'byteLength'\x2C\n      'byteOffset'\x2C\n      'buffer'\x2C\n    ]) {\n      const str = formatValue(ctx\x2C value[key]\x2C recurseTimes\x2C true);\n      ArrayPrototypePush(output\x2C `[${key}]: ${str}`);\n    }\n    ctx.indentationLvl -= 2;\n  }\n  return output;\n}\n\nfunction formatSet(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const v of value) {\n    ArrayPrototypePush(output\x2C formatValue(ctx\x2C v\x2C recurseTimes));\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatMap(value\x2C ctx\x2C ignored\x2C recurseTimes) {\n  const output = [];\n  ctx.indentationLvl += 2;\n  for (const { 0: k\x2C 1: v } of value) {\n    output.push(\n      `${formatValue(ctx\x2C k\x2C recurseTimes)} => ${formatValue(ctx\x2C v\x2C recurseTimes)}`\n    );\n  }\n  ctx.indentationLvl -= 2;\n  return output;\n}\n\nfunction formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  const maxLength = MathMin(maxArrayLength\x2C entries.length);\n  const output = new Array(maxLength);\n  ctx.indentationLvl += 2;\n  for (let i = 0; i < maxLength; i++) {\n    output[i] = formatValue(ctx\x2C entries[i]\x2C recurseTimes);\n  }\n  ctx.indentationLvl -= 2;\n  if (state === kWeak && !ctx.sorted) {\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    ArrayPrototypeSort(output);\n  }\n  const remaining = entries.length - maxLength;\n  if (remaining > 0) {\n    ArrayPrototypePush(output\x2C\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\n  // Entries exist as [key1\x2C val1\x2C key2\x2C val2\x2C ...]\n  const len = entries.length / 2;\n  const remaining = len - maxArrayLength;\n  const maxLength = MathMin(maxArrayLength\x2C len);\n  let output = new Array(maxLength);\n  let i = 0;\n  ctx.indentationLvl += 2;\n  if (state === kWeak) {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      output[i] =\n        `${formatValue(ctx\x2C entries[pos]\x2C recurseTimes)} => ${formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)}`;\n    }\n    // Sort all entries to have a halfway reliable output (if more entries than\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\n    // output is not sorted anyway.\n    if (!ctx.sorted)\n      output = output.sort();\n  } else {\n    for (; i < maxLength; i++) {\n      const pos = i * 2;\n      const res = [\n        formatValue(ctx\x2C entries[pos]\x2C recurseTimes)\x2C\n        formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)\x2C\n      ];\n      output[i] = reduceToSingleString(\n        ctx\x2C res\x2C ''\x2C ['['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\n    }\n  }\n  ctx.indentationLvl -= 2;\n  if (remaining > 0) {\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\n  }\n  return output;\n}\n\nfunction formatWeakCollection(ctx) {\n  return [ctx.stylize('<items unknown>'\x2C 'special')];\n}\n\nfunction formatWeakSet(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatWeakMap(ctx\x2C value\x2C recurseTimes) {\n  const entries = previewEntries(value);\n  return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\n}\n\nfunction formatIterator(braces\x2C ctx\x2C value\x2C recurseTimes) {\n  const { 0: entries\x2C 1: isKeyValue } = previewEntries(value\x2C true);\n  if (isKeyValue) {\n    // Mark entry iterators as such.\n    braces[0] = braces[0].replace(/ Iterator] {$/\x2C ' Entries] {');\n    return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kMapEntries);\n  }\n\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kIterator);\n}\n\nfunction formatPromise(ctx\x2C value\x2C recurseTimes) {\n  let output;\n  const { 0: state\x2C 1: result } = getPromiseDetails(value);\n  if (state === kPending) {\n    output = [ctx.stylize('<pending>'\x2C 'special')];\n  } else {\n    ctx.indentationLvl += 2;\n    const str = formatValue(ctx\x2C result\x2C recurseTimes);\n    ctx.indentationLvl -= 2;\n    output = [\n      state === kRejected ?\n        `${ctx.stylize('<rejected>'\x2C 'special')} ${str}` :\n        str\x2C\n    ];\n  }\n  return output;\n}\n\nfunction formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C type\x2C desc\x2C\n                        original = value) {\n  let name\x2C str;\n  let extra = ' ';\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\x2C key) ||\n    { value: value[key]\x2C enumerable: true };\n  if (desc.value !== undefined) {\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\n    ctx.indentationLvl += diff;\n    str = formatValue(ctx\x2C desc.value\x2C recurseTimes);\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\x2C ctx.colors)) {\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\n    }\n    ctx.indentationLvl -= diff;\n  } else if (desc.get !== undefined) {\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\n    const s = ctx.stylize;\n    const sp = 'special';\n    if (ctx.getters && (ctx.getters === true ||\n          (ctx.getters === 'get' && desc.set === undefined) ||\n          (ctx.getters === 'set' && desc.set !== undefined))) {\n      try {\n        const tmp = FunctionPrototypeCall(desc.get\x2C original);\n        ctx.indentationLvl += 2;\n        if (tmp === null) {\n          str = `${s(`[${label}:`\x2C sp)} ${s('null'\x2C 'null')}${s(']'\x2C sp)}`;\n        } else if (typeof tmp === 'object') {\n          str = `${s(`[${label}]`\x2C sp)} ${formatValue(ctx\x2C tmp\x2C recurseTimes)}`;\n        } else {\n          const primitive = formatPrimitive(s\x2C tmp\x2C ctx);\n          str = `${s(`[${label}:`\x2C sp)} ${primitive}${s(']'\x2C sp)}`;\n        }\n        ctx.indentationLvl -= 2;\n      } catch (err) {\n        const message = `<Inspection threw (${err.message})>`;\n        str = `${s(`[${label}:`\x2C sp)} ${message}${s(']'\x2C sp)}`;\n      }\n    } else {\n      str = ctx.stylize(`[${label}]`\x2C sp);\n    }\n  } else if (desc.set !== undefined) {\n    str = ctx.stylize('[Setter]'\x2C 'special');\n  } else {\n    str = ctx.stylize('undefined'\x2C 'undefined');\n  }\n  if (type === kArrayType) {\n    return str;\n  }\n  if (typeof key === 'symbol') {\n    const tmp = RegExpPrototypeSymbolReplace(\n      strEscapeSequencesReplacer\x2C\n      SymbolPrototypeToString(key)\x2C\n      escapeFn\n    );\n    name = `[${ctx.stylize(tmp\x2C 'symbol')}]`;\n  } else if (key === '__proto__') {\n    name = "['__proto__']";\n  } else if (desc.enumerable === false) {\n    const tmp = RegExpPrototypeSymbolReplace(\n      strEscapeSequencesReplacer\x2C key\x2C escapeFn);\n    name = `[${tmp}]`;\n  } else if (RegExpPrototypeExec(keyStrRegExp\x2C key) !== null) {\n    name = ctx.stylize(key\x2C 'name');\n  } else {\n    name = ctx.stylize(strEscape(key)\x2C 'string');\n  }\n  return `${name}:${extra}${str}`;\n}\n\nfunction isBelowBreakLength(ctx\x2C output\x2C start\x2C base) {\n  // Each entry is separated by at least a comma. Thus\x2C we start with a total\n  // length of at least `output.length`. In addition\x2C some cases have a\n  // whitespace in-between each other that is added to the total as well.\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\n  // function. Check the performance overhead and make it an opt-in in case it's\n  // significant.\n  let totalLength = output.length + start;\n  if (totalLength + output.length > ctx.breakLength)\n    return false;\n  for (let i = 0; i < output.length; i++) {\n    if (ctx.colors) {\n      totalLength += removeColors(output[i]).length;\n    } else {\n      totalLength += output[i].length;\n    }\n    if (totalLength > ctx.breakLength) {\n      return false;\n    }\n  }\n  // Do not line up properties on the same line if `base` contains line breaks.\n  return base === '' || !StringPrototypeIncludes(base\x2C '\\n');\n}\n\nfunction reduceToSingleString(\n  ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value) {\n  if (ctx.compact !== true) {\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\n      // Memorize the original output length. In case the output is grouped\x2C\n      // prevent lining up the entries on a single line.\n      const entries = output.length;\n      // Group array elements together if the array contains at least six\n      // separate entries.\n      if (extrasType === kArrayExtrasType && entries > 6) {\n        output = groupArrayElements(ctx\x2C output\x2C value);\n      }\n      // `ctx.currentDepth` is set to the most inner depth of the currently\n      // inspected object part while `recurseTimes` is the actual current depth\n      // that is inspected.\n      //\n      // Example:\n      //\n      // const a = { first: [ 1\x2C 2\x2C 3 ]\x2C second: { inner: [ 1\x2C 2\x2C 3 ] } }\n      //\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\n      // depth of 1.\n      //\n      // Consolidate all entries of the local most inner depth up to\n      // `ctx.compact`\x2C as long as the properties are smaller than\n      // `ctx.breakLength`.\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\n          entries === output.length) {\n        // Line up all entries on a single line in case the entries do not\n        // exceed `breakLength`. Add 10 as constant to start next to all other\n        // factors that may reduce `breakLength`.\n        const start = output.length + ctx.indentationLvl +\n                      braces[0].length + base.length + 10;\n        if (isBelowBreakLength(ctx\x2C output\x2C start\x2C base)) {\n          const joinedOutput = join(output\x2C '\x2C ');\n          if (!joinedOutput.includes('\\n')) {\n            return `${base ? `${base} ` : ''}${braces[0]} ${joinedOutput}` +\n              ` ${braces[1]}`;\n          }\n        }\n      }\n    }\n    // Line up each entry on an individual line.\n    const indentation = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\n      `${join(output\x2C `\x2C${indentation}  `)}${indentation}${braces[1]}`;\n  }\n  // Line up all entries on a single line in case the entries do not exceed\n  // `breakLength`.\n  if (isBelowBreakLength(ctx\x2C output\x2C 0\x2C base)) {\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output\x2C '\x2C ')} ` +\n      braces[1];\n  }\n  const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\n  // If the opening "brace" is too large\x2C like in the case of "Set {"\x2C\n  // we need to force the first item to be on the next line or the\n  // items will not line up correctly.\n  const ln = base === '' && braces[0].length === 1 ?\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\n  // Line up each entry on an individual line.\n  return `${braces[0]}${ln}${join(output\x2C `\x2C\\n${indentation}  `)} ${braces[1]}`;\n}\n\nfunction hasBuiltInToString(value) {\n  // Prevent triggering proxy traps.\n  const getFullProxy = false;\n  const proxyTarget = getProxyDetails(value\x2C getFullProxy);\n  if (proxyTarget !== undefined) {\n    if (proxyTarget === null) {\n      return true;\n    }\n    value = proxyTarget;\n  }\n\n  // Count objects that have no `toString` function as built-in.\n  if (typeof value.toString !== 'function') {\n    return true;\n  }\n\n  // The object has a own `toString` property. Thus it's not not a built-in one.\n  if (ObjectPrototypeHasOwnProperty(value\x2C 'toString')) {\n    return false;\n  }\n\n  // Find the object that has the `toString` property as own property in the\n  // prototype chain.\n  let pointer = value;\n  do {\n    pointer = ObjectGetPrototypeOf(pointer);\n  } while (!ObjectPrototypeHasOwnProperty(pointer\x2C 'toString'));\n\n  // Check closer if the object is a built-in.\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer\x2C 'constructor');\n  return descriptor !== undefined &&\n    typeof descriptor.value === 'function' &&\n    builtInObjects.has(descriptor.value.name);\n}\n\nconst firstErrorLine = (error) =>\n  StringPrototypeSplit(error.message\x2C '\\n'\x2C 1)[0];\nlet CIRCULAR_ERROR_MESSAGE;\nfunction tryStringify(arg) {\n  try {\n    return JSONStringify(arg);\n  } catch (err) {\n    // Populate the circular error message lazily\n    if (!CIRCULAR_ERROR_MESSAGE) {\n      try {\n        const a = {}; a.a = a; JSONStringify(a);\n      } catch (circularError) {\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);\n      }\n    }\n    if (err.name === 'TypeError' &&\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\n      return '[Circular]';\n    }\n    throw err;\n  }\n}\n\nfunction format(...args) {\n  return formatWithOptionsInternal(undefined\x2C args);\n}\n\nfunction formatWithOptions(inspectOptions\x2C ...args) {\n  validateObject(inspectOptions\x2C 'inspectOptions'\x2C { allowArray: true });\n  return formatWithOptionsInternal(inspectOptions\x2C args);\n}\n\nfunction formatNumberNoColor(number\x2C options) {\n  return formatNumber(\n    stylizeNoColor\x2C\n    number\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\n  );\n}\n\nfunction formatBigIntNoColor(bigint\x2C options) {\n  return formatBigInt(\n    stylizeNoColor\x2C\n    bigint\x2C\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\n  );\n}\n\nfunction formatWithOptionsInternal(inspectOptions\x2C args) {\n  const first = args[0];\n  let a = 0;\n  let str = '';\n  let join = '';\n\n  if (typeof first === 'string') {\n    if (args.length === 1) {\n      return first;\n    }\n    let tempStr;\n    let lastPos = 0;\n\n    for (let i = 0; i < first.length - 1; i++) {\n      if (StringPrototypeCharCodeAt(first\x2C i) === 37) { // '%'\n        const nextChar = StringPrototypeCharCodeAt(first\x2C ++i);\n        if (a + 1 !== args.length) {\n          switch (nextChar) {\n            case 115: { // 's'\n              const tempArg = args[++a];\n              if (typeof tempArg === 'number') {\n                tempStr = formatNumberNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg === 'bigint') {\n                tempStr = formatBigIntNoColor(tempArg\x2C inspectOptions);\n              } else if (typeof tempArg !== 'object' ||\n                         tempArg === null ||\n                         !hasBuiltInToString(tempArg)) {\n                tempStr = String(tempArg);\n              } else {\n                tempStr = inspect(tempArg\x2C {\n                  ...inspectOptions\x2C\n                  compact: 3\x2C\n                  colors: false\x2C\n                  depth: 0\n                });\n              }\n              break;\n            }\n            case 106: // 'j'\n              tempStr = tryStringify(args[++a]);\n              break;\n            case 100: { // 'd'\n              const tempNum = args[++a];\n              if (typeof tempNum === 'bigint') {\n                tempStr = formatBigIntNoColor(tempNum\x2C inspectOptions);\n              } else if (typeof tempNum === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(Number(tempNum)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 79: // 'O'\n              tempStr = inspect(args[++a]\x2C inspectOptions);\n              break;\n            case 111: // 'o'\n              tempStr = inspect(args[++a]\x2C {\n                ...inspectOptions\x2C\n                showHidden: true\x2C\n                showProxy: true\x2C\n                depth: 4\n              });\n              break;\n            case 105: { // 'i'\n              const tempInteger = args[++a];\n              if (typeof tempInteger === 'bigint') {\n                tempStr = formatBigIntNoColor(tempInteger\x2C inspectOptions);\n              } else if (typeof tempInteger === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseInt(tempInteger)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 102: { // 'f'\n              const tempFloat = args[++a];\n              if (typeof tempFloat === 'symbol') {\n                tempStr = 'NaN';\n              } else {\n                tempStr = formatNumberNoColor(\n                  NumberParseFloat(tempFloat)\x2C inspectOptions);\n              }\n              break;\n            }\n            case 99: // 'c'\n              a += 1;\n              tempStr = '';\n              break;\n            case 37: // '%'\n              str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n              lastPos = i + 1;\n              continue;\n            default: // Any other character is not a correct placeholder\n              continue;\n          }\n          if (lastPos !== i - 1) {\n            str += StringPrototypeSlice(first\x2C lastPos\x2C i - 1);\n          }\n          str += tempStr;\n          lastPos = i + 1;\n        } else if (nextChar === 37) {\n          str += StringPrototypeSlice(first\x2C lastPos\x2C i);\n          lastPos = i + 1;\n        }\n      }\n    }\n    if (lastPos !== 0) {\n      a++;\n      join = ' ';\n      if (lastPos < first.length) {\n        str += StringPrototypeSlice(first\x2C lastPos);\n      }\n    }\n  }\n\n  while (a < args.length) {\n    const value = args[a];\n    str += join;\n    str += typeof value !== 'string' ? inspect(value\x2C inspectOptions) : value;\n    join = ' ';\n    a++;\n  }\n  return str;\n}\n\nif (internalBinding('config').hasIntl) {\n  const icu = internalBinding('icu');\n  // icu.getStringWidth(string\x2C ambiguousAsFullWidth\x2C expandEmojiSequence)\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\n  // best thing possible at the moment\x2C since it's difficult to know what\n  // the receiving end supports.\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    for (let i = 0; i < str.length; i++) {\n      // Try to avoid calling into C++ by first handling the ASCII portion of\n      // the string. If it is fully ASCII\x2C we skip the C++ part.\n      const code = str.charCodeAt(i);\n      if (code >= 127) {\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\n        break;\n      }\n      width += code >= 32 ? 1 : 0;\n    }\n    return width;\n  };\n} else {\n  /**\n   * Returns the number of columns required to display the given string.\n   */\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\n    let width = 0;\n\n    if (removeControlChars)\n      str = stripVTControlCharacters(str);\n    str = StringPrototypeNormalize(str\x2C 'NFC');\n    for (const char of new SafeStringIterator(str)) {\n      const code = StringPrototypeCodePointAt(char\x2C 0);\n      if (isFullWidthCodePoint(code)) {\n        width += 2;\n      } else if (!isZeroWidthCodePoint(code)) {\n        width++;\n      }\n    }\n\n    return width;\n  };\n\n  /**\n   * Returns true if the character represented by a given\n   * Unicode code point is full-width. Otherwise returns false.\n   */\n  const isFullWidthCodePoint = (code) => {\n    // Code points are partially derived from:\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\n    return code >= 0x1100 && (\n      code <= 0x115f ||  // Hangul Jamo\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\n      (code >= 0x3250 && code <= 0x4dbf) ||\n      // CJK Unified Ideographs .. Yi Radicals\n      (code >= 0x4e00 && code <= 0xa4c6) ||\n      // Hangul Jamo Extended-A\n      (code >= 0xa960 && code <= 0xa97c) ||\n      // Hangul Syllables\n      (code >= 0xac00 && code <= 0xd7a3) ||\n      // CJK Compatibility Ideographs\n      (code >= 0xf900 && code <= 0xfaff) ||\n      // Vertical Forms\n      (code >= 0xfe10 && code <= 0xfe19) ||\n      // CJK Compatibility Forms .. Small Form Variants\n      (code >= 0xfe30 && code <= 0xfe6b) ||\n      // Halfwidth and Fullwidth Forms\n      (code >= 0xff01 && code <= 0xff60) ||\n      (code >= 0xffe0 && code <= 0xffe6) ||\n      // Kana Supplement\n      (code >= 0x1b000 && code <= 0x1b001) ||\n      // Enclosed Ideographic Supplement\n      (code >= 0x1f200 && code <= 0x1f251) ||\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\n      // Emoticons 0x1f600 - 0x1f64f\n      (code >= 0x1f300 && code <= 0x1f64f) ||\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\n      (code >= 0x20000 && code <= 0x3fffd)\n    );\n  };\n\n  const isZeroWidthCodePoint = (code) => {\n    return code <= 0x1F || // C0 control codes\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\n      // Combining Diacritical Marks for Symbols\n      (code >= 0x20D0 && code <= 0x20FF) ||\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\n  };\n}\n\n/**\n * Remove all VT control characters. Use to estimate displayed string width.\n */\nfunction stripVTControlCharacters(str) {\n  validateString(str\x2C 'str');\n\n  return str.replace(ansi\x2C '');\n}\n\nmodule.exports = {\n  identicalSequenceRange\x2C\n  inspect\x2C\n  inspectDefaultOptions\x2C\n  format\x2C\n  formatWithOptions\x2C\n  getStringWidth\x2C\n  stripVTControlCharacters\x2C\n};\n
code-source-info,0xb46da65f5e8,26,39019,39589,C0O39043C2O39052C6O39059C9O39048C14O39159C21O39168C25O39159C31O39178C33O39186C38O39217C45O39224C49O39237C51O39246C56O39271C59O39297C64O39307C71O39314C75O39297C81O39406C83O39400C90O39413C93O39410C99O39430C102O39425C105O39420C110O39450C115O39386C118O39475C120O39483C125O39500C132O39509C138O39522C144O39526C145O39065C150O39030C153O39558C157O39587,,
tick,0x7ff805db1607,290913,0,0x0,3,0x102d5e910,0xb46da65eda4,0xb46da65ea1b
tick,0x7ff805ede983,290922,0,0x0,3,0x102d5e910,0xb46da65eda4,0xb46da65ea1b
tick,0x102a93b2d,290928,0,0x0,3,0x102d5e910,0xb46da65eda4,0xb46da65ea1b
tick,0x7ff805dd2b58,290933,0,0x0,3,0x102d5e910,0xb46da65eda4,0xb46da65ea1b
tick,0x7ff805ede983,290939,0,0x0,3,0x102d5e910,0xb46da65eda4,0xb46da65ea1b
tick,0x102589416,290944,0,0x0,3,0x102d5e910,0xb46da65eda4,0xb46da65ea1b
tick,0x7ff805f12098,290950,0,0x0,3,0x102d5e910,0xb46da65eda4,0xb46da65ea1b
code-creation,LazyCompile,10,291066,0xb46da6643a0,243,afterInspector node:internal/errors:765:17,0xb4665160a18,~
code-source-info,0xb46da6643a0,17,22890,24278,C0O22932C5O22959C7O23441C10O23453C17O23462C22O23496C28O23496C33O23517C38O23518C43O23556C50O23574C55O23599C62O23574C70O23646C73O23556C79O23661C80O23668C86O23672C93O23685C101O23689C106O23708C108O23845C111O23845C115O23759C125O23815C130O23891C140O23925C145O23948C153O23949C161O23968C172O24000C177O24023C182O24024C194O24106C201O24123C207O24176C210O24192C215O24207C223O24176C232O24098C237O24226C240O24247C242O24268,,
code-creation,LazyCompile,10,291126,0xb46da6645f8,32,lazyInternalUtilInspect node:internal/errors:182:33,0xb466515ffc8,~
code-source-info,0xb46da6645f8,17,5218,5314,C0O5225C14O5249C21O5245C27O5285C31O5312,,
tick,0x10279dbb0,291201,1,0x1026b57c0,6,0x1027fed10,0xb46da664439
code-creation,Eval,10,291335,0xb46da664d70,5, node:internal/tty:1:1,0xb46da664b18,~
script-source,449,node:internal/tty,// MIT License\n\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\n\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a copy\n// of this software and associated documentation files (the "Software")\x2C to deal\n// in the Software without restriction\x2C including without limitation the rights\n// to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C distribute\x2C sublicense\x2C and/or sell\n// copies of the Software\x2C and to permit persons to whom the Software is\n// furnished to do so\x2C subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS OR\n// IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\x2C\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C DAMAGES OR OTHER\n// LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR OTHERWISE\x2C ARISING FROM\x2C\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\n'use strict';\n\nconst {\n  ArrayPrototypeSome\x2C\n  RegExpPrototypeExec\x2C\n  StringPrototypeSplit\x2C\n  StringPrototypeToLowerCase\x2C\n} = primordials;\n\nconst { validateInteger } = require('internal/validators');\n\nlet OSRelease;\n\nconst COLORS_2 = 1;\nconst COLORS_16 = 4;\nconst COLORS_256 = 8;\nconst COLORS_16m = 24;\n\n// Some entries were taken from `dircolors`\n// (https://linux.die.net/man/1/dircolors). The corresponding terminals might\n// support more than 16 colors\x2C but this was not tested for.\n//\n// Copyright (C) 1996-2016 Free Software Foundation\x2C Inc. Copying and\n// distribution of this file\x2C with or without modification\x2C are permitted\n// provided the copyright notice and this notice are preserved.\nconst TERM_ENVS = {\n  'eterm': COLORS_16\x2C\n  'cons25': COLORS_16\x2C\n  'console': COLORS_16\x2C\n  'cygwin': COLORS_16\x2C\n  'dtterm': COLORS_16\x2C\n  'gnome': COLORS_16\x2C\n  'hurd': COLORS_16\x2C\n  'jfbterm': COLORS_16\x2C\n  'konsole': COLORS_16\x2C\n  'kterm': COLORS_16\x2C\n  'mlterm': COLORS_16\x2C\n  'mosh': COLORS_16m\x2C\n  'putty': COLORS_16\x2C\n  'st': COLORS_16\x2C\n  // https://github.com/da-x/rxvt-unicode/tree/v9.22-with-24bit-color\n  'rxvt-unicode-24bit': COLORS_16m\x2C\n  // https://gist.github.com/XVilka/8346728#gistcomment-2823421\n  'terminator': COLORS_16m\n};\n\nconst TERM_ENVS_REG_EXP = [\n  /ansi/\x2C\n  /color/\x2C\n  /linux/\x2C\n  /^con[0-9]*x[0-9]/\x2C\n  /^rxvt/\x2C\n  /^screen/\x2C\n  /^xterm/\x2C\n  /^vt100/\x2C\n];\n\nlet warned = false;\nfunction warnOnDeactivatedColors(env) {\n  if (warned)\n    return;\n  let name = '';\n  if (env.NODE_DISABLE_COLORS !== undefined)\n    name = 'NODE_DISABLE_COLORS';\n  if (env.NO_COLOR !== undefined) {\n    if (name !== '') {\n      name += "' and '";\n    }\n    name += 'NO_COLOR';\n  }\n\n  if (name !== '') {\n    process.emitWarning(\n      `The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`\x2C\n      'Warning'\n    );\n    warned = true;\n  }\n}\n\n// The `getColorDepth` API got inspired by multiple sources such as\n// https://github.com/chalk/supports-color\x2C\n// https://github.com/isaacs/color-support.\nfunction getColorDepth(env = process.env) {\n  // Use level 0-3 to support the same levels as `chalk` does. This is done for\n  // consistency throughout the ecosystem.\n  if (env.FORCE_COLOR !== undefined) {\n    switch (env.FORCE_COLOR) {\n      case '':\n      case '1':\n      case 'true':\n        warnOnDeactivatedColors(env);\n        return COLORS_16;\n      case '2':\n        warnOnDeactivatedColors(env);\n        return COLORS_256;\n      case '3':\n        warnOnDeactivatedColors(env);\n        return COLORS_16m;\n      default:\n        return COLORS_2;\n    }\n  }\n\n  if (env.NODE_DISABLE_COLORS !== undefined ||\n      // See https://no-color.org/\n      env.NO_COLOR !== undefined ||\n      // The "dumb" special terminal\x2C as defined by terminfo\x2C doesn't support\n      // ANSI color control codes.\n      // See https://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\n      env.TERM === 'dumb') {\n    return COLORS_2;\n  }\n\n  if (process.platform === 'win32') {\n    // Lazy load for startup performance.\n    if (OSRelease === undefined) {\n      const { release } = require('os');\n      OSRelease = StringPrototypeSplit(release()\x2C '.');\n    }\n    // Windows 10 build 10586 is the first Windows release that supports 256\n    // colors. Windows 10 build 14931 is the first release that supports\n    // 16m/TrueColor.\n    if (+OSRelease[0] >= 10) {\n      const build = +OSRelease[2];\n      if (build >= 14931)\n        return COLORS_16m;\n      if (build >= 10586)\n        return COLORS_256;\n    }\n\n    return COLORS_16;\n  }\n\n  if (env.TMUX) {\n    return COLORS_256;\n  }\n\n  if (env.CI) {\n    if ([\n      'APPVEYOR'\x2C\n      'BUILDKITE'\x2C\n      'CIRCLECI'\x2C\n      'DRONE'\x2C\n      'GITHUB_ACTIONS'\x2C\n      'GITLAB_CI'\x2C\n      'TRAVIS'\x2C\n    ].some((sign) => sign in env) || env.CI_NAME === 'codeship') {\n      return COLORS_256;\n    }\n    return COLORS_2;\n  }\n\n  if ('TEAMCITY_VERSION' in env) {\n    return RegExpPrototypeExec(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2\x2C}\\.)/\x2C env.TEAMCITY_VERSION) !== null ?\n      COLORS_16 : COLORS_2;\n  }\n\n  switch (env.TERM_PROGRAM) {\n    case 'iTerm.app':\n      if (!env.TERM_PROGRAM_VERSION ||\n        RegExpPrototypeExec(/^[0-2]\\./\x2C env.TERM_PROGRAM_VERSION) !== null\n      ) {\n        return COLORS_256;\n      }\n      return COLORS_16m;\n    case 'HyperTerm':\n    case 'MacTerm':\n      return COLORS_16m;\n    case 'Apple_Terminal':\n      return COLORS_256;\n  }\n\n  if (env.COLORTERM === 'truecolor' || env.COLORTERM === '24bit') {\n    return COLORS_16m;\n  }\n\n  if (env.TERM) {\n    if (RegExpPrototypeExec(/^xterm-256/\x2C env.TERM) !== null) {\n      return COLORS_256;\n    }\n\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\n\n    if (TERM_ENVS[termEnv]) {\n      return TERM_ENVS[termEnv];\n    }\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP\x2C\n                           (term) => RegExpPrototypeExec(term\x2C termEnv) !== null)) {\n      return COLORS_16;\n    }\n  }\n  // Move 16 color COLORTERM below 16m and 256\n  if (env.COLORTERM) {\n    return COLORS_16;\n  }\n  return COLORS_2;\n}\n\nfunction hasColors(count\x2C env) {\n  if (env === undefined &&\n      (count === undefined || (typeof count === 'object' && count !== null))) {\n    env = count;\n    count = 16;\n  } else {\n    validateInteger(count\x2C 'count'\x2C 2);\n  }\n\n  return count <= 2 ** getColorDepth(env);\n}\n\nmodule.exports = {\n  getColorDepth\x2C\n  hasColors\n};\n
code-source-info,0xb46da664d70,449,0,6482,C0O0C4O6482,,
code-creation,Function,10,292053,0xb46da6651d0,358, node:internal/tty:1:1,0xb46da664ce8,~
code-source-info,0xb46da6651d0,449,0,6482,C0O0C69O1186C75O1208C81O1231C87O1255C93O1329C99O1329C104O1309C110O1366C111O1366C113O1395C115O1395C117O1416C119O1416C121O1438C123O1438C125O1460C127O1460C129O1877C136O1890C142O1913C148O1937C154O1960C160O1983C166O2005C172O2026C178O2050C184O2074C190O2096C196O2119C202O2140C208O2163C214O2182C220O2287C226O2379C232O1877C234O2420C328O2420C330O2541C331O2541C333O6431C340O6452C346O6469C352O6446C357O6481,,
code-creation,LazyCompile,10,292205,0xb46da666078,63,hasColors node:internal/tty:222:19,0xb46da664e40,~
code-source-info,0xb46da666078,449,6174,6429,C0O6191C18O6300C21O6317C27O6344C41O6344C46O6387C52O6408C56O6405C59O6400C62O6427,,
code-creation,LazyCompile,10,292314,0xb46da666ef0,762,getColorDepth node:internal/tty:106:23,0xb46da664df0,~
code-source-info,0xb46da666ef0,449,3180,6154,C0O3180C17O3195C27O3327C30O3335C36O3368C39O3380C81O3453C89O3453C93O3491C99O3508C100O3533C108O3533C112O3571C118O3589C119O3614C127O3614C131O3652C137O3670C138O3694C144O3710C145O3724C148O3732C157O3814C166O4044C173O4049C178O4067C184O4083C185O4091C190O4103C197O4112C202O4173C210O4230C218O4230C223O4218C228O4251C235O4284C242O4263C252O4261C260O4483C268O4497C271O4487C276O4501C281O4530C290O4540C293O4530C296O4551C300O4561C305O4579C311O4597C312O4604C316O4614C321O4632C327O4650C328O4662C334O4679C335O4687C338O4695C344O4707C350O4725C351O4733C354O4741C360O4751C365O4892C375O4892C385O4927C392O4935C397O4959C403O4977C404O4988C410O5004C411O5012C416O5035C421O5049C436O5113C441O5056C452O5148C460O5160C462O5169C463O5177C466O5189C501O5233C504O5242C514O5274C525O5310C530O5274C537O5359C543O5377C544O5392C550O5410C551O5459C557O5477C558O5511C564O5529C565O5537C568O5545C575O5555C583O5578C590O5588C595O5607C601O5625C602O5633C605O5641C618O5653C635O5695C640O5657C647O5719C653O5737C654O5765C666O5796C671O5765C675O5765C677O5808C686O5821C691O5840C700O5856C703O5866C704O5877C715O5900C723O5881C730O6010C736O6027C739O6087C742O6095C748O6112C754O6129C755O6136C761O6152,,
tick,0x7ff805ea76fa,292460,0,0x0,3,0x102d5e910,0xb46da6660ac,0xb46da664456
code-creation,LazyCompile,10,292474,0xb46da667458,5,get node:internal/util/inspect:356:6,0xb469fcd7168,~
code-source-info,0xb46da667458,26,10754,10796,C0O10763C4O10792,,
code-creation,LazyCompile,10,292555,0xb46da6677c8,395,inspect node:internal/util/inspect:295:17,0xb469fcd7118,~
code-source-info,0xb46da6677c8,26,8630,10640,C0O8630C2O8681C9O8770C15O8802C18O8824C28O8847C31O8869C41O8888C44O8910C54O8937C57O8959C67O8989C70O9011C80O9042C83O9064C93O9101C96O9123C106O9157C109O9179C119O9205C122O9227C132O9248C135O9270C145O9291C148O9313C158O9344C161O9366C172O9405C179O9412C184O9454C191O9461C196O9474C198O9487C203O9516C205O9537C208O9526C212O9570C219O9577C226O9593C231O9622C233O9644C236O9633C240O9701C246O9740C248O9755C254O9774C258O9808C263O9808C268O9845C270O9860C274O9850C279O9895C281O9902C285O10096C292O10141C295O10111C304O10186C309O10213C311O10228C314O10222C320O10258C326O10366C328O10382C332O9870C337O9832C340O10428C346O10436C348O10448C352O10478C358O10524C361O10522C365O10544C371O10592C374O10590C378O10604C389O10611C394O10638,,
code-creation,LazyCompile,10,292717,0xb46da667d28,491,formatValue node:internal/util/inspect:750:21,0xb469fcd7718,~
code-source-info,0xb46da667d28,26,22683,25385,C0O22771C14O22848C17O22848C23O22883C26O22910C37O22890C42O22931C43O22938C47O22975C58O22975C64O22999C65O23083C68O23211C73O23240C80O23211C86O23254C88O23285C93O23312C98O23345C109O23345C115O23383C116O23402C122O23421C134O23428C139O23466C140O23477C145O23632C151O23673C153O23679C155O23678C159O23705C165O23838C170O23944C176O23965C181O23977C188O23987C193O24133C202O24161C209O24167C213O24220C216O24226C221O24264C223O24253C228O24291C236O24375C254O24291C260O24544C262O24552C267O24575C273O24616C285O24623C290O24659C291O24689C307O24713C312O24724C317O24713C327O24689C333O24743C334O24929C339O24934C344O24934C351O24969C354O24984C360O25016C362O25035C365O25031C370O25029C374O25056C379O25065C384O25065C392O25115C397O25124C402O25124C408O25142C410O25189C415O25198C419O25203C423O25220C428O25229C433O25229C439O25277C449O25299C463O25277C469O25320C470O25328C485O25335C490O25383,,
code-creation,LazyCompile,10,293056,0xb46da668868,3329,formatRaw node:internal/util/inspect:828:19,0xb469fcd7768,~
code-source-info,0xb46da668868,26,25405,35919,C0O25452C2O25464C4O25486C10O25521C14O25514C19O25534C25O25557C28O25601C44O25601C50O25713C54O25756C61O25763C66O25776C68O25817C70O25823C72O25822C76O25957C82O25999C87O26020C95O26041C101O26081C107O26134C111O26117C118O26168C121O26195C124O26217C127O26244C129O26271C131O26287C133O26311C141O26324C147O26341C150O26378C155O26592C163O26611C172O26651C174O26675C180O26679C186O26798C188O26811C195O26830C212O26895C235O26848C246O26926C252O26933C258O26980C269O26993C284O27026C291O27033C296O27047C303O27054C312O27097C313O27113C324O27120C325O27127C330O27164C335O27200C341O27204C347O27239C353O27239C359O27288C373O27327C392O27288C399O27343C403O27369C409O27350C415O27388C423O27441C432O27441C444O27479C455O27490C459O27490C465O27479C472O27524C473O27533C478O27547C485O27554C494O27597C504O27618C505O27625C516O27638C535O27666C541O27670C547O27705C553O27705C559O27754C573O27793C592O27754C599O27809C603O27835C609O27816C615O27854C623O27907C632O27907C644O27945C655O27956C659O27956C665O27945C672O27991C673O28000C678O28014C685O28021C694O28064C704O28085C705O28092C716O28105C735O28133C741O28137C747O28166C753O28173C759O28232C762O28260C766O28270C770O28306C776O28317C782O28419C788O28442C795O28427C802O28488C808O28488C814O28546C824O28588C846O28546C853O28604C864O28617C879O28650C886O28657C891O28671C898O28678C903O28692C909O28712C910O28728C921O28735C922O28891C926O28920C941O28920C947O28951C954O28993C960O28997C966O29027C970O29053C976O29034C982O29072C990O29081C996O29167C1000O29194C1009O29194C1018O29225C1024O29229C1030O29259C1034O29285C1040O29266C1046O29304C1054O29313C1060O29399C1064O29426C1073O29426C1082O29465C1084O29496C1088O29518C1092O29544C1098O29525C1104O29561C1109O29586C1111O29602C1116O29624C1122O29628C1128O29664C1133O29674C1139O29706C1141O29714C1146O29732C1163O29747C1176O29742C1180O29812C1187O29819C1196O29864C1197O29880C1208O29887C1211O29907C1217O29948C1230O29955C1236O30012C1243O30019C1252O30073C1262O30073C1268O30098C1271O30110C1277O30114C1283O30187C1299O30262C1305O30258C1312O30194C1317O30306C1331O30306C1338O30351C1340O30362C1345O30385C1352O30404C1357O30428C1364O30435C1373O30503C1377O30497C1382O30516C1388O30554C1398O30554C1404O30578C1407O30598C1413O30602C1419O30680C1427O30699C1431O30699C1437O30687C1445O30738C1449O30738C1457O30777C1461O30777C1466O30831C1480O30831C1487O30874C1489O30885C1494O30906C1501O30925C1506O30948C1513O30955C1522O31011C1532O31011C1538O31033C1541O31053C1547O31057C1553O31081C1572O31088C1578O31152C1585O31159C1594O31202C1596O31214C1599O31226C1605O31230C1611O31465C1617O31465C1631O31554C1644O31554C1651O31600C1655O31640C1660O31693C1667O31700C1676O31745C1684O31809C1690O31824C1699O31792C1715O31759C1718O31847C1719O31862C1724O31877C1732O31872C1736O31894C1746O31894C1753O31948C1759O31952C1765O31979C1782O31994C1795O31989C1799O32110C1820O32110C1827O32188C1833O32192C1839O32218C1856O32233C1869O32228C1873O32282C1878O32320C1884O32324C1890O32350C1907O32365C1920O32360C1924O32430C1939O32492C1945O32496C1951O32522C1968O32537C1981O32532C1985O32602C2000O32664C2006O32668C2012O32708C2029O32723C2042O32718C2046O32823C2050O32857C2059O32857C2068O32886C2074O32890C2080O32923C2099O32930C2105O32995C2112O33002C2124O33047C2126O33059C2129O33096C2136O33103C2148O33148C2154O33152C2164O33199C2170O33199C2180O33222C2194O33223C2206O33258C2218O33280C2241O33258C2253O33303C2254O33322C2267O33332C2288O33373C2289O33388C2305O33403C2326O33398C2334O33480C2338O33474C2346O33493C2352O33537C2365O33537C2377O33573C2394O33574C2408O33592C2412O33624C2418O33646C2437O33681C2447O33681C2459O33717C2460O33724C2470O33750C2480O33755C2490O33755C2500O33770C2502O33787C2510O33809C2512O33846C2524O33874C2533O33883C2544O33929C2546O33945C2550O33938C2558O33973C2574O34032C2594O33987C2606O33973C2616O33954C2623O33924C2626O34061C2630O34106C2646O34106C2671O34179C2686O34179C2698O34215C2715O34216C2729O34234C2748O34241C2758O34307C2759O34322C2769O34370C2779O34379C2789O34379C2801O34395C2803O34450C2815O34467C2838O34450C2852O34570C2863O34578C2871O34598C2873O34610C2887O34634C2902O34647C2912O34678C2917O34693C2931O34712C2944O34688C2952O34743C2962O34748C2972O34748C2980O34766C2990O34803C3001O34810C3012O34837C3022O34849C3024O34868C3026O34864C3034O34905C3044O34905C3057O34943C3065O34950C3073O34985C3083O34998C3093O35012C3097O35005C3105O34985C3117O35019C3127O35020C3139O35051C3149O35065C3159O35079C3163O35072C3171O35092C3183O35051C3193O35137C3218O35137C3229O35245C3239O35256C3247O35251C3257O35311C3265O35305C3272O35325C3282O35336C3294O35352C3302O35853C3308O35867C3316O35884C3318O35894C3326O35906C3328O35917,,
code-creation,LazyCompile,10,293384,0xb46da669c18,321,getConstructorName node:internal/util/inspect:572:28,0xb469fcd7538,~
code-source-info,0xb46da669c18,26,17086,18327,C0O17131C2O17157C7O17175C13O17178C16O17178C22O17230C30O17230C36O17286C38O17344C46O17387C51O17393C58O17398C66O17445C71O17416C78O17461C84O17514C91O17535C94O17550C99O17565C104O17571C109O17550C116O17589C127O17633C138O17589C143O17693C148O17718C153O17724C158O17700C162O17730C163O17742C168O17748C174O17779C178O17817C183O17164C186O17848C190O17879C191O17891C192O17911C197O17911C202O17970C206O17964C211O17983C217O18005C226O18041C227O18069C232O18123C245O18069C251O18144C253O18176C266O18225C272O18251C278O18271C282O18194C297O18284C298O18292C310O18310C320O18325,,
code-creation,LazyCompile,10,293450,0xb46da669ef0,13,isInstanceof node:internal/util/inspect:564:22,0xb469fcd74e8,~
code-source-info,0xb46da669ef0,26,16960,17057,C3O16990C5O17004C8O17021C11O17038C12O17051,,
code-creation,LazyCompile,10,293505,0xb46da66a0f8,223,getKeys node:internal/util/inspect:693:17,0xb469fcd7628,~
code-source-info,0xb46da66a0f8,26,20789,21764,C0O20789C9O20817C11O20841C21O20841C26O20879C30O20901C40O20908C45O20958C51O20965C56O20978C63O20978C73O21338C83O21345C91O21343C101O21390C112O21397C118O21397C127O21423C134O21428C143O21465C151O21465C156O21390C160O21504C172O21511C179O21567C185O21574C190O21604C195O21668C206O21698C209O21698C215O21668C220O21750C222O21762,,
code-creation,LazyCompile,10,293568,0xb46da66a330,16,filter node:internal/util/inspect:714:22,0xb46da669fd0,~
code-source-info,0xb46da66a330,26,21604,21660,C0O21613C10O21613C15O21660,,
code-creation,LazyCompile,10,293604,0xb46da66a420,19,isError node:internal/util:80:17,0xb4665177390,~
code-source-info,0xb46da66a420,21,1839,2073,C0O2025C5O2032C13O2065C15O2054C18O2071,,
tick,0x1027d9e9a,293728,0,0x0,2,0x102d5e910,0xb46da668e8c,0xb46da667f0d,0xb46da66794d,0xb46da664488
code-creation,LazyCompile,10,293786,0xb46da66a740,753,formatError node:internal/util/inspect:1341:21,0xb469fcd7b78,~
code-source-info,0xb46da66a740,26,43378,45564,C0O43434C9O43449C12O43460C18O43449C27O43491C30O43491C35O43515C50O43515C55O43567C60O43579C65O43601C71O43608C76O43623C85O43623C92O43654C101O43654C106O43725C111O43746C117O43729C123O43769C129O43776C134O43791C143O43791C150O43823C159O43823C164O43846C179O43854C185O43979C191O43996C196O44008C202O43996C212O44027C214O44035C219O44058C225O44066C236O44164C245O44164C252O44192C254O44207C259O44221C264O44233C277O44279C285O44279C292O44334C299O44351C304O44334C310O44375C322O44375C328O44429C334O44521C337O44521C341O44545C343O44589C370O44581C401O44581C404O44624C412O44630C416O44624C422O44657C426O44678C430O44691C438O44702C443O44691C450O44720C454O44741C464O44741C483O44798C492O44827C496O44834C502O44872C506O44936C519O44936C525O44986C527O44998C532O45024C542O45048C547O45099C560O45109C566O45176C571O45215C573O45227C580O44572C653O45270C657O45293C667O45293C683O45317C688O45409C694O45424C699O45457C703O45461C708O45472C714O45461C720O45507C737O45527C743O45507C750O45549C752O45562,,
code-creation,LazyCompile,10,293874,0xb46da66ac48,32,getStackString node:internal/util/inspect:1220:24,0xb469fcd7948,~
code-source-info,0xb46da66ac48,26,39614,39701,C0O39639C8O39647C11O39660C16O39647C24O39669C27O39669C31O39699,,
code-creation,LazyCompile,10,293919,0xb46da66ae00,195,removeDuplicateErrorKeys node:internal/util/inspect:1277:34,0xb469fcd7a38,~
code-source-info,0xb46da66ae00,26,41537,41881,C0O41574C6O41593C12O41600C17O41632C46O41624C74O41624C77O41689C82O41689C88O41782C90O41792C98O41808C105O41820C109O41808C116O41844C124O41844C130O41613C194O41880,,
code-creation,LazyCompile,10,294040,0xb46da66b0b8,282,improveStack node:internal/util/inspect:1244:22,0xb469fcd79e8,~
code-source-info,0xb46da66b0b8,26,40442,41502,C0O40630C5O40641C9O40681C17O40681C24O40714C29O40714C36O40747C43O40754C50O40770C56O40776C63O40792C69O40798C74O40831C77O40844C81O40898C91O40898C98O40967C108O40967C114O41007C118O41033C126O41066C131O41080C138O41137C150O41137C156O41174C166O41175C173O41193C175O41202C180O41233C185O41233C192O41259C193O41267C198O41286C210O41308C218O41344C222O41370C227O41370C240O41417C252O41439C263O41453C268O41453C279O41487C281O41500,,
code-creation,LazyCompile,10,294109,0xb46da66b3c0,158,getPrefix node:internal/util/inspect:678:19,0xb469fcd75d8,~
code-source-info,0xb46da66b3c0,26,20367,20736,C20O20411C24O20443C26O20451C33O20470C38O20487C43O20498C50O20509C63O20535C73O20543C74O20554C79O20565C86O20576C96O20601C97O20609C99O20617C106O20639C111O20654C117O20678C130O20687C140O20695C141O20702C147O20726C157O20734,,
code-creation,LazyCompile,10,294177,0xb46da66b6a8,188,getStackFrames node:internal/util/inspect:1224:24,0xb469fcd7998,~
code-source-info,0xb46da66b6a8,26,39726,40419,C0O39769C8O39769C14O39848C22O39857C25O39869C30O39857C36O39902C39O39921C44O39902C49O39968C57O39968C63O39993C65O40013C70O40060C77O40082C81O40060C87O40086C95O40087C101O40130C104O40130C110O40114C115O40119C120O40181C121O40189C126O40220C128O40224C132O40249C137O40260C148O40323C155O40337C159O40355C167O40355C180O40323C185O40403C187O40417,,
code-creation,LazyCompile,10,294232,0xb46da66b8c0,27,safeGetCWD node:internal/util/inspect:1331:20,0xb469fcd7b28,~
code-source-info,0xb46da66b8c0,26,43225,43356,C0O43236C5O43266C8O43293C13O43293C21O43283C22O43316C23O43323C24O43330C26O43354,,
code-creation,LazyCompile,10,294355,0xb46da66b9d0,21,exists node:internal/bootstrap/loaders:243:16,0xb466514b5e0,~
code-source-info,0xb46da66b9d0,15,7424,7471,C0O7435C5O7455C10O7459C15O7459C20O7467,,
code-creation,LazyCompile,10,294395,0xb46da66bb28,82,stylizeWithColor node:internal/util/inspect:545:26,0xb469fcd73f8,~
code-source-info,0xb46da66bb28,26,16522,16763,C0O16557C3O16565C10O16571C14O16586C16O16631C19O16639C26O16645C30O16658C32O16689C36O16711C52O16718C65O16736C78O16743C79O16750C81O16761,,
code-creation,LazyCompile,10,294429,0xb46da66bc60,6,get node:internal/util/inspect:421:8,0xb469fcd7208,~
code-source-info,0xb46da66bc60,26,12772,12809,C0O12783C2O12794C5O12803,,
code-creation,RegExp,3,294549,0x11324d900,2284,^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$
tick,0x11324e086,294973,0,0x0,0,0x1031bc0ff,0x1031c7dc0,0xb46da66a8e0,0xb46da668e8c,0xb46da667f0d,0xb46da66794d,0xb46da664488
code-creation,LazyCompile,10,295137,0xb46da66be18,123,markNodeModules node:internal/util/inspect:1289:25,0xb469fcd7a88,~
code-source-info,0xb46da66be18,26,41907,42321,C0O41938C3O41948C5O41972C7O42028C12O42016C17O42016C25O42099C30O42121C34O42127C38O42099C51O42154C58O42172C65O42154C78O42209C84O42227C88O42231C92O42215C96O41977C99O42245C100O42253C105O42289C110O42289C115O42282C120O42307C122O42319,,
code-creation,LazyCompile,10,295236,0xb46da66c108,245,markCwd node:internal/util/inspect:1305:17,0xb469fcd7ad8,~
code-source-info,0xb46da66c108,26,42339,43204,C0O42396C5O42396C11O42440C14O42479C19O42489C21O42505C26O42528C33O42546C37O42528C46O42564C51O42587C57O42609C63O42651C65O42668C68O42655C74O42673C81O42695C89O42730C91O42736C96O42760C104O42760C115O42786C120O42829C122O42841C125O42853C129O42884C134O42884C141O42944C148O42944C161O42981C169O42981C182O43034C187O43034C200O43074C202O43082C207O43114C218O43114C233O43162C235O43174C242O43186C244O43202,,
code-creation,LazyCompile,10,295293,0xb46da66c360,48,pathToFileUrlHref node:internal/util/inspect:148:27,0xb469fcd4928,~
code-source-info,0xb46da66c360,26,2871,2979,C0O2886C14O2902C21O2898C27O2929C32O2948C37O2948C43O2971C47O2977,,
code-creation,RegExp,3,296115,0x11324e280,1420,[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])
tick,0x102d42a32,296217,0,0x0,0,0x102d751a0,0x1031b8cb8,0xb46da66be29,0xb46da66a930,0xb46da668e8c,0xb46da667f0d,0xb46da66794d,0xb46da664488
code-creation,LazyCompile,10,296411,0xb46da66c658,3,getEmptyFormatArray node:internal/util/inspect:560:29,0xb469fcd7498,~
code-source-info,0xb46da66c658,26,16918,16937,C0O16925C2O16935,,
code-creation,LazyCompile,10,296532,0xb46da66ca28,996,formatProperty node:internal/util/inspect:1883:24,0xb469fcd8258,~
code-source-info,0xb46da66ca28,26,61900,64415,C29O61994C31O62000C33O62019C36O62026C42O62041C46O62041C61O62105C71O62143C77O62188C84O62196C91O62217C93O62213C106O62243C114O62265C117O62262C121O62275C125O62303C137O62281C143O62329C145O62338C150O62351C158O62365C162O62389C168O62365C173O62363C178O62406C186O62423C192O62434C198O62423C208O62463C216O62485C219O62482C225O62509C231O62553C244O62619C249O62643C252O62666C258O62682C265O62690C270O62717C278O62725C283O62743C289O62780C297O62788C302O62806C311O62861C317O62888C323O62861C330O62912C337O62931C341O62945C345O62975C351O62990C364O62984C387O63007C402O63027C414O63056C420O63097C426O63112C439O63106C467O63129C479O63213C492O63213C499O63253C505O63268C518O63262C535O63285C545O63297C555O63329C562O63348C581O63400C589O63426C605O63447C611O63462C624O63456C641O63479C651O63489C665O63540C677O63552C690O63540C699O63591C705O63626C719O63626C728O63683C742O63683C749O63724C751O63737C753O63733C758O63755C760O63766C761O63773C767O63820C775O63856C781O63890C785O63890C795O63820C801O63946C805O63961C815O63961C835O63997C837O64005C842O64028C847O64070C854O64081C859O64110C867O64146C878O64110C884O64194C890O64205C904O64222C912O64246C916O64226C923O64292C933O64292C942O64340C952O64348C962O64340C969O64381C983O64399C991O64407C995O64413,,
code-creation,LazyCompile,10,296638,0xb46da66d028,11,isUndetectableObject node:internal/util/inspect:161:30,0xb469fcd7078,~
code-source-info,0xb46da66d028,26,3243,3293,C0O3275C9O3280C10O3293,,
code-creation,LazyCompile,10,296709,0xb46da66d2b8,380,formatPrimitive node:internal/util/inspect:1590:25,0xb469fcd7da8,~
code-source-info,0xb46da66d2b8,26,51906,53174,C0O51906C9O51927C15O51978C18O51996C23O52009C27O52003C32O52058C37O52071C41O52065C45O52108C52O52121C57O52108C65O52145C70O52162C83O52199C99O52235C105O52243C110O52435C119O52444C121O52442C126O52476C131O52489C136O52507C140O52501C143O52522C146O52483C151O52557C161O52557C167O52582C177O52583C183O52636C194O52653C199O52664C203O52679C207O52653C217O52637C225O52687C228O52697C229O52708C237O52718C245O52715C253O52746C256O52756C257O52763C263O52798C271O52833C279O52805C284O52851C285O52854C291O52889C299O52924C307O52896C312O52942C313O52945C319O52981C324O52994C329O52988C334O53014C335O53017C341O53055C350O53062C355O53091C356O53120C363O53130C366O53130C374O53127C379O53172,,
code-creation,LazyCompile,10,296830,0xb46da66d760,512,strEscape node:internal/util/inspect:480:19,0xb469fcd73a8,~
code-source-info,0xb46da66d760,26,14375,16495,C0O14402C5O14450C10O14498C13O14757C21O14761C28O14892C36O14897C43O14940C48O14969C56O14974C65O15027C71O15027C78O15071C81O15099C83O15115C88O15131C93O15182C98O15329C107O15336C114O15346C117O15346C124O15397C127O15404C132O15432C133O15443C140O15450C145O15463C159O15469C166O15533C169O15540C174O15568C175O15589C178O15606C180O15624C182O15635C186O15629C191O15668C196O15668C202O15707C204O15717C211O15750C218O15774C225O15797C234O15812C239O15828C241O15837C246O15854C248O15864C253O15868C265O15900C267O15913C279O15913C288O15950C293O15954C307O15979C309O15988C315O16004C321O16014C332O16033C337O16052C343O16062C350O16077C354O16087C358O16081C363O16119C370O16152C374O16119C380O16166C386O16176C397O16195C402O16218C407O16233C409O16267C411O16280C423O16280C436O16326C444O16326C460O16348C462O16357C466O15644C471O15611C477O16392C481O16384C486O16406C488O16416C491O16416C503O16455C506O16462C511O16493,,
code-creation,LazyCompile,10,296935,0xb46da66db60,62,addQuotes node:internal/util/inspect:463:19,0xb469fcd7308,~
code-source-info,0xb46da66db60,26,13944,14084,C0O13962C2O13973C7O13987C12O13998C22O14005C23O14012C25O14023C30O14037C35O14049C45O14057C46O14064C51O14075C61O14082,,
code-creation,LazyCompile,10,297013,0xb46da66dd10,209,formatNumber node:internal/util/inspect:1556:22,0xb469fcd7d08,~
code-source-info,0xb46da66dd10,26,50940,51662,C0O50975C4O51084C12O51088C19O51118C25O51125C30O51144C31O51155C33O51168C38O51162C43O51188C44O51211C49O51211C54O51247C59O51247C64O51266C66O51278C71O51296C76O51301C82O51334C90O51334C97O51357C100O51364C105O51385C106O51396C109O51409C118O51403C123O51450C124O51457C129O51461C135O51488C138O51495C143O51516C144O51523C147O51541C164O51603C167O51603C172O51617C177O51631C181O51638C185O51618C191O51580C203O51530C208O51660,,
code-creation,RegExp,3,297096,0x11324e8c0,1048,^[a-zA-Z_][a-zA-Z_0-9]*$
code-creation,RegExp,3,297189,0x11324ed80,880,[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]
code-creation,LazyCompile,10,297353,0xb46da66e0c8,593,reduceToSingleString node:internal/util/inspect:1976:30,0xb469fcd82f8,~
code-source-info,0xb46da66e0c8,26,65406,68262,C0O65482C6O65490C11O65521C19O65549C26O65557C31O65728C36O65843C38O65862C40O65858C47O65890C52O65905C64O65914C71O66553C78O66566C82O66587C86O66581C91O66627C95O66616C100O66870C105O66883C109O66877C114O66928C118O66932C122O66898C126O66946C130O66939C133O66953C137O66967C152O66971C159O67050C167O67050C173O67098C181O67098C188O67128C194O67148C208O67169C224O67176C234O67217C241O67191C244O67223C245O67333C250O67338C256O67369C261O67338C271O67392C277O67412C291O67433C301O67439C314O67466C322O67483C333O67466C342O67502C349O67522C356O67455C359O67528C360O67631C374O67635C381O67683C382O67699C389O67705C396O67716C417O67731C423O67731C441O67767C444O67753C447O67771C448O67798C456O67829C461O67798C467O68036C469O68041C475O68057C479O68061C486O68068C497O68089C504O68100C522O68116C533O68182C534O68198C541O68204C548O68209C556O68228C567O68209C585O68254C592O68260,,
code-creation,LazyCompile,10,297479,0xb46da66e538,134,isBelowBreakLength node:internal/util/inspect:1952:28,0xb469fcd82a8,~
code-source-info,0xb46da66e538,26,64444,65375,C0O64897C7O64904C11O64940C15O64931C19O64953C23O64947C28O64970C29O64983C30O64999C32O65013C36O65004C41O65040C47O65056C49O65071C54O65090C58O65071C63O65094C76O65122C78O65143C82O65147C93O65187C97O65181C102O65208C103O65221C104O65022C109O64986C112O65314C114O65326C121O65337C127O65337C133O65373,,
tick,0x102c711dd,297533,0,0x0,2,0x102d5e910,0xb46da66e160,0xb46da6694fa,0xb46da667f0d,0xb46da66794d,0xb46da664488
code-creation,LazyCompile,10,297548,0xb46da66e6f0,75,join node:internal/util:380:14,0xb4665177a90,~
code-source-info,0xb46da66e6f0,21,10529,10838,C0O10563C3O10580C9O10587C14O10625C18O10632C22O10654C24O10659C26O10659C31O10741C33O10754C43O10765C45O10772C52O10673C57O10641C60O10793C62O10806C72O10825C74O10836,,
tick,0x7ff805ea71fe,298715,0,0x0,0
tick,0x1032e6cd0,299965,0,0x0,0
